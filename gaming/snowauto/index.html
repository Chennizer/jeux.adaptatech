<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Météo — Neige (Jeu Switch)</title>

<!-- p5.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>

<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0b1220;}
  canvas{display:block;position:fixed;inset:0;}
  /* overlay styles kept for compatibility, but overlay is not used in this auto-start build */
  #modeOverlay{
    position:fixed;inset:0;display:none;flex-direction:column;gap:18px;
    align-items:center;justify-content:center;background:#000;color:#fff;z-index:10000;
    text-align:center;padding:20px;
  }
  #modeOverlay h2{margin:0 0 8px 0;font-weight:600}
  #modeOverlay p{margin:0;opacity:.85}
  #modeOverlay button{
    padding:12px 22px;border:none;border-radius:8px;cursor:pointer;
    background:#ffd250;color:#000;font-size:18px;
  }
  #modeOverlay button:hover{background:#ffb930}
  #settings-icon{
    position:fixed;top:14px;right:14px;width:40px;height:40px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;cursor:pointer;
    background:rgba(0,0,0,.7);color:#fff;font-size:20px;z-index:10001;
    transition:transform .2s ease, background .2s ease; visibility:hidden;
  }
  #settings-icon:hover{transform:rotate(90deg);background:rgba(0,0,0,.85)}
  #menu{
    position:fixed;top:60px;right:-340px;width:300px;max-height:calc(100vh - 80px);
    overflow:auto; background:rgba(0,0,0,.86); color:#fff; border-radius:10px;
    padding:12px 14px;z-index:10000;transition:right .25s ease, opacity .25s ease; opacity:.0;
  }
  #menu.show{right:12px;opacity:1}
  #menu h2{margin:.2rem 0 .6rem 0;font-size:20px;color:#7dd3fc;text-align:center}
  #menu h3{margin:1rem 0 .4rem 0;font-size:15px;color:#93c5fd}
  #menu label{display:block;margin:.5rem 0;font-size:13px}
  #menu input[type="range"]{width:100%}
  #menu .inline{display:flex;align-items:center;justify-content:space-between;gap:8px}
  #menu .val{display:inline-block;min-width:2ch;padding:0 6px;border-radius:6px;background:rgba(255,255,255,.1)}
</style>
</head>
<body>

<!-- (Overlay removed in this auto-start version) -->

<!-- Settings icon + menu -->
<div id="settings-icon" title="Options">⚙️</div>
<div id="menu">
  <h2>Options</h2>
  <h3>Audio</h3>
  <label class="inline">
    <span>Désactiver la musique</span>
    <input type="checkbox" id="muteMusic">
  </label>
  <label>
    <span>Volume musique : <span class="val" id="musicVolVal">50</span></span><br>
    <input type="range" id="musicVol" min="0" max="100" value="50">
  </label>
  <label class="inline">
    <span>Désactiver les effets</span>
    <input type="checkbox" id="muteSFX">
  </label>
  <label>
    <span>Volume effets : <span class="val" id="sfxVolVal">70</span></span><br>
    <input type="range" id="sfxVol" min="0" max="100" value="70">
  </label>

  <h3>Jeu</h3>
  <label>
    <span>Appuis requis (mode normal) : <span class="val" id="reqVal">6</span></span><br>
    <input type="range" id="requiredPresses" min="5" max="6" step="1" value="6">
  </label>
  <label>
    <span>Délai entre appuis (ms) : <span class="val" id="delayVal">1200</span></span><br>
    <input type="range" id="tapDelay" min="400" max="2500" step="100" value="1200">
  </label>
</div>

<script>
/* === Paths === */
const ambiencePath='../../sounds/winterambiance.mp3';
const pressPath   ='../../sounds/snowing.mp3';
const finishPath  ='../../sounds/snowsuccess.mp3'; // celebration sfx
const firPath     ='../../images/pictos/fir.png';

/* === State & settings === */
let gameStarted=false, rapidMode=false, finished=false; // rapidMode stays false (default)
let lastTap=-Infinity, tapDelay=1200;
let requiredPresses=6;
let presses=0;

/* Accumulation */
let progress=0, targetProgress=0;
const INITIAL_SNOW = 0.08;

/* Wave control */
let waveActive=false;
let spawning=false;
let spawnUntil=0;
let airborneCount=0;

/* Celebration auto-trigger (after final snowfall lands + 1s) */
let completionArmed=false;
let celebrationScheduled=false;
let celebrationTimeout=null;

/* Audio */
let ambience, pressSFX, finishSFX;
let isMusicMuted=false, isSFXMuted=false, volMusic=0.5, volSFX=0.7;

/* Visuals */
let clouds=[];
let flakesBack=[], stormFlakes=[];
let w=0, h=0;
let sunRot=0, glarePulse=1;

/* Forest (left cluster) */
let firImg=null;
let forest=[]; // {x,y,w,h,depth,useImg}
const TREE_SCALE = 1.5; // 1.5× larger trees
const TREE_BASE_DROP = 34; // lowered so they sit deeper into the snow

/* Background snow */
const BACK_DENSITY_BASE = 0.00010;
const BACK_SZ_MIN = 1.2, BACK_SZ_MAX = 3.0;
const BACK_VY_MIN = 0.24, BACK_VY_MAX = 0.6;
const BACK_ALPHA  = 130;

/* Ground / accumulation */
const MAX_SNOW_DEPTH_FRAC = 0.62;
const groundNoiseSeed = Math.floor(Math.random()*10000);

/* Storm tuning */
const SPAWN_WINDOW_MS = 1500;
const FLAKES_PER_MEGAPIXEL = 260;
const ACCUM_SCALE = 0.35;
const STORM_ACTIVE_CAP = 10000;

/* Wind (for drift) */
let windT = Math.random()*1000;
let baseWind = 0;
let gust = 0;

/* === Celebration state & timings === */
let celebrating=false;
let celebrateStart=0;
/* EXACT 30s from when the celebration mp3 starts playing */
const CELEBRATE_MS = 30000;

/* Timers/levels */
let sunFadeL=0, starRevealL=0, moonRevealL=0, auroraRevealL=0;

/* ★ Stars */
let stars=[];
const STAR_DENSITY = 0.00008;

/* === Moon visuals === */
let moonSeed = Math.floor(Math.random()*10000);

/* === Aurora (fluid, filled ribbons — richer green/purple, more motion) === */
let AUR = {
  seed: Math.random()*10000,
  t: 0,
  bands: [],
  conf: {
    topOffsetFrac: 0.12,
    heightFrac:    0.34,
    xStep:         16,
    bandCount:     3,
    drift:         0.007,
    baseAlpha:     86
  }
};

function makeBands(){
  AUR.bands.length = 0;
  const C = AUR.conf;
  for (let i=0; i<C.bandCount; i++){
    const lane = (i + 0.5) / C.bandCount;
    AUR.bands.push({
      yFracMid: C.topOffsetFrac + C.heightFrac * lane,
      ampY:     random(20, 34),
      ampX:     random(28, 46),
      wavFreq:  random(1.05, 1.5),
      speed:    random(0.26, 0.40),
      widthMin: random(18, 24),
      widthMax: random(46, 70),
      widthJit: random(0.18, 0.32),
      noiseP:   random(1000),
      flowP:    random(2000),
      hueBias:  random(-0.06, 0.10),
      alphaMul: random(0.92, 1.18)
    });
  }
}

/* Build a closed polygon ribbon from a centerline using local normals */
function ribbonPolygon(b, tNow, widen=1.0){
  const C = AUR.conf;
  const ups = [], downs = [];

  for (let x=-w*0.05; x<=w*1.05; x+=C.xStep){
    const siny  = Math.sin(x*0.004*b.wavFreq + tNow*b.speed) * b.ampY;
    const flow  = (noise(x*0.0022 + tNow*0.12 + b.flowP) - 0.5) * b.ampX*2.0;
    const y     = h*b.yFracMid + siny + flow*0.12;

    const x2    = x + 1;
    const siny2 = Math.sin(x2*0.004*b.wavFreq + tNow*b.speed) * b.ampY;
    const flow2 = (noise(x2*0.0022 + tNow*0.12 + b.flowP) - 0.5) * b.ampX*2.0;
    const y2    = h*b.yFracMid + siny2 + flow2*0.12;

    const dx = 1, dy = y2 - y;
    const len = Math.max(1e-3, Math.hypot(dx,dy));
    const nx = -dy/len, ny = dx/len;

    const wNoise = (noise(x*0.006 + tNow*0.45 + b.noiseP) - 0.5) * b.widthJit;
    const baseW  = lerp(b.widthMin, b.widthMax, 0.65 + 0.35*Math.sin(tNow*0.8 + x*0.002));
    const halfW  = baseW * (1.0 + wNoise) * 0.5 * widen;

    ups.push({x: x + nx*halfW, y: y + ny*halfW});
    downs.push({x: x - nx*halfW, y: y - ny*halfW});
  }

  const poly = [];
  for (let p of ups)   poly.push(p);
  for (let i=downs.length-1; i>=0; i--) poly.push(downs[i]);
  return poly;
}

/* Green↔Purple palette with time & edge modulation (for SCREEN) */
function mix(a,b,t){ return a + (b-a)*t; }
function auroraFillColor(b, edge=0.0, tNow=0, brightness=1.0){
  const g = { r:  50, g: 240, b: 210 };
  const p = { r: 190, g:  80, b: 255 };

  const travel = 0.35 + 0.35*(0.5+0.5*Math.sin(tNow*0.6 + b.flowP));
  const edgeMix = constrain(travel + edge*0.35 - 0.12, 0, 1);

  const r = mix(g.r, p.r, edgeMix) + b.hueBias*40;
  const gg= mix(g.g, p.g, edgeMix) + b.hueBias*15;
  const bl= mix(g.b, p.b, edgeMix) + b.hueBias*25;

  return [
    constrain(r*brightness, 0, 255),
    constrain(gg*brightness, 0, 255),
    constrain(bl*brightness, 0, 255),
  ];
}

function drawAurora(level){ // level: 0..1
  if (level <= 0) return;
  const C = AUR.conf;
  AUR.t += C.drift;

  push();
  blendMode(SCREEN);
  noStroke();

  for (let i=0; i<AUR.bands.length; i++){
    const b = AUR.bands[i];

    // Soft under-glow passes
    for (let gp=0; gp<2; gp++){
      const widen = 1.6 + gp*0.45;
      const poly  = ribbonPolygon(b, AUR.t, widen);
      const [r,g,bl] = auroraFillColor(b, 0.0, AUR.t, 0.65 - gp*0.12);
      fill(r, g, bl, C.baseAlpha * 0.55 * (1 - gp*0.25) * level * b.alphaMul);
      beginShape(); for (let p of poly) vertex(p.x, p.y); endShape(CLOSE);
    }

    // Main ribbon
    const poly = ribbonPolygon(b, AUR.t, 1.0);
    const [r,g,bl] = auroraFillColor(b, 0.18, AUR.t, 1.0);
    fill(r, g, bl, C.baseAlpha * 1.0 * level * b.alphaMul);
    beginShape(); for (let p of poly) vertex(p.x, p.y); endShape(CLOSE);

    // Subtle core filament
    strokeCap(ROUND); strokeJoin(ROUND); strokeWeight(2.5);
    for (let k=1; k<poly.length/2; k++){
      const mPrev = { x:(poly[k-1].x + poly[poly.length- (k)].x)/2,
                      y:(poly[k-1].y + poly[poly.length- (k)].y)/2 };
      const mCur  = { x:(poly[k].x   + poly[poly.length- (k+1)].x)/2,
                      y:(poly[k].y   + poly[poly.length- (k+1)].y)/2 };
      const [rr,gg,bb] = auroraFillColor(b, 0.0, AUR.t, 1.0);
      stroke(rr,gg,bb, (C.baseAlpha*0.65) * level);
      line(mPrev.x, mPrev.y, mCur.x, mCur.y);
    }
    noStroke();
  }

  pop();
}

function safePlay(snd, volume=1){
  if(!snd || typeof snd.play !== 'function') return;
  try{ snd.setVolume(volume); snd.play(); }catch(e){ console.warn('Audio play failed:', e); }
}

/* ——— Auto-audio helper ——— */
function ensureAudioStarted(){
  try{ getAudioContext().resume(); }catch(e){}
}

function preload(){
  try{ ambience = loadSound(ambiencePath, null, err=>console.warn('Ambience load error:', err)); }catch(e){}
  try{ pressSFX = loadSound(pressPath,  null, err=>console.warn('Press SFX load error:', err)); }catch(e){}
  try{ finishSFX= loadSound(finishPath, null, err=>console.warn('Finish SFX load error:', err)); }catch(e){}
  try{ firImg = loadImage(firPath, ()=>{}, err=>console.warn('Fir image load error:', err)); }catch(e){}
}

function setup(){
  createCanvas(windowWidth, windowHeight);
  w=width; h=height;

  for(let i=0;i<6;i++){
    clouds.push(new Cloud(random(w), random(h*0.05, h*0.45),
      random(120,260), random(50,120), random(0.3,1.2)));
  }

  buildForest();
  rebuildBackgroundFlakes();
  seedStars();
  makeBands();

  // Settings menu
  const ico=document.getElementById('settings-icon');
  const menu=document.getElementById('menu');
  const muteM=document.getElementById('muteMusic');
  const volM =document.getElementById('musicVol');
  const valM =document.getElementById('musicVolVal');
  const muteS=document.getElementById('muteSFX');
  const volS =document.getElementById('sfxVol');
  const valS =document.getElementById('sfxVolVal');
  const req  =document.getElementById('requiredPresses');
  const reqV =document.getElementById('reqVal');
  const delay=document.getElementById('tapDelay');
  const delayV=document.getElementById('delayVal');

  ico.onclick=()=>{ if(gameStarted) menu.classList.toggle('show'); };
  document.addEventListener('click',(e)=>{ if(!menu.contains(e.target) && !ico.contains(e.target)) menu.classList.remove('show'); });

  muteM.onchange=e=>{
    isMusicMuted = e.target.checked;
    ambience?.setVolume(isMusicMuted?0:volMusic);
    finishSFX?.setVolume(isMusicMuted?0:volMusic);
  };
  volM.oninput=e=>{
    volMusic=e.target.value/100; valM.textContent=e.target.value;
    if(!isMusicMuted) ambience?.setVolume(volMusic);
    if(!isMusicMuted) finishSFX?.setVolume(volMusic);
  };
  muteS.onchange=e=>{ isSFXMuted = e.target.checked; };
  volS.oninput=e=>{ volSFX=e.target.value/100; valS.textContent=e.target.value; };
  req.oninput=e=>{ requiredPresses = parseInt(e.target.value,10); reqV.textContent = requiredPresses; };
  delay.oninput=e=>{ tapDelay = parseInt(e.target.value,10); delayV.textContent = tapDelay; };

  // —— Auto start the game in default mode ——
  ensureAudioStarted();
  startGame();

  // If autoplay blocked, resume audio on first interaction
  const firstInteract = ()=>{
    ensureAudioStarted();
    if(ambience && ambience.isLoaded() && !ambience.isPlaying()){
      ambience.setLoop(true);
      ambience.setVolume(isMusicMuted?0:volMusic);
      safePlay(ambience, isMusicMuted?0:volMusic);
    }
    window.removeEventListener('pointerdown', firstInteract);
    window.removeEventListener('keydown', firstInteract);
  };
  window.addEventListener('pointerdown', firstInteract, {once:true});
  window.addEventListener('keydown', firstInteract, {once:true});
}

function startGame(){
  // No overlay in this build; keep call for safety (no-op)
  document.getElementById('modeOverlay')?.remove();

  gameStarted=true; finished=false; celebrating=false;
  document.getElementById('settings-icon').style.visibility='visible';

  // Unlock WebAudio (best effort)
  if (typeof userStartAudio === 'function') { userStartAudio(); }

  // Fullscreen attempt (may be blocked)
  (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen)?.call(document.documentElement);

  presses=0;
  progress=INITIAL_SNOW;
  targetProgress=INITIAL_SNOW;
  stormFlakes.length=0; waveActive=false; spawning=false; airborneCount=0;

  if(ambience && ambience.isLoaded()){
    ambience.setLoop(true);
    ambience.setVolume(isMusicMuted?0:volMusic);
    safePlay(ambience, isMusicMuted?0:volMusic);
  }

  rebuildBackgroundFlakes();
  seedStars();
  moonSeed = Math.floor(Math.random()*10000);
  AUR.seed = Math.random()*10000;
  AUR.t = 0;
  makeBands();

  // Reset any celebration scheduling
  completionArmed=false; celebrationScheduled=false;
  if (celebrationTimeout){ clearTimeout(celebrationTimeout); celebrationTimeout=null; }
}

/* Hard reset after celebration ends: fully clear snow & restart round */
function hardResetGame(){
  celebrating=false;
  finished=false;
  completionArmed=false;
  celebrationScheduled=false;
  if (celebrationTimeout){ clearTimeout(celebrationTimeout); celebrationTimeout=null; }

  if(ambience && ambience.isLoaded()){
    ambience.setVolume(isMusicMuted?0:volMusic);
  }

  presses=0;
  progress=INITIAL_SNOW;
  targetProgress=INITIAL_SNOW;
  stormFlakes.length=0; waveActive=false; spawning=false; airborneCount=0;

  rebuildBackgroundFlakes();
  seedStars();
  moonSeed = Math.floor(Math.random()*10000);
  AUR.seed = Math.random()*10000; AUR.t = 0; makeBands();
}

function draw(){
  if(!gameStarted){ background(0); return; }

  const now = millis();

  // Wind (flakes only)
  windT += 0.0025;
  baseWind = map(noise(windT), 0, 1, -1.1, 1.1);
  const gustChance = noise(windT*0.4 + 100);
  const targetGust = gustChance > 0.75 ? map(noise(windT*1.3+200), 0,1, -2.4, 2.4) : 0;
  gust = lerp(gust, targetGust, 0.02);
  const wind = baseWind + gust;

  // Celebration phase timers
  if (celebrating){
    const t = now - celebrateStart;
    sunFadeL      = constrain(t/5000, 0, 1);
    starRevealL   = constrain((t-5000)/2000, 0, 1);
    moonRevealL   = constrain((t-5000)/2000, 0, 1);
    auroraRevealL = constrain((t-7000)/2000, 0, 1);
  } else {
    sunFadeL=0; starRevealL=0; moonRevealL=0; auroraRevealL=0;
  }

  // Sky
  drawSnowySky(celebrating, sunFadeL);

  // Sun
  drawSun(1 - sunFadeL);

  // Clouds are hidden during celebration
  if (!celebrating){
    for(const c of clouds){ c.update(); c.draw(); }
  } else {
    for(const c of clouds){ c.update(); }
  }

  /* === AURORA BEHIND TREES === */
  if (celebrating && auroraRevealL > 0){
    drawAurora(auroraRevealL);
  }

  // Forest (trees drawn AFTER aurora to appear in front)
  drawForest();

  // === Snowstorm & background flakes ONLY if not celebrating ===
  if (!celebrating) {
    for(const f of flakesBack){ f.update(); f.draw(); }

    if(spawning && now < spawnUntil){
      const inc = currentWaveMass;
      const pxMP = (w*h)/1e6;
      let totalFlakes = Math.max(160, Math.floor(pxMP * FLAKES_PER_MEGAPIXEL * (0.5 + inc*1.4)));
      totalFlakes = Math.min(totalFlakes, STORM_ACTIVE_CAP - stormFlakes.length);
      const perFrame = Math.ceil(totalFlakes * (deltaTime / SPAWN_WINDOW_MS));
      for(let i=0;i<perFrame;i++){
        if(stormFlakes.length >= STORM_ACTIVE_CAP) break;
        const fl = new StormFlake();
        fl.mass = inc / Math.max(1, totalFlakes);
        fl.windRef = wind;
        stormFlakes.push(fl);
        airborneCount++;
      }
    } else {
      spawning = false;
    }

    for(let i=stormFlakes.length-1;i>=0;i--){
      const s = stormFlakes[i];
      s.update(wind);
      s.draw();
      if(s.justLanded){
        s.justLanded = false;
        airborneCount = Math.max(0, airborneCount - 1);
        targetProgress = Math.min(1, targetProgress + s.mass);
      }
      if(s.dead) stormFlakes.splice(i,1);
    }

    if(waveActive && !spawning && airborneCount===0){
      waveActive = false;
    }

    // arm completion when done
    if (!completionArmed && (presses >= requiredPresses || targetProgress >= 1)){
      completionArmed = true;
    }
    if (completionArmed && !celebrationScheduled && !waveActive && !spawning && airborneCount===0){
      celebrationScheduled = true;
      celebrationTimeout = setTimeout(()=>{
        if (!finished && !celebrating){
          finished=true;
          startCelebration();
        }
      }, 1000);
    }

    progress = lerp(progress, targetProgress, 0.12);
    drawSnowGround(progress);

    if(waveActive){
      noStroke();
      fill(255,255,255, 26 + 30*Math.abs(wind));
      rect(0,0,w,h);
    }
  } else {
    progress = lerp(progress, targetProgress, 0.12);
    drawSnowGround(progress);
  }

  // Celebration overlays (stars & moon only; aurora already drawn behind trees)
  if(celebrating){
    if (starRevealL > 0) drawStars(starRevealL);
    if (moonRevealL > 0) drawMoon(moonRevealL);

    noStroke();
    const a = 6 + 8*Math.sin((now - celebrateStart)/260);
    fill(255,255,255, a);
    rect(0,0,w,h);

    // End celebration strictly 30s after SFX start, then HARD RESET
    if(now - celebrateStart > CELEBRATE_MS){
      hardResetGame();
    }
  }

  sunRot += 0.003;
  glarePulse = 0.98 + 0.04 * Math.sin(frameCount*0.03);
}

/* === Input === */
function keyPressed(){
  if(key===' ' && gameStarted) trigger();
  if(keyCode===ENTER && gameStarted){
    if (celebrationTimeout){ clearTimeout(celebrationTimeout); celebrationTimeout=null; }
    completionArmed=false; celebrationScheduled=false;

    presses=0; progress=INITIAL_SNOW; targetProgress=INITIAL_SNOW;
    finished=false; celebrating=false; stormFlakes.length=0; waveActive=false; spawning=false; airborneCount=0;
    rebuildBackgroundFlakes();
    seedStars();
    moonSeed = Math.floor(Math.random()*10000);
    AUR.seed = Math.random()*10000; AUR.t = 0; makeBands();

    if(ambience && ambience.isLoaded() && !isMusicMuted){
      ambience.setVolume(volMusic);
      safePlay(ambience, volMusic);
    }
  }
  if(key.toLowerCase()==='f'){
    if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  }
}
function mousePressed(){ if(gameStarted) trigger(); return false; }
function touchStarted(){ if(gameStarted) trigger(); return false; }

/* === Controls === */
let currentWaveMass = 0;
function trigger(){
  if(finished || celebrating) return;
  if(waveActive) return;
  if(millis()-lastTap < tapDelay) return;
  lastTap = millis();

  const baseInc = rapidMode ? (1 - targetProgress) : (1/requiredPresses);
  const inc = Math.min(1 - targetProgress, baseInc * ACCUM_SCALE);
  currentWaveMass = inc;

  waveActive = true;
  spawning   = true;
  spawnUntil = millis() + SPAWN_WINDOW_MS;
  airborneCount = 0;

  if(!isSFXMuted && pressSFX && pressSFX.isLoaded()){
    pressSFX.setVolume(volSFX);
    safePlay(pressSFX, volSFX);
  }

  rebuildBackgroundFlakes();
  presses++;

  if (presses >= requiredPresses) completionArmed = true;
}

/* === Celebration === */
function startCelebration(){
  celebrating = true;

  // lower ambience
  if(ambience && ambience.isLoaded() && !isMusicMuted){ ambience.setVolume(volMusic*0.25); }

  // play finish SFX
  if(finishSFX && finishSFX.isLoaded() && !isMusicMuted){
    finishSFX.setVolume(Math.max(0.2, volMusic));
    safePlay(finishSFX, Math.max(0.2, volMusic));
  }

  // start 30s timer "from when the mp3 starts" (approx right after play is triggered)
  celebrateStart = millis();

  sunFadeL=0; starRevealL=0; moonRevealL=0; auroraRevealL=0;
}

/* === Stars === */
function seedStars(){
  stars.length = 0;
  const n = Math.floor(width * height * STAR_DENSITY);
  for(let i=0;i<n;i++){
    stars.push({
      x: random(width),
      y: random(height * 0.55),
      a: random(110, 230),
      tw: random(0.4, 0.9),
      p: random(TWO_PI)
    });
  }
}
function drawStars(level){
  const t = millis() * 0.001;
  noStroke();
  for(const s of stars){
    const tw = 0.5 + 0.5 * sin(t * s.tw + s.p);
    const a  = s.a * (0.55 + 0.45*tw) * level;
    if (a <= 2) continue;
    fill(255,255,255,a);
    circle(s.x, s.y, 1.2);
  }
}

/* === Moon (NO GLOW) === */
function drawMoon(alphaFactor=1){
  push();
  translate(w*0.82, h*0.18);
  noStroke();

  const R = Math.min(w,h)*0.07;
  fill(230,234,245, 230 * alphaFactor);
  ellipse(0,0,R*2,R*2);

  randomSeed(moonSeed);
  for(let i=0;i<9;i++){
    const ang = random(TWO_PI);
    const rr  = random(R*0.12, R*0.78);
    const cx  = cos(ang)*rr;
    const cy  = sin(ang)*rr;
    const cr  = random(R*0.04, R*0.12);
    fill(180,185,200, 70 * alphaFactor);
    ellipse(cx, cy, cr*2, cr*2);
    fill(160,168,190, 50 * alphaFactor);
    ellipse(cx+cr*0.22, cy+cr*0.18, cr*1.2, cr*1.2);
  }
  pop();
}

/* === (Shimmer & glints placeholders — disabled) === */
let lastShimmerT = 0;
let groundGlints = [];
function drawSnowShimmer(p){ /* no-op */ }
function updateAndDrawGlints(p){ /* no-op */ }

/* === Background snow & helpers === */
function rebuildBackgroundFlakes(){
  const factor = 1 + 0.7*Math.min(1, targetProgress + (waveActive? currentWaveMass*0.7:0));
  const backTarget  = Math.floor(w*h*BACK_DENSITY_BASE * factor);
  while(flakesBack.length < backTarget) flakesBack.push(new FlakeBack(true));
  while(flakesBack.length > backTarget) flakesBack.pop();
}

/* === Ground === */
function drawSnowGround(p){
  const samples = 80;
  noStroke();
  fill(240, 248, 255);
  beginShape();
  vertex(0, h);
  for(let i=0;i<=samples;i++){
    const x = map(i,0,samples,0,w);
    const y = groundYAt(x, p);
    vertex(x, y);
  }
  vertex(w, h);
  endShape(CLOSE);

  const band = 10 + 20*p;
  for(let i=0;i<band;i++){
    const a = map(i,0,band-1, 70, 0);
    stroke(255,255,255,a);
    noFill();
    beginShape();
    for(let j=0;j<=samples;j++){
      const x = map(j,0,samples,0,w);
      const y = groundYAt(x, p) - i*0.7;
      vertex(x,y);
    }
    endShape();
  }
}
function groundYAt(x, p){
  const maxDepth = h * MAX_SNOW_DEPTH_FRAC;
  const baseY = h - p * maxDepth;
  const nx = x*0.003;
  const und = map(noise(nx, groundNoiseSeed), 0, 1, -18*(0.4+p), 18*(0.4+p));
  const side = Math.abs((x/w)-0.5);
  const drift = lerp(0, 14*(0.5+p), Math.pow(side,2));
  return baseY + und + drift;
}

/* === Entities === */
class Cloud{
  constructor(x,y,w,h,s){ this.x=x; this.y=y; this.w=w; this.h=h; this.s=s; this.o=random(150,210); }
  update(){
    this.x -= this.s;
    if(this.x + this.w < -40){
      this.x = width + random(20,120);
      this.y = random(height*0.05, height*0.45);
      this.w = random(120,260);
      this.h = random(50,120);
      this.s = random(0.3,1.2);
      this.o = random(150,210);
    }
  }
  draw(){
    noStroke();
    fill(255,255,255,this.o);
    ellipse(this.x, this.y, this.w, this.h);
    ellipse(this.x-this.w*0.45, this.y+this.h*0.05, this.w*0.7, this.h*0.7);
    ellipse(this.x+this.w*0.45, this.y+this.h*0.05, this.w*0.7, this.h*0.7);
  }
}
class FlakeBack{
  constructor(fromTop=false){ this.reset(fromTop); }
  reset(fromTop=false){
    this.x = random(w);
    this.y = fromTop ? random(-h*0.6, -10) : random(-h, h);
    this.sz = random(BACK_SZ_MIN, BACK_SZ_MAX);
    this.vy = random(BACK_VY_MIN, BACK_VY_MAX);
    this.alpha = BACK_ALPHA;
    this.phase = random(TWO_PI);
  }
  update(){
    this.x += 0.35*Math.sin(frameCount*0.02 + this.phase) * 0.9;
    this.y += this.vy;
    if(this.x < -10) this.x = w+10;
    if(this.x > w+10) this.x = -10;
    const gy = groundYAt(this.x, targetProgress);
    if(this.y >= gy - this.sz*0.3) this.reset(true);
    if(this.y > h + 20) this.reset(true);
  }
  draw(){
    noStroke();
    fill(255,255,255, this.alpha);
    circle(this.x, this.y, this.sz);
  }
}
class StormFlake{
  constructor(){
    this.x = random(-20, w+20);
    this.y = random(-h*0.6, -10);

    const superChance = 0.28;
    const isGiant = random() < superChance;
    this.sz = isGiant ? random(32, 56) : random(14, 32);

    const speedScale = map(this.sz, 14, 56, 1.0, 1.65);
    const vyMin = max(1.0, (h/260) * speedScale);
    const vyMax = max(2.8, (h/150) * speedScale);

    this.vy = random(vyMin, vyMax);
    this.vx = random(-1.05, 1.05);
    this.alpha = isGiant ? 255 : 245;
    this.phase = random(TWO_PI);
    this.dead = false;
    this.g = random(0.010, 0.022) * speedScale;
    this.onGround = false;
    this.justLanded = false;
    this.fadeSpeed = 15;
    this.mass = 0.0;
    this.windRef = 0;
  }
  update(globalWind){
    if(!this.onGround){
      this.vy += this.g;
      const sway = 1.0*Math.sin(frameCount*0.03 + this.phase);
      this.vx += (globalWind - this.windRef) * 0.02;
      this.windRef = lerp(this.windRef, globalWind, 0.05);

      this.x += this.vx + sway;
      this.y += this.vy;

      if(this.x < -60){ this.x = w+60; }
      if(this.x > w+60){ this.x = -60; }

      const gy = groundYAt(this.x, targetProgress);
      if(this.y >= gy - this.sz*0.25){
        this.y = gy - this.sz*0.25;
        this.onGround = true;
        this.justLanded = true;
        this.vx = 0; this.vy = 0; this.g = 0;
      }
    }else{
      this.alpha -= this.fadeSpeed;
      if(this.alpha<=0) this.dead = true;
    }
  }
  draw(){
    noStroke();
    fill(255,255,255, this.alpha);
    circle(this.x, this.y, this.sz);
  }
}

/* === Forest (left cluster) — with 1.5× trees, lowered by TREE_BASE_DROP === */
function buildForest(){
  forest.length = 0;
  const count = Math.floor(random(6, 8));
  const hasImg = (!!firImg && firImg.width && firImg.height);

  for(let i=0;i<count;i++){
    const slotX = map(i, 0, count-1, w*0.04, w*0.48);
    const jitter = random(-w*0.05, w*0.03);
    const centerX = slotX + jitter;

    const targetHFrac = random(0.36, 0.62);

    let H = Math.min(h*targetHFrac, h*0.74);
    H = Math.min(H * TREE_SCALE, h*0.92);

    let W, useImg = hasImg;
    if (hasImg){
      const scale = H / firImg.height;
      W = firImg.width * scale;
    } else {
      W = H * 0.66;
    }

    const x = centerX - W/2;
    const y = h - H + TREE_BASE_DROP; // lowered so bases intersect the snow more
    const depth = 1 - targetHFrac;

    forest.push({x, y, w: W, h: H, depth, useImg});
  }
  forest.sort((a,b)=>a.depth - b.depth);
}
function drawForest(){
  if(!forest.length) return;
  for(const t of forest){
    if (t.useImg && firImg){
      image(firImg, t.x, t.y, t.w, t.h);
    } else {
      push();
      noStroke();
      fill(30, 60, 45, 220);
      triangle(t.x + t.w*0.5, t.y,
               t.x,           t.y + t.h,
               t.x + t.w,     t.y + t.h);
      pop();
    }
  }
}

/* === Resize & utils === */
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  w=width; h=height;
  buildForest();
  rebuildBackgroundFlakes();
  seedStars();
  AUR.seed = Math.random()*10000; AUR.t = 0; makeBands();
}
function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2; }

/* === Sky & Sun === */
function drawSnowySky(isCelebration, sunFadeLevel){
  const topBase = [150,175,195];
  const botBase = [205,215,225];
  const topNight = [6,12,28];
  const botNight = [12,22,44];

  noFill();
  for(let y=0;y<h;y++){
    const gy = y/h;
    let r = lerp(topBase[0], botBase[0], gy);
    let g = lerp(topBase[1], botBase[1], gy);
    let b = lerp(topBase[2], botBase[2], gy);
    if (isCelebration){
      r = lerp(r, lerp(topNight[0], botNight[0], gy), sunFadeLevel);
      g = lerp(g, lerp(topNight[1], botNight[1], gy), sunFadeLevel);
      b = lerp(b, lerp(topNight[2], botNight[2], gy), sunFadeLevel);
    }
    stroke(r,g,b);
    line(0,y,w,y);
  }
}
function drawSun(alphaFactor=1){
  push();
  translate(w*0.82, h*0.18);
  rotate(sunRot);
  const R = Math.min(w,h)*0.08;
  noStroke();
  for(let i=80;i>=1;i--){
    const t = i/80;
    fill(255, 220, 120, 7 * t * alphaFactor);
    const r = R * (1 + 2.2*(1-t)*glarePulse);
    ellipse(0,0,r*2,r*2);
  }
  fill(255,190,60, 230 * alphaFactor);
  ellipse(0,0,R*2,R*2);
  pop();
}
</script>
<script>
(function(){
  const key = 'weatherAutoFS';
  if (sessionStorage.getItem(key) !== '1') return;
  sessionStorage.removeItem(key);

  const tryFullscreen = () => {
    if (document.fullscreenElement) return;
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
    if (!req) return;
    try {
      const result = req.call(el);
      if (result?.catch) result.catch(() => {});
    } catch {}
  };

  if (document.readyState === 'complete') {
    setTimeout(tryFullscreen, 0);
  } else {
    window.addEventListener('load', () => setTimeout(tryFullscreen, 0), { once: true });
  }

  window.addEventListener('pointerdown', () => {
    tryFullscreen();
  }, { once: true, passive: true });
})();
</script>
  <script src="/js/switch-info.js"></script>
</body>
</html>
