<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Routine matinale ‚Äî D√©mo Reveal.js (interactif)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <!-- Reveal.js core + theme -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4/dist/reveal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4/dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4/plugin/highlight/monokai.css">

  <style>
    .reveal .slides { text-align: left; }
    .reveal h1, .reveal h2 { color:#294936; }
    .reveal a { color:#D36135; }
    .badge { display:inline-block; padding:.25em .55em; border-radius:.5em; border:1px solid #623B5A; }
    .note-tip { font-size: .8em; opacity:.8; }
    .row{ display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; margin:.5rem 0 1rem; }
    .row label{ font-weight:600; color:#294936; }
    input[type="range"]{ width:260px; }
    pre code{ font-size:.9em; }

    /* Base grid for pictos */
    .picto-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(120px,1fr));
      gap:1rem;
      justify-items:center;
      align-items:center;
    }
    .picto{
      width:110px; height:110px; display:flex; align-items:center; justify-content:center;
      border-radius:16px; border:2px solid #e6eaef; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.06);
      transition:transform .15s ease, box-shadow .15s ease, border-color .15s ease, outline-color .15s ease;
      outline:4px solid transparent; position:relative; overflow:hidden;
      user-select: none;
      touch-action: manipulation;
    }
    .picto img{ max-width:100%; max-height:100%; }

    /* Selected */
    .picto.selected{
      outline-color:#ADF1D2; border-color:#294936; box-shadow:0 4px 14px rgba(0,0,0,.12), 0 0 0 4px rgba(173,241,210,.35) inset;
      transform:translateY(-1px);
    }

    /* Activation effect */
    @keyframes pulse {
      0% { transform:scale(1); }
      35%{ transform:scale(1.08); }
      100%{ transform:scale(1); }
    }
    .picto.activated{
      animation:pulse .6s ease-out both;
      border-color:#D36135;
      box-shadow:0 6px 18px rgba(0,0,0,.16), 0 0 0 4px rgba(211,97,53,.25) inset;
    }

    /* Eye-gaze dwell ring */
    .gaze .picto::after{
      content:"";
      position:absolute; inset:-2px;
      border-radius:18px;
      background:conic-gradient(#D36135 0deg, #D36135 0deg, transparent 0deg);
      mix-blend-mode:normal; opacity:.18; pointer-events:none;
      transition:opacity .12s ease;
    }
    .gaze .picto.dwell::after{ opacity:.35; }

    /* Fullscreen toggle */
    #fullscreenBtn{
      position:fixed; top:10px; right:10px; z-index:9999;
      background:#294936; color:#fff; border:none;
      padding:.5em 1em; border-radius:8px; cursor:pointer;
      box-shadow:0 2px 8px rgba(0,0,0,.2);
    }
    #fullscreenBtn:active{ transform:translateY(1px); }

    /* Immersive game slide (hide UI) */
    body.immersive .reveal .controls,
    body.immersive .reveal .progress,
    body.immersive .reveal .slide-number { display:none !important; }

    #slide-game{ padding:0 !important; background:#000; }
    #slide-game .frame-wrap{ position:relative; width:100%; height:100%; }
    #gameFrame{ position:absolute; inset:0; width:100%; height:100%; border:0; background:#000; display:block; }
    #slide-game .overlay-hint{
      position:absolute; left:12px; bottom:12px; z-index:2;
      background:rgba(0,0,0,.45); color:#fff; padding:.35em .6em; border-radius:8px; font-size:.9rem;
    }

    /* Drag & drop styling */
    .reorder-row { display:flex; align-items:center; gap:.5rem; margin:.5rem 0 1rem; }
    .reorder-row input[type="checkbox"] { transform: scale(1.2); }
    .picto.draggable { cursor: grab; }
    .picto.dragging { opacity: .6; cursor: grabbing; }
    .picto.drop-target { outline: 4px dashed #ADF1D2; }
  </style>
</head>
<body>

<!-- Fullscreen button -->
<button id="fullscreenBtn" title="Plein √©cran (‚õ∂)">‚õ∂</button>

<div class="reveal">
  <div class="slides">
    <!-- 1: Intro -->
    <section data-background-color="#DFF3E4">
      <h1>Routine matinale</h1>
      <p class="note-tip">‚Üê ‚Üí ‚Üë ‚Üì (navigation), <kbd>Esc</kbd> (plan), <kbd>S</kbd> (notes). Espace = interaction.</p>
      <p class="badge">Reveal.js ‚Ä¢ D√©mo pr√™te √† l‚Äôemploi</p>
      <aside class="notes">Tour de table, m√©t√©o, rappel de l‚Äôhoraire.</aside>
    </section>

    <!-- 2: Plan -->
    <section>
      <h2>Plan du jour</h2>
      <ul>
        <li class="fragment">Accueil &amp; m√©t√©o</li>
        <li class="fragment">Choix d‚Äôactivit√©s</li>
        <li class="fragment">Pause sensorielle</li>
        <li class="fragment">Ateliers</li>
      </ul>
    </section>

    <!-- 3: Vertical group (M√©t√©o + Jeu) -->
    <section>
      <section>
        <h2>M√©t√©o</h2>
        <p>Demander √† l‚Äô√©l√®ve de s√©lectionner l‚Äôic√¥ne m√©t√©o.</p>
        <p class="note-tip">Appuyez sur <kbd>‚Üì</kbd> pour descendre vers le jeu int√©gr√©.</p>
      </section>

      <!-- Full-slide game -->
      <section id="slide-game">
        <div class="frame-wrap">
          <div class="overlay-hint" id="overlayHint">Astuce: ‚õ∂ pour mode plein √©cran du navigateur</div>
          <iframe id="gameFrame"
                  src="../../games/space-activity/index.html"
                  title="Activit√© int√©gr√©e"
                  allow="autoplay; fullscreen; clipboard-read; clipboard-write; gamepad; accelerometer; gyroscope"
                  allowfullscreen
                  referrerpolicy="no-referrer"></iframe>
        </div>
      </section>
    </section>

    <!-- 4: Markdown -->
    <section data-markdown>
      <textarea data-template>
### Option Markdown (FR/EN)

- **FR** : Slide √©crit en *Markdown* pour faciliter la r√©daction.
- **EN** : This slide uses *Markdown* for quick authoring.

---
#### Liste de contr√¥le
- [ ] Pr√©parer images
- [ ] Importer horaires
- [ ] Tester l‚Äôacc√®s clavier/switch
      </textarea>
    </section>

    <!-- 5: Code -->
    <section>
      <h2>Extrait de code</h2>
      <pre><code class="language-js">
// Exemple: initialiser une "sc√®ne" simple
function startMorningRoutine() {
  const steps = ["M√©t√©o", "Choix", "Pause", "Ateliers"];
  steps.forEach((s, i) => console.log(`#${i+1}:`, s));
}
startMorningRoutine();
      </code></pre>
    </section>

    <!-- 6: Buttons -->
    <section>
      <h2>Interaction rapide</h2>
      <p>Boutons de d√©monstration.</p>
      <button onclick="alert('Bonjour üëã')">Dire bonjour</button>
      <button onclick="Reveal.next()">Slide suivant ‚û°Ô∏è</button>
    </section>

    <!-- 7: Keyboard selection + drag & drop -->
    <section id="slide-keyboard">
      <h2>Pictogrammes ‚Äî S√©lection clavier</h2>
      <p class="note-tip">
        <kbd>Entr√©e</kbd> = suivant (‚áß+Entr√©e = pr√©c√©dent) ‚Ä¢ <kbd>Espace</kbd> = activer ‚Ä¢
        üñ±Ô∏è Cliquez pour activer ‚Ä¢ üîÄ Option ci-dessous pour r√©organiser par glisser-d√©poser
      </p>
      <div class="reorder-row">
        <input type="checkbox" id="toggleReorder">
        <label for="toggleReorder">Activer le mode r√©organisation (glisser-d√©poser)</label>
      </div>
      <div class="picto-grid" id="grid-keyboard"></div>
    </section>

    <!-- 8: Eye-gaze (hover/dwell) -->
    <section id="slide-gaze">
      <h2>Pictogrammes ‚Äî Eye-gaze (survol)</h2>
      <div class="row">
        <label for="dwell">Temps de fixation (ms):</label>
        <input id="dwell" type="range" min="400" max="3000" step="100" value="1200">
        <span id="dwellVal">1200</span>
      </div>
      <p class="note-tip">Survolez une image : un court d√©lai d√©clenche l‚Äôactivation.</p>
      <div class="picto-grid gaze" id="grid-gaze"></div>
    </section>

    <!-- 9: Static grid -->
    <section>
      <h2>Pictogrammes (aper√ßu)</h2>
      <div class="picto-grid" id="grid-static"></div>
    </section>

    <!-- 10: End -->
    <section data-background-color="#ADF1D2">
      <h2>Merci!</h2>
      <p>Docs Reveal.js : <a href="https://revealjs.com" target="_blank" rel="noreferrer">revealjs.com</a></p>
      <p class="note-tip">Impression PDF : ajoutez <code>?print-pdf</code> √† l‚ÄôURL.</p>
    </section>
  </div>
</div>

<!-- Scripts: Reveal + Plugins -->
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4/plugin/markdown/marked.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4/plugin/highlight/highlight.js"></script>

<script>
  // --- CONFIG / DATA ---
  const PICTO_BASE = '../../images/pictos/';
  // NOTE: We keep FILES mutable so reordering persists in-session.
  let FILES = [
    'angry.png','apple.png','assistivebike.png','assistiveswitches.png','balloon.png','banana.png',
    'basketball.png','bear.png','beaver.png','bicycle.png','binsensory.png','binwater.png',
    'blackroom.png','boat.png','book.png','book2.png','bowl.png','broccoli.png','brush.png','bus.png'
  ];

  // Build grid into containerId (from FILES order)
  function buildGrid(containerId){
    const el = document.getElementById(containerId);
    el.innerHTML = '';
    FILES.forEach((name, i)=>{
      const tile = document.createElement('div');
      tile.className = 'picto';
      tile.dataset.index = i; // index in FILES
      const img = document.createElement('img');
      img.alt = name.replace('.png','');
      img.src = PICTO_BASE + name;
      tile.appendChild(img);
      el.appendChild(tile);
    });
    return el.querySelectorAll('.picto');
  }

  // ====== Keyboard selection (Enter to move, Space to activate) + Mouse click ======
  function makeKeyboardNavigable(gridId){
    const container = document.getElementById(gridId);
    let nodes = buildGrid(gridId);
    if(!nodes.length) return;

    let idx = 0;
    const refreshNodes = ()=>{ nodes = container.querySelectorAll('.picto'); };

    const select = i=>{
      refreshNodes();
      idx = (i + nodes.length) % nodes.length;
      nodes.forEach(n=>n.classList.remove('selected'));
      nodes[idx].classList.add('selected');
      nodes[idx].scrollIntoView({block:'nearest', inline:'nearest'});
    };
    const activate = ()=>{
      refreshNodes();
      const n = nodes[idx];
      if(!n) return;
      n.classList.add('activated');
      setTimeout(()=>n.classList.remove('activated'), 700);
    };

    // Mouse/touch: click = select + activate
    nodes.forEach((node, i)=>{
      node.addEventListener('click', ()=>{
        select(i);
        activate();
      });
    });

    // Start with first selected
    select(0);

    const onKey = (e)=>{
      if(Reveal.getCurrentSlide()?.id !== 'slide-keyboard') return; // only on this slide
      if(e.key === 'Enter'){
        e.preventDefault(); e.stopImmediatePropagation();
        select(e.shiftKey ? idx-1 : idx+1);
      } else if(e.key === ' ' || e.key === 'Spacebar'){
        e.preventDefault(); e.stopImmediatePropagation();
        activate();
      }
    };

    window.addEventListener('keydown', onKey, { capture: true });

    // ---- Drag & Drop (toggleable) ----
    const toggle = document.getElementById('toggleReorder');

    function enableDnD(){
      refreshNodes();
      nodes.forEach(n=>{
        n.setAttribute('draggable','true');
        n.classList.add('draggable');

        n.addEventListener('dragstart', onDragStart);
        n.addEventListener('dragenter', onDragEnter);
        n.addEventListener('dragover', onDragOver);
        n.addEventListener('dragleave', onDragLeave);
        n.addEventListener('drop', onDrop);
        n.addEventListener('dragend', onDragEnd);
      });
    }
    function disableDnD(){
      refreshNodes();
      nodes.forEach(n=>{
        n.removeAttribute('draggable');
        n.classList.remove('draggable','dragging','drop-target');
        n.removeEventListener('dragstart', onDragStart);
        n.removeEventListener('dragenter', onDragEnter);
        n.removeEventListener('dragover', onDragOver);
        n.removeEventListener('dragleave', onDragLeave);
        n.removeEventListener('drop', onDrop);
        n.removeEventListener('dragend', onDragEnd);
      });
    }

    let dragSrcIndex = null;

    function onDragStart(e){
      const tile = e.currentTarget;
      dragSrcIndex = parseInt(tile.dataset.index, 10);
      tile.classList.add('dragging');
      // Improve dragging feedback image (if supported)
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = 'move';
        try { e.dataTransfer.setData('text/plain', dragSrcIndex); } catch {}
      }
    }
    function onDragEnter(e){
      e.preventDefault();
      e.currentTarget.classList.add('drop-target');
    }
    function onDragOver(e){
      e.preventDefault();
      if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    }
    function onDragLeave(e){
      e.currentTarget.classList.remove('drop-target');
    }
    function onDrop(e){
      e.preventDefault();
      const target = e.currentTarget;
      target.classList.remove('drop-target');
      const dropIndex = parseInt(target.dataset.index, 10);
      if (isNaN(dragSrcIndex) || isNaN(dropIndex) || dragSrcIndex === dropIndex) return;

      // Reorder FILES array
      const moved = FILES.splice(dragSrcIndex, 1)[0];
      FILES.splice(dropIndex, 0, moved);

      // Rebuild grid in new order and keep selection on moved item
      nodes = buildGrid(gridId);
      // Rebind click handlers after rebuild
      nodes.forEach((node, i)=>{
        node.addEventListener('click', ()=>{ select(i); activate(); });
      });
      // Update selection index to new position of moved item
      idx = dropIndex;
      select(idx);
      // Re-enable DnD if toggle is still on
      if (toggle.checked) enableDnD();
    }
    function onDragEnd(e){
      e.currentTarget.classList.remove('dragging');
      container.querySelectorAll('.drop-target').forEach(el=>el.classList.remove('drop-target'));
      dragSrcIndex = null;
    }

    // Toggle handlers
    toggle.addEventListener('change', ()=>{
      if (toggle.checked) enableDnD(); else disableDnD();
    });

    // Clean up when leaving slide
    const off = ()=>{
      window.removeEventListener('keydown', onKey, { capture: true });
      disableDnD();
      Reveal.off('slidechanged', handler);
    };
    const handler = (evt)=>{
      if(evt.previousSlide && evt.previousSlide.id === 'slide-keyboard'){ off(); }
    };
    Reveal.on('slidechanged', handler);
  }

  // ====== Eye-gaze (hover dwell) ======
  function makeGazeGrid(gridId, sliderId, labelId){
    const nodes = buildGrid(gridId);
    const dwellInput = document.getElementById(sliderId);
    const dwellVal = document.getElementById(labelId);
    let dwellMs = parseInt(dwellInput.value,10) || 1200;
    dwellVal.textContent = dwellMs;

    dwellInput.addEventListener('input', ()=>{
      dwellMs = parseInt(dwellInput.value,10);
      dwellVal.textContent = dwellMs;
    });

    nodes.forEach(tile=>{
      let t = null;
      const start = ()=>{
        tile.classList.add('dwell');
        t = setTimeout(()=>{
          tile.classList.remove('dwell');
          tile.classList.add('activated');
          setTimeout(()=>tile.classList.remove('activated'), 700);
        }, dwellMs);
      };
      const stop = ()=>{
        tile.classList.remove('dwell');
        if(t){ clearTimeout(t); t = null; }
      };
      tile.addEventListener('mouseenter', start);
      tile.addEventListener('mouseleave', stop);
      tile.addEventListener('click', ()=>{
        tile.classList.add('activated');
        setTimeout(()=>tile.classList.remove('activated'), 700);
      });
    });
  }

  // ====== Static preview ======
  function buildStatic(){ buildGrid('grid-static'); }

  // ====== Reveal init (Space disabled for slide advance) ======
  Reveal.initialize({
    hash: true, slideNumber: true, controls: true, progress: true,
    center: true, history: true, transition: 'slide',
    width: 1280, height: 720,
    keyboard: { 32: null }, // disable Space advancing slides
    plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
  });

  // Fullscreen toggle (manual)
  document.getElementById("fullscreenBtn").addEventListener("click", ()=>{
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(()=>{});
    } else {
      document.exitFullscreen();
    }
  });

  // Game slide immersive behavior
  const gameFrame = document.getElementById('gameFrame');
  const overlayHint = document.getElementById('overlayHint');

  function enterGameMode(){
    document.body.classList.add('immersive');
    if (gameFrame) gameFrame.focus();
    if (gameFrame && gameFrame.requestFullscreen) {
      gameFrame.requestFullscreen().then(()=>{
        if (overlayHint) overlayHint.style.display = 'none';
      }).catch(()=>{
        if (overlayHint) overlayHint.style.display = '';
      });
    }
  }
  function exitGameMode(){
    document.body.classList.remove('immersive');
    if (document.fullscreenElement && document.exitFullscreen) {
      document.exitFullscreen().catch(()=>{});
    }
  }

  Reveal.on('slidechanged', (evt)=>{
    const now = evt.currentSlide, prev = evt.previousSlide;
    if (now && now.id === 'slide-game') enterGameMode();
    else if (prev && prev.id === 'slide-game') exitGameMode();
  });

  // On ready
  Reveal.on('ready', () => {
    if (window.hljs) { hljs.highlightAll(); }
    buildStatic();
    makeGazeGrid('grid-gaze','dwell','dwellVal');

    // Attach keyboard/mouse + DnD grid when we first land on that slide
    const tryAttachKeyboard = ()=>{
      if(Reveal.getCurrentSlide()?.id === 'slide-keyboard'){
        makeKeyboardNavigable('grid-keyboard');
        Reveal.off('slidechanged', tryAttachKeyboard);
      }
    };
    Reveal.on('slidechanged', tryAttachKeyboard);
    if(Reveal.getCurrentSlide()?.id === 'slide-keyboard'){
      makeKeyboardNavigable('grid-keyboard');
    }

    // If starting on game slide
    if (Reveal.getCurrentSlide()?.id === 'slide-game') enterGameMode();
  });
</script>
</body>
</html>
