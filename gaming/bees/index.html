<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Honey Glow â€“ Cause & Effect</title>
  <style>
    :root {
      --bg-top: #0b1224;
      --bg-bottom: #031316;
      --honey: #f8d477;
      --honey-deep: #f5b50c;
      --wax: #ffe8b5;
      --text: #f1f5f9;
      --muted: #cbd5e1;
      --button: #f9c23c;
      --button-shadow: rgba(249, 194, 60, 0.4);
      --flower-1: #ff9f80;
      --flower-2: #ff6fb7;
      --flower-3: #7bdcb5;
      --flower-4: #ffd166;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Nunito", "Segoe UI", system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      background: radial-gradient(circle at 70% 20%, rgba(79, 70, 229, 0.15), transparent 40%),
        radial-gradient(circle at 30% 80%, rgba(45, 212, 191, 0.14), transparent 35%),
        linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
      color: var(--text);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 1rem 1.5rem 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      align-items: flex-start;
      position: relative;
      z-index: 2;
    }

    h1 {
      font-size: clamp(1.4rem, 2vw, 1.9rem);
      font-weight: 800;
      letter-spacing: 0.5px;
      text-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }

    .subtitle {
      color: var(--muted);
      font-size: 0.98rem;
      max-width: 680px;
      line-height: 1.4;
    }

    .cta-row {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .cta-button {
      appearance: none;
      border: none;
      background: radial-gradient(circle at 30% 30%, #fff6d8, #ffe08a 60%, #f2a600);
      color: #2f1a04;
      padding: 0.85rem 1.8rem;
      font-size: 1.05rem;
      font-weight: 800;
      border-radius: 999px;
      box-shadow: 0 15px 35px var(--button-shadow), inset 0 -6px 10px rgba(0, 0, 0, 0.14);
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.1s ease;
    }

    .cta-button:active {
      transform: scale(0.98);
      box-shadow: 0 8px 18px var(--button-shadow);
    }

    .cta-note {
      color: var(--muted);
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    main {
      position: relative;
      flex: 1;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .floating-hint {
      position: absolute;
      bottom: 1.1rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(3, 7, 18, 0.55);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--muted);
      padding: 0.7rem 1.1rem;
      border-radius: 1rem;
      font-weight: 700;
      letter-spacing: 0.3px;
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.35);
      animation: float 3.5s ease-in-out infinite;
      z-index: 2;
    }

    @keyframes float {
      0%,
      100% {
        transform: translate(-50%, 0);
      }
      50% {
        transform: translate(-50%, -8px);
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Honey Glow</h1>
    <div class="subtitle">
      A calming cause-and-effect activity: send bees to bright flowers, watch honey fill the hive, and enjoy the glow.
    </div>
    <div class="cta-row">
      <button class="cta-button" id="actionButton" aria-label="Send the bees">Send the bees</button>
      <div class="cta-note">Press SPACE or tap anywhere to play.</div>
    </div>
  </header>

  <main>
    <canvas id="scene" aria-hidden="true"></canvas>
    <div class="floating-hint">Every press brings color and honey.</div>
  </main>

  <script>
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    function resize() {
      const rect = canvas.getBoundingClientRect();
      const scale = window.devicePixelRatio || 1;
      canvas.width = rect.width * scale;
      canvas.height = rect.height * scale;
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
    }

    window.addEventListener("resize", resize);
    resize();

    // Sound
    let audioCtx = null;
    function ensureAudio() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
      }
    }

    function playChime() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = 720;
      gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.03);
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.65);
    }

    // Hive
    const cells = [];
    let hexRadius = 42;

    function axialToPixel(q, r) {
      const x = hexRadius * (3 / 2) * q;
      const y = hexRadius * Math.sqrt(3) * (r + q / 2);
      return { x, y };
    }

    function makeCells() {
      cells.length = 0;
      const positions = [
        [0, 0],
        [1, 0],
        [0, 1],
        [-1, 1],
        [-1, 0],
        [0, -1],
        [1, -1],
      ];
      for (const [q, r] of positions) {
        const { x, y } = axialToPixel(q, r);
        cells.push({ x, y, honey: Math.random() * 0.35 });
      }
    }

    makeCells();

    function hiveCenter() {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      return { x: w * 0.28, y: h * 0.55 };
    }

    function drawHex(x, y, radius, fill, stroke) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i + Math.PI / 6;
        const px = x + radius * Math.cos(angle);
        const py = y + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2.5;
      ctx.fill();
      ctx.stroke();
    }

    function drawHive() {
      const center = hiveCenter();
      const glow = ctx.createRadialGradient(center.x, center.y, hexRadius * 0.5, center.x, center.y, hexRadius * 4.2);
      glow.addColorStop(0, "rgba(248, 212, 119, 0.28)");
      glow.addColorStop(1, "rgba(248, 212, 119, 0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(center.x, center.y, hexRadius * 4.3, 0, Math.PI * 2);
      ctx.fill();

      for (const cell of cells) {
        const x = center.x + cell.x;
        const y = center.y + cell.y;
        const honeyAmount = Math.min(1, cell.honey);
        const honey = ctx.createRadialGradient(x, y - hexRadius * 0.15, 0, x, y, hexRadius);
        honey.addColorStop(0, "rgba(255, 252, 235, 0.95)");
        honey.addColorStop(1, `rgba(245, 181, 12, ${0.35 + honeyAmount * 0.55})`);
        const wax = `rgba(255, 232, 181, 0.${Math.round(6 + honeyAmount * 3)})`;
        drawHex(x, y, hexRadius * 0.95, honeyAmount > 0.01 ? honey : wax, "rgba(255, 207, 92, 0.9)");

        if (honeyAmount > 0.2) {
          ctx.beginPath();
          ctx.arc(x, y + hexRadius * 0.05, hexRadius * (0.4 + honeyAmount * 0.2), 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255, 248, 225, 0.55)";
          ctx.fill();
        }
      }
    }

    // Flowers
    const flowers = [];
    function makeFlowers() {
      flowers.length = 0;
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      const startX = w * 0.58;
      const endX = w * 0.86;
      const startY = h * 0.35;
      const endY = h * 0.7;
      const palette = ["var(--flower-1)", "var(--flower-2)", "var(--flower-3)", "var(--flower-4)"];
      for (let i = 0; i < 6; i++) {
        const t = i / 5;
        const x = startX + (endX - startX) * (t + (Math.random() - 0.5) * 0.18);
        const y = startY + (endY - startY) * (t * 0.6 + Math.random() * 0.2);
        const size = Math.min(w, h) * 0.06;
        flowers.push({ x, y, size, color: palette[i % palette.length], sway: Math.random() * Math.PI * 2 });
      }
    }

    makeFlowers();

    function drawFlowers(time) {
      for (const flower of flowers) {
        const sway = Math.sin(time * 0.001 + flower.sway) * flower.size * 0.08;
        ctx.save();
        ctx.translate(flower.x, flower.y);
        ctx.rotate(sway * 0.0025);

        // stem
        ctx.strokeStyle = "#1c7c54";
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(0, -flower.size * 0.1);
        ctx.quadraticCurveTo(-flower.size * 0.1, flower.size * 0.6, 0, flower.size * 1.15);
        ctx.stroke();

        // petals
        const petals = 8;
        for (let i = 0; i < petals; i++) {
          const ang = (Math.PI * 2 * i) / petals;
          const px = Math.cos(ang) * flower.size * 0.75;
          const py = Math.sin(ang) * flower.size * 0.55;
          ctx.beginPath();
          ctx.fillStyle = flower.color;
          ctx.ellipse(px, py, flower.size * 0.55, flower.size * 0.25, ang, 0, Math.PI * 2);
          ctx.fill();
        }

        // center
        ctx.beginPath();
        ctx.fillStyle = "#ffe6a7";
        ctx.arc(0, 0, flower.size * 0.35, 0, Math.PI * 2);
        ctx.fill();

        // glow
        const glow = ctx.createRadialGradient(0, 0, flower.size * 0.2, 0, 0, flower.size * 1.1);
        glow.addColorStop(0, "rgba(255, 240, 200, 0.65)");
        glow.addColorStop(1, "rgba(255, 240, 200, 0)");
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, flower.size * 1.1, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    // Bees
    const bees = [];
    const beeCount = 6;
    for (let i = 0; i < beeCount; i++) {
      bees.push({
        x: 0,
        y: 0,
        wobble: Math.random() * Math.PI * 2,
        heading: Math.random() * Math.PI * 2,
        state: "idle",
        progress: 0,
        duration: 3,
        target: null,
      });
    }

    function resetBeePositions() {
      const center = hiveCenter();
      bees.forEach((bee, i) => {
        const angle = (Math.PI * 2 * i) / beeCount;
        bee.x = center.x + Math.cos(angle) * hexRadius * 0.6;
        bee.y = center.y + Math.sin(angle) * hexRadius * 0.6;
        bee.state = "idle";
        bee.progress = 0;
      });
    }

    resetBeePositions();

    function drawBee(bee, moving) {
      ctx.save();
      ctx.translate(bee.x, bee.y);
      ctx.rotate(bee.heading);
      const bodyL = 26;
      const bodyW = 16;

      // glow
      const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, bodyL * 0.9);
      glow.addColorStop(0, "rgba(255, 219, 121, 0.65)");
      glow.addColorStop(1, "rgba(255, 219, 121, 0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, 0, bodyL * 0.9, 0, Math.PI * 2);
      ctx.fill();

      const flap = Math.sin(bee.wobble * 1.8) * (moving ? 0.8 : 0.3);
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = "rgba(198, 219, 255, 0.9)";
      ctx.beginPath();
      ctx.ellipse(-4, -bodyW, 8, 14, -0.5 + flap, 0, Math.PI * 2);
      ctx.ellipse(-4, bodyW, 8, 14, 0.5 - flap, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      const gradient = ctx.createLinearGradient(-bodyL / 2, 0, bodyL / 2, 0);
      gradient.addColorStop(0, "#ffef8f");
      gradient.addColorStop(0.7, "#a66b1e");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.ellipse(0, 0, bodyL / 2, bodyW / 2, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#1f1300";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-bodyL * 0.05, -bodyW / 2);
      ctx.lineTo(-bodyL * 0.05, bodyW / 2);
      ctx.moveTo(bodyL * 0.23, -bodyW / 2);
      ctx.lineTo(bodyL * 0.23, bodyW / 2);
      ctx.stroke();

      ctx.fillStyle = "#111827";
      ctx.beginPath();
      ctx.arc(bodyL * 0.48, 0, bodyW * 0.55, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(bodyL * 0.5, -2, bodyW * 0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function sendBees() {
      ensureAudio();
      playChime();
      const targets = [...flowers];
      const center = hiveCenter();
      bees.forEach((bee, i) => {
        bee.state = "toFlower";
        bee.progress = 0;
        bee.duration = 2.5 + Math.random() * 0.8;
        bee.from = { x: center.x, y: center.y };
        bee.target = targets[i % targets.length];
      });
      triggerSparkles(center.x, center.y, "honey");
    }

    function updateBees(dt) {
      const center = hiveCenter();
      bees.forEach((bee) => {
        bee.wobble += dt * 6;
        if (bee.state === "idle") {
          bee.heading += dt * 0.7 * (Math.random() > 0.5 ? 1 : -1);
          bee.x += Math.cos(bee.heading) * dt * 10;
          bee.y += Math.sin(bee.heading) * dt * 10;
          const pullX = center.x - bee.x;
          const pullY = center.y - bee.y;
          bee.x += pullX * dt * 0.4;
          bee.y += pullY * dt * 0.4;
          return;
        }

        bee.progress += dt / bee.duration;
        const t = Math.min(1, bee.progress);
        const eased = easeInOut(t);

        const start = bee.state === "toFlower" ? bee.from : bee.target;
        const end = bee.state === "toFlower" ? bee.target : center;
        bee.x = start.x + (end.x - start.x) * eased;
        bee.y = start.y + (end.y - start.y) * eased;
        bee.heading = Math.atan2(end.y - start.y, end.x - start.x);

        if (t >= 1) {
          if (bee.state === "toFlower") {
            triggerSparkles(bee.x, bee.y, "flower");
            bee.state = "return";
            bee.progress = 0;
            bee.duration = 2 + Math.random() * 0.5;
          } else {
            addHoney();
            triggerSparkles(center.x, center.y, "honey");
            bee.state = "idle";
            bee.progress = 0;
          }
        }
      });
    }

    function addHoney() {
      const target = cells.sort((a, b) => a.honey - b.honey)[0];
      target.honey = Math.min(1, target.honey + 0.22 + Math.random() * 0.08);
    }

    // Sparkles
    const sparkles = [];
    function triggerSparkles(x, y, type) {
      const count = 18;
      const baseColor = type === "flower" ? "rgba(255, 225, 160," : "rgba(249, 194, 60,";
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count + Math.random() * 0.4;
        const speed = 60 + Math.random() * 60;
        sparkles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.9 + Math.random() * 0.4,
          color: baseColor,
        });
      }
    }

    function updateSparkles(dt) {
      for (const s of sparkles) {
        s.life -= dt;
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        s.vy += 18 * dt;
      }
      for (let i = sparkles.length - 1; i >= 0; i--) {
        if (sparkles[i].life <= 0) sparkles.splice(i, 1);
      }
    }

    function drawSparkles() {
      for (const s of sparkles) {
        const a = Math.max(0, s.life / 1.2);
        const r = 2 + (1 - a) * 5;
        const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, r);
        grad.addColorStop(0, `${s.color}${(0.6 + a * 0.4).toFixed(2)})`);
        grad.addColorStop(1, `${s.color}0)`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Background bubbles
    const bubbles = Array.from({ length: 30 }, () => ({
      x: Math.random(),
      y: Math.random(),
      r: Math.random() * 12 + 4,
      speed: 8 + Math.random() * 12,
      alpha: 0.08 + Math.random() * 0.08,
    }));

    function drawBackground(dt) {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      ctx.fillStyle = "rgba(1, 6, 14, 0.25)";
      ctx.fillRect(0, 0, w, h);

      bubbles.forEach((b) => {
        b.y -= (dt || 0) * (b.speed * 0.1);
        if (b.y < -0.05) b.y = 1.05;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 255, 255, ${b.alpha})`;
        ctx.arc(b.x * w, b.y * h, b.r, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Interaction
    const actionButton = document.getElementById("actionButton");
    actionButton.addEventListener("click", () => {
      sendBees();
    });

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        sendBees();
      }
    });

    window.addEventListener("pointerdown", () => {
      sendBees();
    });

    // Animation loop
    let last = performance.now();
    function loop(now) {
      const dt = Math.min((now - last) / 1000, 0.05);
      last = now;

      drawBackground(dt);
      drawFlowers(now);
      drawHive();
      updateBees(dt);
      updateSparkles(dt);
      bees.forEach((bee) => drawBee(bee, bee.state !== "idle"));
      drawSparkles();

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
