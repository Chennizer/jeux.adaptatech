<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <title
    class="translate"
    data-fr="Bulles géantes : jeu switch"
    data-en="Giant Bubbles: switch game"
    data-ja="巨大シャボン玉：スイッチゲーム">
    Bulles géantes : jeu switch
  </title>

  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>

  <!-- thème global -->
  <link rel="stylesheet" href="../../css/otherswitch.css">

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #020714;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    /* Icône réglages (40×40) */
    #settings-icon {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #000;
      color: #fff;
      font-size: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: hidden;
      cursor: pointer;
      z-index: 9999;
    }

    /* Bouton langue – top-right on landing */
    #langToggle {
      position: fixed;
      top: 16px;
      right: 46px;
      z-index: 10000;
      padding: 8px 14px;
      border-radius: 12px;
      border: 2px solid #1ccad8;
      background: #0b0f12;
      color: #1ccad8;
      font-weight: 700;
      letter-spacing: .03em;
      cursor: pointer;
      user-select: none;
    }

    #menu {
      z-index: 10000;
    }

    /* Sélecteur de mode (reprend le style du xylophone) */
    #modeSelect {
      display: flex;
      gap: 1rem;
      margin: 1.5rem 0 1.25rem;
    }
    #modeSelect button {
      flex: 1;
      padding: 0.75rem 1rem;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 8px;
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    #modeSelect button:hover {
      background: rgba(255,255,255,0.2);
    }
    #modeSelect button.active {
      background: #00bfff;
      color: #000;
      font-weight: bold;
    }
  </style>

  <!-- Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-B45TJG4GBJ');
  </script>
</head>

<body>
<button id="langToggle" title="Changer la langue / Switch language">EN</button>

<!-- ────────── Landing ────────── -->
<div id="promptOverlay">
  <button id="infoButton"
          title="More info"
          class="translate"
          data-fr="ⓘ" data-en="ⓘ" data-ja="ⓘ">ⓘ</button>

  <p class="translate"
     data-fr="Pour un ou deux joueurs; la première switch crée des bulles et la seconde les fait éclater."
     data-en="For one or two players: the first switch creates bubbles and the second pops them."
     data-ja="1人または2人のプレイヤー向け：1つ目のスイッチでシャボン玉を作り、2つ目のスイッチで割ります。">
    Pour un ou deux joueurs; la première switch crée des bulles et la seconde les fait éclater.
  </p>

  <div id="modeSelect">
    <button data-mode="aqua" class="active translate"
            data-fr="Mode Océan" data-en="Ocean mode" data-ja="オーシャンモード">Mode Océan</button>
    <button data-mode="rainbow" class="translate"
            data-fr="Mode Multicolore" data-en="Multicolor mode" data-ja="マルチカラー">Mode Multicolore</button>
  </div>

  <button id="startButton"
          class="translate"
          data-fr="Commencer"
          data-en="Start"
          data-ja="開始">
    Commencer
  </button>
</div>

<!-- ────────── Modal info ────────── -->
<div id="infoModal" style="display:none;">
<p class="translate"
   data-fr="Différentiation de l'effet de deux switchs (niveau 20) pour l'activité individuelle et exploration individuelle et maintien pour l'activité en équipe (niveau 10 et 17)<br>Switch Heroes (Jiao) : Niveau 5 – Choix entre deux switchs (individuel) · Niveau 2/4 – Maintien et exploration en équipe"
   data-en="Differentiating the effect of two switches (level 20) for individual activities, and individual exploration and sustaining for team activities (levels 10 and 17).<br>Switch Heroes (Jiao): Stage 5 – Two-switch choice (solo) · Stage 2/4 – Hold and explore in group play"
   data-ja="個別活動では2つのスイッチの効果を区別する（レベル20）。集団活動では、個別探索と活動の維持（レベル10・17）をねらいます。<br>Switch Heroes（Jiao）：ステージ5 – 2つのスイッチ選択（個別）、ステージ2/4 – 保持と探索（集団）">
  Différentiation de l'effet de deux switchs (niveau 20) pour l'activité individuelle et exploration individuelle et maintien pour l'activité en équipe (niveau 10 et 17)<br>Switch Heroes (Jiao) : Niveau 5 – Choix entre deux switchs (individuel) · Niveau 2/4 – Maintien et exploration en équipe
</p>

  <button id="closeModal"
          class="translate"
          data-fr="Fermer"
          data-en="Close"
          data-ja="閉じる">
    Fermer
  </button>
</div>

<!-- Icône réglages -->
<div id="settings-icon"
     title="Settings"
     class="translate"
     data-fr="⚙️" data-en="⚙️" data-ja="⚙️">⚙️</div>

<!-- ────────── Menu options ────────── -->
<div id="menu">
  <h2 class="translate" data-fr="Options" data-en="Options" data-ja="オプション">Options</h2>

  <h3 class="translate" data-fr="Musique &amp; son" data-en="Music &amp; Sound" data-ja="音楽と効果音">
    Musique & son
  </h3>

  <label class="inline">
    <span class="translate"
          data-fr="Désactiver la musique"
          data-en="Disable music"
          data-ja="音楽をミュート">Désactiver la musique</span>
    <input type="checkbox" id="muteMusic">
  </label>

  <label>
    <span class="translate" data-fr="Volume musique" data-en="Music volume" data-ja="音楽の音量">
      Volume musique
    </span>
    <span id="musicVolVal">50</span>
    <input type="range" id="musicVol" min="0" max="100" value="50">
  </label>

  <label class="inline">
    <span class="translate"
          data-fr="Désactiver les effets"
          data-en="Disable SFX"
          data-ja="効果音をミュート">Désactiver les effets</span>
    <input type="checkbox" id="muteSFX">
  </label>

  <label>
    <span class="translate" data-fr="Volume effets" data-en="SFX volume" data-ja="効果音の音量">
      Volume effets
    </span>
    <span id="sfxVolVal">50</span>
    <input type="range" id="sfxVol" min="0" max="100" value="50">
  </label>

  <h3 class="translate" data-fr="Délai entre appuis" data-en="Press delay" data-ja="押下間隔">
    Délai entre appuis (ms)
  </h3>

  <label>
    <span class="translate" data-fr="Délai" data-en="Delay" data-ja="間隔">Délai</span>
    <span id="tapDelayVal">2000</span>
    <input type="range" id="tapDelaySlider" min="300" max="5000" value="2000">
  </label>
</div>

<!-- ────────── JS : logique du jeu ────────── -->
<script>
/* === AUDIO : PLAYLISTS + SFX =============================== */
const PLAYLISTS = {
  aqua: [
    '../../songs/bubbles/waterbubble1.mp3',
    '../../songs/bubbles/waterbubble2.mp3'
  ],
  rainbow: [
    '../../songs/bubbles/coloredbubbles1.mp3',
    '../../songs/bubbles/coloredbubbles2.mp3'
  ]
};

/* Deux familles de SFX */
const APPEAR_SFX_PATHS = [
  '../../sounds/bubbles/bubble1.mp3',
  '../../sounds/bubbles/bubble2.mp3',
  '../../sounds/bubbles/bubble3.mp3'
];

const POP_SFX_PATHS = [
  '../../sounds/bubbles/bubbleexplosion1.mp3',
  '../../sounds/bubbles/bubbleexplosion2.mp3'
];

let musicPlaylists = {};    // { mode: [p5.SoundFile | null, ...] }
let currentTrackIndex = 0;
let currentMusic = null;

let appearSounds = [];
let popSounds   = [];

/* === VISUEL ================================================= */
const THEMES = {
  aqua: {
    background: [5, 15, 40],
    bgStroke: [180, 210, 255],
    palette: [[180, 210, 255]],
    halo: 'rgba(150,210,255,0.5)',
    fillCore: [120, 190, 255, 80],
    fillEdge: [60, 120, 200, 30],
    ring: [200, 230, 255, 200],
    outline: [230, 240, 255, 220],
    highlight1: [255, 255, 255, 170],
    highlight2: [200, 230, 255, 150],
    popRing: [230, 240, 255],
    popParticle: [230, 240, 255],
    popFlash: [255, 255, 255]
  },
  rainbow: {
    background: [12, 4, 28],
    bgStroke: [230, 200, 255],
    palette: [
      [255, 72, 160],
      [0, 245, 255],
      [255, 210, 64],
      [125, 255, 167],
      [112, 135, 255],
      [255, 137, 79]
    ],
    haloAlpha: 0.9,
    fillCoreAlpha: 0.65,
    fillEdgeAlpha: 0.5,
    gradient: [
      [255, 77, 196],
      [66, 212, 255],
      [255, 221, 77],
      [102, 255, 195],
      [167, 123, 255]
    ]
  }
};

let bgBubbles = [];
let bigBubbles = [];
let popBursts  = [];
const NUM_BG_BUBBLES = 60;

/* === ÉTAT =================================================== */
let tapDelay = 2000;
let lastTap  = -Infinity;
let currentTheme = 'aqua';
let isGameStarted = false;

/* === VOLUMES =============================================== */
let isMusicMuted = false, isSFXMuted = false;
let volMusic = 0.5, volSFX = 0.5;

/* === p5 : PRELOAD ========================================== */
function preload() {
  // Formats supportés
  soundFormats('mp3', 'wav', 'ogg');

  // Charger playlists
  for (const mode in PLAYLISTS) {
    musicPlaylists[mode] = PLAYLISTS[mode].map(path =>
      loadSound(
        path,
        () => {
          console.log('[OK] music loaded:', path);
        },
        err => {
          console.error('[ERROR] unable to decode music file:', path, err);
        }
      )
    );
  }

  // Charger SFX apparition
  appearSounds = APPEAR_SFX_PATHS.map(path =>
    loadSound(
      path,
      () => {
        console.log('[OK] appear SFX loaded:', path);
      },
      err => {
        console.error('[ERROR] unable to decode appear SFX:', path, err);
      }
    )
  );

  // Charger SFX pop
  popSounds = POP_SFX_PATHS.map(path =>
    loadSound(
      path,
      () => {
        console.log('[OK] pop SFX loaded:', path);
      },
      err => {
        console.error('[ERROR] unable to decode pop SFX:', path, err);
      }
    )
  );
}

/* === BULLES FOND ============================================ */
class BackgroundBubble {
  constructor() {
    this.reset(true);
  }

  reset(randomY = false) {
    this.x = random(width);
    this.y = randomY ? random(height) : height + random(20, 200);
    this.r = random(4, 14);
    this.speed = random(0.2, 0.8);
    this.alpha = random(15, 60);
    this.paletteIndex = floor(random((THEMES[currentTheme].palette || []).length || 1));
  }

  update() {
    this.y -= this.speed;
    if (this.y + this.r < -20) {
      this.reset(false);
    }
  }

  draw() {
    noFill();
    const theme = THEMES[currentTheme];
    const palette = theme.palette || [theme.bgStroke];
    const colorChoice = palette[this.paletteIndex % palette.length];
    stroke(colorChoice[0], colorChoice[1], colorChoice[2], this.alpha);
    strokeWeight(1);
    ellipse(this.x, this.y, this.r * 2);
  }
}

function createBubbleColors(theme) {
  if (theme === 'rainbow') {
    const palette = THEMES.rainbow.palette;
    const main = random(palette);
    const accent = random(palette);
    const highlightAccent = random(palette);
    const glow = random(palette);
    const fillAccent = random(palette);
    return {
      halo: `rgba(${glow[0]},${glow[1]},${glow[2]},${THEMES.rainbow.haloAlpha})`,
      fillCore: [main[0], main[1], main[2], THEMES.rainbow.fillCoreAlpha * 255],
      fillEdge: [fillAccent[0], fillAccent[1], fillAccent[2], THEMES.rainbow.fillEdgeAlpha * 255],
      ring: [accent[0], accent[1], accent[2], 235],
      outline: [main[0], main[1], main[2], 245],
      highlight1: [255, 255, 255, 205],
      highlight2: [highlightAccent[0], highlightAccent[1], highlightAccent[2], 190],
      popRing: [accent[0], accent[1], accent[2]],
      popParticle: [main[0], main[1], main[2]],
      popFlash: [255, 255, 255]
    };
  }

  return {
    halo: THEMES.aqua.halo,
    fillCore: [...THEMES.aqua.fillCore],
    fillEdge: [...THEMES.aqua.fillEdge],
    ring: [...THEMES.aqua.ring],
    outline: [...THEMES.aqua.outline],
    highlight1: [...THEMES.aqua.highlight1],
    highlight2: [...THEMES.aqua.highlight2],
    popRing: [...THEMES.aqua.popRing],
    popParticle: [...THEMES.aqua.popParticle],
    popFlash: [...THEMES.aqua.popFlash]
  };
}

/* === BULLES GÉANTES ======================================== */
class BigBubble {
  constructor(x, baseRadiusMult = 1, theme = 'aqua') {
    this.x = x;
    this.y = height + 80;
    this.baseR = random(90, 180) * baseRadiusMult;
    this.r = this.baseR;
    this.vx = random(-0.3, 0.3);
    this.vy = random(-1.2, -0.6);
    this.wobblePhase = random(TWO_PI);
    this.colors = createBubbleColors(theme);
  }

  update(dt) {
    const k = dt / 16.67;

    this.vx *= 0.99;
    this.vy = lerp(this.vy, -1.2, 0.01);

    this.x += this.vx * k;
    this.y += this.vy * k;

    const topMargin = 12;
    if (this.y - this.r < topMargin) {
      this.y = this.r + topMargin;
      this.vy = 0;
    }

    if (this.x - this.r < 0) {
      this.x = this.r;
      this.vx *= -0.5;
    }
    if (this.x + this.r > width) {
      this.x = width - this.r;
      this.vx *= -0.5;
    }

    this.wobblePhase += 0.005 * dt;
    const wobble = sin(this.wobblePhase) * 0.04;
    this.r = this.baseR * (1 + wobble);
  }

  draw() {
    const cx = this.x;
    const cy = this.y;
    const r  = this.r;
    const c  = this.colors;

    // Remplissage coloré (dégradé radial)
    push();
    drawingContext.save();
    const grad = drawingContext.createRadialGradient(
      cx - r * 0.25, cy - r * 0.25, r * 0.1,
      cx, cy, r * 1.05
    );
    const fc = c.fillCore;
    const fe = c.fillEdge;
    grad.addColorStop(0, `rgba(${fc[0]},${fc[1]},${fc[2]},${(fc[3] ?? 255) / 255})`);
    grad.addColorStop(0.55, `rgba(${fe[0]},${fe[1]},${fe[2]},${(fe[3] ?? 255) / 255})`);
    grad.addColorStop(1, 'rgba(0,0,0,0.05)');
    drawingContext.fillStyle = grad;
    drawingContext.beginPath();
    drawingContext.ellipse(cx, cy, r, r, 0, 0, Math.PI * 2);
    drawingContext.fill();
    drawingContext.restore();
    pop();

    // Halo flou
    push();
    drawingContext.save();
    drawingContext.shadowBlur  = 40;
    drawingContext.shadowColor = c.halo;

    noFill();
    stroke(c.ring[0], c.ring[1], c.ring[2], c.ring[3] ?? 255);
    strokeWeight(6);
    ellipse(cx, cy, r * 2.1);

    drawingContext.restore();
    pop();

    // Contour principal
    noFill();
    stroke(c.outline[0], c.outline[1], c.outline[2], c.outline[3] ?? 255);
    strokeWeight(4);
    ellipse(cx, cy, r * 2);

    // Reflets internes
    noStroke();
    fill(c.highlight1[0], c.highlight1[1], c.highlight1[2], c.highlight1[3] ?? 255);
    ellipse(cx - r * 0.25, cy - r * 0.25, r * 0.6, r * 0.45);
    fill(c.highlight2[0], c.highlight2[1], c.highlight2[2], c.highlight2[3] ?? 255);
    ellipse(cx + r * 0.15, cy + r * 0.2, r * 0.4, r * 0.35);
  }
}

/* === EFFET D’ÉCLATEMENT – VERSION PLUS POPPY =============== */
class PopBurst {
  constructor(x, y, baseR, colors) {
    this.x = x;
    this.y = y;

    // Rayon de départ et rayon maximum plus grand
    this.r0 = baseR * 0.7;
    this.r  = this.r0;
    this.maxR = baseR * 2.6;      // encore plus large

    this.life = 0;
    this.maxLife = 2300;          // ~2.3 s pour l’anneau principal
    this.flashLife = 900;         // flash blanc plus long

    this.innerPulsePhase = random(TWO_PI);

    this.particles = [];
    this.colors = colors || createBubbleColors(currentTheme);

    // Plus de particules, plus rapides et plus durables
    const count = 36;
    for (let i = 0; i < count; i++) {
      const ang   = random(TWO_PI);
      const speed = random(3, 7);
      this.particles.push({
        x: x,
        y: y,
        vx: cos(ang) * speed,
        vy: sin(ang) * speed,
        r: random(baseR * 0.035, baseR * 0.09),
        life: 0,
        maxLife: random(1300, 2600),  // 1.3 à 2.6 s
        alpha: 230
      });
    }
  }

  update(dt) {
    this.life += dt;
    const t = constrain(this.life / this.maxLife, 0, 1);
    this.r = lerp(this.r0, this.maxR, easeOutQuad(t));
    this.alpha = map(1 - t, 0, 1, 0, 255);

    const k = dt / 16.67;

    // Particules
    for (let p of this.particles) {
      p.life += dt;
      const pt = constrain(p.life / p.maxLife, 0, 1);
      p.x += p.vx * k;
      p.y += p.vy * k;
      p.vy += 0.02 * k;              // légère gravité
      p.alpha = map(1 - pt, 0, 1, 0, 230);
    }

    this.innerPulsePhase += 0.004 * dt;  // pulsation plus lente
  }

  isDead() {
    return this.life > this.maxLife &&
           this.particles.every(p => p.life >= p.maxLife);
  }

  draw() {
    const c = this.colors;

    push();
    drawingContext.save();
    drawingContext.globalCompositeOperation = 'lighter';

    // Flash blanc central
    const flashT = 1 - constrain(this.life / this.flashLife, 0, 1);
    if (flashT > 0) {
      noStroke();
      const [fr, fg, fb] = c.popFlash;
      fill(fr, fg, fb, 220 * flashT);
      ellipse(this.x, this.y, this.r * 1.7);
    }

    // Anneau extérieur principal
    noFill();
    const [rr, rg, rb] = c.popRing;
    stroke(rr, rg, rb, this.alpha);
    strokeWeight(7);
    ellipse(this.x, this.y, this.r * 2);

    // Anneau intérieur pulsant
    const innerR = this.r * (0.55 + 0.08 * sin(this.innerPulsePhase));
    stroke(rr, rg, rb, this.alpha * 0.9);
    strokeWeight(3);
    ellipse(this.x, this.y, innerR * 2);

    // Petites étincelles
    noStroke();
    for (let p of this.particles) {
      if (p.life < p.maxLife && p.alpha > 0) {
        const [pr, pg, pb] = c.popParticle;
        fill(pr, pg, pb, p.alpha);
        ellipse(p.x, p.y, p.r * 2);
      }
    }

    drawingContext.restore();
    pop();
  }
}

// petite fonction d’easing pour un agrandissement plus "explosif"
function easeOutQuad(t) {
  return 1 - (1 - t) * (1 - t);
}

/* === COLLISIONS ============================================ */
function resolveBubbleCollisions() {
  const topMargin = 12;
  for (let i = 0; i < bigBubbles.length; i++) {
    for (let j = i + 1; j < bigBubbles.length; j++) {
      const a = bigBubbles[i];
      const b = bigBubbles[j];
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dist = Math.sqrt(dx * dx + dy * dy);

      const minDist = a.r + b.r;
      if (dist === 0) {
        dist = 0.0001;
        dx = 0.0001;
        dy = 0;
      }

      if (dist < minDist) {
        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        const shift = overlap / 2;

        a.x -= nx * shift;
        a.y -= ny * shift;
        b.x += nx * shift;
        b.y += ny * shift;

        if (a.y - a.r < topMargin) a.y = a.r + topMargin;
        if (b.y - b.r < topMargin) b.y = b.r + topMargin;
      }
    }
  }
}

/* === p5 : SETUP ============================================ */
function setup() {
  createCanvas(displayWidth, displayHeight);
  for (let i = 0; i < NUM_BG_BUBBLES; i++) {
    bgBubbles.push(new BackgroundBubble());
  }
}

/* === p5 : DRAW ============================================= */
function draw() {
  drawBackground();

  bgBubbles.forEach(b => {
    b.update();
    b.draw();
  });

  const dt = deltaTime;

  for (let i = 0; i < bigBubbles.length; i++) {
    bigBubbles[i].update(dt);
  }
  resolveBubbleCollisions();
  for (let i = 0; i < bigBubbles.length; i++) {
    bigBubbles[i].draw();
  }

  for (let i = popBursts.length - 1; i >= 0; i--) {
    const pb = popBursts[i];
    pb.update(dt);
    pb.draw();
    if (pb.isDead()) {
      popBursts.splice(i, 1);
    }
  }
}

/* === FOND ================================================== */
function drawBackground() {
  const theme = THEMES[currentTheme];
  if (currentTheme === 'rainbow') {
    const ctx = drawingContext;
    const t = millis() * 0.0006;
    const grad = ctx.createLinearGradient(0, 0, width, height);
    const stops = theme.gradient || theme.palette;
    stops.forEach((stop, i) => {
      const wobble = 0.2 + 0.2 * Math.sin(t + i * 1.3);
      const r = constrain(stop[0] + wobble * 120, 0, 255);
      const g = constrain(stop[1] + wobble * 120, 0, 255);
      const b = constrain(stop[2] + wobble * 120, 0, 255);
      grad.addColorStop(i / (stops.length - 1), `rgba(${r},${g},${b},0.98)`);
    });

    ctx.save();
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    const pulse = 0.6 + 0.4 * Math.sin(t * 3.2);
    const glow = ctx.createRadialGradient(
      width * 0.3,
      height * 0.25,
      0,
      width * 0.3,
      height * 0.25,
      width * 0.8
    );
    glow.addColorStop(0, `rgba(255,255,255,${0.32 * pulse})`);
    glow.addColorStop(1, 'rgba(255,255,255,0)');

    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = glow;
    ctx.fillRect(0, 0, width, height);

    const secondary = ctx.createRadialGradient(
      width * 0.75,
      height * 0.65,
      0,
      width * 0.75,
      height * 0.65,
      width
    );
    secondary.addColorStop(0, `rgba(255,120,220,${0.28 * pulse})`);
    secondary.addColorStop(0.65, 'rgba(120,200,255,0.12)');
    secondary.addColorStop(1, 'rgba(0,0,0,0)');

    ctx.fillStyle = secondary;
    ctx.fillRect(0, 0, width, height);
    ctx.restore();
    return;
  }

  const bg = theme.background;
  background(bg[0], bg[1], bg[2]);
}

/* === AUDIO HELPERS ========================================= */
function isSoundReady(s) {
  return s && typeof s.isLoaded === 'function' && s.isLoaded();
}

function startMusicForCurrentMode() {
  if (isMusicMuted) return;
  const tracks = musicPlaylists[currentTheme];
  if (!tracks || !tracks.length) return;

  if (currentMusic && isSoundReady(currentMusic)) {
    currentMusic.stop();
    currentMusic.onended(null);
  }

  currentTrackIndex = 0;
  currentMusic = tracks[currentTrackIndex];

  if (isSoundReady(currentMusic)) {
    currentMusic.setVolume(volMusic);
    currentMusic.play();
    currentMusic.onended(handleTrackEnded);
  } else {
    console.warn('[WARN] first track for mode', currentTheme, 'not ready or failed to load');
  }
}

function handleTrackEnded() {
  const tracks = musicPlaylists[currentTheme];
  if (!tracks || !tracks.length) return;

  currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
  currentMusic = tracks[currentTrackIndex];

  if (!isMusicMuted && isSoundReady(currentMusic)) {
    currentMusic.setVolume(volMusic);
    currentMusic.play();
    currentMusic.onended(handleTrackEnded);
  } else {
    console.warn('[WARN] next track not ready or failed to load for mode', currentTheme);
  }
}

function playAppearSFX() {
  if (!isSFXMuted && appearSounds.length) {
    const s = random(appearSounds);
    if (isSoundReady(s)) {
      s.setVolume(volSFX);
      s.play();
    }
  }
}

function playPopSFX() {
  if (!isSFXMuted && popSounds.length) {
    const s = random(popSounds);
    if (isSoundReady(s)) {
      s.setVolume(volSFX);
      s.play();
    }
  }
}

/* === ACTIONS SWITCHS ======================================= */
function triggerPlayer1(mult = 1) {
  const cx = width * 0.5;
  bigBubbles.push(new BigBubble(cx, mult, currentTheme));
  playAppearSFX();
}

function triggerPlayer2() {
  if (bigBubbles.length === 0) return;

  bigBubbles.forEach(b => {
    popBursts.push(new PopBurst(b.x, b.y, b.r, b.colors));
  });
  bigBubbles = [];

  playPopSFX();
}

/* === CLAVIER =============================================== */
function keyPressed() {
  const now = millis();

  if (key === ' ') {
    if (now - lastTap < tapDelay) return;
    lastTap = now;
    triggerPlayer1(1);
  } else if (keyCode === ENTER) {
    if (now - lastTap < tapDelay) return;
    lastTap = now;
    triggerPlayer2();
  }
}

/* === UI : plein écran, sliders, menu, son ================= */
window.addEventListener('load', () => {
  const overlay    = document.getElementById('promptOverlay'),
        btn        = document.getElementById('startButton'),
        icon       = document.getElementById('settings-icon'),
        menu       = document.getElementById('menu'),
        muteMusic  = document.getElementById('muteMusic'),
        musicVol   = document.getElementById('musicVol'),
        musicVal   = document.getElementById('musicVolVal'),
        muteSFX    = document.getElementById('muteSFX'),
        sfxVol     = document.getElementById('sfxVol'),
        sfxVal     = document.getElementById('sfxVolVal'),
        tapSlider  = document.getElementById('tapDelaySlider'),
        tapVal     = document.getElementById('tapDelayVal'),
        infoBtn    = document.getElementById('infoButton'),
        infoModal  = document.getElementById('infoModal'),
        closeModal = document.getElementById('closeModal'),
        modeButtons = document.querySelectorAll('#modeSelect button'),
        langToggle = document.getElementById('langToggle');

  modeButtons.forEach(b => {
    b.addEventListener('pointerup', () => {
      modeButtons.forEach(btn => btn.classList.remove('active'));
      b.classList.add('active');
      currentTheme = b.dataset.mode;
      bgBubbles.forEach(bub => {
        bub.paletteIndex = floor(random((THEMES[currentTheme].palette || []).length || 1));
      });

      if (isGameStarted && !isMusicMuted) {
        startMusicForCurrentMode();
      }
    });
  });

  tapSlider.oninput = e => {
    tapDelay = parseInt(e.target.value, 10);
    tapVal.textContent = e.target.value;
  };

  musicVol.oninput = e => {
    volMusic = e.target.value / 100;
    musicVal.textContent = e.target.value;
    if (!isMusicMuted && isSoundReady(currentMusic)) {
      currentMusic.setVolume(volMusic);
    }
  };

  sfxVol.oninput = e => {
    volSFX = e.target.value / 100;
    sfxVal.textContent = e.target.value;
    if (!isSFXMuted) {
      appearSounds.forEach(s => { if (isSoundReady(s)) s.setVolume(volSFX); });
      popSounds.forEach(s => { if (isSoundReady(s)) s.setVolume(volSFX); });
    }
  };

  muteMusic.onchange = e => {
    isMusicMuted = e.target.checked;
    if (isSoundReady(currentMusic)) {
      currentMusic.setVolume(isMusicMuted ? 0 : volMusic);
      if (isMusicMuted) {
        currentMusic.stop();
      } else {
        startMusicForCurrentMode();
      }
    }
  };

  muteSFX.onchange = e => {
    isSFXMuted = e.target.checked;
    const targetVol = isSFXMuted ? 0 : volSFX;
    appearSounds.forEach(s => { if (isSoundReady(s)) s.setVolume(targetVol); });
    popSounds.forEach(s => { if (isSoundReady(s)) s.setVolume(targetVol); });
  };

  btn.addEventListener('pointerup', () => {
    overlay.remove();
    isGameStarted = true;

    // hide language toggle once the game starts
    if (langToggle) {
      langToggle.style.display = 'none';
    }

    const docEl = document.documentElement;
    if (docEl.requestFullscreen) docEl.requestFullscreen().catch(() => {});
    else if (docEl.webkitRequestFullscreen) docEl.webkitRequestFullscreen();

    const fitCanvas = () => resizeCanvas(displayWidth, displayHeight);
    fitCanvas();
    document.addEventListener('fullscreenchange', fitCanvas);
    window.addEventListener('resize', fitCanvas);

    icon.style.visibility = 'visible';

    startMusicForCurrentMode();
  });

  icon.onclick = () => menu.classList.toggle('show');
  document.onclick = e => {
    if (!menu.contains(e.target) && !icon.contains(e.target)) {
      menu.classList.remove('show');
    }
  };

  infoBtn.onclick = () => { infoModal.style.display = 'block'; };
  closeModal.onclick = () => { infoModal.style.display = 'none'; };

  // Empêcher le scroll de la page avec espace/entrée
  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
    }
  }, { passive: false });
});
</script>

<script src="../../js/translationmain.js"></script>
<script>
  document.getElementById('langToggle')?.addEventListener('pointerup', toggleLanguage);
</script>
</body>
</html>
