<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title
    class="translate"
    data-fr="Lucioles magiques : jeu switch"
    data-en="Firefly Magic: switch game">
    Lucioles magiques : jeu switch
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../css/otherswitch.css" />

  <style>
    :root {
      color-scheme: dark;
    }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #02030a;
      font-family: "Poppins", "Segoe UI", sans-serif;
    }

    canvas#fireflyCanvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: none;
      background: #02030a;
      z-index: 0;
    }

    #promptOverlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(1, 3, 12, 0.86);
      z-index: 20;
      transition: opacity 0.45s ease;
    }

    #promptOverlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .overlay-card {
      width: min(420px, 88vw);
      padding: 32px 28px;
      border-radius: 22px;
      background: linear-gradient(160deg, rgba(15, 47, 71, 0.92), rgba(3, 9, 20, 0.95));
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      text-align: center;
      color: #e4f7ff;
    }

    .overlay-card h1 {
      margin: 0 0 16px;
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .overlay-card p {
      margin: 0 0 26px;
      line-height: 1.6;
      font-size: 1.05rem;
    }

    .overlay-card button {
      border: none;
      border-radius: 999px;
      padding: 12px 30px;
      font-size: 1.05rem;
      font-weight: 600;
      background: linear-gradient(130deg, #2cd9ff, #2ef4c8);
      color: #00121a;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .overlay-card button:hover,
    .overlay-card button:focus {
      transform: translateY(-2px);
      box-shadow: 0 14px 30px rgba(8, 224, 198, 0.35);
      outline: none;
    }

    #hintBanner {
      position: fixed;
      left: 50%;
      bottom: 38px;
      transform: translateX(-50%) translateY(40px);
      padding: 10px 22px;
      border-radius: 999px;
      background: rgba(10, 36, 54, 0.65);
      color: #c6f8ff;
      font-size: 1rem;
      letter-spacing: 0.01em;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.45s ease, transform 0.45s ease;
      z-index: 10;
      backdrop-filter: blur(6px);
    }

    #hintBanner.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    #langToggle {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 25;
      padding: 8px 16px;
      border-radius: 999px;
      border: 2px solid rgba(46, 244, 200, 0.9);
      background: rgba(1, 10, 18, 0.7);
      color: #8fffe6;
      font-weight: 600;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    #langToggle:hover,
    #langToggle:focus {
      background: rgba(34, 145, 255, 0.45);
      transform: translateY(-1px);
      outline: none;
    }

    #accessibilityNote {
      position: fixed;
      top: 16px;
      left: 16px;
      padding: 8px 16px;
      border-radius: 999px;
      background: rgba(5, 20, 36, 0.6);
      color: #9eeefc;
      font-size: 0.9rem;
      letter-spacing: 0.03em;
      z-index: 10;
      backdrop-filter: blur(4px);
    }

    @media (max-width: 640px) {
      .overlay-card {
        padding: 26px 22px;
      }
      #accessibilityNote {
        display: none;
      }
    }
  </style>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-B45TJG4GBJ');
  </script>
</head>
<body>
  <canvas id="fireflyCanvas" aria-hidden="true"></canvas>

  <div id="promptOverlay">
    <div class="overlay-card">
      <h1 class="translate"
          data-fr="Lucioles magiques"
          data-en="Firefly Magic">
        Lucioles magiques
      </h1>
      <p class="translate"
         data-fr="Appuie sur la barre d’espace pour déclencher un essaim lumineux. Chaque impulsion garde la musique cosmique et les lucioles en mouvement."
         data-en="Press the space bar to unleash a glowing swarm. Every pulse keeps the cosmic music and the fireflies dancing.">
        Appuie sur la barre d’espace pour déclencher un essaim lumineux. Chaque impulsion garde la musique cosmique et les lucioles en mouvement.
      </p>
      <button id="startButton" class="translate"
              data-fr="Commencer"
              data-en="Start">
        Commencer
      </button>
    </div>
  </div>

  <div id="hintBanner" class="translate"
       data-fr="Astuce : appuie sur la barre d’espace pour faire tourbillonner les lucioles."
       data-en="Hint: press the space bar to whirl the fireflies.">
    Astuce : appuie sur la barre d’espace pour faire tourbillonner les lucioles.
  </div>

  <div id="accessibilityNote" class="translate"
       data-fr="Commande : barre d’espace"
       data-en="Control: space bar">
    Commande : barre d’espace
  </div>

  <button id="langToggle" type="button" title="Changer la langue / Switch language">EN</button>

  <script src="../../js/translationmain.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const langBtn = document.getElementById('langToggle');
      if (langBtn) {
        const siteLang = localStorage.getItem('siteLanguage') || 'en';
        langBtn.textContent = (siteLang === 'fr') ? 'EN' : 'FR';
        langBtn.addEventListener('click', () => {
          if (typeof toggleLanguage === 'function') {
            toggleLanguage();
          }
          const updated = localStorage.getItem('siteLanguage') || 'en';
          langBtn.textContent = (updated === 'fr') ? 'EN' : 'FR';
        });
      }

      const canvas = document.getElementById('fireflyCanvas');
      const ctx = canvas.getContext('2d', { alpha: false });

      const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
      const lerp = (a, b, t) => a + (b - a) * t;

      let W = 0;
      let H = 0;

      const settings = {
        size: 0.58,
        trail: 0.12
      };

      let pulseBoost = 0;
      let pulseFlash = 0;
      let idleClock = 0;
      let lastFrame = 0;
      let running = false;
      let animationId = null;
      let lastBurstTime = 0;

      const attractor = { x: 0, y: 0, vx: 0, vy: 0, speed: 0 };
      const attractorTarget = { x: 0, y: 0 };

      const overlay = document.getElementById('promptOverlay');
      const startButton = document.getElementById('startButton');
      const hintBanner = document.getElementById('hintBanner');

      const music = new Audio('../../songs/space/spacebest1.mp3');
      music.loop = true;
      music.volume = 0.6;
      let musicWanted = true;

      let audioCtx = null;
      function ensureAudioCtx() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
      }

      function resumeAudioCtx() {
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(() => {});
        }
      }

      function playPing(freq = 600) {
        if (!running) return;
        const ac = ensureAudioCtx();
        resumeAudioCtx();
        const now = ac.currentTime;
        const osc = ac.createOscillator();
        const gain = ac.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.09, now + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
        osc.connect(gain).connect(ac.destination);
        osc.start(now);
        osc.stop(now + 0.6);
      }

      function mapIntensity() {
        return clamp(pulseBoost, 0, 1);
      }

      function sizeNorm() {
        return clamp(settings.size, 0, 1);
      }

      function mapTrail() {
        return clamp(settings.trail, 0.02, 0.35);
      }

      function clearToBg(hard = false) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        if (hard) {
          ctx.fillStyle = '#02030a';
          ctx.fillRect(0, 0, W, H);
        } else {
          const fade = mapTrail();
          ctx.fillStyle = `rgba(2, 4, 16, ${fade})`;
          ctx.fillRect(0, 0, W, H);
        }
      }

      const FIREFLIES = { list: [], t: 0 };
      const FIREFLY_NEIGHBORS = { a: [], b: [] };
      const FIREFLY_SPRITE_SIZE = 256;
      const FIREFLY_SPRITES = new Map();

      function getFireflySprite(hue) {
        const quant = ((Math.round(hue / 12) * 12) % 360 + 360) % 360;
        const key = `${quant}`;
        let sprite = FIREFLY_SPRITES.get(key);
        if (!sprite) {
          const canvasSprite = document.createElement('canvas');
          canvasSprite.width = canvasSprite.height = FIREFLY_SPRITE_SIZE;
          const gctx = canvasSprite.getContext('2d');
          const cx = FIREFLY_SPRITE_SIZE / 2;

          const bloom = gctx.createRadialGradient(cx, cx, cx * 0.1, cx, cx, cx * 0.95);
          bloom.addColorStop(0.0, `hsla(${quant}, 100%, 70%, 1)`);
          bloom.addColorStop(0.55, `hsla(${(quant + 16) % 360}, 95%, 55%, 0.65)`);
          bloom.addColorStop(1.0, `hsla(${(quant + 56) % 360}, 85%, 45%, 0)`);
          gctx.fillStyle = bloom;
          gctx.fillRect(0, 0, FIREFLY_SPRITE_SIZE, FIREFLY_SPRITE_SIZE);

          const highlight = gctx.createRadialGradient(cx * 0.68, cx * 0.68, cx * 0.06, cx * 0.68, cx * 0.68, cx * 0.28);
          highlight.addColorStop(0.0, `hsla(${(quant + 36) % 360}, 100%, 90%, 0.75)`);
          highlight.addColorStop(1.0, `hsla(${(quant + 36) % 360}, 100%, 90%, 0)`);
          gctx.fillStyle = highlight;
          gctx.fillRect(0, 0, FIREFLY_SPRITE_SIZE, FIREFLY_SPRITE_SIZE);

          sprite = { canvas: canvasSprite, radius: FIREFLY_SPRITE_SIZE / 2 };
          FIREFLY_SPRITES.set(key, sprite);
        }
        return sprite;
      }

      function firefliesInit() {
        FIREFLIES.list.length = 0;
        const sN = sizeNorm();
        const area = W * H;
        const density = clamp(Math.sqrt(area / (1280 * 720)), 0.6, 1.25);
        const n = Math.floor(clamp(90 * density + 110 * sN, 90, 200));
        const spread = Math.hypot(W, H) * 0.58;
        const neighborA = FIREFLY_NEIGHBORS.a;
        const neighborB = FIREFLY_NEIGHBORS.b;
        neighborA.length = n;
        neighborB.length = n;

        for (let i = 0; i < n; i++) {
          const z = 0.58 + Math.random() * 0.82;
          const invZ = 1 / z;
          const ang = Math.random() * Math.PI * 2;
          const rad = Math.sqrt(Math.random()) * spread;
          const cx = W * 0.5 + Math.cos(ang) * rad;
          const cy = H * 0.5 + Math.sin(ang) * rad;

          FIREFLIES.list.push({
            x: cx,
            y: cy,
            px: cx,
            py: cy,
            vx: (Math.random() - 0.5) * 0.25,
            vy: (Math.random() - 0.5) * 0.25,
            z,
            invZ,
            hue: 170 + Math.random() * 80,
            glow: 0.2 + Math.random() * 0.4,
            phase: Math.random() * Math.PI * 2,
          });
        }

        const shortOffset = Math.min(n - 1, 13);
        const longOffset = Math.min(n - 1, Math.max(shortOffset + 1, Math.round(n * 0.24)));
        for (let i = 0; i < n; i++) {
          neighborA[i] = (i + shortOffset) % n;
          neighborB[i] = (i + longOffset) % n;
        }
      }

      function flyWrap(f) {
        const pad = 80;
        let wrapped = false;
        if (f.x < -pad) { f.x = W + pad; wrapped = true; }
        if (f.x > W + pad) { f.x = -pad; wrapped = true; }
        if (f.y < -pad) { f.y = H + pad; wrapped = true; }
        if (f.y > H + pad) { f.y = -pad; wrapped = true; }
        if (wrapped) { f.px = f.x; f.py = f.y; }
        return wrapped;
      }

      function drawFirefly(f, coreR, bloomR, alphaCore, alphaBloom) {
        const sprite = getFireflySprite(f.hue);
        if (alphaBloom > 0.001) {
          drawGlowSprite(sprite, f.x, f.y, bloomR, alphaBloom, 'screen');
        }

        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 1;
        ctx.fillStyle = `hsla(${f.hue | 0}, 100%, 68%, ${alphaCore})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, coreR, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = 'screen';
        ctx.strokeStyle = `hsla(${(f.hue + 36) | 0}, 100%, 88%, ${0.55 * alphaCore})`;
        ctx.lineWidth = Math.max(0.7, coreR * 0.3);
        ctx.beginPath();
        ctx.arc(f.x - coreR * 0.32, f.y - coreR * 0.32, coreR * 0.30, 0, Math.PI * 2);
        ctx.stroke();
      }

      function drawGlowSprite(sprite, x, y, radius, alpha, composite = 'screen') {
        if (!sprite || alpha <= 0.001) return;
        ctx.save();
        ctx.globalCompositeOperation = composite;
        ctx.globalAlpha = alpha;
        const scale = radius / sprite.radius;
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.drawImage(sprite.canvas, -sprite.radius, -sprite.radius);
        ctx.restore();
      }

      function renderFireflies(dt, intensity) {
        const activity = clamp(intensity, 0, 1);
        const sN = sizeNorm();
        FIREFLIES.t += dt;

        clearToBg(false);

        const wanderBase = lerp(0.0, 0.22, activity);
        const attractK = lerp(0, 36, activity);
        const repelK = lerp(0, 26, activity);
        const maxSpeed = lerp(0.0001, 32, activity);
        const dampBase = lerp(0.72, 0.975, activity);
        const damp = Math.pow(dampBase, dt * 60);
        const velScale = dt * lerp(0, 36, activity);

        const pullR = 220 + 360 * sN;
        const pullR2 = pullR * pullR;
        const nearRange = 180 + 240 * sN;
        const nearRange2 = nearRange * nearRange;
        const repelR = 160 + 240 * sN;
        const repelR2 = repelR * repelR;
        const hopXLimit = W * 0.42;
        const hopYLimit = H * 0.42;

        const neighborsA = FIREFLY_NEIGHBORS.a;
        const neighborsB = FIREFLY_NEIGHBORS.b;

        const N = FIREFLIES.list.length;
        for (let i = 0; i < N; i++) {
          const f = FIREFLIES.list[i];
          f.px = f.x;
          f.py = f.y;

          let near = 0;
          const invZ = f.invZ;

          if (activity > 0.0005) {
          const dx = attractor.x - f.x;
          const dy = attractor.y - f.y;
            const dist2 = dx * dx + dy * dy;
            let dist = 0;
            if (dist2 < nearRange2) {
              dist = Math.sqrt(dist2);
              near = clamp(1 - (dist / nearRange), 0, 1) * activity;
            } else if (dist2 < pullR2) {
              dist = Math.sqrt(dist2);
            }

            const wanderLocal = wanderBase * (1 + 0.7 * (1 - near));
            f.vx += (Math.random() - 0.5) * wanderLocal * invZ;
            f.vy += (Math.random() - 0.5) * wanderLocal * invZ;

            if (dist2 < pullR2 && dist > 0) {
              const t = 1 - dist / pullR;
              const pull = attractK * (0.25 + 0.75 * t) * dt * invZ / 320;
              f.vx += dx * pull;
              f.vy += dy * pull;
            }

            if (repelK > 0) {
              const idxA = neighborsA[i];
              const idxB = neighborsB[i];

              const gA = FIREFLIES.list[idxA];
              if (gA && gA !== f) {
                const rx = f.x - gA.x;
                const ry = f.y - gA.y;
                const rd2 = rx * rx + ry * ry + 0.0001;
                if (rd2 < repelR2) {
                  const inv = 1 / Math.sqrt(rd2);
                  const repelScale = (repelK * (1 - rd2 / repelR2)) * dt * invZ / 120;
                  f.vx += rx * inv * repelScale;
                  f.vy += ry * inv * repelScale;
                }
              }

              const gB = FIREFLIES.list[idxB];
              if (gB && gB !== f) {
                const rx = f.x - gB.x;
                const ry = f.y - gB.y;
                const rd2 = rx * rx + ry * ry + 0.0001;
                if (rd2 < repelR2) {
                  const inv = 1 / Math.sqrt(rd2);
                  const repelScale = (repelK * (1 - rd2 / repelR2)) * dt * invZ / 120;
                  f.vx += rx * inv * repelScale;
                  f.vy += ry * inv * repelScale;
                }
              }
            }
          }

          const settle = lerp(0.0, 0.00012, activity);
          f.vx += (W * 0.5 - f.x) * settle;
          f.vy += (H * 0.5 - f.y) * settle;

          const maxLocal = Math.max(0.0002, maxSpeed * invZ);
          const maxLocalSq = maxLocal * maxLocal;
          const magSq = f.vx * f.vx + f.vy * f.vy;
          if (magSq > maxLocalSq && magSq > 0) {
            const scale = maxLocal / Math.sqrt(magSq);
            f.vx *= scale;
            f.vy *= scale;
          }

          f.vx *= damp;
          f.vy *= damp;
          f.x += f.vx * velScale;
          f.y += f.vy * velScale;

          const wrapped = flyWrap(f);
          if (!wrapped) {
            const hopX = Math.abs(f.x - f.px);
            const hopY = Math.abs(f.y - f.py);
            if (hopX > hopXLimit || hopY > hopYLimit) {
              f.px = f.x;
              f.py = f.y;
            }
          }

          f.phase += dt * (0.6 + 1.2 * activity);
          const twinkle = 0.5 + 0.5 * Math.sin(f.phase + f.x * 0.01 + f.y * 0.01);
          const baseGlow = 0.20 + 0.26 * twinkle;
          f.glow = clamp(baseGlow + near * (0.52 + 0.38 * activity), 0.12, 1.4);
        }

        const trailAlpha = 0.03 + 0.12 * activity;
        const baseTrailW = 0.8 + 1.5 * activity;
        const sizeBoost = 1.68;
        const bloomScale = 4.2 + 6.2 * activity;
        const coreAlpha = clamp(0.22 + 0.28 * activity, 0, 0.6);
        const bloomBase = clamp(0.06 + 0.12 * activity, 0, 0.36);

        ctx.lineCap = 'round';
        ctx.globalCompositeOperation = 'screen';
        for (let i = 0; i < N; i++) {
          const f = FIREFLIES.list[i];
          ctx.strokeStyle = `hsla(${(f.hue + 30) | 0}, 90%, 72%, ${trailAlpha})`;
          ctx.lineWidth = Math.max(0.6, baseTrailW * f.invZ);
          ctx.beginPath();
          ctx.moveTo(f.px, f.py);
          ctx.lineTo(f.x, f.y);
          ctx.stroke();

          const coreR = sizeBoost * (2.2 + 4.0 * f.glow) * f.invZ;
          const bloomR = coreR * bloomScale;

          const aCore = coreAlpha;
          const aBloom = bloomBase * clamp(f.glow / 3.2, 0.35, 0.95);

          drawFirefly(f, coreR, bloomR, aCore, aBloom);
        }
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
      }

      function drawPulseOverlay() {
        if (pulseFlash <= 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = Math.pow(pulseFlash, 1.25) * 0.55;
        const radius = Math.max(W, H) * 0.55;
        const grad = ctx.createRadialGradient(attractor.x, attractor.y, radius * 0.15, attractor.x, attractor.y, radius);
        grad.addColorStop(0.0, 'rgba(140, 255, 230, 0.85)');
        grad.addColorStop(0.45, 'rgba(60, 180, 255, 0.35)');
        grad.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }

      function updateAttractor(dt, intensity) {
        const active = intensity > 0.02;
        if (active) {
          idleClock += dt;
          const radius = Math.min(W, H) * lerp(0.02, 0.18, intensity);
          const idleX = W * 0.5 + Math.cos(idleClock * lerp(0.18, 0.42, intensity)) * radius;
          const idleY = H * 0.5 + Math.sin(idleClock * lerp(0.16, 0.36, intensity)) * radius;
          attractorTarget.x = lerp(attractorTarget.x, idleX, dt * lerp(1.2, 2.8, intensity));
          attractorTarget.y = lerp(attractorTarget.y, idleY, dt * lerp(1.2, 2.8, intensity));
        } else {
          idleClock = 0;
          attractorTarget.x = lerp(attractorTarget.x, W * 0.5, dt * 3.6);
          attractorTarget.y = lerp(attractorTarget.y, H * 0.5, dt * 3.6);
        }

        const follow = Math.min(1, dt * lerp(6, 14, intensity));
        attractor.vx += (attractorTarget.x - attractor.x) * follow;
        attractor.vy += (attractorTarget.y - attractor.y) * follow;
        const damp = active ? 0.90 : 0.80;
        attractor.vx *= damp;
        attractor.vy *= damp;
        attractor.x += attractor.vx;
        attractor.y += attractor.vy;
        attractor.speed = Math.hypot(attractor.vx, attractor.vy);
      }

      function triggerBurst() {
        const now = performance.now();
        if (now - lastBurstTime < 180) return;
        lastBurstTime = now;

        pulseBoost = Math.min(1, Math.max(pulseBoost, 0.75) + 0.35);
        pulseFlash = 1;
        attractorTarget.x = W * (0.15 + Math.random() * 0.7);
        attractorTarget.y = H * (0.18 + Math.random() * 0.64);
        attractor.x = attractorTarget.x;
        attractor.y = attractorTarget.y;
        attractor.vx = 0;
        attractor.vy = 0;
        idleClock = 0;

        const boostBase = 0.40 + Math.random() * 0.4;
        for (const f of FIREFLIES.list) {
          const angle = Math.atan2(attractorTarget.y - f.y, attractorTarget.x - f.x) + (Math.random() - 0.5) * 0.7;
          const strength = boostBase * (0.6 + Math.random() * 0.8);
          f.vx += Math.cos(angle) * strength;
          f.vy += Math.sin(angle) * strength;
          f.glow = Math.max(f.glow, 1.05 + Math.random() * 0.5);
          f.hue = (f.hue + 10 + Math.random() * 30) % 360;
        }
        playPing(520 + Math.random() * 160);
      }

      function resizeCanvas() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        attractor.x = attractorTarget.x = W * 0.5;
        attractor.y = attractorTarget.y = H * 0.5;
        firefliesInit();
        clearToBg(true);
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      function frame(now) {
        if (!running) return;
        if (!lastFrame) lastFrame = now;
        const dt = Math.min(0.1, (now - lastFrame) / 1000);
        lastFrame = now;

        const intensity = mapIntensity();
        updateAttractor(dt, intensity);

        renderFireflies(dt, intensity);
        drawPulseOverlay();
        pulseBoost = Math.max(0, pulseBoost - dt * (0.28 + 0.34 * intensity));
        pulseFlash = Math.max(0, pulseFlash - dt * 1.4);

        animationId = requestAnimationFrame(frame);
      }

      function startExperience() {
        if (running) return;
        running = true;
        if (overlay) {
          overlay.classList.add('hidden');
          setTimeout(() => {
            if (overlay && overlay.parentElement) {
              overlay.parentElement.removeChild(overlay);
            }
          }, 600);
        }
        if (hintBanner) {
          hintBanner.classList.add('visible');
        }

        ensureAudioCtx();
        resumeAudioCtx();

        if (musicWanted) {
          const playPromise = music.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(() => {});
          }
        }

        lastFrame = performance.now();
        animationId = requestAnimationFrame(frame);
      }

      function stopExperience() {
        running = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        if (musicWanted) {
          music.pause();
        }
      }

      startButton?.addEventListener('click', startExperience);
      startButton?.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          startExperience();
        }
      });

      document.addEventListener('keydown', (ev) => {
        if (ev.code === 'Space' || ev.key === ' ') {
          ev.preventDefault();
          if (!running) {
            startExperience();
          } else {
            triggerBurst();
          }
        }
        if (ev.key === 'm' || ev.key === 'M') {
          musicWanted = !musicWanted;
          if (musicWanted) {
            const p = music.play();
            if (p && p.catch) p.catch(() => {});
          } else {
            music.pause();
          }
        }
      });

      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && running && musicWanted) {
          const p = music.play();
          if (p && p.catch) p.catch(() => {});
        }
      });

      ['pointerdown', 'touchstart', 'keydown'].forEach((evName) => {
        document.addEventListener(evName, () => {
          ensureAudioCtx();
          resumeAudioCtx();
        }, { once: true, passive: true });
      });

      window.addEventListener('beforeunload', stopExperience);
    });
  </script>
</body>
</html>
