<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title class="translate" data-fr="Explorons le monde" data-en="Explore the world" data-ja="世界を探検しよう">Explorons le monde</title>

  <!-- CSS commun uniquement pour le MENU -->
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <!-- Tout le CSS du jeu est ici -->
  <style>
    /* Écran initial noir, pas de centrage global */
    html, body { margin:0; height:100%; background:#000; }
    body { display:block !important; }

    /* ===== Zone de jeu ===== */
    #game-root { position: relative; z-index: 1; }
    #game-stage {
      position: relative;
      width: 100vw;
      max-width: 100%;
      margin: 0 auto;
      overflow: hidden;
      background: #000;        /* noir jusqu'au Start */
      z-index: 5;
      display: none;           /* caché avant Start */
    }
    #worldMap {
      display: block;
      width: 100vw;
      max-width: 100%;
      height: auto;
      object-fit: contain;
      user-select: none;
      -webkit-user-drag: none;
    }

    /* Cercle de fixation : rouge, plein, expansif */
    #hover-circle{
      position:absolute; pointer-events:none; display:none;
      background: rgba(255,0,0,0.65);
      border-radius:50%;
      width:20px; height:20px; transform:translate(-50%,-50%);
      box-shadow: 0 0 20px rgba(255,0,0,0.6), inset 0 0 12px rgba(180,0,0,0.6);
      z-index:6;
    }

    /* Overlay vidéo + verrouillage d'input */
    #video-overlay{
      position:fixed; inset:0; background:#000; display:none; place-items:center; z-index:101;
      cursor: not-allowed;
    }
    #video-overlay video{
      max-width:92vw; max-height:92vh; background:#000; outline:none;
      pointer-events: none; /* pas d'interaction sur la vidéo */
    }
    /* Calque invisible qui absorbe tous les inputs pendant la vidéo */
    #interaction-lock{
      position:fixed; inset:0; z-index:102; display:none; pointer-events: auto;
      background: transparent;
    }

    /* Barre de préchargement (dans le menu) */
    #preload-bar-wrap{ display:none; height:8px; background:#eee; border-radius:999px; overflow:hidden; width:100%; max-width:480px; margin:8px auto 0; }
    #preload-bar{ height:100%; width:0%; background:#0a7; transition:width .25s ease; }

    /* Le menu (le détail de style vient de ton CSS commun) */
    #game-options.modal{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:1000; }
    #control-panel-options{ max-width:740px; width:90%; }
  </style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>
<body>

  <!-- ===== MENU (utilise ton CSS commun) ===== -->
  <div id="game-options" class="modal" style="display:flex;">
    <div id="control-panel-options">
      <div id="options-title-bar">
        <h2 id="options-main-title" class="translate" data-fr="Explorons le monde" data-en="Explore the world" data-ja="世界を探検しよう">Explorons le monde</h2>
      </div>

      <div id="preload-bar-wrap" aria-hidden="true">
        <div id="preload-bar"></div>
      </div>

      <div id="options-inline-container" style="display:grid;grid-template-columns:repeat(3,1fr);gap:20px;width:100%;margin-top:20px;">
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label" style="display:inline-flex;align-items:center;gap:.5em;color:#333;">
              <input type="checkbox" id="muteSFX">
              <span class="translate" data-fr="Désactiver les sons" data-en="Disable sounds" data-ja="効果音をオフ">Désactiver les sons</span>
            </label>
          </div>
          <div class="option-item">
            <label for="sfxVol" class="teal-label">
              <span class="translate" data-fr="Volume des sons :" data-en="Sound volume:" data-ja="効果音の音量：">Volume des sons&nbsp;:</span>
              <span id="sfxVolVal">50</span>
            </label>
            <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>

        <div class="options-column"></div>

        <div class="options-column">
          <div class="option-item">
            <label for="dwellTimeSlider" class="teal-label">
              <span class="translate" data-fr="Temps de fixation :" data-en="Dwell time:" data-ja="注視時間：">Temps de fixation&nbsp;:</span>
              <span id="dwellTimeVal">1000</span> ms
            </label>
            <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="5000" step="100" value="1000">
          </div>
        </div>
      </div>

      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
    </div>
  </div>

  <!-- ===== ZONE DE JEU ===== -->
  <div id="game-root">
    <div id="game-stage">
      <img id="worldMap" src="../../images/worldmap.jpg" alt="World Map" />
      <div id="hover-circle"></div>
      <map name="image-map">
        <area alt="north-america" title="Amérique du Nord" href="#" coords="442,530,369,480,260,419,191,256,42,214,167,71,476,34,857,24" shape="poly">
        <area alt="south-america" title="Amérique du Sud" href="#" coords="437,545,450,686,528,940,583,986,650,806,712,647,644,560,522,487" shape="poly">
        <area alt="africa"         title="Afrique"          href="#" coords="835,346,778,509,907,589,993,854,1161,774,1181,636,1154,582,1198,491,1064,362,949,322" shape="poly">
        <area alt="europe"         title="Europe"           href="#" coords="1273,63,983,25,818,241,834,339,912,316,1041,343,1103,297,1163,314,1236,221" shape="poly">
        <area alt="asia"           title="Asie"             href="#" coords="1899,137,1476,49,1271,83,1242,226,1175,316,1081,314,1085,375,1203,491,1326,535,1436,599,1521,657,1604,599" shape="poly">
        <area alt="oceania"        title="Océanie"          href="#" coords="1743,608,1617,586,1522,718,1476,752,1482,857,1561,844,1607,928,1712,976,1783,905" shape="poly">
      </map>
    </div>
  </div>

  <!-- Vidéo + verrouillage d'input -->
  <div id="video-overlay" style="display:none;">
    <video id="end-video" playsinline></video>
  </div>
  <div id="interaction-lock"></div>

  <!-- Eyegaze settings uniquement (menu commun) -->
  <script src="../../js/eyegaze-menu.js"></script>

  <script>
  const EYELANG_KEY='eyegazeMenuLang';
  const languages=['fr','en','ja'];
  const langLabels = { fr: 'FR', en: 'EN', ja: '日本語' };
  let currentLang = (()=>{
    try{
      const saved = localStorage.getItem(EYELANG_KEY);
      if(languages.includes(saved)) return saved;
    }catch(e){}
    return (document.documentElement.lang==='en'||document.documentElement.lang==='ja') ? document.documentElement.lang : 'fr';
  })();

  function applyWorldTranslations(lang){
    const target=languages.includes(lang)?lang:'fr';
    const next=languages[(languages.indexOf(target)+1)%languages.length];
    document.documentElement.lang=target;
    try{localStorage.setItem(EYELANG_KEY,target);}catch(e){}
    document.querySelectorAll('.translate').forEach(el=>{
      const text=el.dataset[target]; if(text) el.textContent=text;
      const placeholder=el.dataset[`${target}Placeholder`]; if(placeholder) el.setAttribute('placeholder', placeholder);
      const title=el.dataset[`${target}Title`]; if(title) el.setAttribute('title', title);
      const aria=el.dataset[`${target}AriaLabel`]; if(aria) el.setAttribute('aria-label', aria);
    });
    const toggle=document.getElementById('langToggle');
    if(toggle){
      const label = langLabels[next] || next.toUpperCase();
      toggle.textContent=label;
      toggle.setAttribute('title', `Change language (${label})`);
    }
  }

  (function initWorldToggle(){
    if(document.getElementById('langToggle')){ applyWorldTranslations(currentLang); return; }
    const btn=document.createElement('button');
    btn.id='langToggle';
    btn.style.position='fixed'; btn.style.top='10px'; btn.style.right='10px'; btn.style.zIndex='100000';
    btn.style.padding='6px 10px'; btn.style.borderRadius='10px'; btn.style.border='2px solid #009688';
    btn.style.background='#fff'; btn.style.color='#009688'; btn.style.fontWeight='700'; btn.style.cursor='pointer';
    btn.addEventListener('click',()=>{
      const idx=languages.indexOf(currentLang);
      currentLang=languages[(idx+1)%languages.length];
      applyWorldTranslations(currentLang);
    });
    document.body.appendChild(btn);
    applyWorldTranslations(currentLang);
  })();
  
  /* ===================== UTIL ===================== */
  function reqFullscreen() {
    const el = document.documentElement;
    const rfs = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen || el.mozRequestFullScreen;
    if (rfs) { try { rfs.call(el); } catch(e){} }
  }

  // PIP helpers
  function pointInPolygon(x, y, poly){
    let inside = false;
    for (let i = 0, j = poly.length - 2; i < poly.length; i += 2) {
      const xi = poly[i], yi = poly[i+1];
      const xj = poly[j], yj = poly[j+1];
      const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
      if (intersect) inside = !inside;
      j = i;
    }
    return inside;
  }
  function pointInRect(x,y, [x1,y1,x2,y2]){
    const minx = Math.min(x1,x2), maxx = Math.max(x1,x2);
    const miny = Math.min(y1,y2), maxy = Math.max(y1,y2);
    return x >= minx && x <= maxx && y >= miny && y <= maxy;
  }
  function pointInCircle(x,y,[cx,cy,r]){
    const dx = x - cx, dy = y - cy;
    return dx*dx + dy*dy <= r*r;
  }

  // Vidéos par zone
  const ZONE_VIDEOS = {
    'north-america': 'https://bucket.adaptatech.org/north-america.mp4',
    'south-america': 'https://bucket.adaptatech.org/south-america.mp4',
    'africa':        'https://bucket.adaptatech.org/africa.mp4',
    'europe':        'https://bucket.adaptatech.org/europe.mp4',
    'asia':          'https://bucket.adaptatech.org/asia.mp4',
    'oceania':       'https://bucket.adaptatech.org/oceania.mp4'
  };

  // Préchargement des vidéos (non bloquant)
  (function preloadVideos(){
    const wrap = document.getElementById('preload-bar-wrap');
    const bar  = document.getElementById('preload-bar');
    wrap.style.display = 'block';
    const keys = Object.keys(ZONE_VIDEOS);
    let done = 0;
    const mark = () => {
      done++;
      bar.style.width = Math.round(done / keys.length * 100) + '%';
      if (done >= keys.length) setTimeout(() => wrap.style.display = 'none', 400);
    };
    keys.forEach(k=>{
      const v = document.createElement('video');
      v.preload = 'auto'; v.muted = true; v.playsInline = true;
      v.src = ZONE_VIDEOS[k]; v.style.display='none';
      document.body.appendChild(v);
      v.addEventListener('canplaythrough', mark, { once:true });
      v.addEventListener('loadeddata', mark, { once:true });
      v.addEventListener('error', mark, { once:true });
    });
  })();

  /* ===================== MAIN ===================== */
  (function main(){
    initEyegazeMenu();

    const startBtn      = document.getElementById('startButton');
    const worldMap      = document.getElementById('worldMap');
    const stage         = document.getElementById('game-stage');
    const hoverCircle   = document.getElementById('hover-circle');
    const videoOverlay  = document.getElementById('video-overlay');
    const endVideo      = document.getElementById('end-video');
    let   inputLock     = document.getElementById('interaction-lock'); // let pour pouvoir réassigner

    // Lire les zones une seule fois
    const areaDefs = Array.from(document.querySelectorAll('map[name="image-map"] area')).map(a => ({
      zone: (a.getAttribute('alt') || '').toLowerCase(),
      shape: (a.getAttribute('shape') || 'poly').toLowerCase(),
      coords: (a.getAttribute('coords') || '').split(',').map(n=>parseFloat(n))
    }));

    function zoneAtClientPoint(clientX, clientY){
      const rect = worldMap.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0 || worldMap.naturalWidth <= 0) return null;
      const sx = worldMap.naturalWidth  / rect.width;
      const sy = worldMap.naturalHeight / rect.height;
      const x = (clientX - rect.left) * sx;
      const y = (clientY - rect.top)  * sy;
      for (const a of areaDefs) {
        if (!a.zone) continue;
        if (a.shape === 'poly' && a.coords.length >= 6) {
          if (pointInPolygon(x, y, a.coords)) return a.zone;
        } else if (a.shape === 'rect' && a.coords.length === 4) {
          if (pointInRect(x, y, a.coords)) return a.zone;
        } else if (a.shape === 'circle' && a.coords.length === 3) {
          if (pointInCircle(x, y, a.coords)) return a.zone;
        }
      }
      return null;
    }

    // === Audio : applique mute/volume du menu & d’eyegazeSettings à la vidéo ===
    function getCurrentVolume() {
      // priorité aux valeurs en mémoire runtime
      if (window.eyegazeSettings && typeof eyegazeSettings.sfxVolume === 'number') {
        return Math.min(100, Math.max(0, eyegazeSettings.sfxVolume));
      }
      const slider = document.getElementById('sfxVol');
      return slider ? parseInt(slider.value, 10) || 50 : 50;
    }
    function getCurrentMuted() {
      if (window.eyegazeSettings && typeof eyegazeSettings.sfxMuted === 'boolean') {
        return eyegazeSettings.sfxMuted;
      }
      const chk = document.getElementById('muteSFX');
      return !!(chk && chk.checked);
    }
    function applyAudioSettings(videoEl){
      const vol = getCurrentVolume();
      const muted = getCurrentMuted();
      videoEl.volume = Math.min(1, Math.max(0, vol / 100));
      videoEl.muted  = !!muted;
    }

    // Synchronise en temps réel si l’utilisateur change les contrôles
    const muteBox = document.getElementById('muteSFX');
    const volSlider = document.getElementById('sfxVol');
    if (muteBox)   muteBox.addEventListener('change', () => applyAudioSettings(endVideo));
    if (volSlider) volSlider.addEventListener('input',  () => applyAudioSettings(endVideo));

    // Logique de fixation
    let dwellTimer = null;
    let currentZone = null;

    function beginDwell(zone, clientX, clientY) {
      const dwell = Number(window.eyegazeSettings?.dwellTime ?? 1500);

      const rect = stage.getBoundingClientRect();
      hoverCircle.style.left = (clientX - rect.left) + 'px';
      hoverCircle.style.top  = (clientY - rect.top)  + 'px';
      hoverCircle.style.display = 'block';
      hoverCircle.style.width = '16px';
      hoverCircle.style.height = '16px';
      hoverCircle.style.opacity = '0.5';
      hoverCircle.style.transition = 'none';

      requestAnimationFrame(() => {
        hoverCircle.style.transition = `width ${dwell}ms ease, height ${dwell}ms ease, opacity ${dwell}ms ease`;
        hoverCircle.style.width = '120px';
        hoverCircle.style.height = '120px';
        hoverCircle.style.opacity = '0.9';
      });

      clearTimeout(dwellTimer);
      dwellTimer = setTimeout(() => {
        hoverCircle.style.display = 'none';
        triggerZone(zone);
      }, dwell);
    }

    function cancelDwell(){
      clearTimeout(dwellTimer);
      dwellTimer = null;
      hoverCircle.style.display = 'none';
      currentZone = null;
    }

    function handleMove(ev){
      const clientX = ev.clientX ?? (ev.touches && ev.touches[0]?.clientX);
      const clientY = ev.clientY ?? (ev.touches && ev.touches[0]?.clientY);
      if (clientX == null || clientY == null) return;

      const z = zoneAtClientPoint(clientX, clientY);
      if (!z) { cancelDwell(); return; }

      if (z !== currentZone) {
        currentZone = z;
        beginDwell(z, clientX, clientY);
      } else {
        const rect = stage.getBoundingClientRect();
        hoverCircle.style.left = (clientX - rect.left) + 'px';
        hoverCircle.style.top  = (clientY - rect.top)  + 'px';
      }
    }

    // Écouteurs (activés quand la scène est visible)
    stage.addEventListener('pointermove', handleMove, { passive:true });
    stage.addEventListener('mousemove', handleMove, { passive:true });
    stage.addEventListener('touchmove', handleMove, { passive:true });
    stage.addEventListener('pointerleave', cancelDwell);
    stage.addEventListener('mouseleave',  cancelDwell);
    stage.addEventListener('touchend',    cancelDwell);

    // Neutraliser toute navigation des <area>
    document.querySelectorAll('area').forEach(a => a.addEventListener('click', e => e.preventDefault()));

    // Start : plein écran, cache le menu, affiche la scène
    startBtn.addEventListener('click', () => {
      reqFullscreen();
      if (window.eyegazeSettings && typeof eyegazeSettings.hideOverlay === 'function') {
        eyegazeSettings.hideOverlay();
      } else {
        const modal = document.getElementById('game-options');
        if (modal) modal.style.display = 'none';
      }
      stage.style.display = 'block';
    });

    // Verrouillage / déverrouillage des inputs pendant la vidéo
    const keyEat = (e) => { e.stopPropagation(); e.preventDefault(); };
    let pauseGuard = null;

    function lockAllInput() {
      // Affiche le calque qui absorbe tout
      inputLock.style.display = 'block';

      const eat = (e) => { e.stopPropagation(); e.preventDefault(); };
      ['pointerdown','pointerup','pointermove','click','dblclick','contextmenu','wheel','touchstart','touchmove','touchend','mousedown','mouseup']
        .forEach(evt => inputLock.addEventListener(evt, eat, { passive:false }));

      // Bloque clavier
      window.addEventListener('keydown', keyEat, { passive:false, capture:true });
      window.addEventListener('keyup',   keyEat, { passive:false, capture:true });

      // Empêche pause manuelle tant que non terminé
      pauseGuard = () => { if (!endVideo.ended) endVideo.play().catch(()=>{}); };
      endVideo.addEventListener('pause', pauseGuard);
    }

    function unlockAllInput() {
      // Masque et réinitialise le calque (en le remplaçant on supprime ses listeners)
      inputLock.style.display = 'none';
      const fresh = inputLock.cloneNode(true);
      inputLock.parentNode.replaceChild(fresh, inputLock);
      inputLock = fresh;

      // Retire les hooks clavier et pause
      window.removeEventListener('keydown', keyEat, { capture:true });
      window.removeEventListener('keyup',   keyEat, { capture:true });
      if (pauseGuard) endVideo.removeEventListener('pause', pauseGuard);
      pauseGuard = null;
    }

    function triggerZone(zone) {
      const src = ZONE_VIDEOS[zone];
      if (!src) return;

      // Prépare la vidéo AVANT de lancer la lecture : appliquer mute/volume demandés
      endVideo.controls = false;
      endVideo.src = src;
      applyAudioSettings(endVideo);     // <-- applique Désactiver les sons + Volume
      videoOverlay.style.display = 'grid';
      lockAllInput();

      // Lecture (fallback muet si l'autoplay refuse)
      endVideo.load();
      endVideo.play().catch(() => {
        // On force muet si nécessaire pour débloquer l'autoplay
        endVideo.muted = true;
        endVideo.play().catch(()=>{ /* si ça échoue encore, l'utilisateur a déjà cliqué Start : généralement accepté */ });
      });

      endVideo.onended = () => {
        unlockAllInput();
        videoOverlay.style.display = 'none';
        // Retour à la carte (on reste en plein écran)
      };
    }

  })();
  </script>
</body>
</html>
