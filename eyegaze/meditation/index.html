<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Samurai Focus — One Orb → Moon (Constant Speed + Designed Halo + Strong/Slow Shake)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #game { display:block; width:100vw; height:100vh; cursor: crosshair; background:#000; }
    #startOverlay { position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(0,0,0,0.75); z-index:10; }
    #startBtn { padding:14px 22px; border:2px solid #6ad1c9; color:#6ad1c9; background:#000;
      border-radius:12px; font-size:18px; font-weight:700; box-shadow:0 6px 24px rgba(0,0,0,.25); cursor:pointer; }
    #startBtn:active{ transform:translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay"><button id="startBtn">Start • Fullscreen</button></div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       PLACEHOLDER ASSETS (reuse your files)
    ======================= */
    const BG_SRC     = "../../images/samurai/lampbg.png";
    const PETAL_SRC  = "../../images/samurai/cherryblossom.png";
    const SFX_RELEASE= "../../sounds/blade.mp3";
    const SFX_IMPACT = "../../sounds/gong.mp3";

    /* =======================
       TUNABLES
    ======================= */
    // Dwell → ball size: 100 → 200 px over 2s
    const MIN_DIAMETER = 100;
    const MAX_DIAMETER = 200;
    const DWELL_MS     = 2000;
    const MAX_JITTER_PX= 26;
    const DECAY_PER_SEC= 0.5;
    const ENTRY_GRACE_MS = 200;

    // Spawn area (bottom third)
    const SPAWN_X_MIN_FRAC = 0.20;
    const SPAWN_X_MAX_FRAC = 0.80;
    const SPAWN_Y_MIN_FRAC = 0.68;
    const SPAWN_Y_MAX_FRAC = 0.90;

    // Launch path → to the moon (constant speed along curve)
    const LAUNCH_SPEED_PX = 360;   // px/s (your chosen speed)
    const END_RADIUS      = 10;    // size at the moon
    const BEZIER_PEAK     = 0.34;  // arc height (fraction of screen)
    const RESPAWN_DELAY_MS = 2500; // wait before next orb

    // Ball look (opaque + small halo)
    const BALL_RGB       = "120,220,210";
    const RIM_ALPHA      = 0.15;
    const HALO_INNER_MULT = 1.00;
    const HALO_OUTER_MULT = 1.12;  // ~6% of diameter beyond edge
    const HALO_ALPHA      = 0.25;
    const HALO_TRAIL_ALPHA= 0.16;

    // Local jitter only
    const ORB_SHAKE_MAX  = 8;
    const ORB_SHAKE_FX   = 23, ORB_SHAKE_FY = 17;

    // Audio (crescendo while charging)
    const HUM_GAIN_MAX   = 0.6;

    // Moon (bigger + designed halo)
    const MOON_R         = 140;     // doubled from 70
    const MOON_GLOW_R    = 560;     // larger to fit the designed halo
    const MOON_X_FRAC    = 0.78;
    const MOON_Y_FRAC    = 0.24;

    // Impact FX
    const IMPACT_PETALS  = 180;
    const IMPACT_SPEED   = 460;
    const IMPACT_LIFE    = 1.9;
    const SHOCKWAVE_MAX_R= 340;
    const FLASH_MAX_ALPHA= 0.7;

    // Craters
    const MAX_CRATERS      = 24;
    const CRATER_FADE_MS   = 250; // pop-in duration
    const CRATER_R_MIN_FR  = 0.06; // 6% of moon radius
    const CRATER_R_MAX_FR  = 0.14; // 14% of moon radius
    const CRATER_MARGIN_FR = 0.04; // keep inside disk

    // Moon-only shake — STRONGER and SLOWER
    // Lower stiffness → slower oscillation; lower damping → longer lingering
    // Bigger impulse → larger initial displacement
    const SHAKE_STIFFNESS = 8;
    const SHAKE_DAMPING   = 5;
    const SHAKE_IMPULSE   = 240;
    let mShake = { ox: 0, oy: 0, vx: 0, vy: 0 }; // offset & velocity

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    const bgImg     = new Image(); bgImg.src = BG_SRC;
    const petalImg  = new Image(); petalImg.src = PETAL_SRC;

    const sfxRelease= new Audio(SFX_RELEASE); sfxRelease.volume = 0.7;
    const sfxImpact = new Audio(SFX_IMPACT);  sfxImpact.volume  = 0.75;
    const play = a => { try { a.currentTime = 0; a.play(); } catch(_){} };

    const rand  = (a,b)=>a+Math.random()*(b-a);
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const nowS  = ()=> performance.now()/1000;

    // Pointer / eye-gaze
    const pointer = { x:-9999, y:-9999, px:-9999, py:-9999, moved:0, inside:false };
    canvas.addEventListener('pointermove', e=>{
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top ) * (canvas.height / r.height);
      if (pointer.px !== -9999) pointer.moved = Math.hypot(x-pointer.px, y-pointer.py);
      pointer.x=x; pointer.y=y; pointer.px=x; pointer.py=y; pointer.inside=true;
    });
    canvas.addEventListener('pointerleave', ()=> pointer.inside=false);

    // Moon position (responsive)
    let moon = { x: W*MOON_X_FRAC, y: H*MOON_Y_FRAC };
    function resize(){
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      moon.x = W*MOON_X_FRAC; moon.y = H*MOON_Y_FRAC;
      if (orb && !launching){
        // keep orb within spawn band on resize
        orb.cx = clamp(orb.cx, W*SPAWN_X_MIN_FRAC, W*SPAWN_X_MAX_FRAC);
        orb.cy = clamp(orb.cy, H*SPAWN_Y_MIN_FRAC, H*SPAWN_Y_MAX_FRAC);
      }
    }
    window.addEventListener('resize', resize);

    /* =======================
       AUDIO — charging hum
    ======================= */
    let audioCtx=null, masterGain=null;
    let chargeGain=null, filter=null, osc1=null, osc2=null, o1g=null, o2g=null;

    function setupAudio(){
      audioCtx   = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(audioCtx.destination);

      osc1 = audioCtx.createOscillator(); osc1.type = 'sawtooth'; osc1.frequency.value = 90;
      osc2 = audioCtx.createOscillator(); osc2.type = 'triangle';  osc2.frequency.value = 180;

      o1g = audioCtx.createGain(); o1g.gain.value = 0.35;
      o2g = audioCtx.createGain(); o2g.gain.value = 0.25;

      filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 700; filter.Q.value = 0.7;

      chargeGain = audioCtx.createGain(); chargeGain.gain.value = 0.0;

      osc1.connect(o1g); osc2.connect(o2g);
      o1g.connect(filter); o2g.connect(filter);
      filter.connect(chargeGain); chargeGain.connect(masterGain);

      osc1.start(); osc2.start();
    }
    function updateHum(level){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const gTarget = clamp(HUM_GAIN_MAX * Math.pow(level,1.15), 0, HUM_GAIN_MAX);
      chargeGain.gain.setTargetAtTime(gTarget, t, 0.06);

      const f1 = 90  + (240-90)  * level;
      const f2 = 180 + (520-180) * level;
      const ff = 700 + (4200-700)* level;
      osc1.frequency.setTargetAtTime(f1, t, 0.05);
      osc2.frequency.setTargetAtTime(f2, t, 0.05);
      filter.frequency.setTargetAtTime(ff, t, 0.08);
    }
    function cutHumPunch(){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const cur = chargeGain.gain.value || 0.0001;
      chargeGain.gain.setValueAtTime(cur, t);
      chargeGain.gain.exponentialRampToValueAtTime(Math.max(0.001, cur*1.6), t+0.05);
      chargeGain.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      filter.frequency.setTargetAtTime(6000, t, 0.03);
    }

    /* =======================
       ORB (single)
    ======================= */
    let orb = null;            // {cx,cy,charge,inZone,enterMs,launching,launchT0,startR,trail,renderR, path, s}
    let launching = false;
    let respawnAtMs = 0;

    function spawnOrb(){
      orb = {
        cx: W*rand(SPAWN_X_MIN_FRAC, SPAWN_X_MAX_FRAC),
        cy: H*SPAWN_Y_MIN_FRAC + rand(0, (H*SPAWN_Y_MAX_FRAC - H*SPAWN_Y_MIN_FRAC)),
        charge: 0, inZone:false, enterMs:0,
        launching:false, launchT0:0, startR:MIN_DIAMETER*0.5,
        trail: [], renderR: MIN_DIAMETER*0.5,
        path: null, s: 0
      };
    }
    function radiusFromCharge(o){ return (MIN_DIAMETER + (MAX_DIAMETER - MIN_DIAMETER)*o.charge) * 0.5; }
    function inOrb(o, x, y){ return Math.hypot(x - o.cx, y - o.cy) <= radiusFromCharge(o); }

    /* =======================
       IMPACT FX
    ======================= */
    const shards=[];
    function burstAt(x,y){
      const tBorn = nowS();
      for (let i=0;i<IMPACT_PETALS;i++){
        const a = Math.random()*Math.PI*2;
        const sp= IMPACT_SPEED*(0.4+0.6*Math.random());
        const size=rand(24,72);
        shards.push({
          x, y, w:size, h:size, ang:rand(-Math.PI,Math.PI),
          vx:Math.cos(a)*sp, vy:Math.sin(a)*sp - rand(60,120),
          rot:rand(-1.6,1.6), born:tBorn, life:IMPACT_LIFE
        });
      }
    }
    let flashLife=0, flashT=0, shockLife=0, shockT=0, shockX=0, shockY=0;
    function flash(a=FLASH_MAX_ALPHA, life=0.16){ flashLife=life; flashT=0; }
    function shock(cx,cy,life=0.9){ shockLife=life; shockT=0; shockX=cx; shockY=cy; }

    /* =======================
       CRATERS
    ======================= */
    const craters = [];
    function addCraterFromImpact() {
      // Approach angle from last trail segment if available
      let ang = -Math.PI/2; // default: from below
      if (orb && orb.trail && orb.trail.length >= 2) {
        const a = orb.trail[orb.trail.length - 1];
        const b = orb.trail[orb.trail.length - 2];
        ang = Math.atan2(a.y - b.y, a.x - b.x);
      }
      const rFrac = rand(CRATER_R_MIN_FR, CRATER_R_MAX_FR);
      const distMax = Math.max(0, 1 - rFrac - CRATER_MARGIN_FR);
      const dist = rand(0.10, distMax);
      craters.push({ ang, dist, rFrac, bornMs: performance.now() });
      if (craters.length > MAX_CRATERS) craters.shift();
    }

    function drawCraters() {
      if (!craters.length) return;
      // light from top-left
      const LVX = -0.5, LVY = -0.9;
      const lvLen = Math.hypot(LVX, LVY) || 1;
      const lx = LVX / lvLen, ly = LVY / lvLen;
      const nowMs = performance.now();

      for (const c of craters) {
        // pop-in animation
        const age = nowMs - c.bornMs;
        const k = Math.min(1, age / CRATER_FADE_MS); // 0..1
        const scale = 0.7 + 0.3 * k;                 // start slightly smaller
        const alpha = k;                              // fade in

        const cx = moon.x + Math.cos(c.ang) * c.dist * MOON_R;
        const cy = moon.y + Math.sin(c.ang) * c.dist * MOON_R;
        const r  = c.rFrac * MOON_R * scale;

        // base depression (radial gradient, darker center)
        const g = ctx.createRadialGradient(
          cx - (lx * r * 0.25), cy - (ly * r * 0.25), r * 0.15,
          cx, cy, r
        );
        g.addColorStop(0, `rgba(185,190,205,${0.45*alpha})`);
        g.addColorStop(1, `rgba(160,165,185,0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

        // soft shadow rim on far (down-right) side
        const shadowAng = Math.atan2(-ly, -lx);
        ctx.strokeStyle = `rgba(90,100,130,${0.20*alpha})`;
        ctx.lineWidth = Math.max(1, r * 0.12);
        ctx.beginPath();
        ctx.arc(cx, cy, r, shadowAng - 0.9, shadowAng + 0.9);
        ctx.stroke();

        // subtle highlight on light (top-left) side
        const lightAng = Math.atan2(ly, lx);
        ctx.strokeStyle = `rgba(255,255,255,${0.12*alpha})`;
        ctx.lineWidth = Math.max(1, r * 0.08);
        ctx.beginPath();
        ctx.arc(cx, cy, r, lightAng - 0.9, lightAng + 0.9);
        ctx.stroke();
      }
    }

    /* =======================
       MOON SHAKE HELPERS
    ======================= */
    function moonKick(ix, iy, power = 1) {
      const len = Math.hypot(ix, iy) || 1;
      const ux = ix / len, uy = iy / len;
      mShake.vx += ux * SHAKE_IMPULSE * power;
      mShake.vy += uy * SHAKE_IMPULSE * power;
    }
    function updateMoonShake(dt) {
      // spring-damper to origin: a = -k*x - c*v
      mShake.vx += (-SHAKE_STIFFNESS * mShake.ox - SHAKE_DAMPING * mShake.vx) * dt;
      mShake.vy += (-SHAKE_STIFFNESS * mShake.oy - SHAKE_DAMPING * mShake.vy) * dt;
      mShake.ox += mShake.vx * dt;
      mShake.oy += mShake.vy * dt;
      if (Math.abs(mShake.ox) < 0.01) mShake.ox = 0;
      if (Math.abs(mShake.oy) < 0.01) mShake.oy = 0;
    }

    /* =======================
       DRAW HELPERS
    ======================= */
    function drawSmallHalo(cx, cy, r, alpha=HALO_ALPHA){
      const inner = r*HALO_INNER_MULT, outer = r*HALO_OUTER_MULT;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(cx, cy, inner, cx, cy, outer);
      g.addColorStop(0, `rgba(${BALL_RGB},${alpha})`);
      g.addColorStop(1, `rgba(${BALL_RGB},0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, outer, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
    function drawSolidBall(cx, cy, r, withRim=true){
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = `rgb(${BALL_RGB})`;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      if (withRim){
        ctx.strokeStyle = `rgba(255,255,255,${RIM_ALPHA})`;
        ctx.lineWidth = Math.max(1, r*0.02);
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    }
    function orbJitter(charge01){
      const t = performance.now()/1000;
      const amp = ORB_SHAKE_MAX * Math.pow(charge01,1.2);
      const ox = Math.sin(t*ORB_SHAKE_FX*2*Math.PI + 0.31) * amp;
      const oy = Math.cos(t*ORB_SHAKE_FY*2*Math.PI + 1.13) * amp * 0.8;
      return [ox, oy];
    }

    /* =======================
       MOON + DESIGNED HALO
    ======================= */
    function drawMoonHaloLayers(){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      // 1) Outer diffuse aura with slight warm→cool blend
      let g = ctx.createRadialGradient(moon.x, moon.y, MOON_R*0.8, moon.x, moon.y, MOON_GLOW_R);
      g.addColorStop(0.00, 'rgba(255,244,220,0.22)');
      g.addColorStop(0.45, 'rgba(230,240,255,0.10)');
      g.addColorStop(1.00, 'rgba(190,210,255,0.00)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_GLOW_R, 0, Math.PI*2); ctx.fill();

      // 2) Warm inner corona hugging the disk
      const coronaR = MOON_R * 1.35;
      g = ctx.createRadialGradient(moon.x, moon.y, MOON_R*0.95, moon.x, moon.y, coronaR);
      g.addColorStop(0.00, 'rgba(255,248,235,0.42)');
      g.addColorStop(1.00, 'rgba(255,248,235,0.00)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(moon.x, moon.y, coronaR, 0, Math.PI*2); ctx.fill();

      // 3) Anisotropic (elliptical) halo for stylized atmosphere scatter
      ctx.save();
      ctx.translate(moon.x, moon.y);
      ctx.rotate(-0.12);
      ctx.scale(1.35, 0.85);
      const ellR = MOON_R * 2.4;
      g = ctx.createRadialGradient(0, 0, MOON_R*0.9, 0, 0, ellR);
      g.addColorStop(0.00, 'rgba(255,240,210,0.10)');
      g.addColorStop(1.00, 'rgba(180,200,255,0.00)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(0, 0, ellR, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // 4) Thin pearly rim ring
      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.lineWidth = Math.max(1, MOON_R * 0.04);
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_R * 1.05, 0, Math.PI*2); ctx.stroke();

      // 5) Very subtle starburst spokes (tasteful)
      const RAY_COUNT = 6;
      for (let i=0;i<RAY_COUNT;i++){
        const ang = i * (Math.PI / RAY_COUNT);
        ctx.save();
        ctx.translate(moon.x, moon.y);
        ctx.rotate(ang + 0.2);
        const grad = ctx.createLinearGradient(0, 0, MOON_R * 3.2, 0);
        grad.addColorStop(0, 'rgba(255,240,210,0.08)');
        grad.addColorStop(1, 'rgba(255,240,210,0.00)');
        ctx.fillStyle = grad;
        ctx.globalAlpha = 0.22;
        ctx.fillRect(0, -1.5, MOON_R * 3.2, 3);
        ctx.restore();
      }

      ctx.restore();
    }

    function drawMoon(){
      // translate just the moon (and its craters/halo) by shake offset
      ctx.save();
      ctx.translate(mShake.ox, mShake.oy);

      // Designed halo layers (behind disk)
      drawMoonHaloLayers();

      // disk
      ctx.save();
      ctx.fillStyle = 'rgb(245,245,250)';
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_R, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // craters over the disk
      drawCraters();

      ctx.restore(); // end translate
    }

    /* =======================
       BACKGROUND + FX
    ======================= */
    function drawBackground(){
      if (bgImg.complete && bgImg.naturalWidth>0){
        const iw=bgImg.width, ih=bgImg.height;
        const sc=Math.max(W/iw, H/ih);
        ctx.drawImage(bgImg, (W-iw*sc)/2, (H-ih*sc)/2, iw*sc, ih*sc);
      } else {
        ctx.fillStyle="#041017"; ctx.fillRect(0,0,W,H);
      }
    }

    function drawShards(){
      const t=nowS();
      for (let i=shards.length-1; i>=0; i--){
        const s = shards[i];
        const a = Math.max(0, 1 - (t - s.born)/s.life);
        ctx.save(); ctx.globalAlpha = a;
        ctx.translate(s.x, s.y); ctx.rotate(s.ang);
        ctx.drawImage(petalImg, -s.w/2, -s.h/2, s.w, s.h);
        ctx.restore();
        if (a<=0) shards.splice(i,1);
      }
    }
    function drawFlash(){
      if (flashLife<=0) return;
      const p = Math.min(1, flashT/flashLife);
      const a = FLASH_MAX_ALPHA*(1-p);
      if (a<=0.01) return;
      ctx.save(); ctx.fillStyle=`rgba(255,255,255,${a})`; ctx.fillRect(0,0,W,H); ctx.restore();
    }
    function drawShockwave(){
      if (shockLife<=0) return;
      const p = Math.min(1, shockT/shockLife);
      const r = SHOCKWAVE_MAX_R*p;
      const a = 0.35*(1-p);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,255,255,${a})`;
      ctx.lineWidth = 6*(1-p);
      ctx.beginPath(); ctx.arc(shockX, shockY, r, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    /* =======================
       CONSTANT-SPEED PATH HELPERS
    ======================= */
    function bezierPoint(p0, p1, p2, t){
      const u = 1 - t;
      const x = u*u*p0.x + 2*u*t*p1.x + t*t*p2.x;
      const y = u*u*p0.y + 2*u*t*p1.y + t*t*p2.y;
      return { x, y };
    }
    function makePathLUT(p0, p1, p2, segments = 260){
      const ts = [], xs = [], ys = [], cum = [];
      let total = 0;
      let prev = bezierPoint(p0, p1, p2, 0);
      ts.push(0); xs.push(prev.x); ys.push(prev.y); cum.push(0);
      for (let i=1;i<=segments;i++){
        const t = i/segments;
        const p = bezierPoint(p0, p1, p2, t);
        total += Math.hypot(p.x - prev.x, p.y - prev.y);
        ts.push(t); xs.push(p.x); ys.push(p.y); cum.push(total);
        prev = p;
      }
      return { ts, xs, ys, cum, total };
    }
    function samplePathByS(lut, s){
      const target = Math.max(0, Math.min(lut.total, s));
      let lo = 0, hi = lut.cum.length - 1;
      while (lo < hi){
        const mid = (lo + hi) >> 1;
        if (lut.cum[mid] < target) lo = mid + 1; else hi = mid;
      }
      if (lo === 0) return { x: lut.xs[0], y: lut.ys[0], t: lut.ts[0] };
      const i = lo, j = lo - 1;
      const c0 = lut.cum[j], c1 = lut.cum[i];
      const ratio = (target - c0) / Math.max(1e-6, (c1 - c0));
      const x = lut.xs[j] + (lut.xs[i] - lut.xs[j]) * ratio;
      const y = lut.ys[j] + (lut.ys[i] - lut.ys[j]) * ratio;
      const t = lut.ts[j] + (lut.ts[i] - lut.ts[j]) * ratio;
      return { x, y, t };
    }

    /* =======================
       UPDATE
    ======================= */
    let started=false, lastT=performance.now();

    function maybeCharge(dt){
      if (!orb || launching) return;
      const r = radiusFromCharge(orb);
      const inside = pointer.inside && inOrb(orb, pointer.x, pointer.y);

      if (inside){
        if (!orb.inZone){ orb.inZone = true; orb.enterMs = performance.now(); }
        const ok = (performance.now() - orb.enterMs) >= ENTRY_GRACE_MS;
        if (ok){
          orb.charge = Math.min(1, orb.charge + dt*(1000/DWELL_MS));
          if (orb.charge >= 1 && !launching){
            // launch!
            launching = true;
            cutHumPunch();
            play(sfxRelease);
            orb.launching = true;
            orb.launchT0 = performance.now();
            orb.startR  = radiusFromCharge(orb);
            orb.trail.length = 0;

            // Build constant-speed path LUT
            const p0   = { x:orb.cx, y:orb.cy };
            const ctrl = { x:orb.cx + (moon.x - orb.cx)*0.35, y: Math.min(orb.cy, moon.y) - H*BEZIER_PEAK };
            const p1   = { x:moon.x, y:moon.y };
            orb.path = makePathLUT(p0, ctrl, p1, 260);
            orb.s = 0;
          }
        }
      } else {
        orb.inZone = false;
        if (!launching) orb.charge = Math.max(0, orb.charge - DECAY_PER_SEC*dt);
      }
    }

    function update(dt){
      // Spawn if needed
      if (!orb && !launching && respawnAtMs && performance.now() >= respawnAtMs){
        respawnAtMs = 0;
        spawnOrb();
      } else if (!orb && !launching && !respawnAtMs){
        // first time
        spawnOrb();
      }

      // Charging
      maybeCharge(dt);

      // Update hum
      updateHum(orb && !launching ? orb.charge : 0);

      // Launch — constant speed along the curve
      if (launching && orb && orb.path){
        orb.s += LAUNCH_SPEED_PX * dt;
        const done = orb.s >= orb.path.total - 0.5;
        const P = samplePathByS(orb.path, orb.s);
        // linear radius shrink by normalized distance
        const u = Math.min(1, orb.s / Math.max(1e-6, orb.path.total));
        const r = orb.startR + (END_RADIUS - orb.startR) * u;

        // trail
        orb.trail.push({ x:P.x, y:P.y, r, a:1 });
        if (orb.trail.length>18) orb.trail.shift();
        for (const tr of orb.trail) tr.a *= 0.9;

        orb.cx = P.x; orb.cy = P.y; orb.renderR = r;

        if (done){
          // derive impact direction from last trail segment
          let ix = 0, iy = -1;
          if (orb.trail.length >= 2) {
            const a = orb.trail[orb.trail.length - 1];
            const b = orb.trail[orb.trail.length - 2];
            ix = a.x - b.x; iy = a.y - b.y;
          }

          // bigger visible nudge, then kick
          const len = Math.hypot(ix, iy) || 1;
          const ux = ix/len, uy = iy/len;
          mShake.ox += ux * 12;
          mShake.oy += uy * 12;
          moonKick(ix, iy, 1.6);

          addCraterFromImpact();
          burstAt(moon.x, moon.y);
          flash(); shock(moon.x, moon.y);
          play(sfxImpact);

          launching = false;
          orb = null;
          respawnAtMs = performance.now() + RESPAWN_DELAY_MS; // schedule next orb
        }
      }

      // FX timers
      if (flashLife>0){ flashT += dt; if (flashT>=flashLife) flashLife=0; }
      if (shockLife>0){ shockT += dt; if (shockT>=shockLife) shockLife=0; }

      // Petal physics
      const t = nowS();
      for (let i=shards.length-1;i>=0;i--){
        const s=shards[i];
        s.x += s.vx*dt; s.y += s.vy*dt; s.vy += 360*dt; s.ang += s.rot*dt;
        if (t - s.born > s.life) shards.splice(i,1);
      }

      // Moon shake integration (slow, strong)
      updateMoonShake(dt);
    }

    /* =======================
       RENDER
    ======================= */
    function drawOrb(){
      if (!orb) return;
      if (!launching){
        const r = radiusFromCharge(orb);
        const [ox, oy] = orbJitter(orb.charge);
        const cx = orb.cx + ox, cy = orb.cy + oy;
        drawSolidBall(cx, cy, r, true);
        drawSmallHalo(cx, cy, r, HALO_ALPHA);
      } else {
        // trail echoes
        ctx.save(); ctx.globalCompositeOperation='source-over';
        for (const tr of orb.trail){
          if (tr.a<=0.02) continue;
          ctx.globalAlpha = 0.10 * tr.a;
          drawSolidBall(tr.x, tr.y, tr.r*0.9, false);
          drawSmallHalo(tr.x, tr.y, tr.r*0.9, HALO_TRAIL_ALPHA*tr.a);
        }
        ctx.restore(); ctx.globalAlpha=1;

        // current position
        drawSolidBall(orb.cx, orb.cy, orb.renderR||END_RADIUS, true);
        drawSmallHalo(orb.cx, orb.cy, orb.renderR||END_RADIUS, HALO_ALPHA);
      }
    }

    function render(){
      // bg
      if (bgImg.complete && bgImg.naturalWidth>0){
        const iw=bgImg.width, ih=bgImg.height;
        const sc=Math.max(W/iw, H/ih);
        ctx.drawImage(bgImg, (W-iw*sc)/2, (H-ih*sc)/2, iw*sc, ih*sc);
      } else {
        ctx.fillStyle="#041017"; ctx.fillRect(0,0,W,H);
      }

      // moon (with designed halo + stronger, slower shake)
      drawMoon();

      // orb + fx
      drawOrb();
      drawShards();
      drawShockwave();
      drawFlash();
    }

    function tick(tMs){
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT)/1000);
      lastT = tMs;
      update(dt);
      render();
      requestAnimationFrame(tick);
    }

    /* =======================
       START
    ======================= */
    const startOverlay=document.getElementById('startOverlay');
    const startBtn=document.getElementById('startBtn');

    async function enterFullscreen(){
      const el=document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    }

    startBtn.addEventListener('click', async ()=>{
      try{ await enterFullscreen(); }catch(e){}
      startOverlay.style.display='none';
      started = true;

      // ensure images then start
      let pending = 0;
      const tryStart = ()=>{ if (--pending<=0) requestAnimationFrame(tick); };
      [bgImg, petalImg].forEach(im=>{ if (!im.complete){ pending++; im.onload=tryStart; }});
      if (pending===0) requestAnimationFrame(tick);

      // audio on gesture
      try { setupAudio(); await audioCtx.resume(); } catch(e){}
      resize();
    });
  })();
  </script>
</body>
</html>
