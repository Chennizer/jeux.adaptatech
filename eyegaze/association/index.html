<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trouve l’image — Pictos</title>

  <!-- Styles partagés -->
  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    /* Thèmes */
    body.light { background-color: #fff; color: #000; }
    body.dark  { background-color: #000; color: #fff; }

    /* Conteneur du jeu */
    .game-container {
      width: 100%;
      max-width: 100vw;
      height: 100%;
      display: none;             /* affiché après Start */
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
      box-sizing: border-box;
    }

    /* --- TOP STRIP: white card, capped height, slimmer width --- */
    .top-strip{
      width: min(720px, 88vw);
      margin-top: 8px;
      padding: 14px 16px;
      border-radius: 14px;
      border: 2px solid rgba(0,0,0,0.12);
      box-shadow: 0 6px 20px rgba(0,0,0,0.06);
      transition: opacity 500ms ease;
      margin-bottom: 16px;       /* constant gap */
      opacity: 1;

      display: none;                 /* shown after Start */
      flex: 0 0 auto;
      overflow: hidden;
      --top-cap: clamp(140px, 26vh, 320px);
      max-height: var(--top-cap);

      background: #ffffff;
    }
    .top-strip.fade-out { opacity: 0; }
    .top-strip.hidden{ display: none !important; }
    body.dark .top-strip{
      border-color: rgba(255,255,255,0.18);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      background: #ffffff;
    }

    /* Content inside: row (text | image) side-by-side */
    .top-center{
      width: 100%;
      height: 100%;
      max-width: 820px;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin: 0 auto;
    }
    @media (max-width: 520px){
      .top-center{ flex-direction: column; }
    }

    /* Prompt block — bigger text, dark on white */
    #prompt{ margin:0; display:none; opacity:1; transition: opacity 500ms ease; }
    #prompt .prompt-text{
      font-size: clamp(1.25rem, 2.2vw, 1.6rem);
      font-weight: 800;
      color: #0f172a; /* slate-900 */
      line-height: 1.25;
      letter-spacing: .2px;
      text-wrap: balance;
    }

    /* Target image fits inside cap */
    .target-image{
      flex: 0 0 auto;
      width: min(36vmin, 300px);
      max-width: 300px;
      max-height: calc(var(--top-cap) - 24px);
      object-fit: contain;
      background: transparent;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.12));
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    /* Zone centrale qui contient la grille */
    .grid-outer{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 100vw;
    }

    /* Grille d’images */
    .letter-grid {
      display: none;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      place-content: center;
      justify-items: stretch;
      align-items: stretch;
      margin: 0;
    }
    .letter-grid.no-input { pointer-events: none; }

    /* Tuiles image */
    .letter-cell {
      position: relative;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: none; /* pour oculométrie */
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;
      transform: translateZ(0);
      background-clip: padding-box;
      background-color: #fff;
      color: #000;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      opacity: 1;
      transition: opacity 500ms ease, transform 500ms ease, filter 500ms ease, background-color 300ms ease;
    }
    body.dark .letter-cell { background-color: #222; color: #fff; }

    .cell-img{
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    /* Estompe les autres cases lors d’un succès */
    .letter-cell.dim {
      opacity: 0;
      transform: scale(0.92);
      filter: blur(1px);
    }

    /* Remplissage de dwell */
    .dwell-fill {
      position: absolute;
      background-color: rgba(255, 0, 0, 0.5);
      top: 50%; left: 50%;
      width: 0; height: 0;
      transform: translate(-50%, -50%);
      pointer-events: none;
      border-radius: 8px;
    }

    /* Clone volant (glide & grow) */
    .flying-tile {
      position: fixed;
      left: 0; top: 0;
      transform: translate3d(0, 0, 0) scale(1);
      transform-origin: center center;

      z-index: 9999;
      pointer-events: none;
      border-radius: 12px;
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;
      background-color: inherit;
      color: inherit;
      backface-visibility: hidden;
      will-change: transform;
      contain: layout paint style;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Verrou + pop prêt */
    .letter-grid.grid-locked { pointer-events: none; }
    .letter-grid.grid-locked .letter-cell {
      opacity: .35;
      filter: grayscale(70%);
      transition: opacity 250ms ease, filter 250ms ease;
    }
    @keyframes readyPop {
      0% { transform: scale(.98); }
      100% { transform: scale(1); }
    }
    .letter-grid.ready-pop .letter-cell { animation: readyPop 220ms ease; }
  </style>
</head>
<body>

<!-- Options -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title">Trouve l’image — Pictos</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Colonne 1: Audio + TTS -->
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span>Désactiver les sons</span>
          </label>
        </div>

        <!-- TTS -->
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="ttsEnabled">
            <span>Lecture vocale</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span>Volume des sons: </span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Colonne 2: Catégorie + nb choix + thème -->
      <div class="options-column">
        <div class="option-item">
          <label for="categorySelect" class="teal-label label-block">Catégorie</label>
          <select id="categorySelect" class="styled-select"></select>
        </div>

        <div class="option-item">
          <label for="choicesCount" class="teal-label">
            <span>Nombre de choix: </span>
            <span id="choicesCountVal">8</span>
          </label>
          <input type="range" id="choicesCount" class="styled-slider" min="3" max="12" step="1" value="8">
        </div>

        <div class="option-item">
          <label for="themeSelect" class="teal-label label-block">Mode</label>
          <select id="themeSelect" class="styled-select">
            <option value="light" selected>Clair</option>
            <option value="dark">Sombre</option>
          </select>
        </div>
      </div>

      <!-- Colonne 3: Dwell + échelle -->
      <div class="options-column">
        <div class="option-item">
          <label for="dwellTimeSlider" class="teal-label">
            <span>Temps de fixation: </span>
            <span id="dwellTimeVal">1500</span> ms
          </label>
          <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="5000" step="100" value="1500">
        </div>
        <div class="option-item">
          <label for="layoutScale" class="teal-label">
            <span>Mise en page (taille):</span>
            <span id="layoutScaleVal"> 1.00</span>x
          </label>
          <input type="range" id="layoutScale" class="styled-slider" min="0.8" max="1.4" step="0.05" value="1.0">
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button">Commencer</button>
  </div>
</div>

<!-- Aire de jeu -->
<div class="game-container">

  <!-- Bande d’instruction / cible : white card, side-by-side -->
  <div id="topStrip" class="top-strip">
    <div class="top-center">
      <h2 id="prompt"><span class="prompt-text" id="promptText">Trouve …</span></h2>
      <img id="targetImage" class="target-image" alt="">
    </div>
  </div>

  <div class="grid-outer">
    <div class="letter-grid" id="imageGrid"></div>
  </div>
</div>

<!-- Audio -->
<audio id="correctSound" src="../../sounds/victory.mp3"></audio>
<audio id="wrongSound"   src="../../sounds/error.mp3"></audio>

<!-- Eyegaze helpers -->
<script src="../../js/eyegaze-menu.js"></script>

<script>
/* =========================
   Chargement des pictos
   ========================= */
const PICTOS_JSON_PATH = '../../images/pictos/newindex.json';
let pictosData = null;

fetch(PICTOS_JSON_PATH)
  .then(r => r.json())
  .then(data => {
    pictosData = data;
    const select = document.getElementById('categorySelect');
    select.innerHTML = '';
    Object.keys(data.categories).forEach(cat => {
      const opt = document.createElement('option');
      opt.value = cat; opt.textContent = cat;
      select.appendChild(opt);
    });
  })
  .catch(err => console.error('Erreur JSON pictos:', err));

/* =========================
   Bindings & options
   ========================= */
const muteSFX      = document.getElementById('muteSFX');
const sfxVol       = document.getElementById('sfxVol');
const sfxVolVal    = document.getElementById('sfxVolVal');
const dwellSlider  = document.getElementById('dwellTimeSlider');
const dwellTimeVal = document.getElementById('dwellTimeVal');
const themeSelect  = document.getElementById('themeSelect');
const startButton  = document.getElementById('startButton');
const ttsEnabled   = document.getElementById('ttsEnabled');
const choicesCountEl = document.getElementById('choicesCount');
const choicesCountVal= document.getElementById('choicesCountVal');

const layoutScaleEl = document.getElementById('layoutScale');
const layoutScaleVal= document.getElementById('layoutScaleVal');

sfxVol.addEventListener('input', () => sfxVolVal.textContent = sfxVol.value);
dwellSlider.addEventListener('input', () => dwellTimeVal.textContent = dwellSlider.value);
choicesCountEl.addEventListener('input', () => choicesCountVal.textContent = choicesCountEl.value);
layoutScaleEl.addEventListener('input', () => {
  layoutScaleVal.textContent = parseFloat(layoutScaleEl.value).toFixed(2);
  if (document.querySelector('.game-container').style.display === 'flex') {
    layoutScale = parseFloat(layoutScaleEl.value);
    adjustGridSizes();
  }
});

/* =========================
   Local storage (TTS)
   ========================= */
const LS_KEYS = { ttsEnabled: 'trouveimage:ttsEnabled' };
(function initPersistedControls(){
  try {
    const en = localStorage.getItem(LS_KEYS.ttsEnabled);
    if (en !== null) ttsEnabled.checked = (en === 'true');
  } catch(e){}
})();
ttsEnabled.addEventListener('change', () => {
  try { localStorage.setItem(LS_KEYS.ttsEnabled, String(ttsEnabled.checked)); } catch(e){}
});

/* =========================
   État du jeu
   ========================= */
let currentCategory = null;
let pool = [];
let targetItem = null;
let isReady = false;
let layoutScale = 1.0;

const EDGE_PAD = 10;
const MIN_TILE = 96;
const GAP_MIN  = 80;
const GAP_MAX  = 120;

const correctAudio = document.getElementById('correctSound');
const wrongAudio   = document.getElementById('wrongSound');

/* =========================
   Thème
   ========================= */
function applyTheme(theme) {
  document.body.classList.remove('light','dark');
  document.body.classList.add(theme);
}

/* =========================
   FR phrase joiner (handles elision: l’ + word => l’ours)
   ========================= */
function joinFr(article, word){
  const a = (article || '').trim();
  const w = (word || '').trim();
  if (!a) return w;
  if (!w) return a;
  // If article ends with apostrophe-like char, concatenate with NO space
  const endsWithApo = /[’'ʼ]$/.test(a);
  return endsWithApo ? (a + w) : (a + ' ' + w);
}

/* =========================
   TTS — ultra-low gap strategy
   ========================= */

/* Set to 0 for “one breath” (single utterance). If > 0, we queue two utterances
   immediately so the engine uses its minimal internal gap. */
let TTS_TROUVE_GAP_MS = 0;

let preferredVoice = null;

function choosePreferredVoice() {
  const ss = window.speechSynthesis;
  if (!ss || !ss.getVoices) return;
  const voices = ss.getVoices() || [];
  if (!voices.length) return;

  const by = (fn) => voices.find(fn);
  preferredVoice =
    by(v => /sylvie/i.test(v.name || '') && /^fr[-_]?CA/i.test(v.lang || '')) ||
    by(v => /^fr[-_]?CA/i.test(v.lang || '')) ||
    by(v => /^fr[-_]?FR/i.test(v.lang || '')) ||
    by(v => (v.lang || '').toLowerCase().startsWith('fr')) ||
    voices[0];
}

function makeUtterance(text) {
  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;
  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number') ? sfxSetting : (isNaN(uiVol) ? 50 : uiVol);
  const volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));

  const u = new SpeechSynthesisUtterance(text);
  if (preferredVoice) { u.voice = preferredVoice; u.lang = preferredVoice.lang || 'fr-CA'; }
  else { u.lang = 'fr-CA'; }
  u.rate = 1.0;
  u.volume = volume;
  return u;
}

/* Ensure voices are ready once */
function voicesReady() {
  return new Promise((resolve) => {
    const ss = window.speechSynthesis;
    if (!ss) return resolve();
    const v = ss.getVoices();
    if (v && v.length) return resolve();
    const onChange = () => { ss.removeEventListener('voiceschanged', onChange); resolve(); };
    ss.addEventListener('voiceschanged', onChange);
  });
}

/* Speak either as a single utterance (gap 0) or queue two utterances immediately. */
async function speakSequence(texts, gapMs = 0) {
  if (!('speechSynthesis' in window)) return;
  try { speechSynthesis.cancel(); } catch(e) {}
  await voicesReady();
  choosePreferredVoice();

  if (gapMs <= 0 && texts.length === 2) {
    const u = makeUtterance(`${texts[0]} ${texts[1]}`);
    speechSynthesis.speak(u);
    return;
  }
  texts.forEach((t) => {
    const u = makeUtterance(t);
    speechSynthesis.speak(u);
  });
}

if ('speechSynthesis' in window) {
  speechSynthesis.addEventListener('voiceschanged', choosePreferredVoice);
  choosePreferredVoice();
}

const TIMING = {
  glide: 3800,
  grow: 2600,
  pauseAfterGrow: 2400
};

function speakPromptForItem(item){
  const enabled = !!ttsEnabled.checked || !!(window.eyegazeSettings?.ttsEnabled);
  if (!enabled || !item) return;

  const phrase  = joinFr(item.label?.fr?.article, item.label?.fr?.word);

  // Zero-gap (single utterance) by default; set TTS_TROUVE_GAP_MS > 0 to queue
  speakSequence(['Trouve', phrase], TTS_TROUVE_GAP_MS);
}

/* =========================
   Verrou / déverrouillage
   ========================= */
function lockGrid() {
  const grid = document.getElementById('imageGrid');
  isReady = false;
  if (grid) grid.classList.add('grid-locked');
}

function unlockGrid() {
  const grid = document.getElementById('imageGrid');
  isReady = true;
  if (grid) {
    grid.classList.remove('grid-locked');
    grid.classList.add('ready-pop');
    setTimeout(() => grid.classList.remove('ready-pop'), 260);
  }
}

/* =========================
   Démarrage
   ========================= */
function startGame() {
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.webkitRequestFullscreen) {
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) {
    document.documentElement.msRequestFullscreen();
  }

  syncEyegazeSettingsFromUI();

  applyTheme(themeSelect.value);
  layoutScale = parseFloat(layoutScaleEl.value) || 1.0;

  currentCategory = document.getElementById('categorySelect').value;

  if (!pictosData || !pictosData.categories[currentCategory]) {
    alert('Catégorie non disponible.');
    return;
  }
  const base = pictosData.base || '';
  pool = pictosData.categories[currentCategory].map(entry => {
    return { file: entry.file, label: entry.label, srcAbs: base + entry.file };
  });

  document.querySelector('.game-container').style.display = 'flex';
  document.getElementById('topStrip').style.display = 'block';
  document.getElementById('prompt').style.display = 'block';

  const grid = document.getElementById('imageGrid');
  grid.style.display = 'grid';

  buildGridSkeleton();
  nextRound();

  try { if (window.eyegazeSettings?.hideOverlay) eyegazeSettings.hideOverlay(); } catch(e) {}
  choosePreferredVoice();
}
startButton.addEventListener('click', startGame);

/* =========================
   Eyegaze settings sync
   ========================= */
function syncEyegazeSettingsFromUI() {
  try {
    if (window.eyegazeSettings) {
      eyegazeSettings.sfxMuted  = !!muteSFX.checked;
      eyegazeSettings.sfxVolume = parseInt(sfxVol.value, 10) || 50;
      eyegazeSettings.dwellTime = parseInt(dwellSlider.value, 10) || 1500;
      eyegazeSettings.ttsEnabled= !!ttsEnabled.checked;
    }
  } catch(e) {}
}

/* =========================
   Construction / sizing
   ========================= */
function buildGridSkeleton(){
  const grid = document.getElementById('imageGrid');
  grid.innerHTML = '';
  const total = getDesiredChoicesCount();
  const columns = Math.min(4, Math.ceil(Math.sqrt(total)));
  grid.dataset.columns = String(columns);
  grid.style.padding = EDGE_PAD + 'px';

  for (let i=0;i<total;i++){
    const cell = document.createElement('div');
    cell.className = 'letter-cell';
    grid.appendChild(cell);
  }
  adjustGridSizes();
}

window.addEventListener('resize', adjustGridSizes);
document.getElementById('targetImage').addEventListener('load', adjustGridSizes);
window.addEventListener('orientationchange', adjustGridSizes);

/* Robust viewport-based sizing that respects the top strip cap */
function adjustGridSizes() {
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  const grid = document.getElementById('imageGrid');
  const outer = grid.parentElement;
  const cells = grid.querySelectorAll('.letter-cell');
  if (!cells.length || !outer) return;

  const columns = parseInt(grid.dataset.columns || '3', 10);
  const rows    = Math.ceil(cells.length / columns);

  const containerW = grid.clientWidth;

  // Compute height available below the top strip without feedback loop
  const outerRect = outer.getBoundingClientRect();
  const containerH = Math.max(0, window.innerHeight - outerRect.top - 8);

  const contentW = Math.max(0, containerW - 2 * EDGE_PAD);
  const contentH = Math.max(0, containerH - 2 * EDGE_PAD);
  const contentMin = Math.min(contentW, contentH);

  let GAP = Math.round((contentMin * 0.02) / Math.max(0.8, layoutScale));
  GAP = clamp(GAP, GAP_MIN, GAP_MAX);
  grid.style.gap = GAP + 'px';

  const sizeByW = (contentW - (columns - 1) * GAP) / columns;
  const SAFETY = 8;
  const sizeByH = ((contentH - (rows - 1) * GAP) / rows) - SAFETY;

  const candidate = Math.floor(Math.min(sizeByW, sizeByH));
  const size = Math.max(MIN_TILE, Math.min(candidate, Math.floor(candidate * layoutScale)));

  const track = size + 'px';
  grid.style.gridTemplateColumns = `repeat(${columns}, ${track})`;
  grid.style.gridAutoRows        = track;
}

/* =========================
   Manche suivante
   ========================= */
function nextRound(){
  const strip = document.getElementById('topStrip');
  strip.classList.remove('hidden','fade-out');

  targetItem = pickRandom(pool);

  const total = getDesiredChoicesCount();
  const distractors = pickNDistinct(pool.filter(x => x.file !== targetItem.file), total - 1);

  const all = shuffle([targetItem, ...distractors]);
  const grid = document.getElementById('imageGrid');
  grid.classList.remove('no-input');
  grid.innerHTML = '';

  const columns = Math.min(4, Math.ceil(Math.sqrt(total)));
  grid.dataset.columns = String(columns);
  grid.style.padding = EDGE_PAD + 'px';

  all.forEach(item => {
    const cell = document.createElement('div');
    cell.className = 'letter-cell';
    const img = document.createElement('img');
    img.src = item.srcAbs;
    img.alt = (item.label?.fr?.word || '').trim();
    img.className = 'cell-img';
    cell.appendChild(img);

    cell.addEventListener('mouseover', () => startHover(cell, item));
    cell.addEventListener('mouseout', stopHover);

    grid.appendChild(cell);
  });

  const promptText = document.getElementById('promptText');
  const targetImage = document.getElementById('targetImage');
  const phrase = joinFr(targetItem.label?.fr?.article, targetItem.label?.fr?.word);
  promptText.textContent = `Trouve ${phrase}`;
  targetImage.src = targetItem.srcAbs;
  targetImage.alt = phrase;

  lockGrid();
  speakPromptForItem(targetItem);
  adjustGridSizes();

  setTimeout(unlockGrid, 3000);
}

/* =========================
   Dwell hover & sélection
   ========================= */
let currentOverlay;
let hoverTimeout;

function startHover(tile, item) {
  if (!isReady) return;

  const hoverTime = (window.eyegazeSettings?.dwellTime) || parseInt(dwellSlider.value, 10) || 1500;

  stopHover();
  currentOverlay = document.createElement('div');
  currentOverlay.className = 'dwell-fill';
  tile.appendChild(currentOverlay);

  requestAnimationFrame(() => {
    currentOverlay.style.transition = `width ${hoverTime}ms linear, height ${hoverTime}ms linear`;
    currentOverlay.style.width = '0';
    currentOverlay.style.height = '0';
    requestAnimationFrame(() => {
      currentOverlay.style.width = '100%';
      currentOverlay.style.height = '100%';
    });
  });

  hoverTimeout = setTimeout(() => {
    handleSelection(tile, item);
    stopHover();
  }, hoverTime);
}

function stopHover() {
  clearTimeout(hoverTimeout);
  if (currentOverlay && currentOverlay.parentElement) currentOverlay.parentElement.removeChild(currentOverlay);
  currentOverlay = null;
}

/* Sélection */
function handleSelection(tile, item){
  const isCorrect = (item.file === (targetItem && targetItem.file));
  if (!isCorrect) { playSound(wrongAudio); return; }

  const grid  = document.getElementById('imageGrid');
  const strip = document.getElementById('topStrip');

  const startRect = tile.getBoundingClientRect();

  playSound(correctAudio);
  grid.classList.add('no-input');
  grid.querySelectorAll('.letter-cell').forEach(cell => { if (cell !== tile) cell.classList.add('dim'); });
  strip.classList.add('fade-out');

  // Direct glide/grow (no red flash staying on the tile)
  const dark = getComputedStyle(document.body).backgroundColor === 'rgb(0, 0, 0)';
  const bgColor = dark ? '#222' : '#fff';
  const textColor = dark ? '#fff' : '#000';
  tile.style.backgroundColor = bgColor;
  tile.style.color = textColor;

  requestAnimationFrame(() => {
    glideTileToCenter(tile, 3800, 2600, {bgColor, textColor}, startRect).then((clone) => {
      const enabled = !!ttsEnabled.checked || !!(window.eyegazeSettings?.ttsEnabled);
      if (enabled) {
        const phrase = joinFr(item.label?.fr?.article, item.label?.fr?.word);
        // Speak the noun phrase after the success animation (single utterance)
        speakSequence([phrase], 0);
      }

      setTimeout(() => {
        if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
        grid.querySelectorAll('.letter-cell').forEach(cell => cell.classList.remove('dim'));
        tile.style.opacity = '';
        tile.style.backgroundColor = '';
        tile.style.color = '';
        grid.classList.remove('no-input');

        strip.classList.add('hidden');
        strip.classList.remove('fade-out');

        nextRound();
      }, TIMING.pauseAfterGrow);
    });
  });
}

/* Animation glide & grow */
function glideTileToCenter(tile, glideMs = 1200, growMs = 700, forcedColors, startRect) {
  return new Promise(resolve => {
    const r  = startRect || tile.getBoundingClientRect();
    const cs = getComputedStyle(tile);

    const clone = tile.cloneNode(true);
    clone.className = 'flying-tile';

    clone.style.width  = r.width + 'px';
    clone.style.height = r.height + 'px';
    clone.style.left   = r.left + 'px';
    clone.style.top    = r.top  + 'px';
    clone.style.transform = 'translate3d(0,0,0) scale(1)';
    clone.style.transformOrigin = 'center center';

    const bg = forcedColors?.bgColor || cs.backgroundColor;
    const fg = forcedColors?.textColor || cs.color;
    clone.style.backgroundColor = bg;
    clone.style.color           = fg;
    clone.style.borderRadius    = cs.borderRadius;
    clone.style.border          = cs.border;
    clone.style.boxShadow       = cs.boxShadow;

    const img = clone.querySelector('img');
    if (img) { img.style.width = '100%'; img.style.height = '100%'; img.style.objectFit = 'contain'; }

    document.body.appendChild(clone);

    tile.style.opacity = '0';
    tile.style.pointerEvents = 'none';

    const centerX = window.innerWidth  / 2;
    const centerY = window.innerHeight / 2;
    const dx = centerX - (r.left + r.width  / 2);
    const dy = centerY - (r.top  + r.height / 2);

    void clone.getBoundingClientRect();

    const a1 = clone.animate(
      [
        { transform: 'translate3d(0px, 0px, 0) scale(1)' },
        { transform: `translate3d(${dx}px, ${dy}px, 0) scale(1)` }
      ],
      { duration: glideMs, easing: 'cubic-bezier(.25,.8,.25,1)', fill: 'forwards' }
    );

    a1.onfinish = () => {
      const a2 = clone.animate(
        [
          { transform: `translate3d(${dx}px, ${dy}px, 0) scale(1)` },
          { transform: `translate3d(${dx}px, ${dy}px, 0) scale(2)` }
        ],
        { duration: growMs, easing: 'cubic-bezier(.2,.7,.2,1)', fill: 'forwards' }
      );
      a2.onfinish = () => resolve(clone);
    };
  });
}

/* Sons */
function playSound(audioEl) {
  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;
  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number') ? sfxSetting : (isNaN(uiVol) ? 50 : uiVol);

  audioEl.volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));
  try { audioEl.currentTime = 0; audioEl.play(); } catch(e) {}

  setTimeout(() => { try { audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }, 2000);
}

/* =========================
   Utilitaires
   ========================= */
function pickRandom(arr){ return arr[Math.floor(Math.random() * arr.length)]; }
function shuffle(a){
  const arr = a.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function pickNDistinct(arr, n){
  const pool = arr.slice();
  const out = [];
  while (pool.length && out.length < n){
    const idx = Math.floor(Math.random() * pool.length);
    out.push(pool.splice(idx,1)[0]);
  }
  return out;
}
function getDesiredChoicesCount(){
  const wanted = parseInt(choicesCountEl.value, 10) || 8;
  if (!pictosData || !pictosData.categories || !currentCategory) return wanted;
  const available = pictosData.categories[currentCategory]?.length || wanted;
  return Math.max(3, Math.min(wanted, available));
}
</script>
</body>
</html>
