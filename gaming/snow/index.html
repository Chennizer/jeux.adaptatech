<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Météo — Neige (Jeu Switch)</title>

<!-- p5.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>

<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#9fb6c6;}
  canvas{display:block;position:fixed;inset:0;}
  #modeOverlay{
    position:fixed;inset:0;display:flex;flex-direction:column;gap:18px;
    align-items:center;justify-content:center;background:#000;color:#fff;z-index:10000;
    text-align:center;padding:20px;
  }
  #modeOverlay h2{margin:0 0 8px 0;font-weight:600}
  #modeOverlay p{margin:0;opacity:.85}
  #modeOverlay button{
    padding:12px 22px;border:none;border-radius:8px;cursor:pointer;
    background:#ffd250;color:#000;font-size:18px;
  }
  #modeOverlay button:hover{background:#ffb930}
  #settings-icon{
    position:fixed;top:14px;right:14px;width:40px;height:40px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;cursor:pointer;
    background:rgba(0,0,0,.7);color:#fff;font-size:20px;z-index:10001;
    transition:transform .2s ease, background .2s ease; visibility:hidden;
  }
  #settings-icon:hover{transform:rotate(90deg);background:rgba(0,0,0,.85)}
  #menu{
    position:fixed;top:60px;right:-340px;width:300px;max-height:calc(100vh - 80px);
    overflow:auto;background:rgba(0,0,0,.86);color:#fff;border-radius:10px;
    padding:12px 14px;z-index:10000;transition:right .25s ease, opacity .25s ease; opacity:.0;
  }
  #menu.show{right:12px;opacity:1}
  #menu h2{margin:.2rem 0 .6rem 0;font-size:20px;color:#7dd3fc;text-align:center}
  #menu h3{margin:1rem 0 .4rem 0;font-size:15px;color:#93c5fd}
  #menu label{display:block;margin:.5rem 0;font-size:13px}
  #menu input[type="range"]{width:100%}
  #menu .inline{display:flex;align-items:center;justify-content:space-between;gap:8px}
  #menu .val{display:inline-block;min-width:2ch;padding:0 6px;border-radius:6px;background:rgba(255,255,255,.1)}
</style>
</head>
<body>

<!-- Mode selection -->
<div id="modeOverlay">
  <h2>Choisis ton mode&nbsp;:</h2>
  <button id="btnNormal">Mode normal (5–6 clics)</button>
  <button id="btnRapid">Mode éclair (1 clic)</button>
  <p>Espace = neige · Entrée = rejouer</p>
</div>

<!-- Settings icon + menu (kept; no HUD/hint text anymore) -->
<div id="settings-icon" title="Options">⚙️</div>
<div id="menu">
  <h2>Options</h2>
  <h3>Audio</h3>
  <label class="inline">
    <span>Désactiver la musique</span>
    <input type="checkbox" id="muteMusic">
  </label>
  <label>
    <span>Volume musique : <span class="val" id="musicVolVal">50</span></span><br>
    <input type="range" id="musicVol" min="0" max="100" value="50">
  </label>
  <label class="inline">
    <span>Désactiver les effets</span>
    <input type="checkbox" id="muteSFX">
  </label>
  <label>
    <span>Volume effets : <span class="val" id="sfxVolVal">70</span></span><br>
    <input type="range" id="sfxVol" min="0" max="100" value="70">
  </label>

  <h3>Jeu</h3>
  <label>
    <span>Appuis requis (mode normal) : <span class="val" id="reqVal">6</span></span><br>
    <input type="range" id="requiredPresses" min="5" max="6" step="1" value="6">
  </label>
  <label>
    <span>Délai entre appuis (ms) : <span class="val" id="delayVal">1200</span></span><br>
    <input type="range" id="tapDelay" min="400" max="2500" step="100" value="1200">
  </label>
</div>

<script>
/* === Paths === */
const ambiencePath='../../sounds/sun/sunnyday.mp3';
const pressPath   ='../../sounds/sun/sun1.mp3';
const finishPath  ='../../sounds/sun/fanfare.mp3';
const firPath     ='../../images/pictos/fir.png';

/* === State & settings === */
let gameStarted=false, rapidMode=false, finished=false;
let lastTap=-Infinity, tapDelay=1200;
let requiredPresses=6;
let presses=0;

/* Accumulation */
let progress=0;               // 0..1 shown
let targetProgress=0;         // 0..1 logical
const INITIAL_SNOW = 0.08;

/* Wave control */
let waveActive=false;
let spawning=false;
let spawnUntil=0;
let airborneCount=0;

/* Audio */
let ambience, pressSFX, finishSFX;
let isMusicMuted=false, isSFXMuted=false, volMusic=0.5, volSFX=0.7;

/* Visuals */
let clouds=[];
let flakesBack=[], stormFlakes=[];
let w=0, h=0;
let sunRot=0, glarePulse=1;

/* Forest (left cluster) */
let firImg=null;
let forest=[]; // {x,y,w,h,depth}

/* Background snow */
const BACK_DENSITY_BASE = 0.00010;
const BACK_SZ_MIN = 1.2, BACK_SZ_MAX = 3.0;
const BACK_VY_MIN = 0.24, BACK_VY_MAX = 0.6;
const BACK_ALPHA  = 130;

/* Ground / accumulation */
const MAX_SNOW_DEPTH_FRAC = 0.62;
const groundNoiseSeed = Math.floor(Math.random()*10000);

/* Storm tuning */
const SPAWN_WINDOW_MS = 1500;
const FLAKES_PER_MEGAPIXEL = 260;
const ACCUM_SCALE = 0.35;
const STORM_ACTIVE_CAP = 10000;

/* Wind (for drift) */
let windT = Math.random()*1000;
let baseWind = 0;
let gust = 0;

/* ★ CELEBRATION state */
let celebrating = false;
let celebrateStart = 0;
const CELEBRATE_MS = 8000; // showy finale length
let fireworks = [];
let sparkles = [];

function preload(){
  try{ ambience = loadSound(ambiencePath); }catch(e){}
  try{ pressSFX = loadSound(pressPath); }catch(e){}
  try{ finishSFX= loadSound(finishPath);}catch(e){}
  try{ firImg = loadImage(firPath); }catch(e){}
}

function setup(){
  createCanvas(windowWidth, windowHeight);
  w=width; h=height;

  for(let i=0;i<6;i++){
    clouds.push(new Cloud(random(w), random(h*0.05, h*0.45),
      random(120,260), random(50,120), random(0.3,1.2)));
  }

  buildForest();
  rebuildBackgroundFlakes();

  // UI
  const btnN=document.getElementById('btnNormal');
  const btnR=document.getElementById('btnRapid');
  btnN.onclick=()=>{ rapidMode=false; startGame(); };
  btnR.onclick=()=>{ rapidMode=true;  startGame(); };

  const ico=document.getElementById('settings-icon');
  const menu=document.getElementById('menu');
  const muteM=document.getElementById('muteMusic');
  const volM =document.getElementById('musicVol');
  const valM =document.getElementById('musicVolVal');
  const muteS=document.getElementById('muteSFX');
  const volS =document.getElementById('sfxVol');
  const valS =document.getElementById('sfxVolVal');
  const req  =document.getElementById('requiredPresses');
  const reqV =document.getElementById('reqVal');
  const delay=document.getElementById('tapDelay');
  const delayV=document.getElementById('delayVal');

  ico.onclick=()=>{ if(gameStarted) menu.classList.toggle('show'); };
  document.addEventListener('click',(e)=>{ if(!menu.contains(e.target) && !ico.contains(e.target)) menu.classList.remove('show'); });

  muteM.onchange=e=>{
    isMusicMuted = e.target.checked;
    ambience?.setVolume(isMusicMuted?0:volMusic);
    finishSFX?.setVolume(isMusicMuted?0:volMusic);
  };
  volM.oninput=e=>{
    volMusic=e.target.value/100; valM.textContent=e.target.value;
    if(!isMusicMuted) ambience?.setVolume(volMusic);
    if(!isMusicMuted) finishSFX?.setVolume(volMusic);
  };
  muteS.onchange=e=>{ isSFXMuted = e.target.checked; };
  volS.oninput=e=>{ volSFX=e.target.value/100; valS.textContent=e.target.value; };
  req.oninput=e=>{
    requiredPresses = parseInt(e.target.value,10);
    reqV.textContent = requiredPresses;
  };
  delay.oninput=e=>{
    tapDelay = parseInt(e.target.value,10);
    delayV.textContent = tapDelay;
  };
}

function startGame(){
  document.getElementById('modeOverlay')?.remove();
  gameStarted=true; finished=false; celebrating=false; fireworks.length=0; sparkles.length=0;
  document.getElementById('settings-icon').style.visibility='visible';

  (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen)?.call(document.documentElement);

  presses=0;
  progress=INITIAL_SNOW;
  targetProgress=INITIAL_SNOW;
  stormFlakes.length=0; waveActive=false; spawning=false; airborneCount=0;

  ambience?.setLoop(true);
  ambience?.setVolume(isMusicMuted?0:volMusic);
  try{ ambience?.play(); }catch(e){}

  rebuildBackgroundFlakes();
}

function draw(){
  if(!gameStarted){ background(0); return; }

  const now = millis();

  // Wind (flakes only)
  windT += 0.0025;
  baseWind = map(noise(windT), 0, 1, -1.1, 1.1);
  const gustChance = noise(windT*0.4 + 100);
  const targetGust = gustChance > 0.75 ? map(noise(windT*1.3+200), 0,1, -2.4, 2.4) : 0;
  gust = lerp(gust, targetGust, 0.02);
  const wind = baseWind + gust;

  // Background sky (tints stronger during celebration)
  drawSnowySky(waveActive || celebrating);

  drawSun();

  // Clouds behind forest
  for(const c of clouds){ c.update(); c.draw(); }

  // Forest (static), then flakes, then ground
  drawForest();

  // Background tiny flakes
  for(const f of flakesBack){ f.update(); f.draw(); }

  // Spawn wave flakes (disabled during celebration)
  if(!celebrating && spawning && now < spawnUntil){
    const inc = currentWaveMass;
    const pxMP = (w*h)/1e6;
    let totalFlakes = Math.max(160, Math.floor(pxMP * FLAKES_PER_MEGAPIXEL * (0.5 + inc*1.4)));
    totalFlakes = Math.min(totalFlakes, STORM_ACTIVE_CAP - stormFlakes.length);
    const perFrame = Math.ceil(totalFlakes * (deltaTime / SPAWN_WINDOW_MS));
    for(let i=0;i<perFrame;i++){
      if(stormFlakes.length >= STORM_ACTIVE_CAP) break;
      const fl = new StormFlake();
      fl.mass = inc / Math.max(1, totalFlakes);
      fl.windRef = wind;
      stormFlakes.push(fl);
      airborneCount++;
    }
  } else {
    spawning = false;
  }

  // Update/draw storm flakes
  for(let i=stormFlakes.length-1;i>=0;i--){
    const s = stormFlakes[i];
    s.update(wind);
    s.draw();
    if(s.justLanded){
      s.justLanded = false;
      airborneCount = Math.max(0, airborneCount - 1);
      targetProgress = Math.min(1, targetProgress + s.mass);
    }
    if(s.dead) stormFlakes.splice(i,1);
  }

  if(waveActive && !spawning && airborneCount===0){
    waveActive = false;
  }

  // Ground (opaque)
  progress = lerp(progress, targetProgress, 0.12);
  drawSnowGround(progress);

  // Storm veil
  if(waveActive && !celebrating){
    noStroke();
    fill(255,255,255, 26 + 30*Math.abs(wind));
    rect(0,0,w,h);
  }

  // ★ CELEBRATION visuals (overlay)
  if(celebrating){
    drawAurora();
    updateFireworks();
    updateSparkles();
    // mild screen glow pulse
    noStroke();
    const a = 18 + 12*Math.sin((now - celebrateStart)/180);
    fill(255,255,255, a);
    rect(0,0,w,h);
    // auto-end celebration
    if(now - celebrateStart > CELEBRATE_MS){ celebrating=false; }
  }

  // Finish condition: either 6 presses OR snow maxed
  if(!finished && (presses >= requiredPresses || targetProgress>=1)){
    finished=true;
    startCelebration();
  }

  sunRot += 0.003;
  glarePulse = 0.98 + 0.04 * Math.sin(frameCount*0.03);
}

/* === Input === */
function keyPressed(){
  if(key===' ' && gameStarted) trigger();
  if(keyCode===ENTER && gameStarted){
    presses=0; progress=INITIAL_SNOW; targetProgress=INITIAL_SNOW;
    finished=false; celebrating=false; fireworks.length=0; sparkles.length=0;
    stormFlakes.length=0; waveActive=false; spawning=false; airborneCount=0;
    rebuildBackgroundFlakes();
  }
  if(key.toLowerCase()==='f'){
    if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  }
}
function mousePressed(){ if(gameStarted) trigger(); return false; }
function touchStarted(){ if(gameStarted) trigger(); return false; }

/* === Controls === */
let currentWaveMass = 0;

function trigger(){
  if(finished || celebrating) return;
  if(waveActive) return;
  if(millis()-lastTap < tapDelay) return;
  lastTap = millis();

  const baseInc = rapidMode ? (1 - targetProgress) : (1/requiredPresses);
  const inc = Math.min(1 - targetProgress, baseInc * ACCUM_SCALE);
  currentWaveMass = inc;

  waveActive = true;
  spawning   = true;
  spawnUntil = millis() + SPAWN_WINDOW_MS;
  airborneCount = 0;

  if(!isSFXMuted && pressSFX){ pressSFX.setVolume(volSFX); try{ pressSFX.play(); }catch(e){} }

  rebuildBackgroundFlakes();
  presses++;
}

/* === Celebration === */
function startCelebration(){
  celebrating = true;
  celebrateStart = millis();
  // fade music a bit
  if(ambience && !isMusicMuted){ ambience.setVolume(volMusic*0.25); }
  // play fanfare
  if(finishSFX && !isMusicMuted){ finishSFX.setVolume(Math.max(0.2, volMusic)); try{ finishSFX.play(); }catch(e){} }

  // seed fireworks and sparkles
  fireworks.length=0; sparkles.length=0;
  for(let i=0;i<4;i++){ fireworks.push(new Firework(random(w*0.15,w*0.85), h, random(w*0.25,w*0.75), random(h*0.18,h*0.42))); }
  for(let i=0;i<140;i++){ sparkles.push(new Sparkle()); }
}
function updateFireworks(){
  for(let i=fireworks.length-1;i>=0;i--){
    const fw = fireworks[i];
    fw.update(); fw.draw();
    if(fw.dead) fireworks.splice(i,1);
  }
  // keep a few bursts coming
  if(random()<0.04){ fireworks.push(new Firework(random(w*0.2,w*0.8), h, random(w*0.25,w*0.75), random(h*0.18,h*0.45))); }
}
function updateSparkles(){
  for(const s of sparkles){ s.update(); s.draw(); }
}
function drawAurora(){
  // soft color bands sweeping across the sky
  const t = (millis()-celebrateStart)/1000;
  noStroke();
  for(let y=0;y<h*0.6;y++){
    const ny = y/h;
    const wave = 0.5 + 0.5*Math.sin(ny*10 + t*1.6);
    const r = 130 + 50*wave;
    const g = 210 + 35*Math.sin(ny*7 + t*1.2);
    const b = 255;
    fill(r, g, b, 28 + 18*Math.sin(ny*8 + t*2.1));
    rect(0,y,w,1);
  }
}

/* === HUD removed === */

/* === Background snow & helpers === */
function rebuildBackgroundFlakes(){
  const factor = 1 + 0.7*Math.min(1, targetProgress + (waveActive? currentWaveMass*0.7:0));
  const backTarget  = Math.floor(w*h*BACK_DENSITY_BASE * factor);
  while(flakesBack.length < backTarget) flakesBack.push(new FlakeBack(true));
  while(flakesBack.length > backTarget) flakesBack.pop();
}
function drawSnowySky(active){
  // darker if storming/celebrating
  const tGrey = active ? 0.45 : 0.28;
  const topBase = [150,175,195];
  const botBase = [205,215,225];
  const topStorm= [160,168,178];
  const botStorm= [196,205,214];
  for(let y=0;y<h;y++){
    const gy = y/h;
    const top = [
      lerp(topBase[0], topStorm[0], tGrey),
      lerp(topBase[1], topStorm[1], tGrey),
      lerp(topBase[2], topStorm[2], tGrey)
    ];
    const bot = [
      lerp(botBase[0], botStorm[0], tGrey),
      lerp(botBase[1], botStorm[1], tGrey),
      lerp(botBase[2], botStorm[2], tGrey)
    ];
    const r = lerp(top[0], bot[0], gy);
    const g = lerp(top[1], bot[1], gy);
    const b = lerp(top[2], bot[2], gy);
    stroke(r,g,b); line(0,y,w,y);
  }
}
function drawSun(){
  push();
  translate(w*0.82, h*0.18);
  rotate(sunRot);
  const R = Math.min(w,h)*0.08;
  noStroke();
  for(let i=80;i>=1;i--){
    const t = i/80;
    fill(255, 220, 120, 7 * t);
    const r = R * (1 + 2.2*(1-t)*glarePulse);
    ellipse(0,0,r*2,r*2);
  }
  fill(255,190,60, 230);
  ellipse(0,0,R*2,R*2);
  pop();
}

/* === Ground === */
function drawSnowGround(p){
  const samples = 80;
  noStroke();
  fill(240, 248, 255); // opaque
  beginShape();
  vertex(0, h);
  for(let i=0;i<=samples;i++){
    const x = map(i,0,samples,0,w);
    const y = groundYAt(x, p);
    vertex(x, y);
  }
  vertex(w, h);
  endShape(CLOSE);

  // soft highlights
  const band = 10 + 20*p;
  for(let i=0;i<band;i++){
    const a = map(i,0,band-1, 70, 0);
    stroke(255,255,255,a);
    noFill();
    beginShape();
    for(let j=0;j<=samples;j++){
      const x = map(j,0,samples,0,w);
      const y = groundYAt(x, p) - i*0.7;
      vertex(x,y);
    }
    endShape();
  }
}
function groundYAt(x, p){
  const maxDepth = h * MAX_SNOW_DEPTH_FRAC;
  const baseY = h - p * maxDepth;
  const nx = x*0.003;
  const und = map(noise(nx, groundNoiseSeed), 0, 1, -18*(0.4+p), 18*(0.4+p));
  const side = Math.abs((x/w)-0.5);
  const drift = lerp(0, 14*(0.5+p), Math.pow(side,2));
  return baseY + und + drift;
}

/* === Entities === */
class Cloud{
  constructor(x,y,w,h,s){ this.x=x; this.y=y; this.w=w; this.h=h; this.s=s; this.o=random(150,210); }
  update(){
    this.x -= this.s;
    if(this.x + this.w < -40){
      this.x = width + random(20,120);
      this.y = random(height*0.05, height*0.45);
      this.w = random(120,260);
      this.h = random(50,120);
      this.s = random(0.3,1.2);
      this.o = random(150,210);
    }
  }
  draw(){
    noStroke();
    fill(255,255,255,this.o);
    ellipse(this.x, this.y, this.w, this.h);
    ellipse(this.x-this.w*0.45, this.y+this.h*0.05, this.w*0.7, this.h*0.7);
    ellipse(this.x+this.w*0.45, this.y+this.h*0.05, this.w*0.7, this.h*0.7);
  }
}
class FlakeBack{
  constructor(fromTop=false){ this.reset(fromTop); }
  reset(fromTop=false){
    this.x = random(w);
    this.y = fromTop ? random(-h*0.6, -10) : random(-h, h);
    this.sz = random(BACK_SZ_MIN, BACK_SZ_MAX);
    this.vy = random(BACK_VY_MIN, BACK_VY_MAX);
    this.alpha = BACK_ALPHA;
    this.phase = random(TWO_PI);
  }
  update(){
    this.x += 0.35*Math.sin(frameCount*0.02 + this.phase) * 0.9;
    this.y += this.vy;
    if(this.x < -10) this.x = w+10;
    if(this.x > w+10) this.x = -10;
    const gy = groundYAt(this.x, targetProgress);
    if(this.y >= gy - this.sz*0.3) this.reset(true);
    if(this.y > h + 20) this.reset(true);
  }
  draw(){
    noStroke();
    fill(255,255,255, this.alpha);
    circle(this.x, this.y, this.sz);
  }
}
class StormFlake{
  constructor(){
    this.x = random(-20, w+20);
    this.y = random(-h*0.6, -10);

    const superChance = 0.28; // giants
    const isGiant = random() < superChance;
    this.sz = isGiant ? random(32, 56) : random(14, 32);

    const speedScale = map(this.sz, 14, 56, 1.0, 1.65);
    const vyMin = max(1.0, (h/260) * speedScale);
    const vyMax = max(2.8, (h/150) * speedScale);

    this.vy = random(vyMin, vyMax);
    this.vx = random(-1.05, 1.05);
    this.alpha = isGiant ? 255 : 245;
    this.phase = random(TWO_PI);
    this.dead = false;
    this.g = random(0.010, 0.022) * speedScale;
    this.onGround = false;
    this.justLanded = false;
    this.fadeSpeed = 15;
    this.mass = 0.0;
    this.windRef = 0;
  }
  update(globalWind){
    if(!this.onGround){
      this.vy += this.g;
      const sway = 1.0*Math.sin(frameCount*0.03 + this.phase);
      this.vx += (globalWind - this.windRef) * 0.02;
      this.windRef = lerp(this.windRef, globalWind, 0.05);

      this.x += this.vx + sway;
      this.y += this.vy;

      if(this.x < -60){ this.x = w+60; }
      if(this.x > w+60){ this.x = -60; }

      const gy = groundYAt(this.x, targetProgress);
      if(this.y >= gy - this.sz*0.25){
        this.y = gy - this.sz*0.25;
        this.onGround = true;
        this.justLanded = true;
        this.vx = 0; this.vy = 0; this.g = 0;
      }
    }else{
      this.alpha -= this.fadeSpeed;
      if(this.alpha<=0) this.dead = true;
    }
  }
  draw(){
    noStroke();
    fill(255,255,255, this.alpha);
    circle(this.x, this.y, this.sz);
  }
}

/* === Firework & Sparkle (celebration) === */
class Firework{
  constructor(x0, y0, x1, y1){
    this.x = x0; this.y = y0; this.tx=x1; this.ty=y1;
    this.vx = (x1-x0)/30; this.vy = (y1-y0)/30 - random(1.0,2.2);
    this.phase = 0;
    this.exploded = false;
    this.particles = [];
    this.dead = false;
    this.col = [random(120,255), random(120,255), random(120,255)];
  }
  update(){
    if(!this.exploded){
      this.x += this.vx; this.y += this.vy;
      this.vy += 0.1;
      this.phase++;
      if(this.phase>28 || this.y<=this.ty){
        this.exploded = true;
        const n = 80;
        for(let i=0;i<n;i++){
          const a = TWO_PI*i/n;
          const sp = random(2.2, 5.0);
          this.particles.push({
            x:this.x, y:this.y,
            vx:Math.cos(a)*sp + random(-0.4,0.4),
            vy:Math.sin(a)*sp + random(-0.4,0.4),
            life: random(40,80),
            a: 255
          });
        }
      }
    }else{
      for(const p of this.particles){
        p.x += p.vx; p.y += p.vy;
        p.vy += 0.06;
        p.a -= 3.5;
        p.life--;
      }
      this.particles = this.particles.filter(p=>p.life>0 && p.a>0);
      if(this.particles.length===0) this.dead = true;
    }
  }
  draw(){
    if(!this.exploded){
      stroke(...this.col, 220);
      strokeWeight(2);
      point(this.x, this.y);
    }else{
      noStroke();
      for(const p of this.particles){
        fill(...this.col, p.a);
        circle(p.x, p.y, 3);
      }
    }
  }
}
class Sparkle{
  constructor(){
    this.reset(true);
  }
  reset(fromTop=false){
    this.x = random(w);
    this.y = fromTop? random(-h*0.2, 0) : random(0, h*0.6);
    this.vy = random(0.3, 0.9);
    this.vx = random(-0.3, 0.3);
    this.sz = random(1.5, 3.5);
    this.a  = random(140, 220);
    this.p  = random(TWO_PI);
  }
  update(){
    this.x += this.vx + 0.6*Math.sin(frameCount*0.03 + this.p);
    this.y += this.vy;
    this.a -= 1.2;
    if(this.a<=0 || this.y>h*0.65) this.reset(true);
  }
  draw(){
    noStroke();
    fill(255,255,255,this.a);
    circle(this.x, this.y, this.sz);
  }
}

/* === Forest (left cluster) === */
function buildForest(){
  forest.length = 0;
  if(!firImg) return;

  const count = Math.floor(random(6, 8)); // 6 or 7
  for(let i=0;i<count;i++){
    const slotX = map(i, 0, count-1, w*0.04, w*0.48);
    const jitter = random(-w*0.05, w*0.03);
    const centerX = slotX + jitter;

    const targetHFrac = random(0.36, 0.62);
    const H = min(h*targetHFrac, h*0.74);
    const scale = H / firImg.height;
    const W = firImg.width * scale;

    const x = centerX - W/2;
    const y = h - H;
    const depth = 1 - targetHFrac;

    forest.push({x, y, w: W, h: H, depth});
  }
  forest.sort((a,b)=>a.depth - b.depth);
}
function drawForest(){
  if(!firImg) return;
  for(const t of forest){ image(firImg, t.x, t.y, t.w, t.h); }
}

/* === Resize & utils === */
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  w=width; h=height;
  buildForest();
  rebuildBackgroundFlakes();
}
function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2; }
</script>

<script>

function trigger(){
  if(finished || celebrating) return;
  if(waveActive) return;
  if(millis()-lastTap < tapDelay) return;
  lastTap = millis();

  const baseInc = rapidMode ? (1 - targetProgress) : (1/requiredPresses);
  const inc = Math.min(1 - targetProgress, baseInc * ACCUM_SCALE);
  currentWaveMass = inc;

  waveActive = true;
  spawning   = true;
  spawnUntil = millis() + SPAWN_WINDOW_MS;
  airborneCount = 0;

  if(!isSFXMuted && pressSFX){ pressSFX.setVolume(volSFX); try{ pressSFX.play(); }catch(e){} }

  rebuildBackgroundFlakes();
  presses++;
}

/* reuse helpers */
function rebuildBackgroundFlakes(){
  const factor = 1 + 0.7*Math.min(1, targetProgress + (waveActive? currentWaveMass*0.7:0));
  const backTarget  = Math.floor(w*h*BACK_DENSITY_BASE * factor);
  while(flakesBack.length < backTarget) flakesBack.push(new FlakeBack(true));
  while(flakesBack.length > backTarget) flakesBack.pop();
}

function keyPressed(){
  if(key===' ' && gameStarted) trigger();
  if(keyCode===ENTER && gameStarted){
    presses=0; progress=INITIAL_SNOW; targetProgress=INITIAL_SNOW;
    finished=false; celebrating=false; fireworks.length=0; sparkles.length=0;
    stormFlakes.length=0; waveActive=false; spawning=false; airborneCount=0;
    rebuildBackgroundFlakes();
    if(ambience && !isMusicMuted){ ambience.setVolume(volMusic); }
  }
  if(key.toLowerCase()==='f'){
    if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  }
}
function mousePressed(){ if(gameStarted) trigger(); return false; }
function touchStarted(){ if(gameStarted) trigger(); return false; }
</script>
</body>
</html>
