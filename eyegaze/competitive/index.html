<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Eyegaze Duel</title>
  <script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: #000;
      color: #fff;
      height: 100vh;
      overflow: hidden;
    }

    body.started {
      cursor: none;
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      z-index: 5;
    }

    .card {
      background: rgba(16, 16, 16, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 12px 16px;
      min-width: 200px;
      backdrop-filter: blur(6px);
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 18px;
      margin-top: 8px;
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--dot-color, #4cc3ff);
    }

    .status {
      font-size: 14px;
      opacity: 0.8;
      margin-top: 6px;
    }

    .arena {
      position: absolute;
      inset: 0;
    }

    body.started .arena {
      cursor: none;
    }

    #target {
      position: absolute;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff, var(--target-color, #ff5a5f));
      box-shadow: 0 0 30px rgba(255, 90, 95, 0.6);
      display: grid;
      place-items: center;
    }

    #target .dwell-ring {
      position: absolute;
      inset: -16px;
      border-radius: 50%;
      background: radial-gradient(
        circle,
        var(--ring-color, #ff3b3b) 0%,
        var(--ring-color, #ff3b3b) var(--progress, 0%),
        rgba(255, 255, 255, 0) calc(var(--progress, 0%) + 1px)
      );
      transition: background 0.05s linear;
      filter: drop-shadow(0 0 18px color-mix(in srgb, var(--ring-color, #ff3b3b) 80%, transparent));
    }

    #target .dwell-ring.complete {
      animation: dwellPulse 0.45s ease-out;
    }

    .burst-pop {
      position: absolute;
      width: 180px;
      height: 180px;
      border-radius: 50%;
      opacity: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      transform: translate(-50%, -50%);
    }

    .burst-pop::before,
    .burst-pop::after {
      content: "";
      position: absolute;
      inset: 10px;
      border-radius: 50%;
      opacity: 0;
    }

    .burst-pop.active {
      animation: burstPulse 0.7s cubic-bezier(0.2, 0.7, 0.2, 1);
    }

    .burst-pop.active::before {
      animation: burstFlash 0.5s ease-out;
    }

    .burst-pop.active::after {
      animation: burstRays 0.7s ease-out;
    }

    .pointer {
      position: absolute;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.9);
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 4;
      background: var(--pointer-color, #4cc3ff);
      box-shadow: 0 0 18px color-mix(in srgb, var(--pointer-color, #4cc3ff) 80%, transparent);
    }

    .helper {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(16, 16, 16, 0.8);
      padding: 10px 18px;
      border-radius: 20px;
      font-size: 14px;
      opacity: 0.9;
    }

    button {
      background: #1c1c1c;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 999px;
      padding: 10px 16px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      border-color: rgba(255, 255, 255, 0.6);
    }

    .start-screen {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: #000;
      z-index: 10;
      cursor: default;
    }

    .start-card {
      text-align: center;
      padding: 32px 36px;
      border-radius: 24px;
      background: rgba(16, 16, 16, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.12);
      max-width: 360px;
    }

    .start-card h1 {
      margin: 0 0 12px;
      font-size: 28px;
    }

    .start-card p {
      margin: 0 0 20px;
      opacity: 0.8;
      font-size: 15px;
    }

    @keyframes dwellPulse {
      0% {
        transform: scale(1);
        opacity: 0.9;
      }
      60% {
        transform: scale(1.15);
        opacity: 1;
      }
      100% {
        transform: scale(1.35);
        opacity: 0;
      }
    }

    @keyframes burstPulse {
      0% {
        transform: scale(0.45);
        opacity: 0;
        box-shadow:
          0 0 0 0 rgba(255, 80, 80, 0.9),
          0 0 30px 12px rgba(255, 80, 80, 0.7);
      }
      35% {
        transform: scale(1);
        opacity: 1;
        box-shadow:
          0 0 0 14px rgba(255, 80, 80, 0.45),
          0 0 50px 24px rgba(255, 80, 80, 0.7);
      }
      100% {
        transform: scale(1.6);
        opacity: 0;
        box-shadow:
          0 0 0 36px rgba(255, 80, 80, 0),
          0 0 70px 38px rgba(255, 80, 80, 0);
      }
    }

    @keyframes burstFlash {
      0% {
        transform: scale(0.4);
        opacity: 0;
        box-shadow:
          inset 0 0 25px rgba(255, 255, 255, 0.9),
          0 0 35px rgba(255, 80, 80, 0.7);
      }
      40% {
        transform: scale(1);
        opacity: 1;
        box-shadow:
          inset 0 0 40px rgba(255, 255, 255, 0.9),
          0 0 50px rgba(255, 120, 120, 0.9);
      }
      100% {
        transform: scale(1.2);
        opacity: 0;
        box-shadow:
          inset 0 0 10px rgba(255, 255, 255, 0),
          0 0 60px rgba(255, 120, 120, 0);
      }
    }

    @keyframes burstRays {
      0% {
        transform: scale(0.6) rotate(0deg);
        opacity: 0;
        background: conic-gradient(
          from 0deg,
          rgba(255, 120, 120, 0.9) 0deg,
          rgba(255, 120, 120, 0.1) 20deg,
          rgba(255, 120, 120, 0.9) 40deg,
          rgba(255, 120, 120, 0.1) 60deg,
          rgba(255, 120, 120, 0.9) 80deg,
          rgba(255, 120, 120, 0.1) 100deg,
          rgba(255, 120, 120, 0.9) 120deg,
          rgba(255, 120, 120, 0.1) 140deg,
          rgba(255, 120, 120, 0.9) 160deg,
          rgba(255, 120, 120, 0.1) 180deg,
          rgba(255, 120, 120, 0.9) 200deg,
          rgba(255, 120, 120, 0.1) 220deg,
          rgba(255, 120, 120, 0.9) 240deg,
          rgba(255, 120, 120, 0.1) 260deg,
          rgba(255, 120, 120, 0.9) 280deg,
          rgba(255, 120, 120, 0.1) 300deg,
          rgba(255, 120, 120, 0.9) 320deg,
          rgba(255, 120, 120, 0.1) 340deg,
          rgba(255, 120, 120, 0.9) 360deg
        );
        filter: blur(0px);
      }
      40% {
        transform: scale(1) rotate(18deg);
        opacity: 0.9;
        filter: blur(0.5px);
      }
      100% {
        transform: scale(1.35) rotate(35deg);
        opacity: 0;
        filter: blur(1px);
      }
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="card">
      <div class="score-row">
        <span class="legend"><span class="dot" style="--dot-color: #ff3b3b;"></span>You</span>
        <strong id="scoreYou">0</strong>
      </div>
      <div class="score-row">
        <span class="legend"><span class="dot" style="--dot-color: #3ddc97;"></span>Opponent</span>
        <strong id="scoreOpponent">0</strong>
      </div>
    </div>
    <div class="card">
      <div class="status">Dwell time: <span id="dwellDisplay">1.2s</span></div>
      <button id="resetButton" type="button">Reset scores</button>
    </div>
  </div>

  <div class="arena" id="arena">
    <div id="target" aria-label="Target">
      <div class="dwell-ring" id="dwellRing"></div>
    </div>
    <div class="burst-pop" id="burstEffect"></div>
    <div class="pointer" id="pointerYou" style="--pointer-color: #ff3b3b;"></div>
    <div class="pointer" id="pointerOpponent" style="--pointer-color: #3ddc97;"></div>
  </div>

  <div class="helper">Move the gaze cursor to the target and hold to score.</div>

  <div class="start-screen" id="startScreen">
    <div class="start-card">
      <h1>Eyegaze Duel</h1>
      <p>Press start to enter fullscreen and begin the duel.</p>
      <button id="startButton" type="button">Start</button>
    </div>
  </div>

  <script>
    const ABLY_KEY = 'cdtKhA.qjdiYA:nbUbeaXqiQWHgQF1F9Nn0glvP62CRod3LcbAQDWJaIE';
    const CHANNEL_NAME = 'eyegaze-duel';
    const DWELL_TIME = 1200;
    const TARGET_RADIUS = 70;

    const arena = document.getElementById('arena');
    const target = document.getElementById('target');
    const dwellRing = document.getElementById('dwellRing');
    const pointerYou = document.getElementById('pointerYou');
    const pointerOpponent = document.getElementById('pointerOpponent');
    const burstEffect = document.getElementById('burstEffect');
    const scoreYouEl = document.getElementById('scoreYou');
    const scoreOpponentEl = document.getElementById('scoreOpponent');
    const dwellDisplay = document.getElementById('dwellDisplay');
    const resetButton = document.getElementById('resetButton');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');

    dwellDisplay.textContent = `${(DWELL_TIME / 1000).toFixed(1)}s`;

    const clientId = localStorage.getItem('eyegaze-duel-id') || `player-${Math.random().toString(16).slice(2, 8)}`;
    localStorage.setItem('eyegaze-duel-id', clientId);

    const ably = new Ably.Realtime({ key: ABLY_KEY, clientId });
    const channel = ably.channels.get(CHANNEL_NAME);

    const state = {
      started: false,
      pointer: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
      opponent: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
      target: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
      targetColor: '#ff5a5f',
      dwellStart: null,
      scoreYou: 0,
      scoreOpponent: 0,
    };

    function getArenaBounds() {
      const rect = arena.getBoundingClientRect();
      return {
        width: rect.width || window.innerWidth,
        height: rect.height || window.innerHeight,
      };
    }

    function randomTarget() {
      const { width, height } = getArenaBounds();
      const padding = Math.max(TARGET_RADIUS + 30, Math.min(width, height) * 0.12);
      const safeWidth = Math.max(width - padding * 2, TARGET_RADIUS * 2);
      const safeHeight = Math.max(height - padding * 2, TARGET_RADIUS * 2);
      const x = Math.random() * safeWidth + padding;
      const y = Math.random() * safeHeight + padding;
      const colors = ['#ff5a5f', '#3ddc97', '#8f7bff', '#ffb347', '#4cc3ff'];
      const color = colors[Math.floor(Math.random() * colors.length)];
      return { x, y, color };
    }

    function positionTarget(x, y, color) {
      state.target.x = x;
      state.target.y = y;
      state.targetColor = color;
      target.style.transform = `translate(${x - TARGET_RADIUS}px, ${y - TARGET_RADIUS}px)`;
      target.style.setProperty('--target-color', color);
    }

    function updatePointer(el, point) {
      el.style.left = `${point.x}px`;
      el.style.top = `${point.y}px`;
    }

    function updateScores() {
      scoreYouEl.textContent = state.scoreYou;
      scoreOpponentEl.textContent = state.scoreOpponent;
    }

    function updateDwell(progress) {
      const percentage = Math.min(100, Math.max(0, progress * 100));
      dwellRing.style.setProperty('--progress', `${percentage}%`);
    }

    function resetDwell() {
      state.dwellStart = null;
      dwellRing.classList.remove('complete');
      updateDwell(0);
    }

    function handleDwell() {
      if (!state.started) return;
      const dx = state.pointer.x - state.target.x;
      const dy = state.pointer.y - state.target.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const inside = distance < TARGET_RADIUS;

      if (!inside) {
        resetDwell();
        return;
      }

      if (!state.dwellStart) {
        state.dwellStart = performance.now();
      }

      const elapsed = performance.now() - state.dwellStart;
      updateDwell(elapsed / DWELL_TIME);

      if (elapsed >= DWELL_TIME) {
        const burstX = state.target.x;
        const burstY = state.target.y;
        const nextTarget = randomTarget();
        state.scoreYou += 1;
        updateScores();
        dwellRing.classList.remove('complete');
        void dwellRing.offsetWidth;
        dwellRing.classList.add('complete');
        resetDwell();
        burstEffect.classList.remove('active');
        void burstEffect.offsetWidth;
        burstEffect.style.left = `${burstX}px`;
        burstEffect.style.top = `${burstY}px`;
        burstEffect.classList.add('active');
        channel.publish('score', {
          id: clientId,
          score: state.scoreYou,
          target: nextTarget,
        });
      }
    }

    function onMove(event) {
      if (!state.started) return;
      const rect = arena.getBoundingClientRect();
      state.pointer.x = Math.min(rect.width, Math.max(0, event.clientX - rect.left));
      state.pointer.y = Math.min(rect.height, Math.max(0, event.clientY - rect.top));
    }

    let publishQueued = false;
    function publishPointer() {
      if (publishQueued) return;
      publishQueued = true;
      requestAnimationFrame(() => {
        publishQueued = false;
        channel.publish('pointer', {
          id: clientId,
          x: state.pointer.x,
          y: state.pointer.y,
        });
      });
    }

    arena.addEventListener('mousemove', (event) => {
      onMove(event);
      publishPointer();
    });

    arena.addEventListener('touchmove', (event) => {
      const touch = event.touches[0];
      if (!touch) return;
      onMove({ clientX: touch.clientX, clientY: touch.clientY });
      publishPointer();
    }, { passive: true });

    resetButton.addEventListener('click', () => {
      state.scoreYou = 0;
      state.scoreOpponent = 0;
      updateScores();
      channel.publish('reset', { id: clientId });
    });

    startButton.addEventListener('click', async () => {
      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen();
        }
      } catch (error) {
        // Fullscreen can fail if not allowed by the browser; continue anyway.
      }
      state.started = true;
      document.body.classList.add('started');
      startScreen.style.display = 'none';
    });

    ably.connection.on('connected', () => {
      const initialTarget = randomTarget();
      positionTarget(initialTarget.x, initialTarget.y, initialTarget.color);
      channel.publish('target', initialTarget);
    });

    ably.connection.on('failed', () => {
      // Connection status is intentionally not shown in the UI.
    });

    channel.subscribe('pointer', (message) => {
      if (message.data.id === clientId) return;
      state.opponent.x = message.data.x;
      state.opponent.y = message.data.y;
    });

    channel.subscribe('score', (message) => {
      if (message.data.id !== clientId) {
        state.scoreOpponent = message.data.score || 0;
        updateScores();
      }
      if (message.data.target) {
        positionTarget(message.data.target.x, message.data.target.y, message.data.target.color);
      }
    });

    channel.subscribe('target', (message) => {
      if (!message?.data) return;
      positionTarget(message.data.x, message.data.y, message.data.color);
    });

    channel.subscribe('reset', () => {
      state.scoreYou = 0;
      state.scoreOpponent = 0;
      updateScores();
    });

    function tick() {
      updatePointer(pointerYou, state.pointer);
      updatePointer(pointerOpponent, state.opponent);
      handleDwell();
      requestAnimationFrame(tick);
    }

    window.addEventListener('resize', () => {
      const nextTarget = randomTarget();
      positionTarget(nextTarget.x, nextTarget.y, nextTarget.color);
      channel.publish('target', nextTarget);
    });

    positionTarget(state.target.x, state.target.y, state.targetColor);
    updateScores();
    tick();
  </script>
</body>
</html>
