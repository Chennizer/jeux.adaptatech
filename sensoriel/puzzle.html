<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../images/binou.png">
  <link rel="stylesheet" href="../css/ipadteachh.css">
  <link rel="stylesheet" href="../css/control-panel.css">
  <link rel="stylesheet" href="css/sensorial-base.css">
  <title>Puzzle (2×2, 3×3 or 4×4)</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    .puzzle-container {
      display: none;
      width: 100%;
      height: 100%;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: clamp(18px, 4vw, 36px);
      padding: clamp(12px, 3vh, 24px);
      flex-wrap: wrap;
      overflow: hidden;
      position: relative;
    }
    #piecesArea {
      position: relative;
      width: clamp(220px, 32vw, 320px);
      height: clamp(220px, 32vw, 320px);
      background: linear-gradient(135deg, #f3f6fb 0%, #e0e6f2 100%);
      border: 3px solid rgba(15, 30, 60, 0.12);
      border-radius: 22px;
      padding: clamp(10px, 2vw, 18px);
      overflow: hidden;
    }
    #puzzleArea {
      background: #fff;
      border: 4px solid rgba(15, 30, 60, 0.16);
      border-radius: 24px;
      box-sizing: border-box;
      position: relative;
      box-shadow: 0 18px 34px rgba(12, 27, 54, 0.18);
    }
    #toggleReferenceContainer { display: none; }
    .slot {
      position: absolute;
      background: rgba(214, 222, 240, 0.35);
      border: none;
      overflow: hidden;
      box-sizing: border-box;
      pointer-events: auto;
      transition: box-shadow 0.2s ease, background-color 0.2s ease;
    }
    .draggable-piece {
      cursor: grab;
      border: none;
      object-fit: cover;
      position: absolute;
      touch-action: none;
      user-select: none;
      transition: opacity 0.2s;
      box-sizing: border-box;
      will-change: transform, left, top;
    }
    .draggable-piece.active { opacity: 0.85; cursor: grabbing; z-index: 1000; }
    #hiddenCanvas { display: none; }
    .highlight {
      box-shadow: 0 0 0 4px rgba(0, 170, 255, 0.35) inset;
      background-color: rgba(0, 170, 255, 0.12);
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: #fefefe;
      padding: clamp(20px, 4vw, 32px);
      border-radius: 18px;
      position: relative;
      width: min(90vw, 640px);
      max-height: 90vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .modal-image {
      display: block;
      width: 100%;
      max-width: 100%;
      height: auto;
      max-height: min(100%, calc(90vh - clamp(40px, 8vw, 64px)));
      object-fit: contain;
    }
    .modal.flex { display: flex; }
    @media (max-width: 820px) {
      #piecesArea { width: clamp(200px, 45vw, 280px); height: clamp(200px, 45vw, 280px); }
    }
    @media (max-width: 620px) {
      #piecesArea { width: clamp(180px, 52vw, 240px); height: clamp(180px, 52vw, 240px); }
      .draggable-piece { width: 82px; height: 82px; }
    }
  </style>
</head>
<body class="sensorial-game">
  <div id="activityNumberOverlay">
    <div class="number-text"></div>
  </div>
  <div class="sensorial-shell">
    <header class="sensorial-header">
      <div class="sensorial-header-main">
        <h1 class="sensorial-title">Casse-tête</h1>
        <div class="sensorial-activity-marker" role="group" aria-label="Activité en cours">
          <img src="../images/plasticbasket.png" alt="" />
          <span class="sensorial-activity-number">–</span>
        </div>
      </div>
      <p class="sensorial-subtitle">Glisse les pièces pour reconstituer l’image.</p>
    </header>
    <main class="sensorial-content">
      <div class="puzzle-container" id="puzzleContainer">
        <div id="piecesArea"></div>
        <div id="puzzleArea"></div>
      </div>
    </main>
    <footer class="sensorial-footer" id="toggleReferenceContainer">
      <button id="toggleReference" class="sensorial-button">Image complète</button>
    </footer>
  </div>
  <div id="referenceModal" class="modal">
    <div class="modal-content">
      <img class="modal-image" src="../images/toupieetbinou.png" alt="Completed Puzzle Model">
    </div>
  </div>
  <canvas id="hiddenCanvas"></canvas>
  <audio id="final-reward-sound" src="" preload="auto"></audio>
  <script src="../js/themes.js"></script>
  <script src="js/games-config.js"></script>
  <script src="js/session-helpers.js"></script>
  <script src="js/reinforcer-overlay.js"></script>
  <script src="js/fullscreen.js"></script>
  <script>
    let ROWS = 2;
    let COLS = 2;
    const PIECE_SIZE = 130;
    const CONNECTOR_TYPES = { FLAT: 0, TAB: 1, SLOT: -1 };
    const CONNECTOR_LENGTH_RATIO = 0.32;
    const CONNECTOR_WIDTH_RATIO = 0.52;
    let puzzleSession = null;
    let puzzleOptions = {};
    let reinforcerController = null;
    let piecesAreaEl = null;
    let themeData = {};
    let finalRewardSound = null;
    document.addEventListener('DOMContentLoaded', () => {
      puzzleSession = sessionHelpers.ensureCurrentGame('puzzle');
      if (!puzzleSession) { return; }

      sessionHelpers.updateActivityMarker(puzzleSession);

      puzzleOptions = sessionHelpers.getCurrentGameOptions(puzzleSession);
      reinforcerController = sessionHelpers.setupSharedReinforcer(puzzleSession);
      themeData = (puzzleSession && puzzleSession.themeData) || {};

      finalRewardSound = document.getElementById('final-reward-sound');
      if (finalRewardSound) {
        finalRewardSound.src = themeData.finalRewardSound || "../sounds/victory.mp3";
      }

      const dimension = puzzleOptions.puzzleDimension || '2x2';
      if (dimension === '3x3') { ROWS = 3; COLS = 3; }
      else if (dimension === '4x4') { ROWS = 4; COLS = 4; }
      else { ROWS = 2; COLS = 2; }

      sessionHelpers.showActivityOverlay(() => {
        document.getElementById('puzzleContainer').style.display = 'flex';
        document.getElementById('toggleReferenceContainer').style.display = 'flex';
        startPuzzleLogic();
      }, puzzleSession);
    });
    function startPuzzleLogic() {
      const imagesArr = themeData.images || ["../images/toupieetbinou.png"];
      const randomIndex = Math.floor(Math.random() * imagesArr.length);
      const puzzleImageSrc = imagesArr[randomIndex];
      const referenceImageSrc = puzzleImageSrc;
      initializePuzzleGame(puzzleImageSrc, referenceImageSrc);
    }
    function initializePuzzleGame(puzzleImagePath, referenceImagePath) {
      const puzzleArea = document.getElementById('puzzleArea');
      piecesAreaEl = document.getElementById('piecesArea');
      const piecesArea = piecesAreaEl;
      const referenceImg = document.querySelector('.modal-image');
      const hiddenCanvas = document.getElementById('hiddenCanvas');
      const ctx = hiddenCanvas.getContext('2d');
      if (!puzzleArea || !piecesArea) {
        return;
      }
      referenceImg.src = referenceImagePath;
      
      const puzzleWidth = COLS * PIECE_SIZE;
      const puzzleHeight = ROWS * PIECE_SIZE;
      puzzleArea.style.width = (puzzleWidth + 8) + 'px';
      puzzleArea.style.height = (puzzleHeight + 8) + 'px';
      const puzzleImage = new Image();
      puzzleImage.src = puzzleImagePath;
      puzzleImage.onload = () => {
        puzzleArea.innerHTML = "";
        piecesArea.innerHTML = "";
        hiddenCanvas.width = puzzleWidth;
        hiddenCanvas.height = puzzleHeight;
        ctx.drawImage(puzzleImage, 0, 0, puzzleWidth, puzzleHeight);

        const sourcePieceWidth = puzzleWidth / COLS;
        const sourcePieceHeight = puzzleHeight / ROWS;
        const tabLength = PIECE_SIZE * CONNECTOR_LENGTH_RATIO;
        const tabWidth = PIECE_SIZE * CONNECTOR_WIDTH_RATIO;
        const connectorGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        const puzzlePieces = [];
        const puzzlePieceMap = {};
        window.puzzlePieces = puzzlePieces;
        window.puzzlePieceMap = puzzlePieceMap;

        let pieceIndex = 0;
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            const pieceMeta = createPieceMeta({
              row,
              col,
              index: pieceIndex,
              sourceWidth: sourcePieceWidth,
              sourceHeight: sourcePieceHeight,
              tabLength,
              tabWidth,
              connectorGrid,
              hiddenCanvas
            });
            puzzlePieces.push(pieceMeta);
            puzzlePieceMap[pieceIndex] = pieceMeta;
            connectorGrid[row][col] = pieceMeta;
            pieceIndex++;
          }
        }

        puzzlePieces.forEach(meta => {
          const slot = document.createElement('div');
          slot.classList.add('slot');
          slot.dataset.index = meta.index;
          slot.dataset.path = meta.path;
          slot.dataset.connectors = JSON.stringify(meta.connectors);
          slot.dataset.width = meta.bounds.width;
          slot.dataset.height = meta.bounds.height;
          slot.dataset.offsetX = meta.bounds.offsetX;
          slot.dataset.offsetY = meta.bounds.offsetY;
          slot.style.width = `${meta.bounds.width}px`;
          slot.style.height = `${meta.bounds.height}px`;
          slot.style.left = `${meta.slotPosition.left}px`;
          slot.style.top = `${meta.slotPosition.top}px`;
          applyClipPathStyles(slot, meta.path);
          slot.addEventListener('dragover', allowDrop);
          slot.addEventListener('drop', onDrop);
          slot.addEventListener('dragenter', onDragEnter);
          slot.addEventListener('dragleave', onDragLeave);
          puzzleArea.appendChild(slot);
        });

        piecesArea.addEventListener('dragover', allowDrop);
        piecesArea.addEventListener('drop', onDropLeft);
        piecesArea.addEventListener('dragenter', onDragEnter);
        piecesArea.addEventListener('dragleave', onDragLeave);

        const easyModeValue = puzzleOptions ? puzzleOptions.puzzleEasy : null;
        const easyMode = easyModeValue === true || easyModeValue === 'true' || easyModeValue === 'on';

        shuffleArray(puzzlePieces);
        puzzlePieces.forEach(pieceMeta => {
          const imgEl = document.createElement('img');
          imgEl.src = pieceMeta.img;
          imgEl.classList.add('draggable-piece');
          imgEl.draggable = true;
          imgEl.dataset.index = pieceMeta.index;
          imgEl.dataset.width = pieceMeta.bounds.width;
          imgEl.dataset.height = pieceMeta.bounds.height;
          imgEl.dataset.offsetX = pieceMeta.bounds.offsetX;
          imgEl.dataset.offsetY = pieceMeta.bounds.offsetY;
          imgEl.dataset.path = pieceMeta.path;
          imgEl.dataset.connectors = JSON.stringify(pieceMeta.connectors);
          imgEl.style.width = `${pieceMeta.bounds.width}px`;
          imgEl.style.height = `${pieceMeta.bounds.height}px`;
          applyClipPathStyles(imgEl, pieceMeta.path);
          imgEl.style.boxShadow = '0 0 0 1px rgba(15, 30, 60, 0.12) inset';

          if (easyMode) {
            applyEdgeHints(imgEl, pieceMeta);
          }

          imgEl.addEventListener('dragstart', onDragStart);
          imgEl.addEventListener('dragend', onDragEnd);
          piecesArea.appendChild(imgEl);
          placePieceRandomlyInArea(imgEl, piecesArea.clientWidth, piecesArea.clientHeight, pieceMeta);
          imgEl.addEventListener('touchstart', touchStartHandler, { passive: false });
          imgEl.addEventListener('touchmove', touchMoveHandler, { passive: false });
          imgEl.addEventListener('touchend', touchEndHandler);
        });
      };
      puzzleImage.onerror = err => { console.error("Puzzle image load error:", err); };
    }
    function createPieceMeta({ row, col, index, sourceWidth, sourceHeight, tabLength, tabWidth, connectorGrid, hiddenCanvas }) {
      const connectors = determineConnectors(row, col, connectorGrid);
      const geometry = buildPiecePathData(PIECE_SIZE, connectors, tabLength, tabWidth);
      const { pathString, width, height, offsetX, offsetY, extend } = geometry;
      const pieceCanvas = document.createElement('canvas');
      pieceCanvas.width = Math.ceil(width);
      pieceCanvas.height = Math.ceil(height);
      const pieceCtx = pieceCanvas.getContext('2d');
      const path2d = new Path2D(pathString);
      pieceCtx.save();
      pieceCtx.clip(path2d);

      const srcX = col * sourceWidth - extend.west;
      const srcY = row * sourceHeight - extend.north;
      const srcWidth = sourceWidth + extend.west + extend.east;
      const srcHeight = sourceHeight + extend.north + extend.south;

      pieceCtx.drawImage(
        hiddenCanvas,
        srcX,
        srcY,
        srcWidth,
        srcHeight,
        0,
        0,
        width,
        height
      );
      pieceCtx.restore();
      pieceCtx.lineWidth = 1.4;
      pieceCtx.strokeStyle = 'rgba(15, 30, 60, 0.25)';
      pieceCtx.stroke(path2d);

      const slotLeft = col * PIECE_SIZE - offsetX;
      const slotTop = row * PIECE_SIZE - offsetY;

      return {
        index,
        row,
        col,
        img: pieceCanvas.toDataURL(),
        connectors,
        path: pathString,
        bounds: { width, height, offsetX, offsetY },
        slotPosition: { left: slotLeft, top: slotTop }
      };
    }
    function determineConnectors(row, col, connectorGrid) {
      const connectors = { north: CONNECTOR_TYPES.FLAT, south: CONNECTOR_TYPES.FLAT, east: CONNECTOR_TYPES.FLAT, west: CONNECTOR_TYPES.FLAT };
      if (row > 0 && connectorGrid[row - 1][col]) {
        connectors.north = invertConnector(connectorGrid[row - 1][col].connectors.south);
      }
      if (col > 0 && connectorGrid[row][col - 1]) {
        connectors.west = invertConnector(connectorGrid[row][col - 1].connectors.east);
      }
      if (col < COLS - 1) {
        connectors.east = randomConnectorType();
      }
      if (row < ROWS - 1) {
        connectors.south = randomConnectorType();
      }
      return connectors;
    }
    function invertConnector(value) {
      if (value === CONNECTOR_TYPES.FLAT) { return CONNECTOR_TYPES.FLAT; }
      return value * -1;
    }
    function randomConnectorType() {
      return Math.random() > 0.5 ? CONNECTOR_TYPES.TAB : CONNECTOR_TYPES.SLOT;
    }
    function buildPiecePathData(baseSize, connectors, tabLength, tabWidth) {
      const extendWest = connectors.west === CONNECTOR_TYPES.TAB ? tabLength : 0;
      const extendEast = connectors.east === CONNECTOR_TYPES.TAB ? tabLength : 0;
      const extendNorth = connectors.north === CONNECTOR_TYPES.TAB ? tabLength : 0;
      const extendSouth = connectors.south === CONNECTOR_TYPES.TAB ? tabLength : 0;
      const width = baseSize + extendWest + extendEast;
      const height = baseSize + extendNorth + extendSouth;
      const offsetX = extendWest;
      const offsetY = extendNorth;
      const baseLeft = offsetX;
      const baseTop = offsetY;
      const baseRight = baseLeft + baseSize;
      const baseBottom = baseTop + baseSize;
      const indentDepth = tabLength * 0.82;
      const handle = tabWidth * 0.35;
      const halfTab = tabWidth / 2;
      const commands = [];
      const fmt = (num) => Number(num.toFixed(3));
      const moveTo = (x, y) => `M ${fmt(x)} ${fmt(y)}`;
      const lineTo = (x, y) => `L ${fmt(x)} ${fmt(y)}`;
      const curveTo = (cp1x, cp1y, cp2x, cp2y, x, y) => `C ${fmt(cp1x)} ${fmt(cp1y)} ${fmt(cp2x)} ${fmt(cp2y)} ${fmt(x)} ${fmt(y)}`;

      commands.push(moveTo(baseLeft, baseTop));

      const topMid = baseLeft + baseSize / 2;
      if (connectors.north === CONNECTOR_TYPES.FLAT) {
        commands.push(lineTo(baseRight, baseTop));
      } else {
        const direction = connectors.north === CONNECTOR_TYPES.TAB ? -1 : 1;
        const depth = connectors.north === CONNECTOR_TYPES.TAB ? tabLength : indentDepth;
        const startX = topMid - halfTab;
        const endX = topMid + halfTab;
        const tipY = baseTop + direction * depth;
        commands.push(lineTo(startX, baseTop));
        commands.push(curveTo(startX + handle, baseTop, topMid - handle, tipY, topMid, tipY));
        commands.push(curveTo(topMid + handle, tipY, endX - handle, baseTop, endX, baseTop));
        commands.push(lineTo(baseRight, baseTop));
      }

      const rightMid = baseTop + baseSize / 2;
      if (connectors.east === CONNECTOR_TYPES.FLAT) {
        commands.push(lineTo(baseRight, baseBottom));
      } else {
        const direction = connectors.east === CONNECTOR_TYPES.TAB ? 1 : -1;
        const depth = connectors.east === CONNECTOR_TYPES.TAB ? tabLength : indentDepth;
        const startY = rightMid - halfTab;
        const endY = rightMid + halfTab;
        const tipX = baseRight + direction * depth;
        commands.push(lineTo(baseRight, startY));
        commands.push(curveTo(baseRight, startY + handle, tipX, rightMid - handle, tipX, rightMid));
        commands.push(curveTo(tipX, rightMid + handle, baseRight, endY - handle, baseRight, endY));
        commands.push(lineTo(baseRight, baseBottom));
      }

      const bottomMid = baseLeft + baseSize / 2;
      if (connectors.south === CONNECTOR_TYPES.FLAT) {
        commands.push(lineTo(baseLeft, baseBottom));
      } else {
        const direction = connectors.south === CONNECTOR_TYPES.TAB ? 1 : -1;
        const depth = connectors.south === CONNECTOR_TYPES.TAB ? tabLength : indentDepth;
        const startX = bottomMid + halfTab;
        const endX = bottomMid - halfTab;
        const tipY = baseBottom + direction * depth;
        commands.push(lineTo(startX, baseBottom));
        commands.push(curveTo(startX - handle, baseBottom, bottomMid + handle, tipY, bottomMid, tipY));
        commands.push(curveTo(bottomMid - handle, tipY, endX + handle, baseBottom, endX, baseBottom));
        commands.push(lineTo(baseLeft, baseBottom));
      }

      const leftMid = baseTop + baseSize / 2;
      if (connectors.west === CONNECTOR_TYPES.FLAT) {
        commands.push(lineTo(baseLeft, baseTop));
      } else {
        const direction = connectors.west === CONNECTOR_TYPES.TAB ? -1 : 1;
        const depth = connectors.west === CONNECTOR_TYPES.TAB ? tabLength : indentDepth;
        const startY = leftMid + halfTab;
        const endY = leftMid - halfTab;
        const tipX = baseLeft + direction * depth;
        commands.push(lineTo(baseLeft, startY));
        commands.push(curveTo(baseLeft, startY - handle, tipX, leftMid + handle, tipX, leftMid));
        commands.push(curveTo(tipX, leftMid - handle, baseLeft, endY + handle, baseLeft, endY));
        commands.push(lineTo(baseLeft, baseTop));
      }

      commands.push('Z');
      return {
        pathString: commands.join(' '),
        width,
        height,
        offsetX,
        offsetY,
        extend: { north: extendNorth, south: extendSouth, east: extendEast, west: extendWest }
      };
    }
    function applyClipPathStyles(element, pathString) {
      if (!element || !pathString) { return; }
      const pathValue = `path('${pathString}')`;
      element.style.clipPath = pathValue;
      element.style.webkitClipPath = pathValue;
    }
    function applyEdgeHints(el, pieceMeta) {
      const shadows = [];
      if (pieceMeta.row === 0) { shadows.push('0 -4px 0 0 rgba(0,0,0,0.6) inset'); }
      if (pieceMeta.row === ROWS - 1) { shadows.push('0 4px 0 0 rgba(0,0,0,0.6) inset'); }
      if (pieceMeta.col === 0) { shadows.push('-4px 0 0 0 rgba(0,0,0,0.6) inset'); }
      if (pieceMeta.col === COLS - 1) { shadows.push('4px 0 0 0 rgba(0,0,0,0.6) inset'); }
      el.style.boxShadow = shadows.join(', ') || '0 0 0 1px rgba(15, 30, 60, 0.2) inset';
    }
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    function placePieceRandomlyInArea(pieceEl, containerW, containerH, pieceMeta) {
      if (!pieceMeta) { return; }
      const width = pieceMeta.bounds.width;
      const height = pieceMeta.bounds.height;
      const maxLeft = Math.max(0, containerW - width);
      const maxTop = Math.max(0, containerH - height);
      const left = Math.random() * maxLeft;
      const top = Math.random() * maxTop;
      pieceEl.style.position = 'absolute';
      pieceEl.style.left = `${left}px`;
      pieceEl.style.top = `${top}px`;
    }
    function getPieceMeta(index) {
      if (!index) { return null; }
      return (window.puzzlePieceMap && window.puzzlePieceMap[index]) || null;
    }
    function snapPieceIntoSlot(pieceEl, slotEl, pieceMeta) {
      if (!pieceEl || !slotEl || !pieceMeta) { return; }
      slotEl.innerHTML = '';
      slotEl.appendChild(pieceEl);
      pieceEl.style.position = 'absolute';
      pieceEl.style.left = '0px';
      pieceEl.style.top = '0px';
      pieceEl.style.transform = '';
      pieceEl.style.width = `${pieceMeta.bounds.width}px`;
      pieceEl.style.height = `${pieceMeta.bounds.height}px`;
      applyClipPathStyles(pieceEl, pieceMeta.path);
      pieceEl.dataset.originalParent = 'slot';
      pieceEl.dataset.originalSlot = slotEl.dataset.index;
    }
    function releasePieceToPool(pieceEl) {
      if (!pieceEl || !piecesAreaEl) { return; }
      const meta = getPieceMeta(pieceEl.dataset.index);
      if (!meta) { return; }
      piecesAreaEl.appendChild(pieceEl);
      pieceEl.style.position = 'absolute';
      pieceEl.style.transform = '';
      pieceEl.style.width = `${meta.bounds.width}px`;
      pieceEl.style.height = `${meta.bounds.height}px`;
      applyClipPathStyles(pieceEl, meta.path);
      placePieceRandomlyInArea(pieceEl, piecesAreaEl.clientWidth, piecesAreaEl.clientHeight, meta);
      pieceEl.dataset.originalParent = 'piecesArea';
      pieceEl.dataset.originalSlot = 'piecesArea';
    }
    function onDragStart(e) {
      const pieceIndex = e.target.dataset.index;
      if (!pieceIndex) { return; }
      e.dataTransfer.setData('text/plain', pieceIndex);
      if (currentDragPreview) {
        currentDragPreview.remove();
        currentDragPreview = null;
      }
      const dragClone = e.target.cloneNode(true);
      dragClone.classList.remove('active');
      dragClone.style.position = 'absolute';
      dragClone.style.left = '-9999px';
      dragClone.style.top = '-9999px';
      dragClone.style.pointerEvents = 'none';
      dragClone.style.margin = '0';
      dragClone.style.transform = 'none';
      dragClone.style.opacity = '1';
      document.body.appendChild(dragClone);
      currentDragPreview = dragClone;
      const rect = e.target.getBoundingClientRect();
      const pointerX = (typeof e.clientX === 'number' ? e.clientX : rect.left + rect.width / 2);
      const pointerY = (typeof e.clientY === 'number' ? e.clientY : rect.top + rect.height / 2);
      const offsetX = pointerX - rect.left;
      const offsetY = pointerY - rect.top;
      e.dataTransfer.setDragImage(dragClone, offsetX, offsetY);
      e.target.classList.add('active');
      const originalParent = e.target.parentElement;
      if (originalParent && originalParent.classList.contains('slot')) {
        e.target.dataset.originalParent = 'slot';
        e.target.dataset.originalSlot = originalParent.dataset.index;
      } else {
        e.target.dataset.originalParent = 'piecesArea';
        e.target.dataset.originalSlot = 'piecesArea';
      }
    }
    function onDragEnd(e) {
      e.target.classList.remove('active');
      if (currentDragPreview) {
        currentDragPreview.remove();
        currentDragPreview = null;
      }
    }
    function allowDrop(e) { e.preventDefault(); }
    function onDragEnter(e) { e.currentTarget.classList.add('highlight'); }
    function onDragLeave(e) { e.currentTarget.classList.remove('highlight'); }
    function onDrop(e) {
      e.preventDefault();
      const slot = e.currentTarget;
      slot.classList.remove('highlight');
      const pieceIndex = e.dataTransfer.getData('text/plain');
      if (!pieceIndex) { return; }
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);
      if (!draggedImg) { return; }
      const pieceMeta = getPieceMeta(pieceIndex);
      if (!pieceMeta) { return; }
      const existingPiece = slot.querySelector('.draggable-piece');
      if (existingPiece) {
        const originalParentId = draggedImg.dataset.originalParent;
        const originalSlot = draggedImg.dataset.originalSlot;
        if (originalParentId === 'piecesArea') {
          releasePieceToPool(existingPiece);
        } else {
          const originalSlotElement = document.querySelector(`.slot[data-index='${originalSlot}']`);
          if (originalSlotElement) {
            snapPieceIntoSlot(existingPiece, originalSlotElement, getPieceMeta(existingPiece.dataset.index));
          } else {
            releasePieceToPool(existingPiece);
          }
        }
      }
      snapPieceIntoSlot(draggedImg, slot, pieceMeta);
      checkPuzzleCompletion();
    }
    function onDropLeft(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('highlight');
      const pieceIndex = e.dataTransfer.getData('text/plain');
      if (!pieceIndex) { return; }
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);
      if (!draggedImg) { return; }
      if (draggedImg.dataset.originalParent === 'slot') {
        const originalSlotElement = document.querySelector(`.slot[data-index='${draggedImg.dataset.originalSlot}']`);
        if (originalSlotElement) { originalSlotElement.innerHTML = ''; }
      }
      releasePieceToPool(draggedImg);
    }
    function checkPuzzleCompletion() {
      let correct = 0;
      const slots = document.querySelectorAll('.slot');
      slots.forEach(slot => {
        const slotIndex = slot.dataset.index;
        const pieceImg = slot.querySelector('img');
        if (pieceImg && pieceImg.dataset.index === slotIndex) { correct++; }
      });
      if (correct === ROWS * COLS) {
        handlePuzzleCompletion();
      }
    }
    function handlePuzzleCompletion() {
      if (finalRewardSound) {
        finalRewardSound.currentTime = 0;
        finalRewardSound.play().catch(error => {
          console.error('Error playing final reward sound:', error);
        });
      }
      if (reinforcerController && typeof reinforcerController.show === 'function') {
        setTimeout(() => {
          reinforcerController.show();
        }, 2000);
      } else {
        sessionHelpers.advanceToNextGame();
      }
    }
    let currentDragPreview = null;
    let touchData = { dragging: false, element: null, originalParentType: null, originalSlot: null, originalPosition: { left: 0, top: 0 }, offsetX: 0, offsetY: 0 };
    function touchStartHandler(e) {
      e.preventDefault();
      const touch = e.touches[0];
      touchData.dragging = true;
      touchData.element = e.target;
      const parent = e.target.parentElement;
      if (parent && parent.classList.contains('slot')) {
        touchData.originalParentType = 'slot';
        touchData.originalSlot = parent.dataset.index;
      } else {
        touchData.originalParentType = 'piecesArea';
        touchData.originalSlot = 'piecesArea';
      }
      e.target.classList.add('active');
      const rect = e.target.getBoundingClientRect();
      touchData.offsetX = touch.clientX - rect.left;
      touchData.offsetY = touch.clientY - rect.top;
      touchData.originalPosition.left = rect.left;
      touchData.originalPosition.top = rect.top;
      e.target.style.zIndex = 1000;
      e.target.style.position = 'fixed';
      e.target.style.left = (touch.clientX - touchData.offsetX) + 'px';
      e.target.style.top = (touch.clientY - touchData.offsetY) + 'px';
    }
    function touchMoveHandler(e) {
      if (!touchData.dragging) return;
      e.preventDefault();
      const touch = e.touches[0];
      touchData.element.style.left = (touch.clientX - touchData.offsetX) + 'px';
      touchData.element.style.top = (touch.clientY - touchData.offsetY) + 'px';
    }
    function touchEndHandler(e) {
      if (!touchData.dragging) return;
      touchData.dragging = false;
      touchData.element.classList.remove('active');
      const touch = e.changedTouches[0];
      touchData.element.style.pointerEvents = 'none';
      const dropTarget = getDropTarget(touch.clientX, touch.clientY);
      touchData.element.style.pointerEvents = '';
      if (dropTarget) {
        if (dropTarget.classList.contains('slot')) { onDropTouch(touch.clientX, touch.clientY, dropTarget, touchData.element); }
        else if (dropTarget.id === 'piecesArea') { onDropLeftTouch(touch.clientX, touch.clientY, touchData.element); }
        else { resetTouchElementPosition(touchData.element); }
      } else { resetTouchElementPosition(touchData.element); }
      touchData.element.style.zIndex = '';
      touchData.element.style.position = 'absolute';
      touchData.originalParentType = null;
      touchData.originalSlot = null;
      touchData.element = null;
    }
    function onDropTouch(clientX, clientY, slotEl, draggedImg) {
      const pieceMeta = getPieceMeta(draggedImg.dataset.index);
      if (!pieceMeta) { return; }
      const existingPiece = slotEl.querySelector('.draggable-piece');
      if (existingPiece) {
        if (touchData.originalParentType === 'piecesArea') {
          releasePieceToPool(existingPiece);
        } else {
          const originalSlotElement = document.querySelector(`.slot[data-index='${touchData.originalSlot}']`);
          if (originalSlotElement) {
            snapPieceIntoSlot(existingPiece, originalSlotElement, getPieceMeta(existingPiece.dataset.index));
          } else {
            releasePieceToPool(existingPiece);
          }
        }
      }
      snapPieceIntoSlot(draggedImg, slotEl, pieceMeta);
      checkPuzzleCompletion();
    }
    function onDropLeftTouch(clientX, clientY, draggedImg) {
      if (touchData.originalParentType === 'slot') {
        const originalSlotElement = document.querySelector(`.slot[data-index='${touchData.originalSlot}']`);
        if (originalSlotElement) { originalSlotElement.innerHTML = ''; }
      }
      releasePieceToPool(draggedImg);
    }
    function resetTouchElementPosition(pieceEl) {
      if (pieceEl.parentElement && pieceEl.parentElement.id === 'piecesArea' && piecesAreaEl) {
        const meta = getPieceMeta(pieceEl.dataset.index);
        placePieceRandomlyInArea(pieceEl, piecesAreaEl.clientWidth, piecesAreaEl.clientHeight, meta);
      }
    }
    function getDropTarget(x, y) {
      const elem = document.elementFromPoint(x, y);
      if (!elem) return null;
      return elem.closest('.slot') || (elem.id === 'piecesArea' ? elem : null);
    }
    const referenceModal = document.getElementById('referenceModal');
    const toggleReferenceBtn = document.getElementById('toggleReference');
    function openModal() {
      referenceModal.classList.add('flex');
      document.documentElement.style.overflow = 'hidden';
      setTimeout(() => {
        document.addEventListener('click', closeModalOnInteraction);
        document.addEventListener('touchend', closeModalOnInteraction);
      }, 0);
    }
    function closeModal() {
      referenceModal.classList.remove('flex');
      document.documentElement.style.overflow = '';
      document.removeEventListener('click', closeModalOnInteraction);
      document.removeEventListener('touchend', closeModalOnInteraction);
    }
    function closeModalOnInteraction(event) {
      if (event.target !== toggleReferenceBtn) { closeModal(); }
    }
    toggleReferenceBtn.addEventListener('click', openModal);
    toggleReferenceBtn.addEventListener('touchend', openModal);
    referenceModal.addEventListener('click', (event) => { if (event.target === referenceModal) { closeModal(); } });
    window.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closeModal(); } });
  </script>
</body>
</html>
