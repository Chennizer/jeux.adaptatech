<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title class="translate" data-fr="Dessine dans le contour" data-en="Draw within the outline">Draw within the outline</title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111923;
      --ink:#f5f5f5;
      --accent:#4fd1c5;
      --edge:#e2e8f0;
      --ok:#22c55e;
      --bad:#ef4444;
    }

    html, body{
      height:100%;
      margin:0;
    }

    body{
      background:var(--bg);
      color:#e6edf3;
      font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
      display:block;
      overflow:hidden;
    }

    #game-options{ display:flex; }

    .game-container{
      width:100%;
      height:100%;
      display:none;
    }

    .stage{
      position:relative;
      display:grid;
      place-items:center;
      background:radial-gradient(1200px 600px at 60% -10%, #1a2330 0%, #0b0f14 60%, #080c11 100%);
      width:100%;
      height:100%;
    }

    .hint{
      font-size:12px;
      opacity:.75;
      margin-top:8px;
      line-height:1.4;
    }

    canvas{display:block;max-width:100%;height:auto}
    #ink{position:absolute;inset:0}
    #outline{position:absolute;inset:0;pointer-events:none}
    .badge{position:absolute;top:12px;right:12px;background:#0b1520;border:1px solid rgba(255,255,255,.1);padding:6px 10px;border-radius:999px;font-size:12px}

    details{border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px 10px}
    details summary{cursor:pointer;font-size:13px}
    #testResults{margin-top:8px;font-size:12px;line-height:1.5}
    .ok{color:var(--ok)} .bad{color:var(--bad)}
    .muted{opacity:.6}

    /* Image picker styled like CVI generator */
    .image-picker{
      margin-top:14px;
      padding:14px 16px;
      background:#0b1520;
      border-radius:14px;
      border:1px solid rgba(79,209,197,0.35);
      box-shadow:0 10px 30px rgba(0,0,0,0.28);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .image-picker h2{
      margin:0;
      font-size:17px;
      font-weight:700;
      color:#e6edf3;
      text-align:center;
    }

    .image-picker label{
      font-size:14px;
      font-weight:600;
      opacity:1;
      min-width:0;
    }

    .image-picker select{
      background:#07111a;
      color:#e6edf3;
      border:2px solid rgba(79,209,197,0.6);
      border-radius:10px;
      padding:10px 34px 10px 12px;
      font-size:15px;
      font-weight:600;
      appearance:none;
      background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iOCIgdmlld0JveD0iMCAwIDEyIDgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMGwxMiAwLTYgOCIgc3R5bGU9ImZpbGw6I2V2ZmZmZjsiLz48L3N2Zz4=");
      background-repeat:no-repeat;
      background-position:right 10px center;
      background-size:14px 8px;
      cursor:pointer;
    }

    .carousel-container{
      position:relative;
      display:flex;
      align-items:center;
      gap:12px;
      min-height:92px;
    }

    .carousel-track{
      flex:1;
      display:flex;
      gap:8px;
      overflow:hidden;
    }

    .carousel-item{
      flex:1;
      min-width:70px;
      max-width:110px;
      border-radius:10px;
      border:2px solid transparent;
      background:#0b1f2b;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px;
      transition:border-color .2s ease, box-shadow .2s ease;
      cursor:pointer;
    }

    .carousel-item.selected{
      border-color:#4fd1c5;
      box-shadow:0 0 0 2px rgba(79,209,197,0.35);
    }

    .carousel-item img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
    }

    .carousel-arrow{
      width:36px;
      height:36px;
      border-radius:50%;
      border:none;
      background:rgba(79,209,197,0.22);
      color:#4fd1c5;
      font-size:20px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition:background .2s ease;
    }

    .carousel-arrow:disabled{
      opacity:0.35;
      cursor:not-allowed;
    }

    .carousel-arrow:not(:disabled):hover{
      background:rgba(79,209,197,0.4);
    }

    .image-picker .hint{
      font-size:12px;
      line-height:1.4;
      opacity:0.75;
      text-align:center;
    }

    .carousel-empty{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:14px;
      opacity:0.7;
    }

    /* Buttons inside picker */
    .image-picker .button{
      align-self:center;
      min-width:200px;
    }

    .value-readout{
      margin-top:6px;
      text-align:center;
      font-size:14px;
      opacity:0.8;
    }

    .color-input{
      width:100%;
      height:44px;
      border-radius:12px;
      border:2px solid rgba(79,209,197,0.6);
      background:#07111a;
      cursor:pointer;
    }

    .floating-controls{
      position:absolute;
      top:18px;
      left:18px;
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      z-index:30;
    }

    .hud-btn{
      background:rgba(11,21,32,0.88);
      color:#e6edf3;
      border:1px solid rgba(79,209,197,0.45);
      border-radius:999px;
      padding:10px 16px;
      font-size:15px;
      font-weight:600;
      cursor:pointer;
      transition:background .2s ease, transform .2s ease;
      box-shadow:0 8px 18px rgba(0,0,0,0.28);
    }

    .hud-btn:hover{
      background:rgba(15,30,45,0.92);
      transform:translateY(-1px);
    }
  </style>

  <!-- Optional presets file; if present, provides window.PNG_ARRAY -->
  <script src="../../js/cvipngarray.js" defer></script>
</head>
<body>
  <div id="game-options" class="modal">
    <div id="control-panel-options">
      <div id="options-title-bar">
        <h2 id="options-main-title" class="translate" data-fr="Dessine dans le contour" data-en="Draw within the outline">Dessine dans le contour</h2>
      </div>

      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label for="brush" class="teal-label label-block translate" data-fr="Taille du pinceau" data-en="Brush size">Brush size</label>
            <input id="brush" type="range" min="3" max="64" value="18" class="styled-slider" />
            <div class="value-readout"><span id="brushV">18</span> px</div>
          </div>
          <div class="option-item">
            <label for="color" class="teal-label label-block translate" data-fr="Couleur du pinceau" data-en="Brush color">Brush color</label>
            <input id="color" type="color" value="#ff7a59" class="color-input" />
          </div>
          <div class="option-item">
            <label for="mode" class="teal-label label-block translate" data-fr="Mode" data-en="Mode">Mode</label>
            <select id="mode" class="styled-select">
              <option value="draw" selected class="translate" data-fr="Dessiner" data-en="Draw">Draw</option>
              <option value="erase" class="translate" data-fr="Effacer" data-en="Erase">Erase</option>
            </select>
          </div>
          <div class="option-item">
            <label for="shape" class="teal-label label-block translate" data-fr="Forme intégrée" data-en="Built-in outline">Built-in outline</label>
            <select id="shape" class="styled-select">
              <option value="blob"  class="translate" data-fr="Goutte" data-en="Blob">Blob</option>
              <option value="star"  class="translate" data-fr="Étoile" data-en="Star">Star</option>
              <option value="heart" class="translate" data-fr="Cœur" data-en="Heart">Heart</option>
              <option value="rect"  class="translate" data-fr="Rectangle arrondi" data-en="Rounded rectangle">Rounded rectangle</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <div class="image-picker">
            <h2 class="translate" data-fr="Choisir une image" data-en="Choose an image">Choisir une image</h2>
            <label for="maskCategory" class="translate" data-fr="Catégorie" data-en="Category">Category</label>
            <select id="maskCategory" disabled>
              <option>Loading…</option>
            </select>
            <div class="carousel-container">
              <button id="maskPrev" class="carousel-arrow" type="button" disabled aria-label="Précédent">‹</button>
              <div id="maskCarouselTrack" class="carousel-track">
                <div class="carousel-empty translate" data-fr="Aucune image" data-en="No images">No images</div>
              </div>
              <button id="maskNext" class="carousel-arrow" type="button" disabled aria-label="Suivant">›</button>
            </div>
            <button id="loadPreset" class="button translate" data-fr="Utiliser l'image" data-en="Use image" disabled>Utiliser l'image</button>
            <p id="presetStatus" class="hint muted">Presets will activate if <code>../../js/cvipngarray.js</code> is found.</p>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="outlineFile" class="teal-label label-block translate" data-fr="Téléverser un contour" data-en="Upload outline">Téléverser un contour</label>
            <input id="outlineFile" type="file" accept="image/png, image/svg+xml" class="styled-input" />
          </div>
          <div class="option-item">
            <label for="fitMode" class="teal-label label-block translate" data-fr="Ajuster l'image" data-en="Fit uploaded image">Ajuster l'image</label>
            <select id="fitMode" class="styled-select">
              <option value="contain" selected class="translate" data-fr="Conserver les proportions" data-en="Contain (keep aspect)">Contain (keep aspect)</option>
              <option value="cover" class="translate" data-fr="Recouvrir" data-en="Cover">Cover</option>
              <option value="stretch" class="translate" data-fr="Étirer" data-en="Stretch">Stretch</option>
            </select>
          </div>
          <div class="option-item">
            <label for="maskSource" class="teal-label label-block translate" data-fr="Source du masque" data-en="Mask source">Mask source</label>
            <select id="maskSource" class="styled-select">
              <option value="alpha" selected class="translate" data-fr="Alpha (opaque = intérieur)" data-en="Alpha (opaque = inside)">Alpha (opaque = inside)</option>
              <option value="luma" class="translate" data-fr="Luminance (blanc = intérieur)" data-en="Luminance (white = inside)">Luminance (white = inside)</option>
              <option value="alpha-invert" class="translate" data-fr="Alpha inversé" data-en="Alpha inverted">Alpha inverted</option>
            </select>
          </div>
          <p class="hint translate" data-fr="Utilise une forme intégrée, sélectionne une image ou téléverse ton propre contour pour définir la zone de dessin." data-en="Use a built-in shape, choose a preset image, or upload your own outline to define the drawing area.">Use a built-in shape, choose a preset image, or upload your own outline to define the drawing area.</p>
          <details>
            <summary class="translate" data-fr="Diagnostics & auto-tests" data-en="Diagnostics & self-tests">Diagnostics & self-tests</summary>
            <div class="option-item">
              <button id="runTests" class="button translate" data-fr="Lancer les tests" data-en="Run tests">Run tests</button>
            </div>
            <div id="testResults">No tests run yet.</div>
          </details>
        </div>
      </div>

      <div id="mode-divider"></div>

      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
    </div>
  </div>

  <div id="drawGame" class="game-container">
    <main class="stage">
      <div class="badge translate" data-fr="Mode dessin" data-en="Drawing mode">Drawing mode</div>
      <canvas id="ink" width="1400" height="900" aria-label="Ink layer"></canvas>
      <canvas id="outline" width="1400" height="900" aria-label="Outline layer"></canvas>
      <div class="floating-controls">
        <button id="optionsBtn" class="hud-btn translate" data-fr="Options" data-en="Options">Options</button>
        <button id="clear" class="hud-btn translate" data-fr="Effacer" data-en="Clear">Effacer</button>
        <button id="download" class="hud-btn translate" data-fr="Enregistrer PNG" data-en="Save PNG">Save PNG</button>
      </div>
    </main>
  </div>

  <script>
    // --- Setup canvases ---
    const ink = document.getElementById('ink');
    const out = document.getElementById('outline');
    const ic = ink.getContext('2d');
    const oc = out.getContext('2d');

    // Avoid ResizeObserver loops by batching in rAF and resizing only on change
    let resizePending = false;
    function fitCanvas(cnv){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = cnv.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width * dpr));
      const h = Math.max(1, Math.round(rect.height * dpr));
      if (cnv.width !== w || cnv.height !== h){
        cnv.width = w; cnv.height = h;
        const ctx = cnv.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
    }
    function resizeAllImmediate(){
      fitCanvas(ink); fitCanvas(out); drawOutline(); syncScratch(); rebuildMaskCache();
    }
    function requestResize(){ if(resizePending) return; resizePending = true; requestAnimationFrame(()=>{ resizePending=false; resizeAllImmediate(); }); }
    const ro = new ResizeObserver(()=>{ requestResize(); });
    ro.observe(out);

    // --- UI ---
    const brushEl = document.getElementById('brush');
    const brushV = document.getElementById('brushV');
    const colorEl = document.getElementById('color');
    const modeEl = document.getElementById('mode');
    const clearEl = document.getElementById('clear');
    const dlEl = document.getElementById('download');
    const shapeEl = document.getElementById('shape');

    const outlineFileEl = document.getElementById('outlineFile');
    const fitModeEl = document.getElementById('fitMode');
    const maskSourceEl = document.getElementById('maskSource');

    const categoryEl = document.getElementById('maskCategory');
    const carouselTrack = document.getElementById('maskCarouselTrack');
    const prevBtn = document.getElementById('maskPrev');
    const nextBtn = document.getElementById('maskNext');
    const loadPresetBtn = document.getElementById('loadPreset');
    const presetStatus = document.getElementById('presetStatus');

    const gameOptions = document.getElementById('game-options');
    const gameArea = document.getElementById('drawGame');
    const startButton = document.getElementById('startButton');
    const optionsBtn = document.getElementById('optionsBtn');

    startButton.addEventListener('click', ()=>{
      gameOptions.style.display = 'none';
      gameArea.style.display = 'block';
      setTimeout(()=>{ resizeAllImmediate(); }, 60);
    });

    optionsBtn.addEventListener('click', ()=>{
      gameOptions.style.display = 'flex';
    });

    const runTestsBtn = document.getElementById('runTests');
    const testResults = document.getElementById('testResults');

    brushEl.addEventListener('input', ()=> brushV.textContent = brushEl.value);
    clearEl.addEventListener('click', ()=>{ ic.clearRect(0,0,ink.width,ink.height); });
    dlEl.addEventListener('click', ()=>{
      const url = mergeForExport();
      const a = document.createElement('a'); a.href=url; a.download='drawing.png'; a.click();
    });
    shapeEl.addEventListener('change', ()=>{ userMask = null; drawOutline(); });
    fitModeEl.addEventListener('change', ()=>{ rebuildMaskCache(); redrawMaskGuide(); });
    maskSourceEl.addEventListener('change', ()=>{ rebuildMaskCache(); redrawMaskGuide(); });

    outlineFileEl.addEventListener('change', async (e)=>{
      const file = e.target.files?.[0]; if(!file) return; await loadUserMaskFromFile(file); redrawMaskGuide();
    });

    // --- Presets (PNG_ARRAY) ---
    let currentItems = [];
    let selectedIndex = 0;

    function renderCarousel(){
      carouselTrack.innerHTML = '';
      if(!currentItems.length){
        carouselTrack.innerHTML = '<div class="carousel-empty translate" data-fr="Aucune image" data-en="No images">No images</div>';
        loadPresetBtn.disabled = true;
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        return;
      }

      if(selectedIndex >= currentItems.length){ selectedIndex = 0; }

      const visible = Math.min(currentItems.length, 4);
      let start = 0;
      if(currentItems.length > visible){
        start = (selectedIndex - Math.floor(visible/2) + currentItems.length) % currentItems.length;
      }

      for(let i=0; i<visible; i++){
        const idx = (start + i) % currentItems.length;
        const item = currentItems[idx];
        const cell = document.createElement('div');
        cell.className = 'carousel-item';
        if(idx === selectedIndex){ cell.classList.add('selected'); }
        cell.innerHTML = `<img src="${item.file}" alt="${item.name}">`;
        cell.addEventListener('click', ()=>{
          selectedIndex = idx;
          renderCarousel();
        });
        carouselTrack.appendChild(cell);
      }

      loadPresetBtn.disabled = false;
      prevBtn.disabled = currentItems.length <= 1;
      nextBtn.disabled = currentItems.length <= 1;
    }

    function setCategory(cat){
      currentItems = window.PNG_ARRAY
        .filter(x=>x.category===cat)
        .sort((a,b)=>a.name.localeCompare(b.name));
      selectedIndex = 0;
      renderCarousel();
    }

    function enablePresets(){
      if(!window.PNG_ARRAY || !Array.isArray(window.PNG_ARRAY) || window.PNG_ARRAY.length===0){
        categoryEl.innerHTML = '<option>Unavailable</option>';
        categoryEl.disabled = true;
        loadPresetBtn.disabled = true;
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        carouselTrack.innerHTML = '<div class="carousel-empty translate" data-fr="Aucune image" data-en="No images">No images</div>';
        presetStatus.textContent = 'Preset list not found. Ensure ../../js/cvipngarray.js is loaded.';
        return;
      }
      const cats = [...new Set(window.PNG_ARRAY.map(x=>x.category))].sort((a,b)=>a.localeCompare(b));
      categoryEl.innerHTML = cats.map(c=>`<option value="${c}">${c}</option>`).join('');
      categoryEl.disabled = false;
      presetStatus.textContent = `Loaded ${window.PNG_ARRAY.length} preset PNGs across ${cats.length} categories.`;
      const first = cats[0] || '';
      categoryEl.value = first;
      setCategory(first);
    }

    categoryEl.addEventListener('change', ()=>{
      setCategory(categoryEl.value);
    });

    prevBtn.addEventListener('click', ()=>{
      if(!currentItems.length) return;
      selectedIndex = (selectedIndex - 1 + currentItems.length) % currentItems.length;
      renderCarousel();
    });

    nextBtn.addEventListener('click', ()=>{
      if(!currentItems.length) return;
      selectedIndex = (selectedIndex + 1) % currentItems.length;
      renderCarousel();
    });

    loadPresetBtn.addEventListener('click', ()=>{
      if(!currentItems.length) return;
      const chosen = currentItems[selectedIndex];
      if(chosen){
        loadUserMaskFromURL(chosen.file);
      }
    });

    // wait for deferred presets script to load
    window.addEventListener('DOMContentLoaded', ()=>{ setTimeout(enablePresets, 0); });

    // --- Outline as vector path (Path2D) ---
    let shapePath = null; // Path2D in canvas units

    function makePath(kind, w, h){
      const p = new Path2D();
      const pad = Math.min(w,h)*0.12;
      const cx=w/2, cy=h/2;
      if(kind==='rect'){
        const r = Math.min(w,h)*0.18; // radius
        const x=pad, y=pad, rw=w-2*pad, rh=h-2*pad;
        roundRectPath(p,x,y,rw,rh,r);
      } else if(kind==='blob'){
        const rx=w*0.32, ry=h*0.28;
        blobPath(p, cx, cy, rx, ry);
      } else if(kind==='star'){
        starPath(p, cx, cy, Math.min(w,h)*0.36, 5);
      } else if(kind==='heart'){
        heartPath(p, cx, cy, Math.min(w,h)*0.36);
      }
      return p;
    }

    function roundRectPath(p,x,y,w,h,r){
      p.moveTo(x+r,y);
      p.arcTo(x+w,y,x+w,y+h,r);
      p.arcTo(x+w,y+h,x,y+h,r);
      p.arcTo(x,y+h,x,y,r);
      p.arcTo(x,y,x+w,y,r);
      p.closePath();
    }

    function blobPath(p, cx, cy, rx, ry){
      p.moveTo(cx, cy-ry);
      p.bezierCurveTo(cx+rx*0.6, cy-ry, cx+rx, cy-ry*0.2, cx+rx, cy);
      p.bezierCurveTo(cx+rx, cy+ry*0.6, cx+rx*0.4, cy+ry, cx, cy+ry);
      p.bezierCurveTo(cx-rx*0.6, cy+ry, cx-rx, cy+ry*0.2, cx-rx, cy);
      p.bezierCurveTo(cx-rx, cy-ry*0.6, cx-rx*0.4, cy-ry, cx, cy-ry);
      p.closePath();
    }

    function starPath(p, cx, cy, r, spikes){
      const step=Math.PI/spikes; let rot=Math.PI/2*3; let x=cx; let y=cy - r;
      p.moveTo(cx, cy - r);
      for(let i=0;i<spikes;i++){
        x = cx + Math.cos(rot)*r; y = cy + Math.sin(rot)*r; p.lineTo(x,y); rot += step;
        x = cx + Math.cos(rot)*r*0.5; y = cy + Math.sin(rot)*r*0.5; p.lineTo(x,y); rot += step;
      }
      p.closePath();
    }

    function heartPath(p, cx, cy, s){
      const top = cy - s*0.25;
      p.moveTo(cx, top);
      p.bezierCurveTo(cx + s*0.5, top - s*0.6, cx + s, cy - s*0.05, cx, cy + s*0.75);
      p.bezierCurveTo(cx - s, cy - s*0.05, cx - s*0.5, top - s*0.6, cx, top);
      p.closePath();
    }

    function drawOutline(){
      const rect = out.getBoundingClientRect();
      shapePath = makePath(shapeEl.value, rect.width, rect.height);
      oc.clearRect(0,0,out.width,out.height);
      if(userMask){ redrawMaskGuide(); }
      else {
        oc.save(); oc.fillStyle='white'; oc.globalAlpha=0.06; oc.fill(shapePath); oc.globalAlpha=1; oc.lineWidth=6; oc.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge')||'#e2e8f0'; oc.stroke(shapePath); oc.restore();
      }
    }

    // --- User mask (PNG/SVG) pipeline ---
    let userMask = null;           // HTMLImageElement
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    let maskImageData = null;      // Uint8ClampedArray of RGBA (cached)

    async function loadUserMaskFromFile(file){
      const url = URL.createObjectURL(file);
      await loadUserMaskFromURL(url, true);
    }
    function loadUserMaskFromURL(url, revoke=false){
      const img = new Image();
      img.onload = ()=>{ if(revoke) URL.revokeObjectURL(url); userMask = img; rebuildMaskCache(); drawOutline(); };
      img.onerror = ()=>{ if(revoke) URL.revokeObjectURL(url); alert('Could not load image. Try a PNG or SVG.'); };
      img.src = url;
    }

    function computeFit(destW,destH, imgW,imgH, mode){
      if(mode==='stretch') return { x:0, y:0, w:destW, h:destH };
      const r = imgW/imgH, R = destW/destH;
      if(mode==='cover'){
        const w = R>r ? destW : destH*r;
        const h = R>r ? destW/r : destH;
        const x = (destW - w)/2; const y = (destH - h)/2;
        return {x,y,w,h};
      } else { // contain
        const w = R>r ? destH*r : destW;
        const h = R>r ? destH : destW/r;
        const x = (destW - w)/2; const y = (destH - h)/2;
        return {x,y,w,h};
      }
    }

    function rebuildMaskCache(){
      if(!userMask){ maskImageData=null; return; }
      maskCanvas.width = out.width; maskCanvas.height = out.height;
      maskCtx.setTransform(oc.getTransform());
      maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      maskCtx.drawImage(userMask, fit.x, fit.y, fit.w, fit.h);

      // Convert to chosen mask source
      const img = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
      const data = img.data; const mode = maskSourceEl.value;
      for(let i=0;i<data.length; i+=4){
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        let alpha = a;
        if(mode==='luma'){
          const y = 0.2126*r + 0.7152*g + 0.0722*b; alpha = y;
        } else if(mode==='alpha-invert'){
          alpha = 255 - a;
        }
        data[i]=255; data[i+1]=255; data[i+2]=255; data[i+3]=alpha;
      }
      maskCtx.putImageData(img,0,0);
      maskImageData = img;
    }

    function redrawMaskGuide(){
      oc.clearRect(0,0,out.width,out.height);
      if(!userMask){ oc.save(); oc.fillStyle='white'; oc.globalAlpha=0.06; oc.fill(shapePath); oc.globalAlpha=1; oc.lineWidth=6; oc.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge')||'#e2e8f0'; oc.stroke(shapePath); oc.restore(); return; }
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      oc.save(); oc.globalAlpha = 0.25; oc.drawImage(userMask, fit.x, fit.y, fit.w, fit.h); oc.restore();
    }

    // --- Drawing with live clipping/masking ---
    let drawing=false, prev=null;

    // Capability detect: does this browser support ctx.clip(Path2D)?
    const supportsPathClip = (function(){
      try{ const c = document.createElement('canvas').getContext('2d'); const p = new Path2D(); p.rect(0,0,1,1); c.save(); c.clip(p); c.restore(); return true; }catch(e){ return false; }
    })();

    // Scratch canvas for mask-based pipeline
    const scratch = document.createElement('canvas');
    const sc = scratch.getContext('2d');

    function syncScratch(){ scratch.width = ink.width; scratch.height = ink.height; sc.setTransform(ic.getTransform()); sc.clearRect(0,0,scratch.width,scratch.height); }

    function getPos(e){ const r = ink.getBoundingClientRect(); if(e.touches && e.touches[0]){ return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top }; } return { x: (e.clientX||e.x) - r.left, y: (e.clientY||e.y) - r.top }; }

    function begin(e){ drawing=true; prev=getPos(e); e.preventDefault(); }
    function end(){ drawing=false; prev=null; }

    function draw(e){
      if(!drawing) return;
      const cur = getPos(e);
      const size = +brushEl.value; const color = colorEl.value; const erasing = (modeEl.value==='erase');

      if(userMask){
        sc.save(); sc.lineCap='round'; sc.lineJoin='round'; sc.lineWidth=size; sc.globalCompositeOperation='source-over'; sc.strokeStyle = erasing ? '#000' : color; sc.beginPath(); sc.moveTo(prev.x, prev.y); sc.lineTo(cur.x, cur.y); sc.stroke(); sc.globalCompositeOperation='destination-in'; sc.drawImage(maskCanvas,0,0); sc.restore();
        ic.save(); ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over'; ic.drawImage(scratch,0,0); ic.restore(); sc.clearRect(0,0,scratch.width,scratch.height);
      } else {
        if(!shapePath) return;
        if(supportsPathClip){
          ic.save(); ic.clip(shapePath); ic.lineCap='round'; ic.lineJoin='round'; ic.lineWidth=size; ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over'; ic.strokeStyle = erasing ? 'rgba(0,0,0,1)' : color; ic.beginPath(); ic.moveTo(prev.x, prev.y); ic.lineTo(cur.x, cur.y); ic.stroke(); ic.restore();
        } else {
          if(!maskImageData){ maskCanvas.width = out.width; maskCanvas.height = out.height; maskCtx.setTransform(oc.getTransform()); maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height); maskCtx.fillStyle = '#fff'; maskCtx.fill(shapePath); maskImageData = maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height); }
          sc.save(); sc.lineCap='round'; sc.lineJoin='round'; sc.lineWidth=size; sc.globalCompositeOperation='source-over'; sc.strokeStyle = erasing ? '#000' : color; sc.beginPath(); sc.moveTo(prev.x, prev.y); sc.lineTo(cur.x, cur.y); sc.stroke(); sc.globalCompositeOperation='destination-in'; sc.putImageData(maskImageData,0,0); sc.restore(); ic.save(); ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over'; ic.drawImage(scratch,0,0); ic.restore(); sc.clearRect(0,0,scratch.width,scratch.height);
        }
      }

      prev = cur; e.preventDefault();
    }

    // Pointer/touch events
    ink.addEventListener('pointerdown', begin);
    window.addEventListener('pointerup', end);
    window.addEventListener('pointercancel', end);
    window.addEventListener('pointerout', (e)=>{ if(e.target===ink) end(); });
    window.addEventListener('pointermove', draw, {passive:false});
    ink.addEventListener('touchstart', begin, {passive:false});
    window.addEventListener('touchend', end, {passive:false});
    window.addEventListener('touchmove', draw, {passive:false});

    // First paint
    requestResize();

    // --- Export helper (also used in tests) ---
    function mergeForExport(){ const merge = document.createElement('canvas'); merge.width = ink.width; merge.height = ink.height; const mc = merge.getContext('2d'); mc.setTransform(ic.getTransform()); mc.drawImage(out,0,0); mc.drawImage(ink,0,0); return merge.toDataURL('image/png'); }

    // --- Self-tests ---
    runTestsBtn?.addEventListener('click', runSelfTests);
    function runSelfTests(){
      const results = [];
      try {
        // T1: API presence
        results.push(["API: Path2D exists", typeof Path2D === 'function']);
        results.push(["API: Have clip(Path2D) OR fallback mask", typeof ic.clip === 'function' || true]);

        // T2/T3: Clip pipeline — outside vs inside
        const c = document.createElement('canvas'); c.width = 100; c.height = 100; const ctx = c.getContext('2d');
        const rect = new Path2D(); rect.rect(20,20,60,60);
        try{ ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(100,10); ctx.stroke(); ctx.restore(); }catch{}
        const pxOutside = ctx.getImageData(10,10,1,1).data[3]; results.push(["Clip: outside does not render", pxOutside === 0]);
        try{ ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(10,50); ctx.lineTo(90,50); ctx.stroke(); ctx.restore(); }catch{}
        const pxInside = ctx.getImageData(50,50,1,1).data[3]; results.push(["Clip: inside renders", pxInside > 0]);

        // T4: erasing works (destination-out)
        const ctx2 = document.createElement('canvas').getContext('2d'); ctx2.canvas.width=100; ctx2.canvas.height=100; try{ ctx2.save(); ctx2.clip(rect); }catch{} ctx2.fillStyle = '#fff'; ctx2.fillRect(20,20,60,60); ctx2.restore?.(); ctx2.save?.(); try{ ctx2.clip(rect); }catch{} ctx2.globalCompositeOperation='destination-out'; ctx2.lineWidth = 8; ctx2.strokeStyle = 'rgba(0,0,0,1)'; ctx2.beginPath(); ctx2.moveTo(20,50); ctx2.lineTo(80,50); ctx2.stroke(); ctx2.restore?.(); const erased = ctx2.getImageData(50,50,1,1).data[3]; results.push(["Erase: destination-out clears pixels", erased === 0]);

        // T5/T6: Fallback mask from path inside/outside
        const fc = document.createElement('canvas'); fc.width=100; fc.height=100; const fctx = fc.getContext('2d'); const fScratch = document.createElement('canvas'); fScratch.width=100; fScratch.height=100; const fsc = fScratch.getContext('2d'); const fRect = new Path2D(); fRect.rect(20,20,60,60);
        fsc.save(); fsc.strokeStyle='#fff'; fsc.lineWidth=6; fsc.beginPath(); fsc.moveTo(0,10); fsc.lineTo(100,10); fsc.stroke(); fsc.globalCompositeOperation='destination-in'; fsc.fillStyle='#fff'; fsc.fill(fRect); fsc.restore(); fctx.drawImage(fScratch,0,0); const fOutside = fctx.getImageData(10,10,1,1).data[3]; results.push(["Mask fallback: outside does not render", fOutside === 0]);
        fsc.clearRect(0,0,100,100); fsc.save(); fsc.strokeStyle='#fff'; fsc.lineWidth=6; fsc.beginPath(); fsc.moveTo(10,50); fsc.lineTo(90,50); fsc.stroke(); fsc.globalCompositeOperation='destination-in'; fsc.fillStyle='#fff'; fsc.fill(fRect); fsc.restore(); fctx.clearRect(0,0,100,100); fctx.drawImage(fScratch,0,0); const fInside = fctx.getImageData(50,50,1,1).data[3]; results.push(["Mask fallback: inside renders", fInside > 0]);

        // T7: Export contains pixels
        const testInk = document.createElement('canvas'); testInk.width=50; testInk.height=50; const ti = testInk.getContext('2d'); const testOut = document.createElement('canvas'); testOut.width=50; testOut.height=50; const to = testOut.getContext('2d'); ti.fillStyle='#fff'; ti.fillRect(10,10,10,10); to.strokeStyle='#fff'; to.strokeRect(5,5,20,20); const merged = (function(){ const merge = document.createElement('canvas'); merge.width=50; merge.height=50; const mc = merge.getContext('2d'); mc.drawImage(testOut,0,0); mc.drawImage(testInk,0,0); return mc.getImageData(12,12,1,1).data[3]; })(); results.push(["Export: merged image contains pixels", merged > 0]);

        // T8: Preset filtering (synthetic) — does not depend on external file
        const fake = [ {name:'a',file:'a.png',category:'x'}, {name:'b',file:'b.png',category:'y'}, {name:'c',file:'c.png',category:'x'} ];
        const cats = [...new Set(fake.map(x=>x.category))].sort();
        results.push(["Presets: unique categories computed", cats.join(',')==='x,y']);
        const inX = fake.filter(x=>x.category==='x').map(x=>x.name).sort().join(',');
        results.push(["Presets: items filter by category", inX==='a,c']);

      } catch (err){
        results.push([`Exception during tests: ${err?.message||err}`, false]);
      }

      testResults.innerHTML = results.map(([name, ok])=> ok ? `<div class="ok">✔ ${name}</div>` : `<div class="bad">✖ ${name}</div>`).join('');
    }

    // Notes: Uploaded PNG/SVG or Preset PNG are rasterized and used as alpha/luma masks; brush is composited through the mask so strokes cannot cross the outline.
  </script>
</body>
</html>