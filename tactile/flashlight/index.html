<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-fr="Lampe torche tactile" data-en="Touch flashlight" data-ja="タッチ懐中電灯">Lampe torche tactile</title>
  <link rel="stylesheet" href="../../css/global.css">
  <style>
    :root {
      --ui-bg: rgba(10, 10, 14, 0.82);
      --ui-border: rgba(255, 255, 255, 0.18);
      --ui-text: #fff;
      --found: #8af58a;
      --radius: 150px;
      --overlay-darkness: 0.99;
    }

    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      font-family: Arial, sans-serif;
      color: var(--ui-text);
    }

    .scene {
      position: relative;
      width: 100%;
      height: 100%;
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
      isolation: isolate;
      filter: brightness(0.55);
    }

    .picto {
      position: absolute;
      width: clamp(54px, 6.5vw, 110px);
      height: auto;
      object-fit: contain;
      pointer-events: none;
      filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.55));
      opacity: 0;
      transition: opacity 180ms ease;
    }

    .picto.found {
      opacity: 1;
    }

    .picto.pop-reveal {
      animation: popReveal 420ms ease-out;
    }

    @keyframes popReveal {
      0% {
        transform: scale(0.55) rotate(-6deg);
        filter: drop-shadow(0 0 0 rgba(138, 245, 138, 0));
      }
      55% {
        transform: scale(1.22) rotate(3deg);
        filter: drop-shadow(0 0 20px rgba(138, 245, 138, 0.85));
      }
      100% {
        transform: scale(1) rotate(0deg);
        filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.55));
      }
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle var(--radius) at var(--x, 50%) var(--y, 50%),
          rgba(0, 0, 0, 0) 0%,
          rgba(0, 0, 0, 0.58) 48%,
          rgba(0, 0, 0, calc(var(--overlay-darkness) - 0.02)) 68%,
          rgba(0, 0, 0, var(--overlay-darkness)) 100%);
    }

    .ui {
      position: absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      z-index: 2;
      pointer-events: none;
    }

    .panel {
      background: var(--ui-bg);
      border: 1px solid var(--ui-border);
      border-radius: 12px;
      padding: 10px 14px;
      line-height: 1.35;
      max-width: min(540px, 82vw);
      backdrop-filter: blur(2px);
    }

    .counter {
      font-weight: bold;
      white-space: nowrap;
    }

    .counter.done { color: var(--found); }

    .controls {
      position: absolute;
      bottom: 14px;
      left: 14px;
      display: flex;
      gap: 8px;
      z-index: 3;
    }

    button {
      border: 1px solid var(--ui-border);
      border-radius: 999px;
      background: var(--ui-bg);
      color: var(--ui-text);
      padding: 10px 14px;
      cursor: pointer;
      font-size: 0.95rem;
    }

    .celebration {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      z-index: 4;
    }

    .celebration.show {
      animation: bigCelebrate 1.3s ease-out;
    }

    @keyframes bigCelebrate {
      0% {
        opacity: 0;
        transform: scale(0.95);
      }
      20% {
        opacity: 1;
      }
      45% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: scale(1.06);
      }
    }

    .celebration::before {
      content: '';
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.58), transparent 34%),
        radial-gradient(circle at 78% 28%, rgba(138, 245, 138, 0.56), transparent 35%),
        radial-gradient(circle at 50% 74%, rgba(0, 200, 255, 0.48), transparent 40%);
    }

    .celebration::after {
      content: '✨ Bravo! ✨';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: clamp(2rem, 7vw, 4.6rem);
      font-weight: 700;
      text-shadow: 0 0 22px rgba(255, 255, 255, 0.95), 0 0 40px rgba(138, 245, 138, 0.95);
      letter-spacing: 0.06em;
    }

    @media (max-width: 700px) {
      .ui { flex-direction: column; }
      .panel { max-width: 100%; }
    }
  </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
<body>
  <main id="scene" class="scene" aria-label="flashlight discovery scene">
    <div class="ui">
      <div class="panel" id="instruction"
        data-fr="Déplace ton doigt (ou la souris) pour éclairer la scène et trouver les animaux cachés."
        data-en="Move your finger (or mouse) to light up the scene and find hidden animals."
        data-ja="指（またはマウス）を動かして、シーンを照らし、隠れた動物を見つけましょう。">
        Déplace ton doigt (ou la souris) pour éclairer la scène et trouver les animaux cachés.
      </div>
      <div class="panel counter" id="counter">0 / 0</div>
    </div>
    <div class="overlay" id="overlay"></div>
    <div class="celebration" id="celebration"></div>
    <div class="controls">
      <button id="resetBtn"
        data-fr="Nouvelle partie"
        data-en="New round"
        data-ja="新しいラウンド">Nouvelle partie</button>
      <button id="backBtn"
        data-fr="Retour"
        data-en="Back"
        data-ja="戻る">Retour</button>
    </div>
  </main>

  <script src="../../js/translationmain.js"></script>
  <script>
    const scene = document.getElementById('scene');
    const counterEl = document.getElementById('counter');
    const resetBtn = document.getElementById('resetBtn');
    const backBtn = document.getElementById('backBtn');
    const celebrationEl = document.getElementById('celebration');

    const sceneConfig = {
      keyword: 'african',
      category: 'animaux',
      pictoCount: 8
    };

    let hiddenItems = [];
    let celebrationTimeout = null;

    function setLightPosition(clientX, clientY) {
      const rect = scene.getBoundingClientRect();
      const x = ((clientX - rect.left) / rect.width) * 100;
      const y = ((clientY - rect.top) / rect.height) * 100;
      scene.style.setProperty('--x', `${Math.max(0, Math.min(100, x))}%`);
      scene.style.setProperty('--y', `${Math.max(0, Math.min(100, y))}%`);
      revealHitItems(clientX, clientY, rect);
    }

    function shuffle(arr) {
      return [...arr].sort(() => Math.random() - 0.5);
    }

    function getRandomBetween(min, max) {
      return Math.random() * (max - min) + min;
    }

    async function loadSceneData() {
      const pictosRes = await fetch('../../images/pictos/index.json');
      const pictosData = await pictosRes.json();
      return { pictosData };
    }

    function findBackgroundName(keyword) {
      const lowerKeyword = keyword.toLowerCase();
      const backgroundFiles = [
        'africanbackground1.webp',
        'africanbackground2.webp',
        'africanbackground3.webp',
        'moana-background.jpg',
        'rocket/rocketbackground.png'
      ];
      const matching = backgroundFiles.filter((file) => file.toLowerCase().includes(lowerKeyword));
      return matching[0] || backgroundFiles[0];
    }

    function drawItems(items, basePath) {
      document.querySelectorAll('.picto').forEach((el) => el.remove());
      hiddenItems = [];

      for (const item of items) {
        const img = document.createElement('img');
        img.className = 'picto';
        img.src = `${basePath}${item.file}`;
        img.alt = item.name?.fr || item.file;
        img.style.left = `${getRandomBetween(8, 84)}%`;
        img.style.top = `${getRandomBetween(15, 83)}%`;
        img.dataset.found = 'false';
        scene.appendChild(img);

        hiddenItems.push({
          el: img,
          found: false
        });
      }

      updateCounter();
    }

    function revealHitItems(clientX, clientY, rect) {
      const radiusPx = 145;
      let foundSomething = false;

      hiddenItems.forEach((entry) => {
        if (entry.found) return;

        const r = entry.el.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2;
        const dx = cx - clientX;
        const dy = cy - clientY;
        const dist = Math.hypot(dx, dy);

        if (dist <= radiusPx * 0.86) {
          entry.found = true;
          entry.el.classList.add('found');
          entry.el.classList.remove('pop-reveal');
          void entry.el.offsetWidth;
          entry.el.classList.add('pop-reveal');
          entry.el.style.outline = '4px solid rgba(138, 245, 138, 0.95)';
          entry.el.style.borderRadius = '10px';
          foundSomething = true;
        }
      });

      if (foundSomething) updateCounter();

      const found = hiddenItems.filter((item) => item.found).length;
      if (found === hiddenItems.length && hiddenItems.length > 0) {
        counterEl.classList.add('done');
        triggerBigCelebration();
      }
    }

    function triggerBigCelebration() {
      if (!celebrationEl) return;
      celebrationEl.classList.remove('show');
      void celebrationEl.offsetWidth;
      celebrationEl.classList.add('show');
      if (celebrationTimeout) clearTimeout(celebrationTimeout);
      celebrationTimeout = setTimeout(() => {
        celebrationEl.classList.remove('show');
      }, 1300);
    }

    function updateCounter() {
      const found = hiddenItems.filter((item) => item.found).length;
      counterEl.textContent = `${found} / ${hiddenItems.length}`;
      counterEl.classList.toggle('done', found === hiddenItems.length && hiddenItems.length > 0);
    }

    async function initRound() {
      const { pictosData } = await loadSceneData();
      const background = findBackgroundName(sceneConfig.keyword);
      scene.style.backgroundImage = background ? `url(../../images/${background})` : 'none';

      const allCategoryItems = pictosData?.categories?.[sceneConfig.category]?.items || [];
      const availableItems = allCategoryItems.filter((item) => item?.file);
      const chosenItems = shuffle(availableItems).slice(0, sceneConfig.pictoCount);

      drawItems(chosenItems, pictosData.base || '../../images/pictos/');
      celebrationEl?.classList.remove('show');
    }

    scene.addEventListener('pointermove', (event) => {
      setLightPosition(event.clientX, event.clientY);
    });

    scene.addEventListener('pointerdown', (event) => {
      setLightPosition(event.clientX, event.clientY);
    });

    scene.addEventListener('touchmove', (event) => {
      if (!event.touches[0]) return;
      setLightPosition(event.touches[0].clientX, event.touches[0].clientY);
    }, { passive: true });

    resetBtn.addEventListener('click', () => {
      initRound();
    });

    backBtn.addEventListener('click', () => {
      window.location.href = '../index.html';
    });

    document.addEventListener('DOMContentLoaded', async () => {
      await initRound();
      if (typeof applyTranslations === 'function') {
        applyTranslations(localStorage.getItem('language') || 'fr');
      }
    });
  </script>
</body>
</html>
