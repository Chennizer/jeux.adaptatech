<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Samurai Focus — Ki Ball (Opaque + Small Halo + Crescendo)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #game { display:block; width:100vw; height:100vh; cursor: crosshair; background:#000; }
    #startOverlay { position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(0,0,0,0.75); z-index:10; }
    #startBtn { padding:14px 22px; border:2px solid #6ad1c9; color:#6ad1c9; background:#000;
      border-radius:12px; font-size:18px; font-weight:700; box-shadow:0 6px 24px rgba(0,0,0,.25); cursor:pointer; }
    #startBtn:active{ transform:translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay"><button id="startBtn">Start • Fullscreen</button></div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       PLACEHOLDER ASSETS
    ======================= */
    const BG_SRC     = "../../images/samurai/lampbg.png";
    const PETAL_SRC  = "../../images/samurai/cherryblossom.png";
    const TARGET_SRC = "../../images/samurai/litlamp1.png";
    const SFX_RELEASE= "../../sounds/blade.mp3";
    const SFX_IMPACT = "../../sounds/gong.mp3";

    /* =======================
       TUNABLES
    ======================= */
    // Dwell: 100px → 200px over 2s
    const MIN_DIAMETER = 100;
    const MAX_DIAMETER = 200;
    const DWELL_MS     = 2000;
    const MAX_JITTER_PX= 26;
    const DECAY_PER_SEC= 0.5;
    const ENTRY_GRACE_MS = 200;

    // Launch (ball flies; no ray)
    const LAUNCH_SPEED_X = 950;
    const LAUNCH_SPEED_Y = -120;
    const GRAVITY_Y      = 520;

    // Trail (faint echoes; main ball stays opaque)
    const TRAIL_SEGMENTS = 14;
    const TRAIL_ALPHA    = 0.10;

    // Ball look (solid + small halo)
    const BALL_RGB       = "120,220,210";
    const RIM_ALPHA      = 0.15;
    const HALO_INNER_MULT = 1.00;
    const HALO_OUTER_MULT = 1.12; // ~6% of diameter outside the edge
    const HALO_ALPHA      = 0.25;
    const HALO_TRAIL_ALPHA= 0.18;

    // Local jitter only
    const ORB_SHAKE_MAX  = 8;
    const ORB_SHAKE_FX   = 23, ORB_SHAKE_FY = 17;

    // Target & impact/reset
    const TARGET_MIN_X_FRAC = 0.62, TARGET_MAX_X_FRAC = 0.82, TARGET_Y_FRAC = 0.56;
    const RESET_DELAY_MS    = 1400;
    const IMPACT_PETALS     = 150;
    const IMPACT_SPEED      = 420;
    const IMPACT_LIFE       = 1.8;
    const SHOCKWAVE_MAX_R   = 260;
    const FLASH_MAX_ALPHA   = 0.75;

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    const bgImg     = new Image(); bgImg.src = BG_SRC;
    const petalImg  = new Image(); petalImg.src = PETAL_SRC;
    const targetImg = new Image(); targetImg.src = TARGET_SRC;

    const sfxRelease= new Audio(SFX_RELEASE); sfxRelease.volume = 0.7;
    const sfxImpact = new Audio(SFX_IMPACT);  sfxImpact.volume  = 0.75;
    function play(a){ try{ a.currentTime = 0; a.play(); }catch(_){} }

    function resize(){
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      focusCx = W*0.28; focusCy = H*0.64; // “hands” position
      placeTarget();
    }
    window.addEventListener('resize', resize);

    // Pointer / eye-gaze
    const pointer = { x:-9999, y:-9999, px:-9999, py:-9999, moved:0, inside:false };
    canvas.addEventListener('pointermove', e=>{
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top ) * (canvas.height / r.height);
      if (pointer.px !== -9999) pointer.moved = Math.hypot(x-pointer.px, y-pointer.py);
      pointer.x=x; pointer.y=y; pointer.px=x; pointer.py=y; pointer.inside=true;
    });
    canvas.addEventListener('pointerleave', ()=> pointer.inside=false);

    const rand = (a,b)=>a+Math.random()*(b-a);

    /* =======================
       AUDIO (WebAudio) — charging hum with crescendo
    ======================= */
    let audioCtx=null, masterGain=null;
    let chargeGain=null, filter=null, osc1=null, osc2=null, osc1Gain=null, osc2Gain=null;

    function setupAudio(){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(audioCtx.destination);

      // Two oscillators blended, through a lowpass filter → charging tone
      osc1 = audioCtx.createOscillator(); osc1.type = 'sawtooth'; osc1.frequency.value = 90;
      osc2 = audioCtx.createOscillator(); osc2.type = 'triangle';  osc2.frequency.value = 180;

      osc1Gain = audioCtx.createGain(); osc1Gain.gain.value = 0.35;
      osc2Gain = audioCtx.createGain(); osc2Gain.gain.value = 0.25;

      filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 600; filter.Q.value = 0.7;

      chargeGain = audioCtx.createGain(); chargeGain.gain.value = 0.0; // we’ll ramp this with charge

      osc1.connect(osc1Gain); osc2.connect(osc2Gain);
      osc1Gain.connect(filter); osc2Gain.connect(filter);
      filter.connect(chargeGain); chargeGain.connect(masterGain);

      osc1.start(); osc2.start();
    }

    function updateChargeSound(active){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;

      if (active){
        // Gain rises nonlinearly with charge; smooth with setTargetAtTime
        const gTarget = 0.05 + 0.55*Math.pow(charge01, 1.2);
        chargeGain.gain.setTargetAtTime(gTarget, t, 0.06);

        // Pitch glide & filter opening as charge builds
        const f1 = 90  + (240-90)  * charge01;   // 90 → 240 Hz
        const f2 = 180 + (520-180) * charge01;   // 180 → 520 Hz
        const ff = 700 + (4200-700)* charge01;   // lowpass opens

        osc1.frequency.setTargetAtTime(f1, t, 0.05);
        osc2.frequency.setTargetAtTime(f2, t, 0.05);
        filter.frequency.setTargetAtTime(ff, t, 0.08);
      } else {
        // Fade out quickly when not charging
        chargeGain.gain.setTargetAtTime(0.0001, t, 0.08);
      }
    }

    function punchAndSilenceChargeSound(){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      // quick bump then cut
      const cur = chargeGain.gain.value;
      chargeGain.gain.setValueAtTime(cur, t);
      chargeGain.gain.exponentialRampToValueAtTime(Math.max(0.001, cur*1.5), t+0.05);
      chargeGain.gain.exponentialRampToValueAtTime(0.0001, t+0.15);
      // brief filter sweep for satisfying “lift”
      filter.frequency.cancelScheduledValues(t);
      filter.frequency.setTargetAtTime(6000, t, 0.03);
    }

    /* =======================
       STATE
    ======================= */
    let started=false, lastT=performance.now();

    // Focus & charge
    let focusCx=W*0.28, focusCy=H*0.64;
    let charge01=0, inZone=false, enterMs=0, locked=false;
    const diameterFromCharge = ()=> MIN_DIAMETER + (MAX_DIAMETER - MIN_DIAMETER)*charge01;
    const radiusFromCharge   = ()=> diameterFromCharge()*0.5;

    // Projectile (ball)
    let proj=null; // {x,y,vx,vy,r,trail:[{x,y,r,a}]}

    // Target
    let target={x:0,y:0,w:0,h:0};
    function placeTarget(){
      const fx = rand(TARGET_MIN_X_FRAC, TARGET_MAX_X_FRAC);
      target.w = Math.min(220, W*0.14);
      const aspect=(targetImg.naturalWidth||1)/(targetImg.naturalHeight||1);
      target.h = target.w / aspect;
      target.x = W*fx;
      target.y = H*TARGET_Y_FRAC;
    }
    placeTarget();

    // Impact FX
    const shards=[]; // {x,y,w,h,ang,vx,vy,rot,born,life}
    function spawnImpactBurst(cx,cy){
      const tBorn=performance.now()/1000;
      for (let i=0;i<IMPACT_PETALS;i++){
        const a = Math.random()*Math.PI*2;
        const sp= IMPACT_SPEED*(0.4+0.6*Math.random());
        const size=rand(24,72);
        shards.push({
          x:cx, y:cy, w:size, h:size, ang:rand(-Math.PI,Math.PI),
          vx:Math.cos(a)*sp, vy:Math.sin(a)*sp - rand(60,120),
          rot:rand(-1.6,1.6), born:tBorn, life:IMPACT_LIFE
        });
      }
    }
    let flashT=0, flashLife=0, flashMax=FLASH_MAX_ALPHA;
    let shockT=0, shockLife=0, shockX=0, shockY=0;
    function triggerFlash(a=FLASH_MAX_ALPHA, life=0.18){ flashT=0; flashLife=life; flashMax=a; }
    function triggerShockwave(cx,cy,life=0.9){ shockT=0; shockLife=life; shockX=cx; shockY=cy; }

    let resetAtMs=0;

    /* =======================
       LOGIC
    ======================= */
    function inBall(x,y,r){ return Math.hypot(x-focusCx, y-focusCy) <= r; }

    function update(dt){
      // Charging
      let isChargingAudibly = false;

      if (!proj && !resetAtMs){
        const r = radiusFromCharge();
        const inside = pointer.inside && inBall(pointer.x, pointer.y, r);
        const stable = pointer.moved <= MAX_JITTER_PX;

        if (inside){
          if (!inZone){ inZone=true; enterMs=performance.now(); }
          const graceOk = (performance.now() - enterMs) >= ENTRY_GRACE_MS;
          if (graceOk && stable){
            charge01 = Math.min(1, charge01 + dt*(1000/DWELL_MS));
            isChargingAudibly = true;
            if (charge01 >= 1 && !locked){
              locked = true;
              proj = { x:focusCx, y:focusCy, vx:LAUNCH_SPEED_X, vy:LAUNCH_SPEED_Y, r:radiusFromCharge(), trail:[] };
              punchAndSilenceChargeSound();
              play(sfxRelease);
            }
          } else if (!locked){
            charge01 = Math.max(0, charge01 - DECAY_PER_SEC*dt);
          }
        } else {
          inZone=false;
          if (!locked) charge01 = Math.max(0, charge01 - DECAY_PER_SEC*dt);
        }
      }

      updateChargeSound(isChargingAudibly);

      // Projectile flight
      if (proj){
        proj.vy += GRAVITY_Y * dt;
        proj.x  += proj.vx * dt;
        proj.y  += proj.vy * dt;

        // trail (faint; doesn’t affect main ball opacity)
        proj.trail.push({ x:proj.x, y:proj.y, r:proj.r, a:1 });
        if (proj.trail.length > TRAIL_SEGMENTS) proj.trail.shift();
        for (const t of proj.trail) t.a *= 0.9;

        // circle vs AABB collision
        const cx = Math.max(target.x - target.w/2, Math.min(proj.x, target.x + target.w/2));
        const cy = Math.max(target.y - target.h/2, Math.min(proj.y, target.y + target.h/2));
        const hit = ((proj.x - cx)**2 + (proj.y - cy)**2) <= (proj.r*proj.r);

        if (hit){
          spawnImpactBurst(target.x, target.y);
          play(sfxImpact);
          triggerFlash();
          triggerShockwave(target.x, target.y);
          proj = null;
          resetAtMs = performance.now() + RESET_DELAY_MS;
          locked = false;
        }

        // off-screen → reset
        if (proj && (proj.x - proj.r > W + 100 || proj.y - proj.r > H + 100 || proj.y + proj.r < -100)){
          proj = null;
          resetAtMs = performance.now() + 800;
          locked = false;
        }
      }

      // Impact shards
      const now = performance.now()/1000;
      for (let i=shards.length-1;i>=0;i--){
        const s=shards[i];
        s.x += s.vx*dt; s.y += s.vy*dt; s.vy += 360*dt; s.ang += s.rot*dt;
        if (now - s.born > s.life) shards.splice(i,1);
      }

      // FX timers
      if (flashLife>0){ flashT+=dt; if (flashT>=flashLife) flashLife=0; }
      if (shockLife>0){ shockT+=dt; if (shockT>=shockLife) shockLife=0; }

      // Re-arm
      if (resetAtMs && performance.now() >= resetAtMs){
        resetAtMs = 0;
        charge01  = 0;
        placeTarget();
      }
    }

    /* =======================
       RENDER
    ======================= */
    function drawBackground(){
      if (bgImg.complete && bgImg.naturalWidth>0){
        const iw=bgImg.width, ih=bgImg.height;
        const scale=Math.max(W/iw, H/ih);
        ctx.drawImage(bgImg, (W-iw*scale)/2, (H-ih*scale)/2, iw*scale, ih*scale);
      } else {
        ctx.fillStyle="#041017"; ctx.fillRect(0,0,W,H);
      }
    }

    function orbJitter(){
      const t = performance.now()/1000;
      const amp = ORB_SHAKE_MAX * Math.pow(charge01, 1.2);
      const ox = Math.sin(t*ORB_SHAKE_FX*2*Math.PI + 0.31) * amp;
      const oy = Math.cos(t*ORB_SHAKE_FY*2*Math.PI + 1.13) * amp * 0.8;
      return [ox, oy];
    }

    function drawSmallHalo(cx, cy, r, alpha=HALO_ALPHA){
      const inner = r*HALO_INNER_MULT, outer = r*HALO_OUTER_MULT;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(cx, cy, inner, cx, cy, outer);
      g.addColorStop(0, `rgba(${BALL_RGB},${alpha})`);
      g.addColorStop(1, `rgba(${BALL_RGB},0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, outer, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // Fully opaque sphere (no inner white circle)
    function drawSolidBall(cx, cy, r, withRim=true){
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = `rgb(${BALL_RGB})`;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      if (withRim){
        ctx.strokeStyle = `rgba(255,255,255,${RIM_ALPHA})`;
        ctx.lineWidth = Math.max(1, r*0.02);
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    }

    function drawChargingBall(){
      const r = radiusFromCharge();
      const [ox, oy] = orbJitter();
      const cx = focusCx + ox, cy = focusCy + oy;
      drawSolidBall(cx, cy, r, true);
      drawSmallHalo(cx, cy, r, HALO_ALPHA);
    }

    function drawProjectile(){
      if (!proj) return;
      // trail ghosts (small halo + faint body)
      ctx.save(); ctx.globalCompositeOperation = 'source-over';
      for (let i=0;i<proj.trail.length;i++){
        const t = proj.trail[i];
        if (t.a <= 0.02) continue;
        ctx.globalAlpha = TRAIL_ALPHA * t.a;
        drawSolidBall(t.x, t.y, t.r*0.9, false);
        drawSmallHalo(t.x, t.y, t.r*0.9, HALO_TRAIL_ALPHA * t.a);
      }
      ctx.restore();
      ctx.globalAlpha = 1;

      // main ball (opaque) + small halo
      drawSolidBall(proj.x, proj.y, proj.r, true);
      drawSmallHalo(proj.x, proj.y, proj.r, HALO_ALPHA);
    }

    function drawTarget(){
      if (!targetImg.complete) return;
      ctx.drawImage(targetImg, target.x - target.w/2, target.y - target.h/2, target.w, target.h);
    }

    function drawShards(){
      const t=performance.now()/1000;
      for (const s of shards){
        const a = Math.max(0, 1 - (t - s.born)/s.life);
        ctx.save(); ctx.globalAlpha = a;
        ctx.translate(s.x, s.y); ctx.rotate(s.ang);
        ctx.drawImage(petalImg, -s.w/2, -s.h/2, s.w, s.h);
        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }

    function drawFlash(){
      if (flashLife<=0) return;
      const p = Math.min(1, flashT/flashLife);
      const a = flashMax * (1 - p);
      if (a <= 0.01) return;
      ctx.save(); ctx.fillStyle = `rgba(255,255,255,${a})`; ctx.fillRect(0,0,W,H); ctx.restore();
    }

    function drawShockwave(){
      if (shockLife<=0) return;
      const p = Math.min(1, shockT/shockLife);
      const r = SHOCKWAVE_MAX_R*p;
      const a = 0.35*(1-p);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,255,255,${a})`;
      ctx.lineWidth = 6*(1-p);
      ctx.beginPath(); ctx.arc(shockX, shockY, r, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    function render(){
      drawBackground();
      drawTarget();
      if (!proj) drawChargingBall();
      drawProjectile();
      drawShards();
      drawShockwave();
      drawFlash();
    }

    /* =======================
       MAIN LOOP
    ======================= */
    function tick(tMs){
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT)/1000);
      lastT = tMs;
      update(dt);
      render();
      requestAnimationFrame(tick);
    }

    /* =======================
       START
    ======================= */
    const startOverlay=document.getElementById('startOverlay');
    const startBtn=document.getElementById('startBtn');

    async function enterFullscreen(){
      const el=document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    }

    startBtn.addEventListener('click', async ()=>{
      try{ await enterFullscreen(); }catch(e){}
      startOverlay.style.display='none';
      started = true;
      resize();

      // Init audio on user gesture
      try { setupAudio(); await audioCtx.resume(); } catch(e){ /* ignore */ }

      // ensure images then start
      let pending = 0;
      const tryStart = ()=>{ if (--pending<=0) requestAnimationFrame(tick); };
      [bgImg, petalImg, targetImg].forEach(im=>{ if (!im.complete){ pending++; im.onload=tryStart; }});
      if (pending===0) requestAnimationFrame(tick);
    });
  })();
  </script>
</body>
</html>
