<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title class="translate" data-fr="Fluid" data-en="Fluid" data-ja="フルイド">Fluid</title>
  <!-- Use your existing styling system (exact same classes / colors) -->
  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    /* Canvas stage hidden until Start */
    #stage {
      position: fixed;
      inset: 0;
      display: none;
      background: #000;
      z-index: 1;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none; /* prevents browser gestures interfering with touch splats */
    }

    /* Lang toggle (same styling you use elsewhere) */
    #langToggle {
      position: fixed;
      top: 10px; right: 10px;
      z-index: 99999;
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 10px; border: 2px solid #009688;
      background: #fff; color: #009688; font-weight: 700; cursor: pointer;
      user-select: none;
    }

    /* Simple gaze pointer (kept compatible with your controls) */
    .hide-native-cursor, .hide-native-cursor * { cursor: none !important; }

    #gazePointer {
      position: fixed;
      left: -100px; top: -100px;
      width: var(--gp-size, 36px);
      height: var(--gp-size, 36px);
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 2147483647;
      opacity: 0;
      transition: opacity 120ms linear;
    }
    #gazePointer::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: rgba(255, 0, 0, 0.85);
    }
    #gazePointer.gp-dwell::before {
      animation: gpPulse 650ms ease-in-out infinite;
    }
    @keyframes gpPulse {
      0%, 100% { transform: scale(1); }
      50%      { transform: scale(1.12); }
    }

    /* Note modal */
    .note-modal {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .note-modal__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.5);
      cursor: pointer;
    }
    .note-modal__dialog {
      position: relative;
      background: #fff;
      padding: 16px;
      border-radius: 12px;
      width: min(80vw, 520px);
      max-width: 90vw;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .note-modal__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .note-modal__close {
      background: transparent;
      border: none;
      font-size: 22px;
      cursor: pointer;
      line-height: 1;
    }
    .note-modal__body { display: flex; }
    .note-modal__text {
      width: 100%;
      min-height: 220px;
      padding: 8px;
      font-size: 16px;
      border: 2px solid #009688;
      border-radius: 10px;
      background: #f8f8f8;
      color: #111;
      display: flex;
      align-items: flex-start;
    }
  </style>
</head>

<body>
<button id="langToggle" title="Basculer la langue / Toggle language">EN</button>

<!-- MENU (3 columns, pointer options in RIGHT column) -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title" class="translate"
        data-fr="Fluides"
        data-en="Fluids"
        data-ja="フルイド">Fluid</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Left column (visual mode) -->
      <div class="options-column">
        <div class="option-item">
          <label for="monoColorSelect" class="teal-label">
            <span class="translate" data-fr="Couleur " data-en="Color" data-ja="色">Mode monochrome</span>
          </label>
          <select id="monoColorSelect" class="styled-select">
            <option value="normal" class="translate" data-fr="Multicolore" data-en="Multicolor" data-ja="マルチカラー">Normal</option>
            <option value="white" class="translate" data-fr="Blanc" data-en="White" data-ja="白">Blanc</option>
            <option value="red" class="translate" data-fr="Rouge" data-en="Red" data-ja="赤">Rouge</option>
            <option value="blue" class="translate" data-fr="Bleu" data-en="Blue" data-ja="青">Bleu</option>
            <option value="green" class="translate" data-fr="Vert" data-en="Green" data-ja="緑">Vert</option>
            <option value="yellow" class="translate" data-fr="Jaune" data-en="Yellow" data-ja="黄">Jaune</option>
            <option value="purple" class="translate" data-fr="Violet" data-en="Purple" data-ja="紫">Violet</option>
            <option value="pink" class="translate" data-fr="Rose" data-en="Pink" data-ja="ピンク">Rose</option>
          </select>
        </div>
        
        <div class="option-item">
          <button id="openNoteModal" class="button translate" data-fr="Note" data-en="Note" data-ja="メモを開く">Ouvrir une note</button>
        </div>
      </div>

      <!-- Middle column (intensity) -->
      <div class="options-column">
        <div class="option-item">
          <label for="intensitySlider" class="teal-label">
            <span class="translate" data-fr="Intensité" data-en="Intensity" data-ja="強さ">Intensité</span> :
            <span id="intensityVal">1.0</span>
          </label>
          <input type="range" id="intensitySlider" class="styled-slider" min="0.5" max="2" step="0.1" value="1">
        </div>
        <div class="option-item">
          <label for="qualitySlider" class="teal-label">
            <span class="translate" data-fr="Qualité" data-en="Quality" data-ja="品質">Qualité</span> :
            <span id="qualityVal">1.0</span>
          </label>
          <input type="range" id="qualitySlider" class="styled-slider" min="0.6" max="1.6" step="0.05" value="1">
        </div>
      </div>

      <!-- Right column (pointer options ONLY, as requested) -->
      <div class="options-column">
        <div class="option-item gp-compact">
          <label class="teal-label">
            <input type="checkbox" id="showGazePointer" checked>
            <span class="translate"
                  data-fr="Afficher le pointeur (cache la souris)"
                  data-en="Show pointer (hide mouse cursor)"
                  data-ja="ポインターを表示（マウスカーソルを非表示）">
              Afficher le pointeur (cache la souris)
            </span>
          </label>

          <details id="gpDetails">
            <summary class="gp-summary">
              <span class="translate"
                    data-fr="Options avancées du pointeur"
                    data-en="Advanced pointer options"
                    data-ja="ポインターの詳細設定">
                Options avancées du pointeur
              </span>
            </summary>

            <div class="gp-advanced">
              <div class="gp-row">
                <label for="gazeSize" class="teal-label gp-label">
                  <span class="translate" data-fr="Taille" data-en="Size" data-ja="サイズ">Taille</span>:
                  <span id="gazeSizeVal">36</span> px
                </label>
                <input type="range" id="gazeSize" class="styled-slider gp-range" min="16" max="120" step="2" value="36">
              </div>

              <div class="gp-row">
                <label for="gazeOpacity" class="teal-label gp-label">
                  <span class="translate" data-fr="Opacité" data-en="Opacity" data-ja="不透明度">Opacité</span>:
                  <span id="gazeOpacityVal">100</span>%
                </label>
                <input type="range" id="gazeOpacity" class="styled-slider gp-range" min="20" max="100" step="5" value="100">
              </div>
            </div>
          </details>
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
  </div>
</div>

<!-- Stage -->
<div id="stage">
  <canvas id="c"></canvas>
</div>

<!-- Pointer overlay element -->
<div id="gazePointer" aria-hidden="true"></div>

<!-- Blank note modal -->
<div id="noteModal" class="note-modal" role="dialog" aria-modal="true" aria-labelledby="noteModalTitle" style="display:none;">
  <div class="note-modal__backdrop" data-close-note></div>
    <div class="note-modal__dialog">
      <div class="note-modal__header">
        <h3 id="noteModalTitle" class="translate" data-fr="Note " data-en="Note" data-ja="メモ">Note</h3>
        <button type="button" class="note-modal__close" id="closeNoteModal" aria-label="Fermer / Close">×</button>
      </div>
      <div class="note-modal__body">
        <p class="note-modal__text translate"
           data-fr="Cette page est directement inspirée et utilise le code de base de PavelDoGreat (https://github.com/PavelDoGreat/WebGL-Fluid-Simulation) qui en donne la permission avec la license MIT. Le projet original était utilisé avec les utilisateurs de contrôles oculaires, cependant, elle n'était pas conçue pour cela. Donc, elle a été simplifiée et optimisée pour être utilisée avec les utilisateurs de contrôle oculaire (nouvelles options, activation sans clic de souris). Toutes suggestions pour améliorations sont bienvenues. "
           data-en="This page is directly inspired by, and uses the core code from, PavelDoGreat (https://github.com/PavelDoGreat/WebGL-Fluid-Simulation), which is permitted under the MIT License. The original project was used with eye-gaze users; however, it was not designed for that purpose. It has therefore been simplified and optimized for eye-gaze use (new options, activation without mouse clicks). Suggestions for improvements are welcome."
           data-ja="このページは PavelDoGreat のプロジェクト（https://github.com/PavelDoGreat/WebGL-Fluid-Simulation）に直接着想を得ており、MIT ライセンスのもとで提供されている基礎コードを使用しています。元のプロジェクトは視線入力ユーザーにも使われていましたが、その用途向けに設計されていたわけではありません。そのため、本ページでは視線入力で使いやすいように簡略化・最適化しています（新しいオプション、マウスクリックなしでの操作）。改善提案は歓迎します。">
          Texte de la note
        </p>
      </div>
    </div>
  </div>


  <script>

    const LS_LANG_KEY = 'siteLanguage';
    const languages = ['fr', 'en', 'ja'];
    const languageLabels = { fr: 'FR', en: 'EN', ja: '日本語' };
    const langToggle = document.getElementById('langToggle');

    function getLang(){
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr' || saved === 'ja') return saved;
      } catch(e){}

      return (['en','fr','ja'].includes(document.documentElement.lang)) ? document.documentElement.lang : 'fr';
    }

    function updateLangToggleLabel(current){
      if (!langToggle) return;

      const currentIndex = languages.indexOf(current);
      const safeIndex = currentIndex >= 0 ? currentIndex : 0;
      const next = languages[(safeIndex + 1) % languages.length];
      const label = languageLabels[next] || next.toUpperCase();

      langToggle.textContent = label;
      langToggle.setAttribute('aria-label', `Switch language (${label})`);
      langToggle.classList.toggle('lang-ja-label', next === 'ja');
    }

    function setLang(lang){
      const safe = (lang === 'en' || lang === 'fr' || lang === 'ja') ? lang : 'fr';
      document.documentElement.lang = safe;
      try { localStorage.setItem(LS_LANG_KEY, safe); } catch(e){}
      document.querySelectorAll('.translate').forEach(el=>{
        const text = el.getAttribute(`data-${safe}`);
        if (text != null) el.textContent = text;
      });

      updateLangToggleLabel(safe);
    }

    (function normalizeLangOnLoad(){
      let initial = 'fr';
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr' || saved === 'ja') initial = saved;
        else localStorage.setItem(LS_LANG_KEY, initial);
      } catch(e){}
      setLang(initial);
    })();

    langToggle.addEventListener('click', ()=> {
      const current = getLang();
      const next = languages[(languages.indexOf(current) + 1) % languages.length];
      setLang(next);
    });

    /* =========================================================
       Pointer UI (right column controls)
       ========================================================= */
    const showGazePointer = document.getElementById('showGazePointer');
    const gazeSize = document.getElementById('gazeSize');
    const gazeSizeVal = document.getElementById('gazeSizeVal');
    const gazeOpacity = document.getElementById('gazeOpacity');
    const gazeOpacityVal = document.getElementById('gazeOpacityVal');
    const gpDetails = document.getElementById('gpDetails');
    const gazePointer = document.getElementById('gazePointer');
    const intensitySlider = document.getElementById('intensitySlider');
    const intensityVal = document.getElementById('intensityVal');
    const qualitySlider = document.getElementById('qualitySlider');
    const qualityVal = document.getElementById('qualityVal');
    const openNoteModal = document.getElementById('openNoteModal');
    const noteModal = document.getElementById('noteModal');
    const closeNoteModal = document.getElementById('closeNoteModal');
    const monoColorSelect = document.getElementById('monoColorSelect');

    let intensityFactor = 1;
    let qualityFactor = 1;
    let monoColorChoice = 'normal';

    let applyIntensitySetting = null;
    let applyQualitySetting = null;
    let applyColorOverrideSetting = null;

    let pointerLast = { x: null, y: null };

    function pointerSizeFromControls(){ return parseInt(gazeSize?.value, 10) || 36; }
    function pointerOpacityFromControls(){
      const raw = parseInt(gazeOpacity?.value, 10);
      return Math.max(0, Math.min(1, (isNaN(raw) ? 100 : raw) / 100));
    }

    function setPointerPos(x, y){
      if (!gazePointer) return;
      gazePointer.style.left = `${x}px`;
      gazePointer.style.top = `${y}px`;
    }

    function setPointerDwell(active){
      if (!gazePointer) return;
      gazePointer.classList.toggle('gp-dwell', !!active);
    }

    function isStageActive(){
      return document.getElementById('stage')?.style.display === 'block';
    }

    function applyPointerToggle(){
      if (!gazePointer) return;

      const size = pointerSizeFromControls();
      const opct = pointerOpacityFromControls();
      if (gazeSizeVal) gazeSizeVal.textContent = String(size);
      if (gazeOpacityVal) gazeOpacityVal.textContent = String(Math.round(opct * 100));

      gazePointer.style.setProperty('--gp-size', `${size}px`);

      const stageActive = isStageActive();
      const enable = !!showGazePointer?.checked && stageActive;
      document.documentElement.classList.toggle('hide-native-cursor', stageActive);

      if (!enable) {
        setPointerDwell(false);
        // Only collapse advanced options when the pointer is explicitly disabled
        // (keep it open while adjusting values before starting the stage).
        if (gpDetails && showGazePointer && !showGazePointer.checked) gpDetails.open = false;
      }

      gazePointer.style.opacity = enable ? String(opct) : '0';

      if (enable && pointerLast.x !== null && pointerLast.y !== null) {
        setPointerPos(pointerLast.x, pointerLast.y);
      }
    }

    window.addEventListener('pointermove', (e)=> {
      pointerLast.x = e.clientX;
      pointerLast.y = e.clientY;
      setPointerPos(e.clientX, e.clientY);
    }, { passive: true });

    showGazePointer?.addEventListener('change', applyPointerToggle);
    gazeSize?.addEventListener('input', applyPointerToggle);
    gazeOpacity?.addEventListener('input', applyPointerToggle);

    function syncIntensityFromUI(){
      const raw = parseFloat(intensitySlider?.value);
      intensityFactor = Math.max(0.5, Math.min(2, isNaN(raw) ? 1 : raw));
      if (intensityVal) intensityVal.textContent = intensityFactor.toFixed(1);
      if (applyIntensitySetting) applyIntensitySetting();
    }

    function syncQualityFromUI(){
      const raw = parseFloat(qualitySlider?.value);
      qualityFactor = Math.max(0.6, Math.min(1.6, isNaN(raw) ? 1 : raw));
      if (qualityVal) qualityVal.textContent = qualityFactor.toFixed(2);
      if (applyQualitySetting) applyQualitySetting();
    }

    function syncMonoColorFromUI(){
      monoColorChoice = monoColorSelect?.value || 'normal';
      if (applyColorOverrideSetting) applyColorOverrideSetting();
    }
    intensitySlider?.addEventListener('input', syncIntensityFromUI);
    qualitySlider?.addEventListener('input', syncQualityFromUI);
    monoColorSelect?.addEventListener('change', syncMonoColorFromUI);

    syncIntensityFromUI();
    syncQualityFromUI();
    syncMonoColorFromUI();

    function showNoteModal(){
      if (!noteModal) return;
      noteModal.style.display = 'flex';
    }

    function hideNoteModal(){
      if (!noteModal) return;
      noteModal.style.display = 'none';
    }

    openNoteModal?.addEventListener('click', showNoteModal);
    closeNoteModal?.addEventListener('click', hideNoteModal);
    noteModal?.addEventListener('click', (evt)=>{
      if (evt.target?.dataset?.closeNote !== undefined) hideNoteModal();
    });

    /* =========================================================
       Start button: fullscreen + hide menu + show canvas
       ========================================================= */
    const startButton = document.getElementById('startButton');

    let fluidStarted = false;

    async function goFullscreen(){
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        else if (el.msRequestFullscreen) el.msRequestFullscreen();
      } catch(e){}
    }

    startButton.addEventListener('click', async ()=> {
      await goFullscreen();

      document.getElementById('game-options').style.display = 'none';
      document.getElementById('langToggle').style.display = 'none';

      document.getElementById('stage').style.display = 'block';

      applyPointerToggle();

      if (!fluidStarted) {
        startFluid(); // defined below (your combined JS)
        fluidStarted = true;
      }
    });

    function startFluid () {
      /*
      MIT License

      Copyright (c) 2017 Pavel Dobryakov
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
      */

      'use strict';

      const canvas = document.getElementById('c');

      let config = {
        SIM_RESOLUTION: 96,
        DYE_RESOLUTION: 768,

        DENSITY_DISSIPATION: 1.0,
        VELOCITY_DISSIPATION: 0.2,
        PRESSURE: 0.8,
        PRESSURE_ITERATIONS: 16,
        CURL: 30,

        SPLAT_RADIUS: 0.25,
        SPLAT_FORCE: 6000,

        SHADING: true,
        COLORFUL: true,
        COLOR_UPDATE_SPEED: 10,

        PAUSED: false,
        BACK_COLOR: { r: 0, g: 0, b: 0 },
        TRANSPARENT: false,

        BLOOM: true,
        BLOOM_ITERATIONS: 6,
        BLOOM_RESOLUTION: 192,
        BLOOM_INTENSITY: 0.7,
        BLOOM_THRESHOLD: 0.7,
        BLOOM_SOFT_KNEE: 0.7,

        SUNRAYS: true,
        SUNRAYS_RESOLUTION: 128,
        SUNRAYS_WEIGHT: 0.85,
      };

      let pixelRatioCap = 1.5;

      function isMobile () {
        return /Mobi|Android/i.test(navigator.userAgent);
      }
      if (isMobile()) config.DYE_RESOLUTION = 512;

      const baseSplatForce = config.SPLAT_FORCE;
      const baseSplatRadius = config.SPLAT_RADIUS;
      const baseSimResolution = config.SIM_RESOLUTION;
      const baseDyeResolution = config.DYE_RESOLUTION;
      const baseBloomResolution = config.BLOOM_RESOLUTION;
      const baseSunraysResolution = config.SUNRAYS_RESOLUTION;
      const basePixelRatioCap = pixelRatioCap;

      let pointers = [];

      const monoColorStrength = 0.35;

      function scaleColor(color, strength = monoColorStrength) {
        return { r: color.r * strength, g: color.g * strength, b: color.b * strength };
      }

      const monoWhite = scaleColor({ r: 1, g: 1, b: 1 });

      function getColorOverride(){
        switch (monoColorChoice) {
          case 'white': return { ...monoWhite };
          case 'red': return scaleColor({ r: 1, g: 0, b: 0 });
          case 'blue': return scaleColor({ r: 0.15, g: 0.4, b: 1 });
          case 'green': return scaleColor({ r: 0, g: 1, b: 0.25 });
          case 'yellow': return scaleColor({ r: 1, g: 0.9, b: 0.1 });
          case 'purple': return scaleColor({ r: 0.6, g: 0.1, b: 1 });
          case 'pink': return scaleColor({ r: 1, g: 0.2, b: 0.6 });
          default: return null;
        }
      }

      applyColorOverrideSetting = function(){
        const allowed = ['normal', 'white', 'red', 'blue', 'green', 'yellow', 'purple', 'pink'];
        if (!allowed.includes(monoColorChoice)) monoColorChoice = 'normal';

        const colorfulAllowed = monoColorChoice === 'normal';
        config.COLORFUL = colorfulAllowed;
        config.BACK_COLOR = { r: 0, g: 0, b: 0 };

        if (Array.isArray(pointers) && pointers.length) {
          if (!colorfulAllowed) {
            const forcedColor = getColorOverride();
            if (forcedColor) {
              pointers.forEach(p => { p.color = { ...forcedColor }; });
            }
          } else {
            pointers.forEach(p => { p.color = generateColor(); });
          }
        }
      };

      applyIntensitySetting = function(){
        const clamped = Math.max(0.5, Math.min(2, intensityFactor));
        intensityFactor = clamped;
        const scaledRadius = Math.min(0.6, Math.max(0.08, baseSplatRadius * clamped));
        config.SPLAT_FORCE = baseSplatForce * clamped;
        config.SPLAT_RADIUS = scaledRadius;
        if (intensityVal) intensityVal.textContent = clamped.toFixed(1);
      };

      applyQualitySetting = function(){
        const clamped = Math.max(0.6, Math.min(1.6, qualityFactor));
        qualityFactor = clamped;
        config.SIM_RESOLUTION = Math.max(32, Math.round(baseSimResolution * clamped));
        config.DYE_RESOLUTION = Math.max(256, Math.round(baseDyeResolution * clamped));
        config.BLOOM_RESOLUTION = Math.max(64, Math.round(baseBloomResolution * clamped));
        config.SUNRAYS_RESOLUTION = Math.max(64, Math.round(baseSunraysResolution * clamped));
        pixelRatioCap = Math.max(0.7, Math.min(basePixelRatioCap * clamped, 2));
        if (fluidStarted) {
          resizeCanvas();
          initFramebuffers();
        }
        if (qualityVal) qualityVal.textContent = clamped.toFixed(2);
      };

      applyColorOverrideSetting();
      applyIntensitySetting();
      applyQualitySetting();

      function pointerPrototype () {
        this.id = -1;
        this.texcoordX = 0;
        this.texcoordY = 0;
        this.prevTexcoordX = 0;
        this.prevTexcoordY = 0;
        this.deltaX = 0;
        this.deltaY = 0;
        this.down = false;
        this.moved = false;
        this.color = [30, 0, 300];
      }

      pointers = [];
      let splatStack = [];
      pointers.push(new pointerPrototype());

      const { gl, ext } = getWebGLContext(canvas);

      if (!ext.supportLinearFiltering) {
        config.DYE_RESOLUTION = 512;
        config.SHADING = false;
        config.BLOOM = false;
        config.SUNRAYS = false;
      }

      resizeCanvas();

      function getWebGLContext (canvas) {
        const params = { alpha: true, depth: false, stencil: false, antialias: false, preserveDrawingBuffer: false };

        let gl = canvas.getContext('webgl2', params);
        const isWebGL2 = !!gl;
        if (!isWebGL2)
          gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);

        let halfFloat;
        let supportLinearFiltering;
        if (isWebGL2) {
          gl.getExtension('EXT_color_buffer_float');
          supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
        } else {
          halfFloat = gl.getExtension('OES_texture_half_float');
          supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;
        let formatRGBA;
        let formatRG;
        let formatR;

        if (isWebGL2) {
          formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
          formatRG   = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
          formatR    = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
        } else {
          formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
          formatRG   = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
          formatR    = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
        }

        return {
          gl,
          ext: {
            formatRGBA,
            formatRG,
            formatR,
            halfFloatTexType,
            supportLinearFiltering: !!supportLinearFiltering
          }
        };
      }

      function getSupportedFormat (gl, internalFormat, format, type) {
        if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
          switch (internalFormat) {
            case gl.R16F:
              return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
            case gl.RG16F:
              return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
            default:
              return null;
          }
        }
        return { internalFormat, format };
      }

      function supportRenderTextureFormat (gl, internalFormat, format, type) {
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);

        let fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

        let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        gl.deleteTexture(texture);
        gl.deleteFramebuffer(fbo);

        return status === gl.FRAMEBUFFER_COMPLETE;
      }

      class Material {
        constructor (vertexShader, fragmentShaderSource) {
          this.vertexShader = vertexShader;
          this.fragmentShaderSource = fragmentShaderSource;
          this.programs = [];
          this.activeProgram = null;
          this.uniforms = [];
        }

        setKeywords (keywords) {
          let hash = 0;
          for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);

          let program = this.programs[hash];
          if (program == null) {
            let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);
            program = createProgram(this.vertexShader, fragmentShader);
            this.programs[hash] = program;
          }

          if (program === this.activeProgram) return;
          this.uniforms = getUniforms(program);
          this.activeProgram = program;
        }

        bind () { gl.useProgram(this.activeProgram); }
      }

      class Program {
        constructor (vertexShader, fragmentShader) {
          this.program = createProgram(vertexShader, fragmentShader);
          this.uniforms = getUniforms(this.program);
        }
        bind () { gl.useProgram(this.program); }
      }

      function createProgram (vertexShader, fragmentShader) {
        let program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.bindAttribLocation(program, 0, 'aPosition');

        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS))
          console.warn(gl.getProgramInfoLog(program));
        return program;
      }

      function getUniforms (program) {
        let uniforms = [];
        let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < uniformCount; i++) {
          let uniformName = gl.getActiveUniform(program, i).name;
          uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
        }
        return uniforms;
      }

      function compileShader (type, source, keywords) {
        source = addKeywords(source, keywords);
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
          console.warn(gl.getShaderInfoLog(shader));
        return shader;
      }

      function addKeywords (source, keywords) {
        if (keywords == null) return source;
        let keywordsString = '';
        keywords.forEach(k => { keywordsString += '#define ' + k + '\n'; });
        return keywordsString + source;
      }

      const baseVertexShader = compileShader(gl.VERTEX_SHADER, `
        precision highp float;
        attribute vec2 aPosition;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform vec2 texelSize;

        void main () {
          vUv = aPosition * 0.5 + 0.5;
          vL = vUv - vec2(texelSize.x, 0.0);
          vR = vUv + vec2(texelSize.x, 0.0);
          vT = vUv + vec2(0.0, texelSize.y);
          vB = vUv - vec2(0.0, texelSize.y);
          gl_Position = vec4(aPosition, 0.0, 1.0);
        }
      `);

      const blurVertexShader = compileShader(gl.VERTEX_SHADER, `
        precision highp float;
        attribute vec2 aPosition;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        uniform vec2 texelSize;

        void main () {
          vUv = aPosition * 0.5 + 0.5;
          float offset = 1.33333333;
          vL = vUv - texelSize * offset;
          vR = vUv + texelSize * offset;
          gl_Position = vec4(aPosition, 0.0, 1.0);
        }
      `);

      const blurShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        uniform sampler2D uTexture;

        void main () {
          vec4 sum = texture2D(uTexture, vUv) * 0.29411764;
          sum += texture2D(uTexture, vL) * 0.35294117;
          sum += texture2D(uTexture, vR) * 0.35294117;
          gl_FragColor = sum;
        }
      `);

      const copyShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        uniform sampler2D uTexture;
        void main () {
          gl_FragColor = texture2D(uTexture, vUv);
        }
      `);

      const clearShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        uniform sampler2D uTexture;
        uniform float value;

        void main () {
          gl_FragColor = value * texture2D(uTexture, vUv);
        }
      `);

      const colorShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        uniform vec4 color;
        void main () {
          gl_FragColor = color;
        }
      `);

      const displayShaderSource = `
        precision highp float;
        precision highp sampler2D;

        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;

        uniform sampler2D uTexture;

        #ifdef BLOOM
          uniform sampler2D uBloom;
        #endif

        #ifdef SUNRAYS
          uniform sampler2D uSunrays;
        #endif

        uniform vec2 texelSize;

        vec3 linearToGamma (vec3 color) {
          color = max(color, vec3(0));
          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));
        }

        void main () {
          vec3 c = texture2D(uTexture, vUv).rgb;

        #ifdef SHADING
          vec3 lc = texture2D(uTexture, vL).rgb;
          vec3 rc = texture2D(uTexture, vR).rgb;
          vec3 tc = texture2D(uTexture, vT).rgb;
          vec3 bc = texture2D(uTexture, vB).rgb;

          float dx = length(rc) - length(lc);
          float dy = length(tc) - length(bc);

          vec3 n = normalize(vec3(dx, dy, length(texelSize)));
          vec3 l = vec3(0.0, 0.0, 1.0);

          float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
          c *= diffuse;
        #endif

        #ifdef BLOOM
          vec3 bloom = texture2D(uBloom, vUv).rgb;
        #endif

        #ifdef SUNRAYS
          float sr = texture2D(uSunrays, vUv).r;
          c *= sr;
        #ifdef BLOOM
          bloom *= sr;
        #endif
        #endif

        #ifdef BLOOM
          bloom = linearToGamma(bloom);
          c += bloom;
        #endif

          float a = max(c.r, max(c.g, c.b));
          gl_FragColor = vec4(c, a);
        }
      `;

      const bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        uniform vec3 curve;
        uniform float threshold;

        void main () {
          vec3 c = texture2D(uTexture, vUv).rgb;
          float br = max(c.r, max(c.g, c.b));
          float rq = clamp(br - curve.x, 0.0, curve.y);
          rq = curve.z * rq * rq;
          c *= max(rq, br - threshold) / max(br, 0.0001);
          gl_FragColor = vec4(c, 0.0);
        }
      `);

      const bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform sampler2D uTexture;

        void main () {
          vec4 sum = vec4(0.0);
          sum += texture2D(uTexture, vL);
          sum += texture2D(uTexture, vR);
          sum += texture2D(uTexture, vT);
          sum += texture2D(uTexture, vB);
          sum *= 0.25;
          gl_FragColor = sum;
        }
      `);

      const bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform sampler2D uTexture;
        uniform float intensity;

        void main () {
          vec4 sum = vec4(0.0);
          sum += texture2D(uTexture, vL);
          sum += texture2D(uTexture, vR);
          sum += texture2D(uTexture, vT);
          sum += texture2D(uTexture, vB);
          sum *= 0.25;
          gl_FragColor = sum * intensity;
        }
      `);

      const sunraysMaskShader = compileShader(gl.FRAGMENT_SHADER, `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uTexture;

        void main () {
          vec4 c = texture2D(uTexture, vUv);
          float br = max(c.r, max(c.g, c.b));
          c.a = 1.0 - min(max(br * 20.0, 0.0), 0.8);
          gl_FragColor = c;
        }
      `);

      const sunraysShader = compileShader(gl.FRAGMENT_SHADER, `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        uniform float weight;

        #define ITERATIONS 16

        void main () {
          float Density = 0.3;
          float Decay = 0.95;
          float Exposure = 0.7;

          vec2 coord = vUv;
          vec2 dir = vUv - 0.5;

          dir *= 1.0 / float(ITERATIONS) * Density;
          float illuminationDecay = 1.0;

          float color = texture2D(uTexture, vUv).a;

          for (int i = 0; i < ITERATIONS; i++) {
            coord -= dir;
            float col = texture2D(uTexture, coord).a;
            color += col * illuminationDecay * weight;
            illuminationDecay *= Decay;
          }

          gl_FragColor = vec4(color * Exposure, 0.0, 0.0, 1.0);
        }
      `);

      const splatShader = compileShader(gl.FRAGMENT_SHADER, `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uTarget;
        uniform float aspectRatio;
        uniform vec3 color;
        uniform vec2 point;
        uniform float radius;

        void main () {
          vec2 p = vUv - point.xy;
          p.x *= aspectRatio;
          vec3 splat = exp(-dot(p, p) / radius) * color;
          vec3 base = texture2D(uTarget, vUv).xyz;
          gl_FragColor = vec4(base + splat, 1.0);
        }
      `);

      const advectionShader = compileShader(
        gl.FRAGMENT_SHADER,
        `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uVelocity;
        uniform sampler2D uSource;
        uniform vec2 texelSize;
        uniform vec2 dyeTexelSize;
        uniform float dt;
        uniform float dissipation;

        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
          vec2 st = uv / tsize - 0.5;
          vec2 iuv = floor(st);
          vec2 fuv = fract(st);

          vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
          vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
          vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
          vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);

          return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
        }

        void main () {
        #ifdef MANUAL_FILTERING
          vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
          vec4 result = bilerp(uSource, coord, dyeTexelSize);
        #else
          vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
          vec4 result = texture2D(uSource, coord);
        #endif
          float decay = 1.0 + dissipation * dt;
          gl_FragColor = result / decay;
        }`,
        ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']
      );

      const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uVelocity;

        void main () {
          float L = texture2D(uVelocity, vL).x;
          float R = texture2D(uVelocity, vR).x;
          float T = texture2D(uVelocity, vT).y;
          float B = texture2D(uVelocity, vB).y;

          vec2 C = texture2D(uVelocity, vUv).xy;
          if (vL.x < 0.0) { L = -C.x; }
          if (vR.x > 1.0) { R = -C.x; }
          if (vT.y > 1.0) { T = -C.y; }
          if (vB.y < 0.0) { B = -C.y; }

          float div = 0.5 * (R - L + T - B);
          gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
        }
      `);

      const curlShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uVelocity;

        void main () {
          float L = texture2D(uVelocity, vL).y;
          float R = texture2D(uVelocity, vR).y;
          float T = texture2D(uVelocity, vT).x;
          float B = texture2D(uVelocity, vB).x;
          float vorticity = R - L - T + B;
          gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
        }
      `);

      const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform sampler2D uVelocity;
        uniform sampler2D uCurl;
        uniform float curl;
        uniform float dt;

        void main () {
          float L = texture2D(uCurl, vL).x;
          float R = texture2D(uCurl, vR).x;
          float T = texture2D(uCurl, vT).x;
          float B = texture2D(uCurl, vB).x;
          float C = texture2D(uCurl, vUv).x;

          vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
          force /= length(force) + 0.0001;
          force *= curl * C;
          force.y *= -1.0;

          vec2 velocity = texture2D(uVelocity, vUv).xy;
          velocity += force * dt;
          velocity = min(max(velocity, -1000.0), 1000.0);
          gl_FragColor = vec4(velocity, 0.0, 1.0);
        }
      `);

      const pressureShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uPressure;
        uniform sampler2D uDivergence;

        void main () {
          float L = texture2D(uPressure, vL).x;
          float R = texture2D(uPressure, vR).x;
          float T = texture2D(uPressure, vT).x;
          float B = texture2D(uPressure, vB).x;
          float divergence = texture2D(uDivergence, vUv).x;
          float pressure = (L + R + B + T - divergence) * 0.25;
          gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
        }
      `);

      const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uPressure;
        uniform sampler2D uVelocity;

        void main () {
          float L = texture2D(uPressure, vL).x;
          float R = texture2D(uPressure, vR).x;
          float T = texture2D(uPressure, vT).x;
          float B = texture2D(uPressure, vB).x;
          vec2 velocity = texture2D(uVelocity, vUv).xy;
          velocity.xy -= vec2(R - L, T - B);
          gl_FragColor = vec4(velocity, 0.0, 1.0);
        }
      `);

      const blit = (() => {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1,  1,  1,  1,  1, -1]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);

        return (target, clear = false) => {
          if (target == null) {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          } else {
            gl.viewport(0, 0, target.width, target.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
          }
          if (clear) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        };
      })();

      let dye;
      let velocity;
      let divergence;
      let curl;
      let pressure;

      let bloom;
      let bloomFramebuffers = [];

      let sunrays;
      let sunraysTemp;

      const blurProgram            = new Program(blurVertexShader, blurShader);
      const copyProgram            = new Program(baseVertexShader, copyShader);
      const clearProgram           = new Program(baseVertexShader, clearShader);
      const colorProgram           = new Program(baseVertexShader, colorShader);

      const bloomPrefilterProgram  = new Program(baseVertexShader, bloomPrefilterShader);
      const bloomBlurProgram       = new Program(baseVertexShader, bloomBlurShader);
      const bloomFinalProgram      = new Program(baseVertexShader, bloomFinalShader);

      const sunraysMaskProgram     = new Program(baseVertexShader, sunraysMaskShader);
      const sunraysProgram         = new Program(baseVertexShader, sunraysShader);

      const splatProgram           = new Program(baseVertexShader, splatShader);
      const advectionProgram       = new Program(baseVertexShader, advectionShader);
      const divergenceProgram      = new Program(baseVertexShader, divergenceShader);
      const curlProgram            = new Program(baseVertexShader, curlShader);
      const vorticityProgram       = new Program(baseVertexShader, vorticityShader);
      const pressureProgram        = new Program(baseVertexShader, pressureShader);
      const gradientSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);

      const displayMaterial = new Material(baseVertexShader, displayShaderSource);

      function initFramebuffers () {
        let simRes = getResolution(config.SIM_RESOLUTION);
        let dyeRes = getResolution(config.DYE_RESOLUTION);

        const texType = ext.halfFloatTexType;
        const rgba    = ext.formatRGBA;
        const rg      = ext.formatRG;
        const r       = ext.formatR;
        const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

        gl.disable(gl.BLEND);

        if (dye == null)
          dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);
        else
          dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);

        if (velocity == null)
          velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);
        else
          velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);

        divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
        curl       = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
        pressure   = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);

        if (config.BLOOM) initBloomFramebuffers();
        if (config.SUNRAYS) initSunraysFramebuffers();
      }

      function initBloomFramebuffers () {
        let res = getResolution(config.BLOOM_RESOLUTION);

        const texType = ext.halfFloatTexType;
        const rgba = ext.formatRGBA;
        const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

        bloom = createFBO(res.width, res.height, rgba.internalFormat, rgba.format, texType, filtering);

        bloomFramebuffers.length = 0;
        for (let i = 0; i < config.BLOOM_ITERATIONS; i++) {
          let width = res.width >> (i + 1);
          let height = res.height >> (i + 1);
          if (width < 2 || height < 2) break;
          bloomFramebuffers.push(createFBO(width, height, rgba.internalFormat, rgba.format, texType, filtering));
        }
      }

      function initSunraysFramebuffers () {
        let res = getResolution(config.SUNRAYS_RESOLUTION);

        const texType = ext.halfFloatTexType;
        const r = ext.formatR;
        const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

        sunrays     = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);
        sunraysTemp = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);
      }

      function createFBO (w, h, internalFormat, format, type, param) {
        gl.activeTexture(gl.TEXTURE0);
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

        let fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.viewport(0, 0, w, h);
        gl.clear(gl.COLOR_BUFFER_BIT);

        return {
          texture,
          fbo,
          width: w,
          height: h,
          texelSizeX: 1.0 / w,
          texelSizeY: 1.0 / h,
          attach (id) {
            gl.activeTexture(gl.TEXTURE0 + id);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            return id;
          }
        };
      }

      function createDoubleFBO (w, h, internalFormat, format, type, param) {
        let fbo1 = createFBO(w, h, internalFormat, format, type, param);
        let fbo2 = createFBO(w, h, internalFormat, format, type, param);
        return {
          width: w,
          height: h,
          texelSizeX: fbo1.texelSizeX,
          texelSizeY: fbo1.texelSizeY,
          get read () { return fbo1; },
          set read (value) { fbo1 = value; },
          get write () { return fbo2; },
          set write (value) { fbo2 = value; },
          swap () { let t = fbo1; fbo1 = fbo2; fbo2 = t; }
        };
      }

      function resizeFBO (target, w, h, internalFormat, format, type, param) {
        let newFBO = createFBO(w, h, internalFormat, format, type, param);
        copyProgram.bind();
        gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
        blit(newFBO);
        return newFBO;
      }

      function resizeDoubleFBO (target, w, h, internalFormat, format, type, param) {
        if (target.width === w && target.height === h) return target;
        target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);
        target.write = createFBO(w, h, internalFormat, format, type, param);
        target.width = w;
        target.height = h;
        target.texelSizeX = 1.0 / w;
        target.texelSizeY = 1.0 / h;
        return target;
      }

      function updateKeywords () {
        let displayKeywords = [];
        if (config.SHADING) displayKeywords.push('SHADING');
        if (config.BLOOM) displayKeywords.push('BLOOM');
        if (config.SUNRAYS) displayKeywords.push('SUNRAYS');
        displayMaterial.setKeywords(displayKeywords);
      }

      updateKeywords();
      initFramebuffers();
      multipleSplats((Math.random() * 20 + 5) | 0);

      let lastUpdateTime = Date.now();
      let colorUpdateTimer = 0.0;

      function update () {
        const dt = calcDeltaTime();
        if (resizeCanvas()) initFramebuffers();
        updateColors(dt);
        applyInputs();
        if (!config.PAUSED) step(dt);
        render(null);
        requestAnimationFrame(update);
      }

      function calcDeltaTime () {
        let now = Date.now();
        let dt = (now - lastUpdateTime) / 1000;
        dt = Math.min(dt, 0.016666);
        lastUpdateTime = now;
        return dt;
      }

      function resizeCanvas () {
        let width = scaleByPixelRatio(canvas.clientWidth);
        let height = scaleByPixelRatio(canvas.clientHeight);
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
          return true;
        }
        return false;
      }

      function updateColors (dt) {
        if (!config.COLORFUL) return;
        colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;
        if (colorUpdateTimer >= 1) {
          colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);
          pointers.forEach(p => { p.color = generateColor(); });
        }
      }

      function applyInputs () {
        if (splatStack.length > 0) multipleSplats(splatStack.pop());
        pointers.forEach(p => {
          if (p.moved) {
            p.moved = false;
            splatPointer(p);
          }
        });
      }

      function step (dt) {
        gl.disable(gl.BLEND);

        curlProgram.bind();
        gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
        blit(curl);

        vorticityProgram.bind();
        gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
        gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
        gl.uniform1f(vorticityProgram.uniforms.dt, dt);
        blit(velocity.write);
        velocity.swap();

        divergenceProgram.bind();
        gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
        blit(divergence);

        clearProgram.bind();
        gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
        gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
        blit(pressure.write);
        pressure.swap();

        pressureProgram.bind();
        gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
        for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
          gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
          blit(pressure.write);
          pressure.swap();
        }

        gradientSubtractProgram.bind();
        gl.uniform2f(gradientSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(gradientSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
        gl.uniform1i(gradientSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
        blit(velocity.write);
        velocity.swap();

        advectionProgram.bind();
        gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        if (!ext.supportLinearFiltering)
          gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);

        let velocityId = velocity.read.attach(0);
        gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
        gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
        gl.uniform1f(advectionProgram.uniforms.dt, dt);
        gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
        blit(velocity.write);
        velocity.swap();

        if (!ext.supportLinearFiltering)
          gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);

        gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
        gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
        blit(dye.write);
        dye.swap();
      }

      function render (target) {
        if (config.BLOOM) applyBloom(dye.read, bloom);
        if (config.SUNRAYS) {
          applySunrays(dye.read, dye.write, sunrays);
          blur(sunrays, sunraysTemp, 1);
        }

        if (target == null || !config.TRANSPARENT) {
          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          gl.enable(gl.BLEND);
        } else {
          gl.disable(gl.BLEND);
        }

        if (!config.TRANSPARENT) drawColor(target, normalizeColor(config.BACK_COLOR));
        drawDisplay(target);
      }

      function drawColor (target, color) {
        colorProgram.bind();
        gl.uniform4f(colorProgram.uniforms.color, color.r, color.g, color.b, 1);
        blit(target);
      }

      function drawDisplay (target) {
        let width = target == null ? gl.drawingBufferWidth : target.width;
        let height = target == null ? gl.drawingBufferHeight : target.height;

        displayMaterial.bind();
        if (config.SHADING)
          gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);

        gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
        if (config.BLOOM) gl.uniform1i(displayMaterial.uniforms.uBloom, bloom.attach(1));
        if (config.SUNRAYS) gl.uniform1i(displayMaterial.uniforms.uSunrays, sunrays.attach(3));

        blit(target);
      }

      function applyBloom (source, destination) {
        if (bloomFramebuffers.length < 2) return;

        let last = destination;
        gl.disable(gl.BLEND);

        bloomPrefilterProgram.bind();
        let knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;
        let curve0 = config.BLOOM_THRESHOLD - knee;
        let curve1 = knee * 2;
        let curve2 = 0.25 / knee;

        gl.uniform3f(bloomPrefilterProgram.uniforms.curve, curve0, curve1, curve2);
        gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD);
        gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, source.attach(0));
        blit(last);

        bloomBlurProgram.bind();
        for (let i = 0; i < bloomFramebuffers.length; i++) {
          let dest = bloomFramebuffers[i];
          gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);
          gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));
          blit(dest);
          last = dest;
        }

        gl.blendFunc(gl.ONE, gl.ONE);
        gl.enable(gl.BLEND);

        for (let i = bloomFramebuffers.length - 2; i >= 0; i--) {
          let baseTex = bloomFramebuffers[i];
          gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);
          gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));
          gl.viewport(0, 0, baseTex.width, baseTex.height);
          blit(baseTex);
          last = baseTex;
        }

        gl.disable(gl.BLEND);

        bloomFinalProgram.bind();
        gl.uniform2f(bloomFinalProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);
        gl.uniform1i(bloomFinalProgram.uniforms.uTexture, last.attach(0));
        gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY);
        blit(destination);
      }

      function applySunrays (source, mask, destination) {
        gl.disable(gl.BLEND);

        sunraysMaskProgram.bind();
        gl.uniform1i(sunraysMaskProgram.uniforms.uTexture, source.attach(0));
        blit(mask);

        sunraysProgram.bind();
        gl.uniform1f(sunraysProgram.uniforms.weight, config.SUNRAYS_WEIGHT);
        gl.uniform1i(sunraysProgram.uniforms.uTexture, mask.attach(0));
        blit(destination);
      }

      function blur (target, temp, iterations) {
        blurProgram.bind();
        for (let i = 0; i < iterations; i++) {
          gl.uniform2f(blurProgram.uniforms.texelSize, target.texelSizeX, 0.0);
          gl.uniform1i(blurProgram.uniforms.uTexture, target.attach(0));
          blit(temp);

          gl.uniform2f(blurProgram.uniforms.texelSize, 0.0, target.texelSizeY);
          gl.uniform1i(blurProgram.uniforms.uTexture, temp.attach(0));
          blit(target);
        }
      }

      function splatPointer (pointer) {
        let dx = pointer.deltaX * config.SPLAT_FORCE;
        let dy = pointer.deltaY * config.SPLAT_FORCE;
        splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);
      }

      function multipleSplats (amount) {
        for (let i = 0; i < amount; i++) {
          const color = generateColor();
          color.r *= 10.0;
          color.g *= 10.0;
          color.b *= 10.0;
          const x = Math.random();
          const y = Math.random();
          const dx = 1000 * (Math.random() - 0.5);
          const dy = 1000 * (Math.random() - 0.5);
          splat(x, y, dx, dy, color);
        }
      }

      function splat (x, y, dx, dy, color) {
        splatProgram.bind();
        gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
        gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
        gl.uniform2f(splatProgram.uniforms.point, x, y);
        gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);
        gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));
        blit(velocity.write);
        velocity.swap();

        gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
        gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
        blit(dye.write);
        dye.swap();
      }

      function correctRadius (radius) {
        let aspectRatio = canvas.width / canvas.height;
        if (aspectRatio > 1) radius *= aspectRatio;
        return radius;
      }

      /* ---- Input handlers (your "NO click" mouse hover/move) ---- */
      let mouseInside = false;

      canvas.addEventListener('mouseenter', (e) => {
        mouseInside = true;
        const posX = scaleByPixelRatio(e.offsetX);
        const posY = scaleByPixelRatio(e.offsetY);
        const p = pointers[0];
        updatePointerDownData(p, -1, posX, posY);
        p.down = true;
        setPointerDwell(true);
      });

      canvas.addEventListener('mousemove', (e) => {
        if (!mouseInside) return;
        const posX = scaleByPixelRatio(e.offsetX);
        const posY = scaleByPixelRatio(e.offsetY);
        const p = pointers[0];
        p.down = true;
        updatePointerMoveData(p, posX, posY);
        if (p.moved) {
          p.moved = false;
          splatPointer(p);
        }
      });

      canvas.addEventListener('mouseleave', () => {
        mouseInside = false;
        pointers[0].down = false;
        setPointerDwell(false);
      });

      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const touches = e.targetTouches;
        while (touches.length >= pointers.length) pointers.push(new pointerPrototype());
        for (let i = 0; i < touches.length; i++) {
          let posX = scaleByPixelRatio(touches[i].pageX);
          let posY = scaleByPixelRatio(touches[i].pageY);
          updatePointerDownData(pointers[i + 1], touches[i].identifier, posX, posY);
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const touches = e.targetTouches;
        for (let i = 0; i < touches.length; i++) {
          let pointer = pointers[i + 1];
          if (!pointer.down) continue;
          let posX = scaleByPixelRatio(touches[i].pageX);
          let posY = scaleByPixelRatio(touches[i].pageY);
          updatePointerMoveData(pointer, posX, posY);
        }
      }, { passive: false });

      window.addEventListener('touchend', e => {
        const touches = e.changedTouches;
        for (let i = 0; i < touches.length; i++) {
          let pointer = pointers.find(p => p.id === touches[i].identifier);
          if (pointer == null) continue;
          updatePointerUpData(pointer);
        }
      });

      window.addEventListener('keydown', e => {
        if (e.code === 'KeyP') config.PAUSED = !config.PAUSED;
        if (e.key === ' ') splatStack.push((Math.random() * 20 + 5) | 0);
      });

      function updatePointerDownData (pointer, id, posX, posY) {
        pointer.id = id;
        pointer.down = true;
        pointer.moved = false;
        pointer.texcoordX = posX / canvas.width;
        pointer.texcoordY = 1.0 - posY / canvas.height;
        pointer.prevTexcoordX = pointer.texcoordX;
        pointer.prevTexcoordY = pointer.texcoordY;
        pointer.deltaX = 0;
        pointer.deltaY = 0;
        pointer.color = generateColor();
      }

      function updatePointerMoveData (pointer, posX, posY) {
        pointer.prevTexcoordX = pointer.texcoordX;
        pointer.prevTexcoordY = pointer.texcoordY;
        pointer.texcoordX = posX / canvas.width;
        pointer.texcoordY = 1.0 - posY / canvas.height;
        pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);
        pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);
        pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;
      }

      function updatePointerUpData (pointer) {
        pointer.down = false;
      }

      function correctDeltaX (delta) {
        let aspectRatio = canvas.width / canvas.height;
        if (aspectRatio < 1) delta *= aspectRatio;
        return delta;
      }

      function correctDeltaY (delta) {
        let aspectRatio = canvas.width / canvas.height;
        if (aspectRatio > 1) delta /= aspectRatio;
        return delta;
      }

      function generateColor () {
        const forced = monoColorChoice !== 'normal' ? getColorOverride() : null;
        if (forced) return { ...forced };
        let c = HSVtoRGB(Math.random(), 1.0, 1.0);
        c.r *= 0.15;
        c.g *= 0.15;
        c.b *= 0.15;
        return c;
      }

      function HSVtoRGB (h, s, v) {
        let r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);

        switch (i % 6) {
          case 0: r = v; g = t; b = p; break;
          case 1: r = q; g = v; b = p; break;
          case 2: r = p; g = v; b = t; break;
          case 3: r = p; g = q; b = v; break;
          case 4: r = t; g = p; b = v; break;
          case 5: r = v; g = p; b = q; break;
        }
        return { r, g, b };
      }

      function normalizeColor (input) {
        return { r: input.r / 255, g: input.g / 255, b: input.b / 255 };
      }

      function wrap (value, min, max) {
        let range = max - min;
        if (range === 0) return min;
        return (value - min) % range + min;
      }

      function getResolution (resolution) {
        let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
        if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;

        let min = Math.round(resolution);
        let max = Math.round(resolution * aspectRatio);

        if (gl.drawingBufferWidth > gl.drawingBufferHeight)
          return { width: max, height: min };
        else
          return { width: min, height: max };
      }

      function scaleByPixelRatio (input) {
        let pixelRatio = Math.min(window.devicePixelRatio || 1, pixelRatioCap);
        return Math.floor(input * pixelRatio);
      }

      function hashCode (s) {
        if (s.length === 0) return 0;
        let hash = 0;
        for (let i = 0; i < s.length; i++) {
          hash = (hash << 5) - hash + s.charCodeAt(i);
          hash |= 0;
        }
        return hash;
      }

      // Kick off the loop ONLY after the menu has been dismissed
      update();
    }
  </script>
</body>
</html>
