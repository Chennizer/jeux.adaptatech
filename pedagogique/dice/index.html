<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dice vs. Colors vs. Photos vs. Words</title>
  
  <!-- Responsive Viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Link your existing CSS stylesheet -->
  <link rel="stylesheet" href="../../css/choix.css" />

  <!-- p5.js library -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>

  <style>
    /*
      Additional styles for color selection, containers, black bold headings,
      plus styles for words inputs with dynamic addition.
    */

    /* Container for the new “Words” mode inputs */
    #wordsOptions {
      display: none;
      margin-top: 15px;
      text-align: center;
    }
    #wordsOptions p {
      font-size: 16px;
      margin-bottom: 8px;
    }

    /* We'll place the text fields in a container (#wordsContainer) */
    #wordsContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .word-input {
      display: block;
      width: 80%;
      max-width: 300px;
      padding: 8px;
      font-size: 16px;
      border: 2px solid #00796B;
      border-radius: 5px;
      outline: none;
    }
    .word-input:focus {
      border-color: #009688;
    }

    /* The + button style */
    #addWordButton {
      background-color: #009688;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 24px;
      cursor: pointer;
      outline: none;
      margin-top: 5px;
    }
    #addWordButton:hover {
      background-color: #00796B;
    }
  </style>
</head>

<body>
  <!-- Main overlay for mode selection & options -->
  <div id="game-options" class="modal" style="display: flex;">
    <div id="control-panel-options">
      <!-- Title bar -->
      <div id="options-title-bar">
        <h2 id="options-main-title">Dice vs. Colors vs. Photos vs. Words</h2>
      </div>

      <!-- Main Segmented Control: Dice, Colors, Photos, Words -->
      <div id="mode-segmented-control">
        <button id="mode-dice-button"   class="mode-btn selected">Dice</button>
        <button id="mode-colors-button" class="mode-btn">Colors</button>
        <button id="mode-photos-button" class="mode-btn">Photos</button>
        <button id="mode-words-button"  class="mode-btn">Words</button>
      </div>

      <!-- Divider line -->
      <div id="mode-divider"></div>

      <!-- Colors Section -->
      <div id="colorsOptions" style="display: none;">
        <!-- same as before -->
      </div>

      <!-- Photos Section -->
      <div id="photosOptions" style="display: none;">
        <!-- same as before -->
      </div>

      <!-- Words Section -->
      <div id="wordsOptions" style="display: none;">
        <p>Enter words or short phrases:</p>
        <!-- Container for text fields -->
        <div id="wordsContainer">
          <!-- We'll start with 4 fields by default -->
          <input class="word-input" type="text" placeholder="Word 1" />
          <input class="word-input" type="text" placeholder="Word 2" />
          <input class="word-input" type="text" placeholder="Word 3" />
          <input class="word-input" type="text" placeholder="Word 4" />
        </div>
        <!-- The + button to add more fields -->
        <button id="addWordButton">+</button>
      </div>

      <!-- Start Button -->
      <button id="startButton" class="button">Start</button>
    </div>
  </div>

  <script>
    /* ======================
       Global / Common State
       ====================== */
    let mode = null;  
    let started = false;

    // For the Colors approach
    let availableColors = [];
    let selectedColors  = [];

    /* Dice variables */
    let rolling = false;
    let rollStart = 0;
    const ROLL_DURATION = 4000; 
    let lastChange = 0;
    const ROLL_INT = 300;
    let diceVal = 1;
    let diceSize;

    /* BOUNCE variables */
    let bouncing = false;
    let bounceStart = 0;
    const BOUNCE_DURATION = 1000;
    let currentScale = 1;

    /* Carousel variables (Colors, Photos, Words) */
    const SPIN_DUR = 10000; 
    let imgs = [];       
    let imgsAll = [];    
    let cur = 0, startIdx = 0, targetIdx = 0;
    let spinning = false, spinStart = 0;
    let sideItemsRemoved = false;

    /*
      SOUND PLACEHOLDERS
      Replace with actual audio code if desired
    */
    function playCarouselStartSound(){
      console.log("PLAYING Carousel Start Sound...");
    }
    function playCarouselStopSound(){
      console.log("PLAYING Carousel Stop Sound...");
    }

    function setup(){
      createCanvas(windowWidth, windowHeight, WEBGL);
      angleMode(DEGREES);
      diceSize = min(width, height) * 0.4;

      // 12 colors (no black)
      const allColors = [
        'red', 'green', 'blue', 'yellow',
        'pink', 'purple', 'orange', 'brown',
        'white', 'gray', 'teal', 'gold'
      ];
      availableColors = [...allColors];
      selectedColors  = [];
    }

    function windowResized(){
      resizeCanvas(windowWidth, windowHeight);
      diceSize = min(width, height) * 0.4;
    }

    function draw(){
      background(0);
      if(!started) return;

      if(mode === 'dice'){
        updateClassic();
        drawClassicDice();
      } else if(mode === 'colors' || mode === 'photos' || mode === 'words'){
        updateCarousel();
        drawCarousel();
      }
    }

    /* ================
       Dice Functions
       ================ */
    function triggerRollClassic(){
      if(rolling || bouncing) return;
      rolling = true;
      rollStart = millis();
    }

    function updateClassic(){
      if(rolling){
        let now = millis();
        let elapsed = now - rollStart;
        if(elapsed < ROLL_DURATION){
          if(now - lastChange > ROLL_INT){
            diceVal = floor(random(1,7));
            lastChange = now;
          }
        } else {
          // rolling done, start bounce
          rolling = false;
          bouncing = true;
          bounceStart = now;
        }
      }
      if(bouncing){
        let now = millis();
        let t = constrain((now - bounceStart)/BOUNCE_DURATION, 0, 1);
        currentScale = 1 + 0.2*(1 - Math.pow(1 - t, 2));
        if(t >= 1){
          bouncing = false;
          currentScale = 1;
        }
      } else {
        currentScale = 1;
      }
    }

    function drawClassicDice(){
      push();
      translate(-width/2 + width/2, -height/2 + height/2);
      scale(currentScale);
      rectMode(CENTER);
      fill(255);
      stroke(0);
      strokeWeight(8);
      rect(0, 0, diceSize, diceSize, 20);

      fill(0);
      noStroke();
      const r = diceSize / 8;
      const o = diceSize / 4;
      const pips = {
        1: [[0,0]],
        2: [[-o,-o],[ o, o]],
        3: [[-o,-o],[ 0, 0],[ o, o]],
        4: [[-o,-o],[ o,-o],[-o, o],[ o, o]],
        5: [[-o,-o],[ o,-o],[ 0, 0],[-o, o],[ o, o]],
        6: [[-o,-o],[ o,-o],[-o, 0],[ o, 0],[-o, o],[ o, o]]
      };
      pips[diceVal].forEach(([dx,dy]) => ellipse(dx,dy,r,r));
      pop();
    }

    /* ==================
       Carousel
       ================== */
    function triggerSpin(){
      if(!imgs.length || spinning) return;

      // If we previously removed side items, restore them
      if(imgs.length === 1 && imgsAll.length > 1){
        imgs = imgsAll.slice();
        cur = 0;
      }

      spinning = true;
      spinStart = millis();
      sideItemsRemoved = false;
      startIdx = cur;

      // random steps 3..6 => negative direction
      const steps = floor(random(3,7));
      targetIdx = cur - steps;

      // start sound
      playCarouselStartSound();
    }

    function updateCarousel(){
      if(!spinning) return;
      let t = constrain((millis() - spinStart)/SPIN_DUR, 0, 1);

      // ease-out
      let eased = 1 - Math.pow(1 - t, 3);
      cur = startIdx + (targetIdx - startIdx)*eased;

      if(t >= 1){
        spinning = false;
        cur = targetIdx;
        // stop sound
        playCarouselStopSound();

        // remove side items after 2s
        if(!sideItemsRemoved && imgs.length > 1){
          sideItemsRemoved = true;
          setTimeout(removeSideItems, 2000);
        }
      }
    }

    function removeSideItems(){
      if(!imgs.length) return;
      let cIdx = Math.round(cur) % imgs.length;
      if(cIdx < 0) cIdx += imgs.length;
      let chosenOne = imgs[cIdx];
      imgs = [chosenOne];
      cur = 0;
    }

    function drawCarousel(){
      if(!imgs.length) return;
      const total = imgs.length;
      const centerW = 0.30 * width, sideW = 0.15 * width;

      for(let i=0; i<total; i++){
        let rel = circularRel(i, cur, total);
        if(Math.abs(rel) > 1.2) continue;
        let xPos = rel * 0.4 * width;
        let w = lerp(centerW, sideW, Math.min(Math.abs(rel),1));
        let h = w * (imgs[i].height/imgs[i].width);

        push();
        translate(xPos,0,0);
        noStroke();
        texture(imgs[i]);
        plane(w,h);
        pop();
      }
    }

    function circularRel(i, center, total){
      let rel = i - center;
      rel = ((rel + total/2) % total) - total/2;
      return rel;
    }

    function makeColorCircle(c){
      let g = createGraphics(256,256);
      g.noStroke();
      g.fill(c);
      g.ellipse(128,128,220,220);
      return g;
    }

    /*
      Make a black background with large white letters
    */
    function makeWordGraphic(txt){
      let g = createGraphics(256,256);
      g.background(0);
      g.textAlign(CENTER, CENTER);
      g.textSize(100);
      g.fill(255);
      g.text(txt, 128, 128);
      return g;
    }

    /* 
      Key & Mouse
    */
    function keyPressed(){
      if(!started) return;
      if(key === ' '){
        // Press space => spin or roll dice
        if(mode === 'dice') {
          triggerRollClassic();
        } else if(mode === 'colors' || mode === 'photos' || mode === 'words'){
          triggerSpin();
        }
      }
    }

    function mousePressed(){
      if(!started) return;
      if(mode === 'dice'){
        triggerRollClassic();
      } else if(mode === 'colors' || mode === 'photos' || mode === 'words'){
        triggerSpin();
      }
    }

    /* 
      DOM hooking 
    */
    const diceBtn       = document.getElementById('mode-dice-button');
    const colorsBtn     = document.getElementById('mode-colors-button');
    const photosBtn     = document.getElementById('mode-photos-button');
    const wordsBtn      = document.getElementById('mode-words-button');

    const colorsOptions = document.getElementById('colorsOptions');
    const photosOptions = document.getElementById('photosOptions');
    const wordsOptions  = document.getElementById('wordsOptions');

    // Add Word button
    const addWordButton = document.getElementById('addWordButton');
    const wordsContainer = document.getElementById('wordsContainer');

    // Color arrays
    const availableColorsGrid = document.getElementById('availableColorsGrid');
    const selectedColorsGrid  = document.getElementById('selectedColorsGrid');

    // Photo toggles
    const radioFiles   = document.getElementById('radioFiles');
    const radioFolder  = document.getElementById('radioFolder');
    const fileInput    = document.getElementById('fileInput');
    const folderInput  = document.getElementById('folderInput');
    const fileSelectWrap   = document.getElementById('fileSelectWrap');
    const folderSelectWrap = document.getElementById('folderSelectWrap');

    // Start
    const startButton  = document.getElementById('startButton');

    mode = 'dice'; // default

    // Switch among modes
    diceBtn.onclick = () => {
      mode = 'dice';
      diceBtn.classList.add('selected');
      colorsBtn.classList.remove('selected');
      photosBtn.classList.remove('selected');
      wordsBtn.classList.remove('selected');

      colorsOptions.style.display = 'none';
      photosOptions.style.display  = 'none';
      wordsOptions.style.display   = 'none';
    };

    colorsBtn.onclick = () => {
      mode = 'colors';
      colorsBtn.classList.add('selected');
      diceBtn.classList.remove('selected');
      photosBtn.classList.remove('selected');
      wordsBtn.classList.remove('selected');

      colorsOptions.style.display = 'block';
      photosOptions.style.display = 'none';
      wordsOptions.style.display  = 'none';
      renderColorGrids();
    };

    photosBtn.onclick = () => {
      mode = 'photos';
      photosBtn.classList.add('selected');
      diceBtn.classList.remove('selected');
      colorsBtn.classList.remove('selected');
      wordsBtn.classList.remove('selected');

      colorsOptions.style.display = 'none';
      photosOptions.style.display = 'block';
      wordsOptions.style.display  = 'none';
    };

    wordsBtn.onclick = () => {
      mode = 'words';
      wordsBtn.classList.add('selected');
      diceBtn.classList.remove('selected');
      colorsBtn.classList.remove('selected');
      photosBtn.classList.remove('selected');

      colorsOptions.style.display = 'none';
      photosOptions.style.display = 'none';
      wordsOptions.style.display  = 'block';
    };

    // Photo toggles
    radioFiles.onclick = () => {
      fileSelectWrap.style.display   = 'block';
      folderSelectWrap.style.display = 'none';
    };
    radioFolder.onclick = () => {
      fileSelectWrap.style.display   = 'none';
      folderSelectWrap.style.display = 'block';
    };

    /*
      Renders the left/right color columns
      (Used by Colors mode)
    */
    function renderColorGrids(){
      availableColorsGrid.innerHTML = '';
      selectedColorsGrid.innerHTML  = '';

      // Left side
      availableColors.forEach(color => {
        let tile = document.createElement('div');
        tile.className = 'color-tile';
        tile.style.backgroundColor = color;
        tile.onclick = () => {
          availableColors = availableColors.filter(c => c !== color);
          selectedColors.push(color);
          renderColorGrids();
        };
        availableColorsGrid.appendChild(tile);
      });

      // Right side
      selectedColors.forEach(color => {
        let tile = document.createElement('div');
        tile.className = 'color-tile selected';
        tile.style.backgroundColor = color;
        tile.onclick = () => {
          selectedColors = selectedColors.filter(c => c !== color);
          availableColors.push(color);
          renderColorGrids();
        };
        selectedColorsGrid.appendChild(tile);
      });
    }

    // Listen for the + button in Words mode
    // Start with 4 fields, let user add up to 8
    addWordButton.onclick = () => {
      const currentFields = wordsContainer.querySelectorAll("input.word-input");
      if(currentFields.length >= 8){
        alert("Maximum 8 word fields.");
        return;
      }
      // create a new input
      const newInput = document.createElement('input');
      newInput.className = 'word-input';
      newInput.type = 'text';
      newInput.placeholder = `Word ${currentFields.length+1}`;
      wordsContainer.appendChild(newInput);
    };

    // Start Button
    startButton.onclick = () => {
      // Dice
      if(mode === 'dice'){
        document.getElementById('game-options').style.display = 'none';
        started = true;
        return;
      }

      // Colors
      if(mode === 'colors'){
        if(!selectedColors.length){
          alert('Please pick at least one color on the right side before starting.');
          return;
        }
        imgs = selectedColors.map(c => makeColorCircle(c));
        imgsAll = imgs.slice();
        sideItemsRemoved = false;

        document.getElementById('game-options').style.display = 'none';
        started = true;
        cur = 0;
        return;
      }

      // Photos
      if(mode === 'photos'){
        let files = radioFiles.checked ? fileInput.files : folderInput.files;
        if(!files.length){
          alert('Please select at least one image or folder.');
          return;
        }
        imgs = [];
        const tasks = [];
        for(let i=0; i<Math.min(files.length,6); i++){
          tasks.push(new Promise(resolve => {
            const fr = new FileReader();
            fr.onload = () => {
              imgs.push(loadImage(fr.result, resolve));
            };
            fr.readAsDataURL(files[i]);
          }));
        }
        Promise.all(tasks).then(() => {
          imgsAll = imgs.slice();
          sideItemsRemoved = false;
          document.getElementById('game-options').style.display = 'none';
          started = true;
          cur = 0;
        });
        return;
      }

      // Words
      if(mode === 'words'){
        // gather typed words from all input fields in #wordsContainer
        const fields = wordsContainer.querySelectorAll("input.word-input");
        let typedWords = [];
        fields.forEach((f) => {
          let val = f.value.trim();
          if(val) typedWords.push(val);
        });
        if(!typedWords.length){
          alert("Please enter at least one word.");
          return;
        }
        imgs = typedWords.map(w => makeWordGraphic(w));
        imgsAll = imgs.slice();
        sideItemsRemoved = false;

        document.getElementById('game-options').style.display = 'none';
        started = true;
        cur = 0;
        return;
      }
    };
  </script>
</body>
</html>
