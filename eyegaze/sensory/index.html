<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Eyegaze — Sensory Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    body.light { background:#fff; color:#000; }
    body.dark  { background:#000; color:#fff; }

    html, body { height:100%; margin:0; overflow:hidden; }
    canvas#c { position:fixed; inset:0; display:none; }

    #game-options.modal {
      display:flex; align-items:center; justify-content:center;
    }

    .value-badge{
      display:inline-block; min-width:2ch; padding:2px 6px; border-radius:8px;
      background:rgba(255,255,255,.12); color:#0b1a18; font-variant-numeric:tabular-nums
    }
    body.light .value-badge{ background:rgba(0,0,0,.08); color:inherit; }
  </style>
</head>
<body class="dark">
  <canvas id="c"></canvas>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title">Laboratoire Sensoriel</h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="muteSFX">
              <span>Désactiver les sons</span>
            </label>
          </div>
          <div class="option-item">
            <label for="sfxVol" class="teal-label">
              <span>Volume des sons:&nbsp;</span>
              <span id="sfxVolVal" class="value-badge">50</span>
            </label>
            <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="themeSelect" class="teal-label label-block">Mode</label>
            <select id="themeSelect" class="styled-select">
              <option value="light">Clair</option>
              <option value="dark" selected>Sombre</option>
            </select>
          </div>

          <div class="option-item">
            <label for="sceneSelect" class="teal-label label-block">Scène</label>
            <select id="sceneSelect" class="styled-select">
              <option value="aurora">Aurora</option>
              <option value="ripples">Ondes</option>
              <option value="fireworks" selected>Feux d’artifice</option>
              <option value="kaleido">Kaleido</option>
              <option value="fireflies">Lucioles</option>
              <option value="confetti">Confetti</option>
              <option value="nebula">Nébuleuse</option>
              <option value="jelly">Gelée</option>
              <option value="snow">Neige-Boule</option>
              <option value="sand">Sable Arc-en-ciel</option>
              <option value="magnet">Essaim Magnétique</option>
              <option value="glass">Vitrail</option>
              <option value="streamers">Rubans de Soie</option>
              <option value="laserharp">Harpe Laser</option>
              <option value="bubblepop">Bulle-Pop</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="intensitySlider" class="teal-label">
              <span>Intensité:&nbsp;</span>
              <span id="intensityVal" class="value-badge">50</span>
            </label>
            <input type="range" id="intensitySlider" class="styled-slider" min="0" max="100" value="50">
          </div>

          <div class="option-item">
            <label for="sizeSlider" class="teal-label">
              <span>Taille:&nbsp;</span>
              <span id="sizeVal" class="value-badge">105</span>
            </label>
            <input type="range" id="sizeSlider" class="styled-slider" min="10" max="200" value="105">
          </div>

          <div class="option-item">
            <label for="trailSlider" class="teal-label">
              <span>Traînée:&nbsp;</span>
              <span id="trailVal" class="value-badge">50</span>
            </label>
            <input type="range" id="trailSlider" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button">Commencer</button>
    </div>
  </div>

  <script src="../../js/eyegaze-menu.js"></script>

  <script>
  const startButton = document.getElementById('startButton');
  const themeSel  = document.getElementById('themeSelect');
  const sceneSel  = document.getElementById('sceneSelect');

  const muteSFX   = document.getElementById('muteSFX');
  const sfxVol    = document.getElementById('sfxVol');
  const sfxVolVal = document.getElementById('sfxVolVal');

  const intSlider = document.getElementById('intensitySlider');
  const sizeSlider= document.getElementById('sizeSlider');
  const trailSlider= document.getElementById('trailSlider');
  const intVal    = document.getElementById('intensityVal');
  const sizeVal   = document.getElementById('sizeVal');
  const trailVal  = document.getElementById('trailVal');

  function reflectSliders(){
    sfxVolVal.textContent = sfxVol.value;
    intVal.textContent = intSlider.value;
    sizeVal.textContent = sizeSlider.value;
    trailVal.textContent = trailSlider.value;
  }
  [sfxVol,intSlider,sizeSlider,trailSlider].forEach(el=>el.addEventListener('input', reflectSliders));
  reflectSliders();

  function applyTheme(){
    document.body.classList.remove('light','dark');
    document.body.classList.add(themeSel.value === 'light' ? 'light' : 'dark');
  }
  themeSel.addEventListener('change', applyTheme);
  applyTheme();

  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d', { alpha:false });
  let W = innerWidth, H = innerHeight;
  cvs.width = W; cvs.height = H;

  addEventListener('resize', ()=>{
    W=innerWidth; H=innerHeight; cvs.width=W; cvs.height=H;
    if (typeof resizeGlass === 'function') resizeGlass();
    if (typeof resizeLaser === 'function') resizeLaser();
    if (typeof caSandOnResize === 'function') caSandOnResize();
    if (typeof auroraResize === 'function') auroraResize();
    if (typeof snowResize === 'function') snowResize();
    if (typeof magnetResize === 'function') magnetResize();
    if (typeof ribbonsResize === 'function') ribbonsResize();
  });

  let menuOpen = true;
  cvs.style.display = 'none';

  let ac=null;
  function ensureAC(){ if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)(); return ac; }

  function currentSfxGain(){
    const vol = (parseInt(sfxVol.value,10)||50)/100;
    return (muteSFX.checked?0:1) * vol;
  }

  function playPing(f=440, len=0.2, gain=0.05){
    if (menuOpen) return;
    try{
      ensureAC();
      const master = currentSfxGain();
      if (master <= 0) return;
      const o=ac.createOscillator(), g=ac.createGain(), hp=ac.createBiquadFilter();
      hp.type='highpass'; hp.frequency.value=300;
      o.type='sine'; o.frequency.value=f;
      g.gain.value = gain * master;
      o.connect(hp).connect(g).connect(ac.destination);
      const t = ac.currentTime;
      o.start(t);
      g.gain.setValueAtTime(g.gain.value, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t+len);
      o.stop(t+len+0.02);
    }catch(e){}
  }

  const ui = {
    get mode(){ return sceneSel; },
    get intensity(){ return intSlider; },
    get size(){ return sizeSlider; },
    get trail(){ return trailSlider; }
  };

  let paused=false;
  let mouse = { x:W/2, y:H/2, vx:0, vy:0, speed:0, down:false };
  let last  = { x:mouse.x, y:mouse.y, t:performance.now() };
  let lastMoveT = performance.now();
  let dwellMs = 0;
  let now = performance.now();

  addEventListener('mousemove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const nx=e.clientX, ny=e.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
  }, {passive:true});

  addEventListener('touchmove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const touch=e.touches[0]; if(!touch) return;
    const nx=touch.clientX, ny=touch.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
  }, {passive:true});

  addEventListener('pointerdown', ()=>{ mouse.down=true; lastMoveT = performance.now(); playPing(700,0.08,0.05); });
  addEventListener('pointerup',   ()=>{ mouse.down=false; });

  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  const mapTrail = ()=> {
    const t = Number(ui.trail.value)/100;
    const shaped = Math.pow(1 - t, 2.2);
    return clamp(0.01 + shaped*0.98, 0.01, 0.99);
  };
  const mapIntensity = ()=> {
    const t = Number(ui.intensity.value)/100;
    return clamp(Math.pow(t, 1.6), 0, 1);
  };
  const mapSize = ()=> {
    const s = Number(ui.size.value);
    const t = (s - 10) / 190;
    const shaped = Math.pow(t, 1.35);
    return 8 + shaped * 420;
  };
  const sizeNorm = ()=> clamp((Number(ui.size.value)-10)/190, 0, 1);

  function mapSizeJelly(){
    const s = Number(ui.size.value);
    const sEff = 10 + (s - 10) * (50/90);
    const t = (sEff - 10) / 190;
    const shaped = Math.pow(t, 1.35);
    return 8 + shaped * 420;
  }

  const dwellFactor=()=> clamp(dwellMs/1200,0,1);
  let lastDwellStage=0;
  function dwellJustCrossed(ms){
    const stage = dwellMs >= ms ? 1 : 0;
    const crossed = stage > lastDwellStage;
    lastDwellStage = stage;
    return crossed;
  }
  function clearToBg(hard=false){
    const isLight = document.body.classList.contains('light');
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = hard ? (isLight ? '#fff' : '#000')
                         : (isLight ? `rgba(255,255,255,${mapTrail()})` : `rgba(0,0,0,${mapTrail()})`);
    ctx.fillRect(0,0,W,H);
  }

  /* =========================
     AURORA
     ========================= */
  const AUR = { t:0, hueBase:140, stars:[], ribbons:[] };
  function fbm(x, t=0){ let v=0,a=0.5,f=1.0; for(let i=0;i<4;i++){ v+=a*Math.sin(x*f+t*(0.35+i*0.07)+i*1.3); a*=0.5; f*=1.8; } return v; }
  function auroraInit(){
    const n = Math.floor((W*H)/18000);
    AUR.stars = Array.from({length:n}, () => ({ x:Math.random()*W, y:Math.random()*H, z:Math.random(), a:0.25+Math.random()*0.5 }));
    AUR.ribbons = [
      { amp:70,  thick:42, hue:(AUR.hueBase+40)%360, speed:0.5, alpha:0.10, warp:0.75, offsetY:0.60, jitter:0.5 },
      { amp:100, thick:58, hue:(AUR.hueBase+0)%360,  speed:0.7, alpha:0.16, warp:1.00, offsetY:0.52, jitter:0.9 },
      { amp:130, thick:66, hue:(AUR.hueBase-40+360)%360, speed:0.9, alpha:0.22, warp:1.15, offsetY:0.44, jitter:1.2 },
    ];
  }
  function auroraResize(){ auroraInit(); }
  auroraInit();

  function drawStars(dt, boost=1){
    ctx.globalCompositeOperation = 'screen';
    for (const s of AUR.stars){
      s.x += mouse.vx * 0.000015 * (0.3 + s.z);
      if (s.x < -5) s.x = W+5; if (s.x > W+5) s.x = -5;
      const px = s.x - (mouse.x - W*0.5) * 0.04 * s.z;
      const py = s.y - (mouse.y - H*0.5) * 0.02 * s.z;
      const r = 0.6 + s.z*1.4;
      const alpha = (s.a) * boost;
      ctx.fillStyle = `hsla(200,100%,${70+25*s.z}%,${alpha})`;
      ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawCurtainRibbon(rib, t, intensity){
    const followY = 0.18 + 0.22*intensity;
    const baseY = H * rib.offsetY + (mouse.y - H*0.5) * followY;
    const step = 10; const upper=[]; const lower=[];
    for (let x=0; x<=W; x+=step){
      const u = x / W;
      const phaseShift = (mouse.x/W - 0.5) * 1.2;
      const n = fbm(u*6*rib.warp + rib.jitter*0.6 + phaseShift, t*rib.speed);
      const amp = rib.amp * (0.8 + 0.7*intensity) * (1 + dwellFactor()*0.25);
      const dx = (x - mouse.x);
      const prox = Math.max(0, 1 - Math.abs(dx) / (W*0.6));
      const bend = - (dx / W) * amp * 0.55 * prox * (0.6 + intensity);
      const y = baseY + n*amp + Math.sin(u*3 + t*0.3)*amp*0.05 + bend;
      const thick = rib.thick * (0.85 + 0.6*intensity) * (0.9 + 0.25*Math.abs(n));
      upper.push([x, y - thick]); lower.push([x, y + thick]);
    }
    const hue = (rib.hue + 20*Math.sin(t*0.15))%360;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = `hsla(${hue}, 95%, 60%, ${rib.alpha})`;
    ctx.beginPath(); for (let i=0;i<upper.length;i++){ const [x,y]=upper[i]; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    for (let i=lower.length-1;i>=0;i--){ const [x,y]=lower[i]; ctx.lineTo(x, y); }
    ctx.closePath(); ctx.fill();
    ctx.globalCompositeOperation = 'screen';
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0.25, `hsla(${(hue+60)%360},95%,75%,0)`); g.addColorStop(0.50, `hsla(${hue},95%,75%,0.28)`); g.addColorStop(0.75, `hsla(${(hue+300)%360},95%,75%,0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    for (let i=0;i<upper.length;i++){ const [x,y]=upper[i]; ctx.lineTo(x, y + 0.55*(lower[i][1]-upper[i][1])); }
    for (let i=lower.length-1;i>=0;i--){ const [x,y]=lower[i]; ctx.lineTo(x, y - 0.55*(y - upper[i][1])); }
    ctx.closePath(); ctx.fill();
  }
  function renderAurora(dt){
    AUR.t += dt; AUR.hueBase = (AUR.hueBase + 12*dt) % 360;
    ctx.globalCompositeOperation='source-over';
    const isLight = document.body.classList.contains('light');
    const fade = isLight ? `rgba(255,255,255,${mapTrail()*0.9})` : `rgba(0,0,0,${mapTrail()*0.9})`;
    ctx.fillStyle = fade; ctx.fillRect(0,0,W,H);
    const intensity = mapIntensity(); drawStars(dt);
    for (let i=0;i<AUR.ribbons.length;i++){ const rib=AUR.ribbons[i]; rib.hue=(rib.hue+6*dt)%360; drawCurtainRibbon(rib, AUR.t + i*0.12, intensity); }
    if (dwellMs>500){
      ctx.globalCompositeOperation='screen';
      const r = 140 + 300*intensity;
      const g = ctx.createRadialGradient(mouse.x, mouse.y, r*0.08, mouse.x, mouse.y, r);
      g.addColorStop(0, `hsla(${(AUR.hueBase+90)%360},100%,75%,0.20)`); g.addColorStop(1, `hsla(0,0%,0%,0)`);
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, r, 0, Math.PI*2); ctx.fill();
    }
  }

  /* =========================
     RIPPLES
     ========================= */
  const ripples = [];
  const halos = [];
  let rippleCooldown = 0;
  let waterT = 0;

  function emitRipple(x, y, power=1){
    const sp   = 54 + 42*mapIntensity();
    const hue  = 198 + Math.random()*22;
    const sat  = 92;
    const lite = 50 + power*4;
    ripples.push({
      x, y, r:0,
      vr: sp * (0.9 + Math.random()*0.22),
      width: 5.5 + mapSize()*0.06 + power*2.5,
      life: 1.0, hue, sat, lite,
      phase: Math.random()*Math.PI*2
    });
  }
  function emitHalo(x, y, strength=1){
    const hue = 200 + Math.random()*16;
    halos.push({
      x, y, r:24,
      vr: (160 + 280*mapIntensity()) * (0.7 + 0.6*Math.random()),
      a: 0.28 * strength, hue
    });
  }
  function renderRipples(dt){
    waterT += dt;

    const baseHue = 210, baseSat = 70;
    const baseLight = document.body.classList.contains('light') ? 18 : 8;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = `hsla(${baseHue}, ${baseSat}%, ${baseLight}%, ${mapTrail()})`;
    ctx.fillRect(0,0,W,H);

    const tideR = (420 + mapSize()*1.2) * (1 + 0.05*Math.sin(waterT*0.7));
    const tide = ctx.createRadialGradient(mouse.x, mouse.y, tideR*0.25, mouse.x, mouse.y, tideR);
    tide.addColorStop(0, `hsla(205, 60%, 30%, ${0.06 + 0.04*Math.sin(waterT*1.1)})`);
    tide.addColorStop(1, `hsla(205, 60%, 20%, 0)`);
    ctx.globalCompositeOperation='screen';
    ctx.fillStyle = tide;
    ctx.beginPath(); ctx.arc(mouse.x, mouse.y, tideR, 0, Math.PI*2); ctx.fill();

    const speedN = clamp(mouse.speed/1200, 0, 1);
    rippleCooldown = Math.max(0, rippleCooldown - dt);
    if (speedN > 0.10 && rippleCooldown <= 0){
      emitRipple(mouse.x, mouse.y, 0.25 + speedN*0.55);
      rippleCooldown = 0.04 + (0.10*(1-mapIntensity()));
    }
    if (dwellJustCrossed(650)){
      playPing(520,0.16,0.05);
      for (let i=0;i<2;i++) emitRipple(mouse.x, mouse.y, 1.1);
      emitHalo(mouse.x, mouse.y, 0.9);
    }

    for (let i=halos.length-1;i>=0;i--){
      const h = halos[i];
      h.r  += h.vr*dt;
      h.a  *= Math.pow(0.975 - 0.15*dt, 1.0);
      if (h.a < 0.02 || h.r > Math.max(W,H)*1.2){ halos.splice(i,1); continue; }
      const g = ctx.createRadialGradient(h.x, h.y, h.r*0.15, h.x, h.y, h.r);
      g.addColorStop(0.0, `hsla(${h.hue}, 90%, 65%, ${0.10*h.a})`);
      g.addColorStop(0.6, `hsla(${h.hue+8}, 90%, 55%, ${0.08*h.a})`);
      g.addColorStop(1.0, `hsla(${h.hue+30}, 90%, 45%, 0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(h.x, h.y, h.r, 0, Math.PI*2); ctx.fill();
    }

    for (let i=ripples.length-1;i>=0;i--){
      const r = ripples[i];
      r.r    += r.vr*dt;
      r.life *= Math.pow(0.985 - 0.20*dt, 1 + 0.6*mapIntensity());
      const alive = clamp(r.life, 0, 1);
      if (alive < 0.02 || r.r > Math.hypot(W,H)){ ripples.splice(i,1); continue; }

      r.phase += dt*(0.8 + 0.6*mapIntensity());
      const shimmer = 1 + 0.18*Math.sin(r.phase) + 0.08*Math.sin(waterT*1.7 + i*0.6);
      const w = (r.width * (0.75 + 0.45*alive)) * shimmer;

      ctx.globalCompositeOperation = 'screen';
      const glowR1 = r.r*0.90, glowR2 = r.r*1.20;
      const g1 = ctx.createRadialGradient(r.x, r.y, glowR1*0.45, r.x, r.y, glowR1);
      g1.addColorStop(0, `hsla(${r.hue}, ${r.sat}%, ${r.lite+8}%, ${0.08*alive})`);
      g1.addColorStop(1, `hsla(${r.hue+10}, ${r.sat}%, ${r.lite-6}%, 0)`);
      ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(r.x, r.y, glowR1, 0, Math.PI*2); ctx.fill();

      const g2 = ctx.createRadialGradient(r.x, r.y, glowR2*0.55, r.x, r.y, glowR2);
      g2.addColorStop(0, `hsla(${r.hue+12}, ${r.sat}%, ${r.lite}%, ${0.06*alive})`);
      g2.addColorStop(1, `hsla(${r.hue+28}, ${r.sat}%, ${r.lite-10}%, 0)`);
      ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(r.x, r.y, glowR2, 0, Math.PI*2); ctx.fill();

      ctx.globalCompositeOperation='lighter';
      const hues   = [ r.hue-10, r.hue, r.hue+12 ];
      const alphas = [ alive*0.20, alive*0.38, alive*0.20 ];
      const radii  = [ r.r*0.985, r.r, r.r*1.015 ];

      for (let k=0;k<3;k++){
        ctx.strokeStyle = `hsla(${hues[k]}, ${r.sat}%, ${r.lite}%, ${alphas[k]})`;
        ctx.lineWidth   = Math.max(1.2, w * (k===1?1:0.7));
        ctx.beginPath();
        ctx.arc(r.x, r.y, Math.max(0.1, radii[k]), 0, Math.PI*2);
        ctx.stroke();
      }

      const echoAlpha = 0.13 * alive;
      if (echoAlpha > 0.01){
        ctx.strokeStyle = `hsla(${r.hue+6}, ${r.sat}%, ${r.lite-4}%, ${echoAlpha})`;
        ctx.lineWidth   = Math.max(1, w*0.55);
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r*0.55, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  /* =========================
     FIREWORKS
     ========================= */
  const fwParts = [];
  let fwHueBase = 0;
  let fwMoveCooldown = 0;
  let fwAutoCooldown = 0;

  function fwSpawnBurst(x, y, power=1, style='peony'){
    const sN = sizeNorm();
    const sPow = Math.pow(sN, 1.15);
    const base = 16 + Math.floor(28*mapIntensity());
    const count = Math.floor(base * (0.5 + 2.7*sPow) * power);

    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const speedBase = 1.8 + Math.random()*2.8;
      const speed = speedBase * (0.7 + 1.6*sPow);
      let vx = Math.cos(a)*speed, vy = Math.sin(a)*speed;

      if (style==='ring'){
        const ringR = (2.2 + Math.random()*1.2) * (0.8 + 1.4*sPow);
        vx = Math.cos(a)*ringR; vy = Math.sin(a)*ringR;
      } else if (style==='willow'){
        const willowS = (1.3 + Math.random()*1.1) * (0.7 + 1.4*sPow);
        vx = Math.cos(a)*willowS*0.85; vy = Math.sin(a)*willowS*0.6 - (0.8 + 0.6*sPow);
      }

      const hue = (fwHueBase + (Math.random()*40 - 20) + i)%360;
      fwParts.push({
        x, y, px:x, py:y,
        vx, vy,
        drag: 0.986,
        gy: 0.02,
        life: (0.6 + Math.random()*0.6) * (0.8 + 1.6*sPow),
        age: 0,
        size: (0.7 + Math.random()*1.2) * (0.8 + 2.6*sPow),
        hue,
        light: 60 + Math.random()*10,
        sat: 95
      });
    }
    if (power > 1.1) playPing(420+Math.random()*280, 0.15, 0.05);
  }

  function renderFireworks(dt){
    fwHueBase = (fwHueBase + 60*dt) % 360;

    const isLight = document.body.classList.contains('light');
    const fade = isLight ? `rgba(255,255,255,${mapTrail()*0.85})` : `rgba(0,0,0,${mapTrail()*0.82})`;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = fade; ctx.fillRect(0,0,W,H);

    fwMoveCooldown = Math.max(0, fwMoveCooldown - dt);
    fwAutoCooldown = Math.max(0, fwAutoCooldown - dt);
    const speedN = clamp(mouse.speed/1200, 0, 1);
    const sN = sizeNorm();

    if (speedN > 0.25 && fwMoveCooldown === 0){
      const pow = 0.8 + 0.8*speedN*mapIntensity();
      const style = (Math.random() < 0.25) ? 'ring' : (Math.random()<0.15 ? 'willow' : 'peony');
      fwSpawnBurst(mouse.x, mouse.y, pow, style);
      fwMoveCooldown = (0.08 + 0.10*(1-mapIntensity())) * (0.85 + 0.3*(1-sN));
    }
    if (dwellJustCrossed(600)){
      fwSpawnBurst(mouse.x, mouse.y, 1.2 + 0.9*mapIntensity(), (Math.random()<0.3?'ring':'peony'));
    }
    if (fwAutoCooldown === 0 && Math.random() < 0.02*mapIntensity()*(0.7 + 0.8*sN)){
      fwSpawnBurst(mouse.x + (Math.random()-0.5)*60, mouse.y + (Math.random()-0.5)*40, 0.9 + 0.6*sN, 'peony');
      fwAutoCooldown = 0.25 * (0.9 + 0.6*(1-sN));
    }

    ctx.globalCompositeOperation='lighter';
    ctx.lineCap='round';
    for (let i=fwParts.length-1;i>=0;i--){
      const p = fwParts[i];
      p.age += dt;
      if (p.age >= p.life){ fwParts.splice(i,1); continue; }

      p.vx *= Math.pow(p.drag, dt*60);
      p.vy = p.vy*Math.pow(p.drag, dt*60) + p.gy*(dt*60);
      p.px = p.x; p.py = p.y;
      p.x += p.vx*(dt*60);
      p.y += p.vy*(dt*60);

      const t = p.age / p.life;
      const alpha = Math.max(0, (1 - t) * (0.65 - 0.25*t));

      const strokeScale = 0.7 + 2.2*sN;
      ctx.strokeStyle = `hsla(${p.hue}, ${p.sat}%, ${p.light}%, ${alpha})`;
      ctx.lineWidth   = Math.max(1, (p.size * (1 - 0.5*t)) * strokeScale);
      ctx.beginPath(); ctx.moveTo(p.px, p.py); ctx.lineTo(p.x, p.y); ctx.stroke();

      const glowAlpha = alpha * (0.6 + 0.8*sN);
      ctx.fillStyle = `hsla(${(p.hue+10)%360}, ${p.sat}%, ${Math.min(90, p.light+15)}%, ${glowAlpha})`;
      const glowR = Math.max(1, p.size * (0.6 + 2.0*sN));
      ctx.beginPath(); ctx.arc(p.x, p.y, glowR*0.6, 0, Math.PI*2); ctx.fill();
    }

    const cap = Math.floor(900 + 1200*sizeNorm());
    if (fwParts.length > cap) fwParts.splice(0, fwParts.length - cap);
  }

  /* =========================
     KALEIDO
     ========================= */
  let hueBase = 0;
  let kaleidoAngle=0;
  function renderKaleido(dt){
    const segs=8, r=mapSize()*0.8; kaleidoAngle += dt*0.4;
    clearToBg(false);
    const cx=W/2, cy=H/2, dx=mouse.x-cx, dy=mouse.y-cy;
    const baseHue=(performance.now()*0.02)%360, w=7+mapIntensity()*18;
    ctx.globalCompositeOperation='lighter'; ctx.lineCap='round'; ctx.lineJoin='round';
    for (let i=0;i<segs;i++){
      const a=(i/segs)*Math.PI*2 + kaleidoAngle;
      const x = cx + (dx*Math.cos(a) - dy*Math.sin(a));
      const y = cy + (dx*Math.sin(a) + dy*Math.cos(a));
      const h=(baseHue + i*(360/segs))%360;
      ctx.strokeStyle=`hsla(${h},85%,65%,0.5)`; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(lerp(cx,x,0.55), lerp(cy,y,0.55)); ctx.lineTo(x,y); ctx.stroke();
      ctx.fillStyle=`hsla(${(h+40)%360},85%,60%,0.25)`; ctx.beginPath(); ctx.arc(x,y, r*0.28, 0, Math.PI*2); ctx.fill();
    }
    if (dwellMs>600){
      const s=r*(1+0.12*Math.sin(performance.now()*0.006));
      ctx.strokeStyle=`hsla(${(baseHue+120)%360},90%,75%,0.35)`; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(cx,cy,s,0,Math.PI*2); ctx.stroke();
    }
  }

  /* =========================
     FIREFLIES
     ========================= */
  const fireflies = Array.from({length:50},()=>({ x: Math.random()*W, y: Math.random()*H, vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6, glow: Math.random()*0.6 }));
  function renderFireflies(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    const attract = 15*mapIntensity();
    fireflies.forEach(f=>{
      f.vx += (Math.random()-0.5)*0.05; f.vy += (Math.random()-0.5)*0.05;
      f.vx += (mouse.x - f.x)/W * attract*dt; f.vy += (mouse.y - f.y)/H * attract*dt;
      f.vx = clamp(f.vx, -1.2, 1.2); f.vy = clamp(f.vy, -1.2, 1.2);
      f.x += f.vx; f.y += f.vy;
      if (f.x<-10) f.x=W+10; if (f.x>W+10) f.x=-10; if (f.y<-10) f.y=H+10; if (f.y>H+10) f.y=-10;
      const d = Math.hypot(mouse.x-f.x, mouse.y-f.y), charge = clamp(1 - d/220, 0, 1);
      f.glow = clamp(f.glow + (charge*1.6 - 0.4)*dt, 0.1, 1.4);
      const h = (200 + f.glow*100)%360, r = 2 + f.glow*4 + mapSize()*0.05;
      ctx.fillStyle = `hsla(${h},90%,65%,${0.6*f.glow})`; ctx.beginPath(); ctx.arc(f.x, f.y, r, 0, Math.PI*2); ctx.fill();
    });
    if (dwellJustCrossed(800)){ playPing(660,0.15,0.045); fireflies.forEach(f=> f.glow = Math.max(f.glow, 1.2)); }
  }

  /* =========================
     CONFETTI
     ========================= */
  const confettis = Array.from({length:220},()=>resetPiece({}));
  function resetPiece(p){
    p.x=Math.random()*W; p.y=Math.random()*H; p.vx=(Math.random()-0.5)*0.7; p.vy=Math.random()*0.6+0.2;
    p.size=2+Math.random()*4; p.h=Math.random()*360; p.spin=(Math.random()-0.5)*0.15; return p;
  }
  function renderConfetti(dt){
    clearToBg(false);
    const windX = clamp(mouse.vx/400, -1.5, 1.5) * (0.5 + mapIntensity());
    const windY = 0.15 + (dwellMs>600 ? 0.25 : 0);
    ctx.globalCompositeOperation='lighter';
    confettis.forEach(p=>{
      const dx = mouse.x - p.x, dy = mouse.y - p.y, pull = 0.02*mapIntensity();
      p.vx += windX*dt + dx*pull*dt; p.vy += windY*dt + dy*pull*dt;
      p.x += p.vx; p.y += p.vy; p.h += p.spin;
      ctx.fillStyle = `hsla(${(p.h)%360},90%,60%,0.8)`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
      if (p.x<-20||p.x>W+20||p.y<-20||p.y>H+20) resetPiece(p);
    });
    if (dwellJustCrossed(700)){
      playPing(550,0.12,0.04);
      for(let i=0;i<50;i++){ const q=resetPiece({}); q.x=mouse.x; q.y=mouse.y; q.vx=(Math.random()-0.5)*3.2; q.vy=Math.random()*-1.8; confettis.push(q); }
      if (confettis.length>400) confettis.splice(0, confettis.length-400);
    }
  }

  /* =========================
     NÉBULEUSE
     ========================= */
  let nebulaHue = 0;
  function renderNebula(dt){
    nebulaHue = (nebulaHue + 18*dt) % 360;
    clearToBg(false);
    if (!AUR.stars || AUR.stars.length === 0) auroraInit();
    drawStars(dt, 1.35);
    ctx.globalCompositeOperation='lighter';
    const layers = 3 + Math.floor(mapIntensity()*3);
    for (let i=0;i<layers;i++){
      const s = mapSize()*(0.8 + i*0.35), h = (nebulaHue + i*40) % 360;
      const g = ctx.createRadialGradient(mouse.x, mouse.y, s*0.1, mouse.x, mouse.y, s);
      g.addColorStop(0, `hsla(${h},85%,60%,0.18)`);
      g.addColorStop(0.6, `hsla(${(h+30)%360},85%,50%,0.08)`);
      g.addColorStop(1, `hsla(${(h+60)%360},85%,45%,0)`);
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, s, 0, Math.PI*2); ctx.fill();
    }
    if (dwellMs>650){
      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(nebulaHue+150)%360},90%,75%,0.4)`;
      ctx.lineWidth = 1.5;
      const m = 6;
      for (let i=0;i<m;i++){
        const a=(i/m)*Math.PI*2 + performance.now()*0.0015, r=mapSize()*1.1;
        ctx.beginPath(); ctx.arc(mouse.x + Math.cos(a)*r, mouse.y + Math.sin(a)*r, r*0.15, 0, Math.PI*2); ctx.stroke();
      }
    }
  }

  /* =========================
     GELÉE
     ========================= */
  const blobs = Array.from({length:6}, ()=>({
    x: W*(0.2+0.6*Math.random()),
    y: H*(0.2+0.6*Math.random()),
    r: 40+Math.random()*80,
    hue: Math.random()*360,
    vx:0, vy:0
  }));
  function renderJelly(dt){
    clearToBg(false);
    const intensity = mapIntensity();
    const pull = 18*intensity;
    const damping = 0.99;
    const gravity = 0.012;
    const sizeJ = mapSizeJelly();

    blobs.forEach(b=>{
      const dx = mouse.x - b.x, dy = mouse.y - b.y;
      b.vx += dx * pull * 0.00018;
      b.vy += dy * pull * 0.00018 + gravity;
      b.vx *= damping; b.vy *= damping;
      b.x += b.vx; b.y += b.vy;
      if (b.x < -120) b.x = W+120; else if (b.x > W+120) b.x = -120;
      if (b.y < -120) b.y = H+120; else if (b.y > H+120) b.y = -120;
    });

    const parts = blobs.map(b=>{
      const speed = Math.hypot(b.vx, b.vy);
      const squish = clamp(1 + speed*0.03, 1, 1.5) * (1 + dwellFactor()*0.15);
      const rx = b.r * squish * (sizeJ/95);
      const ry = b.r * (2 - squish) * (sizeJ/95);
      const R  = (rx + ry) * 0.5;
      const h  = (b.hue + performance.now()*0.02)%360;
      return { b, rx, ry, R, h, squish };
    });

    for (let iter=0; iter<2; iter++){
      for (let i=0; i<parts.length; i++){
        for (let j=i+1; j<parts.length; j++){
          const pi = parts[i], pj = parts[j];
          const ax = pi.b.x, ay = pi.b.y;
          const bx = pj.b.x, by = pj.b.y;
          let dx = bx - ax, dy = by - ay;
          let d = Math.hypot(dx,dy);
          if (d === 0){ dx = (Math.random()-0.5)*0.001; dy=(Math.random()-0.5)*0.001; d = Math.hypot(dx,dy); }
          const minD = (pi.R + pj.R) * 0.95;
          if (d < minD){
            const push = (minD - d) * 0.5;
            const nx = dx / d, ny = dy / d;
            pi.b.x -= nx*push; pi.b.y -= ny*push;
            pj.b.x += nx*push; pj.b.y += ny*push;
            pi.b.vx *= 0.9; pi.b.vy *= 0.9;
            pj.b.vx *= 0.9; pj.b.vy *= 0.9;
          }
        }
      }
    }

    const links = [];
    for (let i=0;i<parts.length;i++){
      let bestJ=-1, bestD=1e9;
      for (let j=0;j<parts.length;j++){
        if (j===i) continue;
        const di = Math.hypot(parts[j].b.x - parts[i].b.x, parts[j].b.y - parts[i].b.y);
        if (di < bestD){ bestD=di; bestJ=j; }
      }
      if (bestJ>=0){
        const span = (parts[i].R + parts[bestJ].R) * 0.8;
        if (bestD < span) links.push([i, bestJ, bestD, span]);
      }
    }
    links.sort((A,B)=>A[2]-B[2]);
    if (links.length > 12) links.length = 12;

    ctx.lineJoin='round'; ctx.lineCap='round';
    parts.forEach(p=>{
      const b = p.b;
      ctx.globalCompositeOperation='multiply';
      const sx = b.x + b.vx*4, sy = b.y + b.vy*4;
      const sg = ctx.createRadialGradient(sx, sy, Math.min(p.rx,p.ry)*0.2, sx, sy, Math.max(p.rx,p.ry)*1.05);
      sg.addColorStop(0, 'rgba(0,0,0,0.10)');
      sg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = sg;
      ctx.beginPath(); ctx.ellipse(sx, sy, p.rx*1.02, p.ry*1.02, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.fill();
    });

    parts.forEach(p=>{
      const b = p.b;
      ctx.globalCompositeOperation='lighter';
      const g = ctx.createRadialGradient(b.x, b.y, Math.min(p.rx,p.ry)*0.28, b.x, b.y, Math.max(p.rx,p.ry));
      g.addColorStop(0.00, `hsla(${p.h},95%,58%,0.60)`);
      g.addColorStop(0.55, `hsla(${(p.h+30)%360},95%,50%,0.32)`);
      g.addColorStop(1.00, `hsla(${(p.h+60)%360},90%,45%,0.0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.ellipse(b.x, b.y, p.rx, p.ry, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.fill();

      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(p.h+40)%360},95%,80%,0.35)`;
      ctx.lineWidth = Math.max(1.2, 1.5 + sizeJ*0.01);
      ctx.beginPath(); ctx.ellipse(b.x, b.y, p.rx*0.98, p.ry*0.98, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.stroke();

      const glx = b.x - p.rx*0.28, gly = b.y - p.ry*0.28;
      const glr = Math.min(p.rx,p.ry)*0.22;
      const gl = ctx.createRadialGradient(glx, gly, glr*0.2, glx, gly, glr);
      gl.addColorStop(0, 'rgba(255,255,255,0.25)');
      gl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gl;
      ctx.beginPath(); ctx.arc(glx, gly, glr, 0, Math.PI*2); ctx.fill();
    });

    ctx.globalCompositeOperation='screen';
    links.forEach(link=>{
      const i = link[0], j = link[1], d = link[2], span = link[3];
      const a = parts[i], b = parts[j];
      const t = clamp(1 - d/span, 0, 1);
      if (t <= 0) return;
      const midH = ((a.h + b.h)*0.5) % 360;
      ctx.strokeStyle = `hsla(${midH},95%,70%,${0.08 + 0.22*t*(0.6+0.4*mapIntensity())})`;
      ctx.lineWidth = 2 + t * (2 + mapSizeJelly()*0.02);
      const mx = (a.b.x + b.b.x) * 0.5;
      const my = (a.b.y + b.b.y) * 0.5;
      const cx = mx + (mouse.x - mx) * 0.02 * t;
      const cy = my + (mouse.y - my) * 0.02 * t;
      ctx.beginPath();
      ctx.moveTo(a.b.x, a.b.y);
      ctx.quadraticCurveTo(cx, cy, b.b.x, b.b.y);
      ctx.stroke();
    });

    if (dwellJustCrossed(900)){
      playPing(330,0.12,0.05);
      blobs.forEach(b=>{ b.vx*=0.6; b.vy*=-0.8; b.hue = (b.hue+15)%360; });
    }
  }

  /* =========================
     SNOW — simplified & reactive
     ========================= */
  const SNOW = {
    layers: [[],[],[]],
    ground: { cell: 6, cols: 0, h: null },
    frameCounter: 0
  };

  function snowResize(){
    const c = SNOW.ground.cell;
    SNOW.ground.cols = Math.max(4, Math.floor(W / c));
    SNOW.ground.h = new Float32Array(SNOW.ground.cols);
    SNOW.ground.h.fill(0);
    initSnowFlakes();
  }

  function initSnowFlakes(){
    SNOW.layers.forEach(a=>a.length=0);
    const density = 0.00006;
    const N = clamp(Math.floor(W*H*density*(0.7 + 0.9*mapIntensity())), 180, 900);
    const counts = [Math.floor(N*0.35), Math.floor(N*0.40), N];
    for (let i=0;i<counts[0];i++) SNOW.layers[0].push(makeFlake(0.35));
    for (let i=0;i<counts[1];i++) SNOW.layers[1].push(makeFlake(0.65));
    for (let i=0;i<counts[2];i++) SNOW.layers[2].push(makeFlake(0.95));
  }

  function makeFlake(depth){
    const z = depth;
    const baseR = 0.8 + 2.2*z + sizeNorm()*1.4*z;
    const speed = (0.10 + 0.50*z) * (0.75 + 0.6*mapIntensity());
    return {
      x: Math.random()*W,
      y: Math.random()*H,
      z,
      r: baseR,
      vx: (Math.random()-0.5)*0.06*z,
      vy: speed,
      phase: Math.random()*Math.PI*2,
      swayAmp: 0.15 + 0.9*z
    };
  }
  function resetFlake(f, burst=false){
    f.x = Math.random()*W;
    f.y = (-20) - Math.random()*40;
    f.vx = (Math.random()-0.5)*0.08*f.z + (burst? (Math.random()-0.5)*0.6 : 0);
    f.vy = (0.10 + 0.50*f.z) * (0.75 + 0.6*mapIntensity()) + (burst? -0.3 : 0);
    f.phase = Math.random()*Math.PI*2;
  }

  function groundDeposit(x, amount){
    const G = SNOW.ground;
    const i = clamp(Math.floor(x / G.cell), 0, G.cols-1);
    G.h[i] += amount;
  }

  function groundDiffuseCheap(){
    const G = SNOW.ground;
    for (let i=1;i<G.cols-1;i++){
      const avg = (G.h[i-1]+G.h[i]+G.h[i+1]) / 3;
      G.h[i] = lerp(G.h[i], avg, 0.25);
    }
  }

  function drawSky(){
    ctx.globalCompositeOperation='source-over';
    const isLight = document.body.classList.contains('light');
    const g = ctx.createLinearGradient(0,0,0,H);
    if (isLight){
      g.addColorStop(0, 'rgba(225,235,255,1)');
      g.addColorStop(1, 'rgba(245,250,255,1)');
    } else {
      g.addColorStop(0, 'rgba(12,18,28,1)');
      g.addColorStop(1, 'rgba(16,24,36,1)');
    }
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawGround(){
    const {h, cols, cell} = SNOW.ground;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = 'rgba(255,255,255,0.96)';
    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let i=0;i<cols;i++){
      const x = i*cell;
      ctx.lineTo(x, H - h[i]);
    }
    ctx.lineTo(W, H - h[cols-1]);
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();
  }

  function renderSnow(dt){
    clearToBg(false);
    drawSky();

    const intensity = mapIntensity();
    const sN = sizeNorm();

    const windX = mouse.vx * 0.0016 * (0.6 + 1.0*intensity);
    const windY = mouse.vy * 0.0012 * (0.4 + 0.8*intensity);

    const radius = 180 + 140*sN;
    const invR = 1 / Math.max(1, radius);
    const pullBase = (mouse.down ? 0.9 : 0.6) * (0.4 + 1.2*intensity);

    const layerAlphas = [0.35, 0.55, 0.85];

    for (let L=0; L<3; L++){
      const arr = SNOW.layers[L];
      const alpha = layerAlphas[L];
      ctx.globalCompositeOperation='source-over';
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.beginPath();

      for (let i=0;i<arr.length;i++){
        const f = arr[i];

        f.phase += dt*(0.5 + 0.8*f.z);
        const sway = Math.sin(f.phase) * f.swayAmp;

        const dx = mouse.x - f.x;
        const dy = mouse.y - f.y;
        const d  = Math.hypot(dx,dy);
        const t  = clamp(1 - d*invR, 0, 1);
        const pull = (pullBase) * (t*t);

        f.vx += sway*0.02*dt + windX*(0.4 + 0.8*f.z) + (dx * pull * 0.06);
        f.vy += (0.03 + 0.10*f.z) + windY*(0.3 + 0.7*f.z) + (dy * pull * 0.06) - (t*0.06);

        const drag = 1 - (0.08 + 0.04*f.z)*dt;
        f.vx *= drag; f.vy *= drag;

        f.x += f.vx; f.y += f.vy;

        if (f.x < -8) f.x = W+8; else if (f.x > W+8) f.x = -8;

        const G = SNOW.ground;
        const col = clamp(Math.floor(f.x / G.cell), 0, G.cols-1);
        const surfaceY = H - G.h[col];
        if (f.y + f.r >= surfaceY){
          groundDeposit(f.x, clamp(f.r*0.5, 0.4, 2));
          resetFlake(f);
        }

        if (f.y > H + 40) resetFlake(f);

        ctx.moveTo(f.x + f.r, f.y);
        ctx.arc(f.x, f.y, Math.max(0.7, f.r), 0, Math.PI*2);
      }
      ctx.fill();
    }

    if ((SNOW.frameCounter++ & 7) === 0) groundDiffuseCheap();

    drawGround();

    if (dwellJustCrossed(800)){
      playPing(880,0.16,0.04);
      const arr = SNOW.layers[2];
      for (let k=0;k<20;k++){
        const nf = makeFlake(0.95);
        nf.x = mouse.x + (Math.random()-0.5)*40;
        nf.y = mouse.y + (Math.random()-0.5)*40;
        nf.vx += (Math.random()-0.5)*0.6 + windX*20;
        nf.vy += (Math.random()-0.5)*0.4 + windY*20 - 0.2;
        arr.push(nf);
      }
      if (arr.length > 600) arr.splice(0, arr.length-600);
    }
  }

  /* =========================
     SAND (Cellular)
     ========================= */
  const SAND_CELL = (()=> {
    const state = { cellSize:3, cols:0, rows:0, grid:null, palette:[], lastHueBase:0 };
    function allocGrid(){
      state.cols = Math.floor(W / state.cellSize);
      state.rows = Math.floor(H / state.cellSize);
      state.grid = new Int16Array(state.cols * state.rows);
      state.grid.fill(-1);
      state.palette = new Array(360);
      for (let h=0; h<360; h++){ state.palette[h] = `hsla(${h},95%,60%,1)`; }
    }
    function idx(x,y){ return y*state.cols + x; }
    function inBounds(x,y){ return (x>=0 && x<state.cols && y>=0 && y<state.rows); }
    function caSandReset(){ allocGrid(); }
    function caSandOnResize(){ allocGrid(); }
    function caEmitSand(px, py, n){
      const cs = state.cellSize;
      const cx = Math.floor(px / cs);
      const cy = Math.floor(py / cs);
      for (let i=0;i<n;i++){
        const rx = cx + Math.floor((Math.random()*5)-2);
        const ry = cy + Math.floor((Math.random()*5)-2);
        if (!inBounds(rx, ry)) continue;
        const id = idx(rx, ry);
        if (state.grid[id] === -1){
          const hue = ((state.lastHueBase + Math.floor(Math.random()*40)) % 360)|0;
          state.grid[id] = hue;
        }
      }
    }
    function caStep(windBias){
      const C = state.cols; const R = state.rows;
      const leftFirst = windBias < 0 ? true : windBias > 0 ? false : (Math.random() < 0.5);
      for (let y=R-2; y>=0; y--){
        const xStartLeft = (Math.random() < 0.5);
        if (xStartLeft){
          for (let x=0; x<C; x++){
            const i = y*C + x; const hue = state.grid[i]; if (hue === -1) continue;
            const iD = i + C;
            if (state.grid[iD] === -1){ state.grid[i] = -1; state.grid[iD] = hue; continue; }
            const tryDiag = leftFirst ? [-1,1] : [1,-1];
            for (let k=0;k<2;k++){
              const nx = x + tryDiag[k], ny = y + 1;
              if (nx<0 || nx>=C) continue;
              const ii = ny*C + nx;
              if (state.grid[ii] === -1){ state.grid[i] = -1; state.grid[ii] = hue; break; }
            }
          }
        } else {
          for (let x=C-1; x>=0; x--){
            const i = y*C + x; const hue = state.grid[i]; if (hue === -1) continue;
            const iD = i + C;
            if (state.grid[iD] === -1){ state.grid[i] = -1; state.grid[iD] = hue; continue; }
            const tryDiag = leftFirst ? [-1,1] : [1,-1];
            for (let k=0;k<2;k++){
              const nx = x + tryDiag[k], ny = y + 1;
              if (nx<0 || nx>=C) continue;
              const ii = ny*C + nx;
              if (state.grid[ii] === -1){ state.grid[i] = -1; state.grid[ii] = hue; break; }
            }
          }
        }
      }
    }
    function caDraw(){
      const cs = state.cellSize; const C = state.cols, R = state.rows;
      const isLight = document.body.classList.contains('light');
      ctx.globalCompositeOperation='source-over';
      ctx.fillStyle = isLight ? '#ffffff' : '#000000';
      ctx.fillRect(0,0,W,H);
      for (let y=0; y<R; y++){
        let x=0;
        while (x<C){
          const h = state.grid[y*C + x];
          if (h === -1){ x++; continue; }
          let run = 1;
          while (x+run < C && state.grid[y*C + (x+run)] === h) run++;
          ctx.fillStyle = state.palette[h];
          ctx.fillRect(x*cs, y*cs, run*cs, cs);
          x += run;
        }
      }
    }
    function caRender(dt){
      state.lastHueBase = (state.lastHueBase + 60*dt) % 360;
      const baseRate = 4 + Math.floor(12 * mapIntensity());
      const dwellBoost = dwellMs>600 ? 4 : 0;
      const toSpawn = baseRate + dwellBoost;
      caEmitSand(mouse.x, mouse.y, toSpawn + Math.floor(mouse.speed/250));
      const windBias = clamp(mouse.vx/1000, -1, 1);
      const subSteps = 2;
      for (let s=0; s<subSteps; s++) caStep(windBias);
      caDraw();
      if (dwellJustCrossed(700)) playPing(700,0.12,0.05);
    }
    return { caSandReset, caSandOnResize, caRender };
  })();
  function caSandOnResize(){ SAND_CELL.caSandOnResize(); } (function(){ SAND_CELL.caSandReset(); })();

  /* =========================
     ESSAIM MAGNÉTIQUE
     ========================= */
  const MAG = {
    pins: [],
    t: 0
  };

  function magnetTargetCount(){ return Math.floor(160 + 500 * sizeNorm()); }
  function makePin(){ return { x: Math.random()*W, y: Math.random()*H, vx: 0, vy: 0 }; }
  function magnetResize(){ MAG.pins.forEach(p=>{ p.x = clamp(p.x,0,W); p.y = clamp(p.y,0,H); }); }
  function ensureMagnetPins(){
    const target = magnetTargetCount();
    const cur = MAG.pins.length;
    if (cur < target){ for (let i=0;i<target-cur;i++) MAG.pins.push(makePin()); }
    else if (cur > target){ MAG.pins.splice(0, cur-target); }
  }

  function renderMagnet(dt){
    ensureMagnetPins();
    clearToBg(false);

    const sN = sizeNorm();
    const intensity = mapIntensity();
    const sep = 28 + 140*sN;
    const soft = 120;
    const polarity = (dwellMs>600) ? -1 : 1;

    const ang = Math.atan2(mouse.vy||0.0001, mouse.vx||0.0001);
    const axis = (mouse.speed>25) ? ang : -Math.PI/2;
    const hx = Math.cos(axis), hy = Math.sin(axis);

    const pxN = mouse.x + hx*sep*0.5, pyN = mouse.y + hy*sep*0.5;
    const pxS = mouse.x - hx*sep*0.5, pyS = mouse.y - hy*sep*0.5;
    const q = 1 * polarity;

    ctx.globalCompositeOperation='screen';
    const gN = ctx.createRadialGradient(pxN,pyN,sep*0.1, pxN,pyN, sep*0.9);
    gN.addColorStop(0, 'hsla(0,100%,60%,0.45)');
    gN.addColorStop(1, 'hsla(0,100%,60%,0)');
    ctx.fillStyle=gN; ctx.beginPath(); ctx.arc(pxN,pyN,sep*0.9,0,Math.PI*2); ctx.fill();

    const gS = ctx.createRadialGradient(pxS,pyS,sep*0.1, pxS,pyS, sep*0.9);
    gS.addColorStop(0, 'hsla(210,100%,60%,0.45)');
    gS.addColorStop(1, 'hsla(210,100%,60%,0)');
    ctx.fillStyle=gS; ctx.beginPath(); ctx.arc(pxS,pyS,sep*0.9,0,Math.PI*2); ctx.fill();

    const lines = 10;
    ctx.strokeStyle = `hsla(${polarity>0?30:200},100%,75%,${0.18+0.28*intensity})`;
    ctx.lineWidth = 1 + 1.8*sN;
    ctx.beginPath();
    for (let i=0;i<lines;i++){
      const a = (i/lines)*Math.PI*2 + MAG.t*0.4;
      const r1 = sep*0.25, r2 = sep*(1.0 + 0.2*Math.sin(MAG.t*0.8+i));
      const x1 = mouse.x + Math.cos(a)*r1, y1 = mouse.y + Math.sin(a)*r1;
      const cx = mouse.x + Math.cos(a+Math.PI/2)*r2*0.5;
      const cy = mouse.y + Math.sin(a+Math.PI/2)*r2*0.5;
      ctx.moveTo(pxN,pyN); ctx.quadraticCurveTo(cx,cy,pxS,pyS);
      ctx.moveTo(x1,y1);   ctx.quadraticCurveTo(cx,cy,pxS,pyS);
    }
    ctx.stroke();

    const baseK = 240 + 560*intensity;
    const boost  = mouse.down ? 1.5 : 1.0;
    const swirl  = 0.6 + 2.2*intensity;
    const windX = mouse.vx * 0.0006, windY = mouse.vy * 0.00045;

    ctx.globalCompositeOperation='lighter';
    ctx.lineCap='round';
    const segLen = 8 + 20*sN;
    const maxSpeed = 14 + 50*intensity;
    const damp = 0.965 - 0.08*intensity + (mouse.down?-0.02:0);

    for (let i=0;i<MAG.pins.length;i++){
      const p = MAG.pins[i];

      let ax=0, ay=0;

      let dx = pxN - p.x, dy = pyN - p.y;
      let r2 = dx*dx + dy*dy + soft;
      let invR = 1/Math.sqrt(r2);
      let invR3 = invR*invR*invR;
      ax +=  baseK*boost * (+q) * dx * invR3;
      ay +=  baseK*boost * (+q) * dy * invR3;

      dx = pxS - p.x; dy = pyS - p.y;
      r2 = dx*dx + dy*dy + soft;
      invR = 1/Math.sqrt(r2);
      invR3 = invR*invR*invR;
      ax +=  baseK*boost * (-q) * dx * invR3;
      ay +=  baseK*boost * (-q) * dy * invR3;

      const cx = mouse.x - p.x, cy = mouse.y - p.y;
      const c2 = cx*cx + cy*cy + soft;
      const cInv = 1/Math.sqrt(c2);
      ax += swirl * (-cy*cInv) * 0.35;
      ay += swirl * ( cx*cInv) * 0.35;

      ax += windX + (Math.random()-0.5)*0.0005;
      ay += windY + (Math.random()-0.5)*0.0005;

      p.vx = (p.vx + ax*dt*600) * damp;
      p.vy = (p.vy + ay*dt*600) * damp;
      const sp = Math.hypot(p.vx,p.vy);
      if (sp>maxSpeed){ const s=maxSpeed/sp; p.vx*=s; p.vy*=s; }

      const px0 = p.x - p.vx*segLen*0.04;
      const py0 = p.y - p.vy*segLen*0.04;
      const spN = clamp(sp/(maxSpeed||1),0,1);
      const hue = polarity>0 ? (10 + spN*100) % 360 : (200 + spN*100) % 360;
      ctx.strokeStyle = `hsla(${hue},100%,70%,${0.30 + 0.55*spN})`;
      ctx.lineWidth = 0.7 + 2.0*sN*spN;
      ctx.beginPath();
      ctx.moveTo(px0,py0); ctx.lineTo(p.x,p.y); ctx.stroke();

      p.x += p.vx; p.y += p.vy;
      if (p.x < -5) p.x = W+5; else if (p.x > W+5) p.x = -5;
      if (p.y < -5) p.y = H+5; else if (p.y > H+5) p.y = -5;
    }

    MAG.t += dt;
  }

  /* =========================
     VITRAIL + glassy chimes
     ========================= */
  let glassAudio = null;
  let glassGlobalCooldown = 0;
  function glassEnsureAudio(){
    if (menuOpen) return;
    ensureAC();
    if (!glassAudio){
      const master = ac.createGain();
      master.gain.value = 0.22 * currentSfxGain();
      master.connect(ac.destination);
      glassAudio = { master };
    } else {
      glassAudio.master.gain.value = 0.22 * currentSfxGain();
    }
  }
  function glassPling(hz=900, panPos=0, vel=0.7){
    if (menuOpen) return;
    glassEnsureAudio();
    const masterScale = currentSfxGain();
    if (masterScale <= 0) return;

    const t = ac.currentTime;
    const o1 = ac.createOscillator(); o1.type='sine'; o1.frequency.setValueAtTime(hz, t);
    const o2 = ac.createOscillator(); o2.type='triangle'; o2.frequency.setValueAtTime(hz*2, t);
    const mod = ac.createOscillator(); mod.type='sine'; mod.frequency.value = 6 + 10*Math.random();
    const modGain = ac.createGain(); modGain.gain.value = 12 + 18*vel;
    mod.connect(modGain);
    modGain.connect(o1.detune);
    modGain.connect(o2.detune);

    const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 600; hp.Q.value = 0.7;
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = hz; bp.Q.value = 6;
    const sh = ac.createWaveShaper();
    sh.curve = new Float32Array([ -1, -0.2, 0, 0.2, 1 ]);

    const g  = ac.createGain();
    const p  = (ac.createStereoPanner ? ac.createStereoPanner() : null);
    const peak = 0.6 * vel * masterScale;

    const A=0.004, D=0.18, R=0.35;
    const t0=t;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(peak, t0+A);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak*0.05), t0+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+A+D+R);

    o1.connect(hp); o2.connect(hp);
    hp.connect(bp); bp.connect(sh); sh.connect(g);
    if (p) { g.connect(p); p.pan.value = clamp(panPos,-1,1); p.connect(glassAudio.master); }
    else { g.connect(glassAudio.master); }

    o1.start(t0); o2.start(t0); mod.start(t0);
    o1.stop(t0+A+D+R+0.05); o2.stop(t0+A+D+R+0.05); mod.stop(t0+A+D+R+0.05);
  }

  let glassCells=[], glassCols=20, glassRows=12;
  function resizeGlass(){
    glassCells=[];
    const cw=W/glassCols, ch=H/glassRows;
    for(let y=0;y<glassRows;y++){
      for(let x=0;x<glassCols;x++){
        glassCells.push({
          x:x*cw, y:y*ch, w:cw, h:ch,
          hue:Math.random()*360,
          pop:0, vpop:0, prevPop:0, cool:0
        });
      }
    }
  }
  resizeGlass();

  function renderGlass(dt){
    clearToBg(false);

    const intensity = mapIntensity();
    const sN = sizeNorm();

    const radius = 240 + 220*sN;
    const invR = 1 / Math.max(1, radius);

    const stiffness = 6 + 20*intensity;
    const damping   = Math.pow(0.32 + 0.58*(1-intensity), dt*60);

    const maxScaleBoost = 0.18 + 0.22*sN;
    const maxLightBoost = 78 * (0.5 + 0.8*intensity);

    const isLight = document.body.classList.contains('light');
    const baseL = isLight ? 86 : 14;

    glassGlobalCooldown = Math.max(0, glassGlobalCooldown - dt);

    ctx.globalCompositeOperation='source-over';
    for (let i=0;i<glassCells.length;i++){
      const c = glassCells[i];
      const cx = c.x + c.w/2;
      const cy = c.y + c.h/2;

      const dx = mouse.x - cx;
      const dy = mouse.y - cy;
      const d  = Math.hypot(dx,dy);
      const n  = clamp(1 - d*invR, 0, 1);

      const target = Math.pow(n, 1.2 + 1.2*intensity) * (mouse.down ? 1.15 : 1.0);

      const accel = (target - c.pop) * stiffness;
      c.vpop += accel * dt;
      c.vpop *= (1 - damping);
      c.pop  += c.vpop;

      c.cool = Math.max(0, c.cool - dt);
      const dPop = c.pop - c.prevPop;
      const trigger = (c.pop > 0.38) && (dPop > 0.02 + 0.04*intensity) && (c.cool===0) && (glassGlobalCooldown===0);
      if (trigger){
        const hueN = ((c.hue%360)+360)/360;
        const hz = 700 + hueN*1000;
        const pan = (cx/W)*2 - 1;
        const vel = clamp(0.4 + 0.6*(c.pop) + 0.2*clamp(mouse.speed/1400,0,1), 0.2, 1.0);
        glassPling(hz, pan, vel);
        c.cool = 0.08 + 0.08*(1-intensity);
        glassGlobalCooldown = 0.02;
      }
      c.prevPop = c.pop;

      const scale = 1 + maxScaleBoost * c.pop;
      const lift  = 2 + 10 * c.pop;
      const L = baseL + maxLightBoost * c.pop;
      const sat = 85;

      ctx.globalCompositeOperation='multiply';
      const sg = ctx.createRadialGradient(cx, cy+lift, Math.min(c.w,c.h)*0.15, cx, cy+lift, Math.max(c.w,c.h)*0.75);
      sg.addColorStop(0, 'rgba(0,0,0,0.10)');
      sg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = sg;
      const sw = c.w*scale, sh = c.h*scale;
      ctx.fillRect(cx - sw/2, cy - sh/2 + lift, sw, sh);

      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle = `hsla(${c.hue},85%,${L}%,0.96)`;
      ctx.fillRect(cx - sw/2, cy - sh/2, sw, sh);

      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(c.hue+40)%360},90%,${Math.min(92, L+10)}%,${0.35 + 0.35*c.pop})`;
      ctx.lineWidth = Math.max(1, 1.2 + 2.2*c.pop);
      ctx.strokeRect(cx - sw/2+0.7, cy - sh/2+0.7, sw-1.4, sh-1.4);

      if (c.pop > 0.55){
        const r = Math.min(c.w,c.h)*0.18*scale;
        const glx = cx - sw*0.28, gly = cy - sh*0.28;
        const gl = ctx.createRadialGradient(glx, gly, r*0.25, glx, gly, r);
        gl.addColorStop(0, 'rgba(255,255,255,0.28)');
        gl.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gl;
        ctx.beginPath(); ctx.arc(glx, gly, r, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  /* =========================
     STREAMERS — Rubans de Soie (CHANGED: falling + swirling)
     ========================= */

  // Old rope helpers (kept but unused)
  function makeRope(n, y){
    n = Math.max(2, n|0);
    const pts=[]; const step=(W-1)/(n-1); const sag=H*0.06;
    for(let i=0;i<n;i++){
      const x=i*step; const t=(n===1)?0:i/(n-1); const yy=y + (1 - Math.cos(Math.PI*t))*0.5*sag;
      pts.push({x, y:yy, px:x, py:yy});
    }
    return { pts, color: Math.random()*360 };
  }
  const ropes = Array.from({length:4},(_,i)=>makeRope(40,(i+1)/(5)*H));
  function verlet(p){ const x=p.x,y=p.y; p.x += (p.x-p.px); p.y += (p.y-p.py) + 0.15; p.px=x; p.py=y; }
  function constrain(rope){
    const segLen=W/(rope.pts.length-1);
    for(let k=0;k<2;k++){
      for(let i=0;i<rope.pts.length-1;i++){
        const a=rope.pts[i], b=rope.pts[i+1], dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy)||1, diff=(d-segLen)/d;
        const off=0.5*diff; a.x += dx*off; a.y += dy*off; b.x -= dx*off; b.y -= dy*off;
      }
      rope.pts[0].x = lerp(rope.pts[0].x, 0, 0.3); rope.pts[0].y = lerp(rope.pts[0].y, 0, 0.3);
      rope.pts.at(-1).x = lerp(rope.pts.at(-1).x, W, 0.3); rope.pts.at(-1).y = lerp(rope.pts.at(-1).y, H, 0.3);
    }
  }

  // New falling ribbons
  const RIB = { list: [], t: 0 };

  function spawnRibbon(){
    const sN = sizeNorm();
    const intensity = mapIntensity();
    const x = Math.random()*W;
    const y = -Math.random()*H*0.8 - 80;
    const vy = 18 + 22*(0.4 + 0.6*(1-intensity));  // slow fall
    const amp = 28 + 42*(0.3 + sN);                // horizontal sway
    const freq = 0.0045 + Math.random()*0.0025;
    const wobble = 0.9 + Math.random()*0.6;
    const hue = (Math.random()*360)|0;
    const width = 8 + 22*sN;
    return { x, y, vy, amp, freq, wobble, hue, phase: Math.random()*Math.PI*2, width };
  }

  function ribbonsInit(){
    RIB.list.length = 0;
    const baseCount = 5 + Math.floor(3 * sizeNorm());
    for (let i=0;i<baseCount;i++) RIB.list.push(spawnRibbon());
  }

  function ribbonsResize(){ RIB.list.forEach(r=>{ r.x = clamp(r.x, 0, W); }); }
  ribbonsInit();

  let ribbonSoundCooldown = 0;

  function renderStreamers(dt){
    // Background trail
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = document.body.classList.contains('light')
      ? `rgba(255,255,255,${mapTrail()})`
      : `rgba(0,0,0,${mapTrail()})`;
    ctx.fillRect(0,0,W,H);

    const intensity = mapIntensity();
    const sN = sizeNorm();
    const t = (RIB.t += dt);

    const influenceR = 120 + 160*intensity;   // pointer influence radius
    const swirlK = 0.9 + 1.6*intensity;       // tangential swirl multiplier

    ctx.lineCap='round';
    ctx.lineJoin='round';

    ribbonSoundCooldown = Math.max(0, ribbonSoundCooldown - dt);

    for (let i=0;i<RIB.list.length;i++){
      const r = RIB.list[i];

      // fall down
      r.y += r.vy * dt;

      // recycle after leaving screen
      if (r.y > H + 160){ RIB.list[i] = spawnRibbon(); continue; }

      // build vertical polyline
      const segs = 46;
      const span = H + 260;
      const y0 = r.y - 200;

      const pts = new Array(segs+1);
      for (let k=0;k<=segs;k++){
        const y = y0 + (k/segs)*span;

        // base sway (two sine layers for silkiness)
        const sway = Math.sin(y*r.freq + r.phase + t*r.wobble)*r.amp
                   + Math.sin(y*r.freq*2.3 + t*1.8 + r.phase*0.7)*r.amp*0.18;

        let x = r.x + sway;

        // pointer interaction: swirl around cursor + slight attraction
        const dx = mouse.x - x;
        const dy = mouse.y - y;
        const d  = Math.hypot(dx, dy);
        if (d < influenceR){
          const n = 1 - (d/influenceR);
          const inv = 1/(d+0.0001);
          const tx = -dy * inv;  // tangential unit vector
          const ty =  dx * inv;
          const curl = swirlK * n * (mouse.down?1.4:1.0);
          const pull = 0.25 * n * (0.5 + intensity);
          x += tx * 90 * curl + dx * pull * 0.25;
          const yswirl = ty * 90 * curl + dy * pull * 0.12;
          pts[k] = [x, y + yswirl];
        } else {
          pts[k] = [x, y];
        }
      }

      // draw ribbon
      const thickness = 10 + 22*sN;
      const g = ctx.createLinearGradient(pts[0][0], pts[0][1], pts.at(-1)[0], pts.at(-1)[1]);
      g.addColorStop(0, `hsla(${(r.hue+20)%360},90%,68%,0.55)`);
      g.addColorStop(1, `hsla(${(r.hue+240)%360},90%,68%,0.55)`);

      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle = g;
      ctx.lineWidth = thickness;
      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for (let k=1;k<pts.length;k++) ctx.lineTo(pts[k][0], pts[k][1]);
      ctx.stroke();

      ctx.strokeStyle = `hsla(${(r.hue+40)%360},100%,90%,0.35)`;
      ctx.lineWidth = Math.max(2, thickness*0.42);
      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for (let k=1;k<pts.length;k++) ctx.lineTo(pts[k][0], pts[k][1]);
      ctx.stroke();

      // whoosh ping when strongly bent near pointer (throttled)
      const nearIdx = Math.floor(segs * clamp((mouse.y - y0) / span, 0, 1));
      const bend = Math.abs(pts[nearIdx][0] - r.x);
      if (ribbonSoundCooldown===0 && bend > r.amp*0.9 && currentSfxGain()>0){
        playPing(320 + i*35, 0.10, 0.03);
        ribbonSoundCooldown = 0.25;
      }
    }

    // dwell pulse to all ribbons
    if (dwellJustCrossed(800)){
      for (const r of RIB.list){
        r.phase += Math.PI*0.5;
        r.amp *= (1.05 + 0.15*mapIntensity());
        setTimeout(()=>{ r.amp *= 0.92; }, 200);
      }
      playPing(540, 0.14, 0.035);
    }
  }

  /* =========================
     HARPE LASER (unchanged)
     ========================= */
  let laserCols=11;
  const laserGap = ()=> W / (laserCols + 1);
  let harpPalette = Array.from({ length: laserCols }, (_, i) => (i * (360 / laserCols)) | 0);
  let harpBeams=[], beamDwell=[], beamCooldown=[], beamHold=[], beamVoice=[];
  function initLaserArrays(){
    harpPalette = Array.from({length:laserCols},(_,i)=>(i*(360/laserCols))|0);
    harpBeams = Array.from({length:laserCols},(_,i)=>({energy:0,rippleT:0,rippleY:H/2,hue:harpPalette[i]}));
    beamDwell=new Array(laserCols).fill(0);
    beamCooldown=new Array(laserCols).fill(0);
    beamHold=new Array(laserCols).fill(false);
    beamVoice=new Array(laserCols).fill(null);
  }
  initLaserArrays();

  function harpEnsureAudio(){
    if (menuOpen) return;
    ensureAC();
    if (!harpEnsureAudio.master){
      const master=ac.createGain(); master.gain.value = (parseInt(sfxVol.value,10)||50)/100 * (muteSFX.checked?0:1) * 0.24;
      const delay = ac.createDelay(); delay.delayTime.value=0.18;
      const fb = ac.createGain(); fb.gain.value=0.38;
      delay.connect(fb).connect(delay);
      delay.connect(master);
      master.connect(ac.destination);
      harpEnsureAudio.master=master; harpEnsureAudio.delay=delay;
    }
  }
  function harpNote(i){
    const pent=[0,2,4,7,9]; const base=220;
    const si=i%pent.length, oct=Math.floor(i/pent.length);
    return base * Math.pow(2, (pent[si] + 12*oct)/12);
  }
  const sparks = [];
  function harpPluck(i, y, velocity=1){
    if (menuOpen) return;
    harpEnsureAudio();
    const f=harpNote(i), det=(Math.random()*14-7), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=det;
    const g=ac.createGain(); const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2200+1800*velocity;
    const A=0.005, D=0.08, S=0.25*velocity, R=0.35+0.25*(1-velocity);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.9*velocity, t+A);
    g.gain.exponentialRampToValueAtTime(Math.max(S,0.08), t+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t+A+D+R);
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t); o1.stop(t+A+D+R+0.02); o2.stop(t+A+D+R+0.02);
    const b=harpBeams[i]; b.energy=Math.min(1, b.energy + 0.6*velocity); b.rippleT=0; b.rippleY=y;
    for(let k=0;k<12;k++){
      sparks.push({x:(i+1)*laserGap(), y, vx:(Math.random()-0.5)*2.4, vy:(Math.random()-0.5)*2.4, life:26+Math.random()*18, h:(b.hue+10+Math.random()*40)%360});
    }
  }
  function startVoice(i){
    if (menuOpen) return;
    harpEnsureAudio();
    if (beamVoice[i]) return;
    const f=harpNote(i), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=-6;
    const g=ac.createGain(); g.gain.value=0.0001;
    const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1400;
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t);
    g.gain.linearRampToValueAtTime(0.18 + 0.10*mapIntensity(), t + 0.08);
    beamVoice[i]={o1,o2,g,lp,baseF:f,t0:t};
  }
  function stopVoice(i){
    const v=beamVoice[i]; if(!v||!ac){ beamVoice[i]=null; return; }
    const t=ac.currentTime;
    try{
      v.g.gain.cancelScheduledValues(t);
      v.g.gain.setValueAtTime(v.g.gain.value, t);
      v.g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      v.o1.stop(t+0.22); v.o2.stop(t+0.22);
    }catch(e){}
    beamVoice[i]=null;
  }
  function updateVoice(i){
    const v=beamVoice[i]; if(!v||!ac) return;
    const t=ac.currentTime, e=harpBeams[i].energy;
    const vib=0.25+0.35*mapIntensity(), amt=7+10*mapIntensity(), phase=(t-v.t0);
    const mod=Math.sin(phase*2*Math.PI*vib)*amt;
    v.o1.frequency.setValueAtTime(v.baseF,t); v.o2.frequency.setValueAtTime(v.baseF,t);
    v.o2.detune.setValueAtTime(mod,t);
    v.lp.frequency.setValueAtTime(1200 + 1200*e, t);
    const targetGain = 0.14 + 0.10*mapIntensity();
    v.g.gain.setTargetAtTime(targetGain, t, 0.08);
  }
  function resizeLaser(){
    if (harpBeams.length !== laserCols) initLaserArrays();
    for (let i=0;i<harpBeams.length;i++) harpBeams[i].rippleY = Math.min(harpBeams[i].rippleY, H);
  }
  function renderLaser(dt){
    clearToBg(false);
    const gap=laserGap(); const lineBase=10 + mapSize()*0.14;
    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap; const nearRadius=34 + lineBase*1.7;
      const near = Math.abs(mouse.x - x) < nearRadius;
      const stationary = mouse.speed < 60;
      const velocity = clamp(mouse.speed/1400, 0.05, 1);
      if (near && velocity>0.25){
        harpPluck(i, mouse.y, velocity);
        lastMoveT = performance.now();
        beamCooldown[i]=160; beamHold[i]=false; stopVoice(i);
      }
      beamCooldown[i]=Math.max(0, beamCooldown[i]-dt*1000);
      if (near){
        beamDwell[i]+=dt*1000;
        const dwellThreshold=450;
        if (!beamHold[i] && stationary && beamDwell[i]>=dwellThreshold && beamCooldown[i]===0){
          const vel=0.72+0.28*mapIntensity();
          harpPluck(i, mouse.y, vel); beamHold[i]=true; startVoice(i);
        }
      } else {
        if (beamHold[i]) stopVoice(i);
        beamDwell[i]=0; beamHold[i]=false;
      }
    }

    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap, b=harpBeams[i];
      const decay = beamHold[i] ? 0.96 : 0.82;
      b.energy *= Math.pow(decay, dt*60);
      b.rippleT += dt;
      if (beamHold[i]){ b.energy = lerp(b.energy, 0.85, 0.12); updateVoice(i); }

      ctx.globalCompositeOperation='screen';
      const e=b.energy; const hue=(b.hue + Math.sin((performance.now()*0.001+i)*0.7)*6)%360;

      const grad=ctx.createLinearGradient(x,0,x,H);
      grad.addColorStop(0.0, `hsla(${(hue+6)%360},100%,55%,${0.35+0.20*e})`);
      grad.addColorStop(0.5, `hsla(${hue},100%,52%,${0.65+0.30*e})`);
      grad.addColorStop(1.0, `hsla(${(hue+12)%360},100%,55%,${0.35+0.20*e})`);
      const w=Math.max(2, lineBase * (beamHold[i] ? 1.8 : (1 + 1.3*e)));
      ctx.strokeStyle=grad; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      ctx.strokeStyle=`hsla(${hue},100%,50%,${0.22+0.25*e})`; ctx.lineWidth=w*1.9;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      const waveAmp=(10+mapSize()*0.028)*e*(beamHold[i]?0.35:1.0);
      const waveFreq=0.02+0.035*mapIntensity();
      ctx.strokeStyle=`hsla(${(hue+200)%360},100%,80%,${0.55+0.35*e})`;
      ctx.lineWidth=Math.max(1.5, w*0.22);
      ctx.beginPath();
      for (let y=0;y<=H;y+=7){
        const off = Math.sin((y + performance.now()*0.6)*waveFreq)*waveAmp;
        ctx.lineTo(x+off, y);
      }
      ctx.stroke();

      if (e>0.02){
        const speed=480 + 420*mapIntensity();
        const r=Math.max(10,(b.rippleT*speed) % (H*1.2));
        ctx.strokeStyle=`hsla(${(hue+60)%360},100%,70%,${(beamHold[i]?0.28:0.42)*e})`;
        ctx.lineWidth=2.2;
        ctx.beginPath();
        ctx.arc(x, b.rippleY, r*(0.12+0.12*e), 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  /* =========================
     BUBBLE-POP (unchanged)
     ========================= */
  const bubbles = Array.from({length:70},()=>({x:Math.random()*W,y:H+Math.random()*200,r:8+Math.random()*22,vx:(Math.random()-0.5)*0.2,vy:-(0.4+Math.random()*0.6),charge:0,h:Math.random()*360}));
  function renderBubblePop(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    for(let i=bubbles.length-1;i>=0;i--){
      const b=bubbles[i];
      if (b.cool===undefined) b.cool=0;
      if (b.phase===undefined) b.phase=0;
      if (b.maxCharge===undefined) b.maxCharge=2.0;
      const d=Math.hypot(mouse.x-b.x, mouse.y-b.y);
      const near=clamp(1 - d/160, 0, 1);
      const baseGrow=(near*2.2 - 0.18)*dt;
      const dwellBoost=(dwellMs>600 ? 0.8*near*dt : 0);
      b.charge = clamp((b.charge||0) + baseGrow + dwellBoost, 0, b.maxCharge);
      b.phase += dt*(0.8 + b.charge*0.6);
      const pulse=1 + 0.04*Math.sin(b.phase*2.7);
      const growth=1 + Math.pow(b.charge,1.25)*2.6;
      const R=b.r*growth*pulse;
      const g=ctx.createRadialGradient(b.x,b.y,R*0.4,b.x,b.y,R*1.2);
      g.addColorStop(0,`hsla(${b.h},90%,70%,${0.10+0.25*near})`);
      g.addColorStop(1,`hsla(${(b.h+60)%360},90%,45%,0)`);
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=`hsla(${b.h},90%,70%,${0.22+0.5*near})`;
      ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=`hsla(${(b.h+40)%360},90%,85%,0.9)`; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.arc(b.x - R*0.35, b.y - R*0.35, R*0.32, 0, Math.PI*2); ctx.stroke();
      b.x += b.vx + (mouse.x-b.x)*0.00035*mapIntensity();
      b.y += b.vy - (mouse.y-b.y)*0.00025*mapIntensity();
      if (b.y<-R-20){ b.y=H+40; b.x=Math.random()*W; b.vx=(Math.random()-0.5)*0.2; b.vy=-(0.4+Math.random()*0.6); b.charge=0; b.cool=0; }
      const canPop=(b.cool<=0) && (b.charge>=1.7) && (near>0.6);
      if (canPop){
        playPing(740,0.12,0.06);
        for(let k=0;k<22;k++){
          sparks.push({x:b.x,y:b.y,vx:Math.cos(k*Math.PI/11)*(2.2+Math.random()*1.6),vy:Math.sin(k*Math.PI/11)*(2.2+Math.random()*1.6),life:40+Math.random()*20,h:(b.h+Math.random()*50)%360});
        }
        for(let d2=0; d2<8; d2++){
          sparks.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*4.5,vy:(Math.random()-0.5)*4.5,life:28,h:(b.h+20)%360});
        }
        ctx.globalCompositeOperation='screen';
        ctx.strokeStyle=`hsla(${(b.h+20)%360},95%,80%,0.8)`; ctx.lineWidth=2.2;
        ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.stroke();
        b.charge=0.15; b.cool=0.25;
      }
      if (b.cool>0) b.cool -= dt;
    }
  }

  function tick(t){
    const dt = clamp((t - now)/1000, 0, 0.05);
    now = t;
    dwellMs = t - lastMoveT;

    if (menuOpen || paused){
      return requestAnimationFrame(tick);
    }

    switch (ui.mode.value){
      case 'aurora':    renderAurora(dt);     break;
      case 'ripples':   renderRipples(dt);    break;
      case 'fireworks': renderFireworks(dt);  break;
      case 'kaleido':   renderKaleido(dt);    break;
      case 'fireflies': renderFireflies(dt);  break;
      case 'confetti':  renderConfetti(dt);   break;
      case 'nebula':    renderNebula(dt);     break;
      case 'jelly':     renderJelly(dt);      break;
      case 'snow':      renderSnow(dt);       break;
      case 'sand':      SAND_CELL.caRender(dt); break;
      case 'magnet':    renderMagnet(dt);     break;
      case 'glass':     renderGlass(dt);      break;
      case 'streamers': renderStreamers(dt);  break;
      case 'laserharp': renderLaser(dt);      break;
      case 'bubblepop': renderBubblePop(dt);  break;
    }
    requestAnimationFrame(tick);
  }

  (function seedBlueBg(){
    ctx.fillStyle = 'hsl(210, 70%, 8%)';
    ctx.fillRect(0,0,W,H);
  })();

  snowResize();
  requestAnimationFrame(tick);

  startButton.addEventListener('click', () => {
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen();
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if (el.msRequestFullscreen) el.msRequestFullscreen();

    document.getElementById('game-options').style.display = 'none';
    cvs.style.display = 'block';
    menuOpen = false;

    cvs.addEventListener('pointerdown', ()=>{ playPing(523,0.08,0.03); }, {once:true});
  });
  </script>
</body>
</html>
