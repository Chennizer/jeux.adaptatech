<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Time Timer</title>
  <style>
    body {
      margin:0;
      font-family:Arial, sans-serif;
      height:100vh;
      overflow:hidden;
    }

    #overlay {
      position:fixed;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      background:#fff;
      z-index:2;
    }

    #overlay button {
      font-size:5vmin;
      padding:1em 2em;
    }

    #timerCanvas {
      position:absolute;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      background:none;
    }

    .controls,
    .color-controls,
    .feature-controls {
      position:fixed;
      top:50%;
      right:-240px;
      transform:translateY(-50%);
      z-index:1;
      text-align:center;
      font-size:3vmin;
      display:flex;
      flex-direction:column;
      align-items:center;
      background:rgba(255,255,255,0.95);
      padding:1em;
      border-radius:8px;
      box-shadow:0 2px 5px rgba(0,0,0,0.3);
      width:200px;
      transition:right 0.3s ease;
    }

    .controls.show,
    .color-controls.show,
    .feature-controls.show { right:2vw; }

    .controls > *,
    .color-controls > *,
    .feature-controls > * { margin:0.5vmin 0; }
    input[type=number] { width:6vmin; font-size:1em; }
    button { padding:0.5em 1em; font-size:1em; margin:0; }

    #menuBtn {
      position:fixed;
      top:10px;
      right:10px;
      width:40px;
      height:40px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:22px;
      cursor:pointer;
      background:rgba(0,0,0,0.7);
      color:#fff;
      z-index:1;
      transition:background 0.3s ease;
    }

    #menuBtn:hover { background:rgba(0,0,0,0.9); }

    #colorBtn {
      position:fixed;
      top:60px;
      right:10px;
      width:40px;
      height:40px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:22px;
      cursor:pointer;
      background:rgba(0,0,0,0.7);
      color:#fff;
      z-index:1;
      transition:background 0.3s ease;
    }

    #colorBtn:hover { background:rgba(0,0,0,0.9); }

    #featureBtn {
      position:fixed;
      top:110px;
      right:10px;
      width:40px;
      height:40px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:22px;
      cursor:pointer;
      background:rgba(0,0,0,0.7);
      color:#fff;
      z-index:1;
      transition:background 0.3s ease;
    }

    #featureBtn:hover { background:rgba(0,0,0,0.9); }
  </style>
</head>
<body>
  <div id="overlay"><button id="enterBtn">Start</button></div>
  <canvas id="timerCanvas"></canvas>
  <div id="menuBtn">‚öôÔ∏è</div>
  <div id="colorBtn">üé®</div>
  <div id="featureBtn">‚≠ê</div>
  <div class="controls">
    <label>Minutes: <input type="number" id="minutes" min="1" max="60" value="5"></label>
    <label>
      Dial:
      <select id="dialSelect">
        <option value="60" selected>60 min</option>
        <option value="30">30 min</option>
        <option value="10">10 min</option>
        <option value="5">5 min</option>
        <option value="1">1 min</option>
        <option value="120">120 min</option>
      </select>
    </label>
    <label><input type="checkbox" id="toggleDigits"> Show numbers</label>
    <button id="startBtn">Start</button>
    <button id="pauseBtn">Pause</button>
    <button id="fsBtn">Fullscreen</button>
    <button id="stopBtn">Stop</button>
  </div>
  <div class="color-controls">
    <label>Select color: <input type="color" id="colorPicker" value="#d9534f"></label>
  </div>
  <div class="feature-controls">
    <label><input type="radio" name="layoutMode" value="none" checked> None</label>
    <label><input type="radio" name="layoutMode" value="around"> Images around timer</label>
    <label><input type="radio" name="layoutMode" value="stack"> Images stacked left</label>
    <label>Image 1: <input type="file" id="img1"></label>
    <label>Image 2: <input type="file" id="img2"></label>
    <label>Image 3: <input type="file" id="img3"></label>
    <label>Image 4: <input type="file" id="img4"></label>
  </div>
  <script>
    const overlay = document.getElementById('overlay');
    const enterBtn = document.getElementById('enterBtn');
  const canvas = document.getElementById('timerCanvas');
  const ctx = canvas.getContext('2d');
  let totalSeconds = 300; // default 5 minutes
  let remainingSeconds = 0;
  let intervalId = null;
  let paused = false;
  let dragging = false;
  let showDigits = false;
  let dialMax = 60;
  let timerColor = '#d9534f';
  let layoutMode = 'none';
  const segmentColors = ['#ff0000', '#ffff00', '#00ff00', '#0000ff'];
  const images = [null, null, null, null];
  const defaultImagePaths = [
    '../../images/cartoonelephant.png',
    '../../images/window.png',
    '../../images/fingerpaint.png',
    '../../images/pawpatrollogo.png'
  ];
  defaultImagePaths.forEach((src, i) => {
    const img = new Image();
    img.src = src;
    img.onload = () => { images[i] = img; draw(); };
  });
  const minutesInput = document.getElementById('minutes');
  minutesInput.max = dialMax;
  const dialConfigs = {
    60:  {ticks:60, nums:[0,5,10,15,20,25,30,35,40,45,50,55], denom:60, short:true,  step:5},
    120: {ticks:60, nums:[0,10,20,30,40,50,60,70,80,90,100,110], denom:120, short:true,  step:5},
    30:  {ticks:30, nums:[0,5,10,15,20,25], denom:30, short:false, step:1},
    10:  {ticks:60, nums:[0,1,2,3,4,5,6,7,8,9], denom:10, short:true,  step:6},
    5:   {ticks:60, nums:[0,1,2,3,4], denom:5,  short:true,  step:12},
    1:   {ticks:60, nums:[0,5,10,15,20,25,30,35,40,45,50,55], denom:60, short:true,  step:5}
  };

  function getSecondsFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const rawAng = Math.atan2(y - centerY, x - centerX);
    let ang = -Math.PI / 2 - rawAng;
    while (ang < 0) ang += Math.PI * 2;
    const cfg = dialConfigs[dialMax];
    const ratio = ang / (Math.PI * 2);
    if (dialMax <= 10) {
      const tick = Math.round(ratio * cfg.ticks);
      let secs = tick * (dialMax * 60 / cfg.ticks);
      return secs === 0 ? dialMax * 60 : secs;
    } else {
      const minutes = Math.round(ratio * dialMax);
      return (minutes === 0 ? dialMax : minutes) * 60;
    }
  }

  function insideDial(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const size = Math.min(canvas.width, canvas.height) * 0.9;
    const outerRadius = size * 0.4;
    const dist = Math.hypot(x - centerX, y - centerY);
    return dist <= outerRadius;
  }

  function updateDrag(e) {
    const secs = Math.max(1, Math.min(dialMax * 60, getSecondsFromEvent(e)));
    minutesInput.value = (secs / 60).toFixed(dialMax <= 10 ? 2 : 0);
    totalSeconds = Math.round(secs);
    remainingSeconds = totalSeconds;
    draw();
  }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }

    function draw() {
      const size = Math.min(canvas.width, canvas.height) * 0.9; // leave margin
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const outerRadius = size * 0.4; // room for ticks and numbers
      const borderWidth = size * 0.0067;
      const wedgeRadius = outerRadius - borderWidth / 2;
      const tickLong = size * 0.05;
      const tickShort = size * 0.025;
      const tickStart = outerRadius + borderWidth / 2;
      const numbersRadius = tickStart + tickLong + size * 0.03;
      const quarterAngle = Math.PI / 2;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // outer circle
      ctx.strokeStyle = '#000';
      ctx.lineWidth = borderWidth;
      ctx.beginPath();
      ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
      ctx.stroke();

      if (layoutMode === 'around') {
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 4; i++) {
          ctx.fillStyle = segmentColors[i];
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(
            centerX,
            centerY,
            wedgeRadius,
            -Math.PI / 2 - i * quarterAngle,
            -Math.PI / 2 - (i + 1) * quarterAngle,
            true
          );
          ctx.closePath();
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      let activeQuarter = 0;
      if (remainingSeconds > 0) {
        const maxAngle = (totalSeconds / (dialMax * 60)) * Math.PI * 2;
        const angle = maxAngle * (remainingSeconds / totalSeconds);
        const elapsed = (maxAngle - angle) % (Math.PI * 2);
        activeQuarter = Math.floor(elapsed / quarterAngle);
        ctx.fillStyle = layoutMode === 'stack' ? segmentColors[activeQuarter] : timerColor;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, wedgeRadius, -Math.PI / 2, -Math.PI / 2 - angle, true);
        ctx.closePath();
        ctx.fill();
      }

      const cfg = dialConfigs[dialMax];

      // ticks
      for (let i = 0; i < cfg.ticks; i++) {
        const ang = -Math.PI / 2 - (i / cfg.ticks) * Math.PI * 2;
        const startX = centerX + Math.cos(ang) * tickStart;
        const startY = centerY + Math.sin(ang) * tickStart;
        const long = i % cfg.step === 0;
        const len = cfg.short ? (long ? tickLong : tickShort) : tickLong;
        const endX = centerX + Math.cos(ang) * (tickStart + len);
        const endY = centerY + Math.sin(ang) * (tickStart + len);
        ctx.lineWidth = long ? size * 0.006 : size * 0.003;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }

      // numbers every 5 minutes
      ctx.fillStyle = '#000';
      ctx.font = `${size * 0.04}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let m of cfg.nums) {
        const ang = -Math.PI / 2 - (m / cfg.denom) * Math.PI * 2;
        const x = centerX + Math.cos(ang) * numbersRadius;
        const y = centerY + Math.sin(ang) * numbersRadius;
        ctx.fillText(m.toString(), x, y);
      }

      if (showDigits) {
        ctx.fillStyle = '#000';
        ctx.font = `bold ${size * 0.12}px Arial`;
        const mins = Math.floor(remainingSeconds / 60);
        const secs = Math.floor(remainingSeconds % 60);
        ctx.fillText(`${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`, centerX, centerY);
      }

      if (layoutMode === 'around') {
        for (let i = 0; i < 4; i++) {
          const img = images[i];
          if (!img) continue;
          const ang = -Math.PI / 2 - quarterAngle * i - quarterAngle / 2;
          const imgRadius = numbersRadius + size * 0.05;
          const imgSize = size * 0.15;
          const x = centerX + Math.cos(ang) * imgRadius - imgSize / 2;
          const y = centerY + Math.sin(ang) * imgRadius - imgSize / 2;
          ctx.drawImage(img, x, y, imgSize, imgSize);
          ctx.strokeStyle = segmentColors[i];
          ctx.lineWidth = borderWidth;
          ctx.strokeRect(x, y, imgSize, imgSize);
        }
      } else if (layoutMode === 'stack') {
        const imgSize = size * 0.15;
        const bigSize = imgSize * 2;
        const spacing = size * 0.03;
        const startX = (centerX - outerRadius) / 2 - imgSize / 2;
        const startY = centerY - (imgSize * 4 + spacing * 3) / 2;
        for (let i = 0; i < 4; i++) {
          const img = images[i];
          if (!img) continue;
          const yCenter = startY + i * (imgSize + spacing) + imgSize / 2;
          const curSize = i === activeQuarter ? bigSize : imgSize;
          const x = startX - (curSize - imgSize) / 2;
          const y = yCenter - curSize / 2;
          ctx.drawImage(img, x, y, curSize, curSize);
          ctx.strokeStyle = segmentColors[i];
          ctx.lineWidth = borderWidth;
          ctx.strokeRect(x, y, curSize, curSize);
        }
      }
    }

    function tick() {
      if (!paused) {
        remainingSeconds--;
        if (remainingSeconds <= 0) {
          remainingSeconds = 0;
          clearInterval(intervalId);
          beep();
        }
        draw();
      }
    }

    function startTimer() {
      totalSeconds = Math.round(parseFloat(minutesInput.value) * 60);
      if (isNaN(totalSeconds) || totalSeconds <= 0) return;
      if (totalSeconds > dialMax * 60) {
        totalSeconds = dialMax * 60;
        minutesInput.value = dialMax;
      }
      remainingSeconds = totalSeconds;
      paused = false;
      document.getElementById('pauseBtn').textContent = 'Pause';
      clearInterval(intervalId);
      intervalId = setInterval(tick, 1000);
      draw();
    }

    function pauseTimer() {
      paused = !paused;
      document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
    }

    function stopTimer() {
      clearInterval(intervalId);
      remainingSeconds = 0;
      paused = false;
      document.getElementById('pauseBtn').textContent = 'Pause';
      draw();
    }

    function beep() {
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ac.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 880;
      osc.connect(ac.destination);
      osc.start();
      osc.stop(ac.currentTime + 0.2);
    }

    function startDrag(e) {
      if (!insideDial(e)) return;
      clearInterval(intervalId);
      paused = false;
      document.getElementById('pauseBtn').textContent = 'Pause';
      dragging = true;
      updateDrag(e);
    }

    function dragMove(e) {
      if (!dragging) return;
      e.preventDefault();
      updateDrag(e);
    }

    function endDrag(e) {
      if (!dragging) return;
      dragMove(e);
      dragging = false;
      startTimer();
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen).call(document.documentElement);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen).call(document);
      }
      setTimeout(resizeCanvas, 100);
    }

    enterBtn.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen).call(document.documentElement);
      }
      overlay.style.display = 'none';
      resizeCanvas();
    });

    document.getElementById('startBtn').addEventListener('click', startTimer);
    document.getElementById('pauseBtn').addEventListener('click', pauseTimer);
    document.getElementById('stopBtn').addEventListener('click', stopTimer);
    document.getElementById('fsBtn').addEventListener('click', toggleFullscreen);
    const toggleDigits = document.getElementById('toggleDigits');
    toggleDigits.addEventListener('change', () => {
      showDigits = toggleDigits.checked;
      draw();
    });

    const dialSelect = document.getElementById('dialSelect');
    dialSelect.addEventListener('change', () => {
      dialMax = parseInt(dialSelect.value, 10);
      minutesInput.max = dialMax;
      minutesInput.step = dialMax <= 10 ? 0.01 : 1;
      minutesInput.min = dialMax <= 10 ? 0 : 1;
      if (parseFloat(minutesInput.value) > dialMax) {
        minutesInput.value = dialMax;
      }
      remainingSeconds = 0;
      draw();
    });

    const menuBtn = document.getElementById('menuBtn');
    const menu = document.querySelector('.controls');
    const colorBtn = document.getElementById('colorBtn');
    const colorMenu = document.querySelector('.color-controls');
    const colorPicker = document.getElementById('colorPicker');
    const featureBtn = document.getElementById('featureBtn');
    const featureMenu = document.querySelector('.feature-controls');

    menuBtn.addEventListener('click', e => {
      e.stopPropagation();
      menu.classList.toggle('show');
      colorMenu.classList.remove('show');
      featureMenu.classList.remove('show');
    });
    colorBtn.addEventListener('click', e => {
      e.stopPropagation();
      colorMenu.classList.toggle('show');
      menu.classList.remove('show');
      featureMenu.classList.remove('show');
    });
    featureBtn.addEventListener('click', e => {
      e.stopPropagation();
      featureMenu.classList.toggle('show');
      menu.classList.remove('show');
      colorMenu.classList.remove('show');
    });
    document.addEventListener('click', e => {
      if (!menu.contains(e.target) && !menuBtn.contains(e.target)) {
        menu.classList.remove('show');
      }
      if (!colorMenu.contains(e.target) && !colorBtn.contains(e.target)) {
        colorMenu.classList.remove('show');
      }
      if (!featureMenu.contains(e.target) && !featureBtn.contains(e.target)) {
        featureMenu.classList.remove('show');
      }
    });

    colorPicker.addEventListener('input', () => {
      timerColor = colorPicker.value;
      draw();
    });

    document.querySelectorAll('input[name="layoutMode"]').forEach(r => {
      r.addEventListener('change', () => {
        layoutMode = r.value;
        draw();
      });
    });
    ['img1','img2','img3','img4'].forEach((id,i)=>{
      document.getElementById(id).addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) { images[i] = null; draw(); return; }
        const reader = new FileReader();
        reader.onload = ev => {
          const img = new Image();
          img.onload = () => { images[i] = img; draw(); };
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      });
    });

    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('touchstart', startDrag);
    window.addEventListener('mousemove', dragMove);
    window.addEventListener('touchmove', dragMove, {passive:false});
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
  </script>
</body>
</html>
