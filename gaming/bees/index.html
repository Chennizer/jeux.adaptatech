<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gentle Bees – Cause & Effect</title>
  <style>
    :root {
      --sky-top: #fef3c7;
      --sky-bottom: #a5b4fc;
      --hive: #fbbf24;
      --hive-dark: #b45309;
      --leaf: #22c55e;
      --text: #0f172a;
      --muted: #334155;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Nunito", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(180deg, var(--sky-top) 0%, var(--sky-bottom) 70%);
      min-height: 100vh;
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.25rem 1.5rem 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      text-align: center;
    }

    header h1 {
      font-size: clamp(1.3rem, 2vw + 1rem, 1.8rem);
      letter-spacing: 0.02em;
      font-weight: 800;
    }

    header p {
      color: var(--muted);
      font-weight: 600;
      font-size: 1rem;
    }

    main {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    #scene {
      width: 100%;
      height: 100%;
      display: block;
    }

    .hud {
      position: absolute;
      left: 50%;
      bottom: 1.25rem;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: center;
      padding: 0.85rem 1.1rem;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 999px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
      backdrop-filter: blur(8px);
    }

    #trigger {
      border: none;
      background: linear-gradient(120deg, #facc15, #fb923c);
      color: #0f172a;
      font-weight: 800;
      font-size: 1.1rem;
      padding: 0.95rem 1.35rem;
      border-radius: 999px;
      cursor: pointer;
      letter-spacing: 0.03em;
      transition: transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 8px 18px rgba(217, 119, 6, 0.25);
    }

    #trigger:active {
      transform: scale(0.97);
      box-shadow: 0 5px 12px rgba(217, 119, 6, 0.22);
    }

    .hint {
      font-weight: 700;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .honey-meter {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(15, 23, 42, 0.08);
      padding: 0.45rem 0.8rem;
      border-radius: 999px;
    }

    .meter-track {
      width: 120px;
      height: 10px;
      background: rgba(15, 23, 42, 0.1);
      border-radius: 999px;
      overflow: hidden;
      position: relative;
    }

    .meter-fill {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: linear-gradient(90deg, #fde047, #f97316);
      width: 0%;
      transition: width 0.5s ease;
    }

    @media (max-width: 640px) {
      .hud {
        bottom: 0.75rem;
        width: calc(100% - 1.5rem);
        border-radius: 1rem;
      }

      .honey-meter .hint-text {
        display: none;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Gentle Bees – Cause &amp; Effect</h1>
    <p>Press the big button, hit SPACE/ENTER, or tap anywhere to send the bees.</p>
  </header>

  <main>
    <canvas id="scene"></canvas>
    <div class="hud">
      <button id="trigger">SEND THE BEES</button>
      <div class="honey-meter" aria-label="Honey made">
        <div class="hint-text">Honey</div>
        <div class="meter-track" role="presentation">
          <div class="meter-fill" id="honeyFill"></div>
        </div>
      </div>
      <div class="hint">Cause → bees fly → flowers glow → honey grows</div>
    </div>
  </main>

  <script>
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");
    const honeyFill = document.getElementById("honeyFill");
    const trigger = document.getElementById("trigger");

    let width = 0;
    let height = 0;
    const hive = {
      x: 0,
      y: 0,
      honey: 0,
    };

    const flowers = [];
    const bees = [];
    const particles = [];
    let breeze = 0;

    function resize() {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
      const ratio = window.devicePixelRatio || 1;
      canvas.width = width * ratio;
      canvas.height = height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      positionWorld();
    }

    window.addEventListener("resize", resize);

    function positionWorld() {
      hive.x = width * 0.23;
      hive.y = height * 0.52;
      const flowerCount = 5;
      flowers.length = 0;
      for (let i = 0; i < flowerCount; i++) {
        const t = i / (flowerCount - 1 || 1);
        const x = width * (0.55 + 0.35 * t) + (Math.random() - 0.5) * 30;
        const y = height * (0.4 + 0.25 * Math.sin(t * Math.PI)) + (Math.random() - 0.5) * 25;
        flowers.push({
          x,
          y,
          radius: Math.min(width, height) * 0.04,
          pulse: 0,
          color: ["#f97316", "#ec4899", "#22c55e", "#f59e0b", "#8b5cf6"][i % 5],
        });
      }
      if (bees.length === 0) {
        const count = 9;
        for (let i = 0; i < count; i++) {
          bees.push(createBee());
        }
      } else {
        bees.forEach((bee) => (bee.x = hive.x + (Math.random() - 0.5) * 8));
      }
    }

    function createBee() {
      return {
        x: hive.x,
        y: hive.y,
        angle: Math.random() * Math.PI * 2,
        state: "rest",
        target: null,
        wobble: Math.random() * Math.PI * 2,
        delay: Math.random() * 0.8,
        sparkle: 0,
      };
    }

    function sendBees() {
      bees.forEach((bee, i) => {
        const flower = flowers[(i + Math.floor(Math.random() * flowers.length)) % flowers.length];
        bee.state = "toFlower";
        bee.target = flower;
        bee.delay = 0.05 * i;
        bee.sparkle = 1;
      });
      gentleTone();
    }

    trigger.addEventListener("click", sendBees);
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "Enter") {
        e.preventDefault();
        sendBees();
      }
    });
    window.addEventListener("pointerdown", (e) => {
      if (e.target !== trigger) sendBees();
    });

    function gentleTone() {
      if (typeof AudioContext === "undefined") return;
      const ctxAudio = new AudioContext();
      const osc = ctxAudio.createOscillator();
      const gain = ctxAudio.createGain();
      osc.type = "sine";
      osc.frequency.value = 520;
      gain.gain.setValueAtTime(0.001, ctxAudio.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.12, ctxAudio.currentTime + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.0001, ctxAudio.currentTime + 0.4);
      osc.connect(gain).connect(ctxAudio.destination);
      osc.start();
      osc.stop(ctxAudio.currentTime + 0.45);
    }

    function update(dt) {
      breeze += dt * 0.0003;
      flowers.forEach((flower) => {
        flower.pulse = Math.max(0, flower.pulse - dt * 0.0015);
      });

      bees.forEach((bee) => {
        bee.wobble += dt * 0.008;
        if (bee.delay > 0) {
          bee.delay -= dt * 0.001;
          return;
        }
        if (bee.state === "rest") {
          bee.angle += 0.002 * Math.sin(bee.wobble);
          bee.x = lerp(bee.x, hive.x + Math.cos(bee.angle) * 12, 0.02);
          bee.y = lerp(bee.y, hive.y + Math.sin(bee.angle) * 10, 0.02);
        } else if (bee.state === "toFlower" && bee.target) {
          moveBee(bee, bee.target, dt, () => {
            const visited = bee.target;
            bee.state = "return";
            bee.target = { x: hive.x, y: hive.y };
            bee.sparkle = 1;
            visited.pulse = 1;
            rewardHoney();
            burst(bee.x, bee.y, visited.color || "#fde047");
          });
        } else if (bee.state === "return" && bee.target) {
          moveBee(bee, bee.target, dt, () => {
            bee.state = "rest";
            bee.sparkle = 0;
            bee.target = null;
          });
        }
      });

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt * 0.001;
        p.x += p.vx * dt * 0.06;
        p.y += p.vy * dt * 0.06;
        p.vy += 0.001 * dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

    }

    function moveBee(bee, target, dt, onArrive) {
      const dx = target.x - bee.x;
      const dy = target.y - bee.y;
      const dist = Math.hypot(dx, dy);
      const speed = 0.08 * dt;
      if (dist < 6) {
        onArrive();
        return;
      }
      bee.x += (dx / dist) * speed + Math.cos(bee.wobble) * 0.08;
      bee.y += (dy / dist) * speed + Math.sin(bee.wobble * 1.2) * 0.05 + Math.sin(breeze) * 0.04;
    }

    function rewardHoney() {
      hive.honey = Math.min(1, hive.honey + 0.08);
      honeyFill.style.width = `${Math.round(hive.honey * 100)}%`;
      if (hive.honey >= 1) hive.honey = 0;
    }

    function burst(x, y, color) {
      for (let i = 0; i < 12; i++) {
        const ang = (Math.PI * 2 * i) / 12 + Math.random() * 0.3;
        particles.push({
          x,
          y,
          vx: Math.cos(ang) * (10 + Math.random() * 20),
          vy: Math.sin(ang) * (10 + Math.random() * 12),
          life: 0.9 + Math.random() * 0.5,
          color,
        });
      }
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      drawBackground();
      drawFlowers();
      drawHive();
      drawBees();
      drawParticles();
    }

    function drawBackground() {
      const horizon = height * 0.78;
      const grd = ctx.createLinearGradient(0, horizon, 0, height);
      grd.addColorStop(0, "#86efac");
      grd.addColorStop(1, "#22c55e");
      ctx.fillStyle = grd;
      ctx.fillRect(0, horizon, width, height - horizon);

      ctx.fillStyle = "rgba(255,255,255,0.18)";
      for (let i = 0; i < 3; i++) {
        const y = height * (0.18 + 0.08 * i);
        ctx.beginPath();
        ctx.ellipse(width * (0.2 + 0.25 * i), y, 140, 40, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawHive() {
      const r = Math.min(width, height) * 0.09;
      const x = hive.x;
      const y = hive.y;
      ctx.save();
      ctx.shadowColor = "rgba(180,83,9,0.35)";
      ctx.shadowBlur = 16;
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.beginPath();
      ctx.ellipse(x + 6, y + r * 0.8, r, r * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "#fed7aa";
      ctx.beginPath();
      ctx.ellipse(x, y, r * 1.05, r * 0.9, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(15,23,42,0.08)";
      ctx.lineWidth = 8;
      ctx.lineCap = "round";
      for (let i = -2; i <= 2; i++) {
        ctx.beginPath();
        ctx.moveTo(x - r * 0.9, y + i * r * 0.35);
        ctx.lineTo(x + r * 0.9, y + i * r * 0.35);
        ctx.stroke();
      }

      ctx.fillStyle = "#111827";
      ctx.beginPath();
      ctx.ellipse(x + r * 0.05, y + r * 0.05, r * 0.25, r * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.lineWidth = 10;
      ctx.strokeStyle = "rgba(251,191,36,0.5)";
      ctx.beginPath();
      ctx.arc(x, y, r * 1.1, -Math.PI * 0.7, -Math.PI * 0.7 + hive.honey * Math.PI * 1.4);
      ctx.stroke();

      ctx.restore();
    }

    function drawFlowers() {
      flowers.forEach((flower) => {
        const r = flower.radius;
        ctx.save();
        ctx.translate(flower.x, flower.y);
        ctx.shadowColor = "rgba(0,0,0,0.1)";
        ctx.shadowBlur = 10;
        ctx.lineWidth = 6;
        ctx.strokeStyle = "#166534";
        ctx.beginPath();
        ctx.moveTo(0, r * 0.2);
        ctx.lineTo(0, r * 1.6);
        ctx.stroke();

        const pulse = 1 + flower.pulse * 0.4;
        const petals = 6;
        for (let i = 0; i < petals; i++) {
          const ang = (Math.PI * 2 * i) / petals;
          ctx.beginPath();
          ctx.fillStyle = flower.color;
          ctx.ellipse(Math.cos(ang) * r * 0.8 * pulse, Math.sin(ang) * r * 0.8 * pulse, r * 0.55, r * 0.35, ang, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.beginPath();
        ctx.fillStyle = "#fde047";
        ctx.arc(0, 0, r * 0.45 * pulse, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      });
    }

    function drawBees() {
      bees.forEach((bee) => {
        ctx.save();
        ctx.translate(bee.x, bee.y);
        const dir = bee.target ? Math.atan2(bee.target.y - bee.y, bee.target.x - bee.x) : bee.angle;
        ctx.rotate(dir);
        const bodyL = 22;
        const bodyH = 12;

        if (bee.sparkle > 0) {
          ctx.globalAlpha = 0.6 * bee.sparkle;
          ctx.fillStyle = "#fde047";
          ctx.beginPath();
          ctx.arc(-4, 0, 14, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          bee.sparkle = Math.max(0, bee.sparkle - 0.02);
        }

        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.beginPath();
        ctx.ellipse(-4, -bodyH * 0.7, 7, 10, -0.5, 0, Math.PI * 2);
        ctx.ellipse(-4, bodyH * 0.7, 7, 10, 0.5, 0, Math.PI * 2);
        ctx.fill();

        const gradient = ctx.createLinearGradient(-bodyL / 2, 0, bodyL / 2, 0);
        gradient.addColorStop(0, "#facc15");
        gradient.addColorStop(1, "#f97316");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyL / 2, bodyH / 2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(15,23,42,0.85)";
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(-bodyL * 0.2, -bodyH / 2);
        ctx.lineTo(-bodyL * 0.2, bodyH / 2);
        ctx.moveTo(bodyL * 0.1, -bodyH / 2);
        ctx.lineTo(bodyL * 0.1, bodyH / 2);
        ctx.stroke();

        ctx.fillStyle = "#0f172a";
        ctx.beginPath();
        ctx.arc(bodyL / 2 - 3, 0, bodyH * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#f9fafb";
        ctx.beginPath();
        ctx.arc(bodyL / 2 - 2, -2, bodyH * 0.12, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    function drawParticles() {
      particles.forEach((p) => {
        ctx.save();
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    let last = performance.now();
    function step(now) {
      const dt = Math.min(40, now - last);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(step);
    }

    resize();
    positionWorld();
    requestAnimationFrame(step);
  </script>
</body>
</html>
