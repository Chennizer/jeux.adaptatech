<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Story Prototype — Cherry Blossom, Meditation, Lamp</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Helvetica Neue", Arial, system-ui, sans-serif;
    }
    html, body {
      margin: 0;
      height: 100%;
    }
    body {
      background: #030712;
      color: #f9fafb;
    }
    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    .page {
      position: absolute;
      inset: 0;
      display: none;
    }
    .page.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 40px;
      padding: clamp(24px, 6vw, 80px);
      text-align: center;
    }
    .landing-page {
      background: radial-gradient(circle at top, rgba(56,189,248,0.25), transparent 60%),
                  radial-gradient(circle at bottom, rgba(190,242,100,0.12), transparent 70%),
                  #030712;
    }
    .landing-page h1 {
      margin: 0;
      font-size: clamp(32px, 6vw, 56px);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    .landing-page p {
      max-width: min(720px, 90vw);
      line-height: 1.7;
      font-size: clamp(18px, 3vw, 24px);
      color: rgba(226, 232, 240, 0.9);
    }
    .start-button {
      padding: 16px 32px;
      border-radius: 999px;
      border: 2px solid rgba(191, 219, 254, 0.6);
      background: rgba(59, 130, 246, 0.3);
      color: #f8fafc;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      box-shadow: 0 12px 40px rgba(15, 23, 42, 0.35);
    }
    .start-button:hover,
    .start-button:focus-visible {
      transform: translateY(-2px);
      border-color: rgba(248, 250, 252, 0.85);
      box-shadow: 0 16px 50px rgba(59, 130, 246, 0.35);
      outline: none;
    }
    .story-page {
      background: radial-gradient(circle at top, rgba(14,116,144,0.25), transparent 60%),
                  radial-gradient(circle at bottom, rgba(190,242,100,0.12), transparent 70%),
                  #030712;
    }
    .story-page h1 {
      margin: 0;
      font-size: clamp(28px, 5vw, 48px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .story-page p {
      max-width: min(720px, 90vw);
      line-height: 1.6;
      font-size: clamp(18px, 2.8vw, 24px);
    }
    .gaze-target {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 14px 24px;
      border-radius: 999px;
      border: 2px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.65);
      color: #e2e8f0;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.3s ease, background 0.3s ease;
    }
    .gaze-target:hover,
    .gaze-target:focus-visible,
    .gaze-target.progress {
      border-color: rgba(248, 250, 252, 0.85);
      background: rgba(59, 130, 246, 0.35);
    }
    .gaze-target::after {
      content: "";
      position: absolute;
      inset: 4px;
      border-radius: inherit;
      border: 3px solid rgba(59, 130, 246, 0.6);
      transform: scaleX(0);
      transform-origin: left center;
      transition: transform 1.6s linear;
      pointer-events: none;
    }
    .gaze-target.progress::after {
      transform: scaleX(1);
    }
    .page.game-page {
      background: #000;
      padding: 0;
    }
    .game-frame {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
      background: #000;
    }
    .page.game-page .loading-note {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      font-size: 14px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.7);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.6);
    }
  </style>
</head>
<body>
  <div id="app">
    <section class="page landing-page active" data-index="0">
      <h1>Samurai Journey</h1>
      <p>
        Begin an interactive tale guided by your gaze. Press start to enter fullscreen and follow the
        warrior through moments of story and play.
      </p>
      <button id="startStory" class="start-button" type="button">Start the Story</button>
    </section>

    <section class="page story-page" data-index="1">
      <h1>Samurai Dawn</h1>
      <p>
        The young warrior arrives at the cherry grove to begin a journey of focus and harmony.
        Follow the story by resting your gaze on the glowing sigil below. The tale will unfold
        between moments of play.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Focus to Continue</div>
    </section>

    <section class="page story-page" data-index="2">
      <h1>Whispers in the Wind</h1>
      <p>
        Petals spiral through the air as a playful spirit challenges the warrior to slice blossoms
        carried by the breeze. Prepare to enter the first training.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Enter the Grove</div>
    </section>

    <section class="page game-page" data-index="3" data-game="cherry">
      <iframe title="Cherry Blossom Game" class="game-frame" allowfullscreen></iframe>
      <div class="loading-note">Loading Cherry Blossom Training…</div>
    </section>

    <section class="page story-page" data-index="4">
      <h1>Breath of the Mountain</h1>
      <p>
        With the challenge complete, the warrior rests beside a moonlit lake. Slow breaths and a
        guiding light call for quiet concentration before the next path.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Begin Meditation</div>
    </section>

    <section class="page game-page" data-index="5" data-game="meditation">
      <iframe title="Meditation Game" class="game-frame" allowfullscreen></iframe>
      <div class="loading-note">Loading Meditation Focus…</div>
    </section>

    <section class="page story-page" data-index="6">
      <h1>Lanterns Ascend</h1>
      <p>
        Enlightened by calm, the warrior must now send lanterns skyward to guide wandering spirits.
        A final game of patience awaits among the stars.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Release the Light</div>
    </section>

    <section class="page game-page" data-index="7" data-game="lamp">
      <iframe title="Lantern Game" class="game-frame" allowfullscreen></iframe>
      <div class="loading-note">Loading Lantern Sky…</div>
    </section>

    <section class="page story-page" data-index="8">
      <h1>Journey Complete</h1>
      <p>
        The night sky glows with quiet lanterns. The warrior bows in gratitude, ready for whatever
        tale will come next.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Restart Story</div>
    </section>
  </div>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const pages = Array.from(document.querySelectorAll('.page'));
      let currentIndex = 0;
      let gameTimeoutId = null;

      function clearGameTimer() {
        if (gameTimeoutId) {
          clearTimeout(gameTimeoutId);
          gameTimeoutId = null;
        }
      }

      function showPage(index) {
        if (index < 0 || index >= pages.length) return;
        pages[currentIndex].classList.remove('active');
        clearGameTimer();
        currentIndex = index;
        const page = pages[currentIndex];
        page.classList.add('active');
        if (page.dataset.game) {
          loadGame(page.dataset.game, page);
          gameTimeoutId = window.setTimeout(() => {
            if (pages[currentIndex] === page) {
              nextPage();
            }
          }, 30000);
        }
      }

      function nextPage() {
        const nextIndex = (currentIndex + 1) % pages.length;
        showPage(nextIndex);
      }

      const startButton = document.getElementById('startStory');
      if (startButton) {
        const beginStory = async () => {
          await requestAppFullscreen();
          showPage(1);
        };
        startButton.addEventListener('click', (event) => {
          event.preventDefault();
          beginStory();
        });
        startButton.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            beginStory();
          }
        });
      }

      const gazeTargets = document.querySelectorAll('[data-next]');
      gazeTargets.forEach((target) => {
        const dwell = Number(target.dataset.dwell || 1800);
        let timer = null;
        const trigger = () => {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          target.classList.remove('progress');
          nextPage();
        };
        target.addEventListener('pointerenter', () => {
          if (timer) return;
          target.classList.add('progress');
          timer = setTimeout(trigger, dwell);
        });
        target.addEventListener('pointerleave', () => {
          if (!timer) return;
          clearTimeout(timer);
          timer = null;
          target.classList.remove('progress');
        });
        target.addEventListener('click', trigger);
        target.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            trigger();
          }
        });
      });

      async function requestAppFullscreen() {
        if (document.fullscreenElement) return;
        const root = document.documentElement;
        const method = root.requestFullscreen || root.webkitRequestFullscreen || root.msRequestFullscreen;
        if (method) {
          try {
            await method.call(root);
          } catch (error) {
            /* ignore failures */
          }
        }
      }

      const templateCache = {};
      function loadTemplate(id) {
        if (!templateCache[id]) {
          const tpl = document.getElementById(id);
          templateCache[id] = tpl ? tpl.innerHTML.trim() : '';
        }
        return templateCache[id];
      }

      const loadedGames = new Set();

      function autoStartGameFrame(iframe) {
        if (!iframe) return;
        const doc = iframe.contentDocument || iframe.contentWindow?.document;
        if (!doc) return;
        const startBtn = doc.getElementById('startBtn');
        if (startBtn && typeof startBtn.click === 'function') {
          startBtn.click();
        }
        const startOverlay = doc.getElementById('startOverlay');
        if (startOverlay) {
          startOverlay.style.display = 'none';
        }
        const autoFns = ['startExperience', 'startGame'];
        autoFns.forEach((name) => {
          const fn = iframe.contentWindow && iframe.contentWindow[name];
          if (typeof fn === 'function') {
            try {
              fn.call(iframe.contentWindow);
            } catch (error) {
              /* ignore individual game errors */
            }
          }
        });
      }

      function loadGame(key, page) {
        const iframe = page.querySelector('iframe');
        const note = page.querySelector('.loading-note');
        if (!iframe) return;

        const handleLoaded = () => {
          if (note) {
            try {
              note.remove();
            } catch (error) {
              /* ignore */
            }
          }
          window.requestAnimationFrame(() => autoStartGameFrame(iframe));
        };

        if (!loadedGames.has(key)) {
          let templateId = '';
          if (key === 'cherry') templateId = 'tpl-cherryblossom';
          else if (key === 'meditation') templateId = 'tpl-meditation';
          else if (key === 'lamp') templateId = 'tpl-lamp';
          if (!templateId) return;
          const html = loadTemplate(templateId);
          if (!html) return;
          iframe.addEventListener('load', handleLoaded, { once: true });
          iframe.srcdoc = html;
          loadedGames.add(key);
        } else {
          handleLoaded();
        }
      }
    });
  </script>

  <template id="tpl-cherryblossom">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cherry Blossom Cut — Tornado Swirl (Fly-Off) Intro</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: #fff;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    #game {
      display: block;
      width: 100vw; height: 100vh;
      cursor: crosshair;          /* fallback if custom cursor is not ready */
      background: #fff;
    }
    #startOverlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: rgba(255,255,255,0.9);
      z-index: 10;
    }
    #startBtn {
      padding: 14px 22px;
      border: 2px solid #d40000; color: #d40000; background: #fff;
      border-radius: 12px; font-size: 18px; font-weight: 700;
      box-shadow: 0 6px 24px rgba(0,0,0,0.08);
      cursor: pointer;
    }
    #startBtn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay">
    <button id="startBtn">Start • Fullscreen</button>
  </div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       CONFIG
    ======================= */
    const IMG_SRC = "../../images/samurai/cherryblossom.png";       // petal image
    const BG_SRC  = "../../images/samurai/cherryblossombg.png";     // background image
    const SLASH_SOUND = "../../sounds/blade.mp3";
    const KATANA_SRC  = "../../images/samurai/katana.png";
    const SONG_SRC    = "../../songs/samurai/cherryblossomsong2.mp3"; // bg song
    const KATANA_DRAW_SRC = "../../sounds/katana.mp3";               // sword drawing SFX

    // Cursor limits and hotspot (in ORIGINAL image pixels)
    const CURSOR_MAX_PX = 124;
    const HOTSPOT_ORIG = { x: 12, y: 28 };

    // Play (normal game) settings
    const SPAWN_EVERY_MS   = 1400;
    const FALL_SPEED_MIN   = 40;
    const FALL_SPEED_MAX   = 95;
    const BLOSSOM_SIZE_MIN = 72 * 3;
    const BLOSSOM_SIZE_MAX = 138 * 3;
    const HOVER_CUT_RADIUS = 52;
    const SHARD_SPREAD_SPEED = 190;
    const SHARD_ROT_SPEED    = 1.2;
    const SHARD_FADE_TIME    = 0.85;
    const MAX_FALLING        = 5;

    // Intro (tornado swirl) settings — fly-off
    const INTRO_DURATION_MS = 5000;     // 5s total
    const SWIRL_PETALS      = 50;       // keep it smooth
    const SWIRL_SIZE_MIN    = 40;
    const SWIRL_SIZE_MAX    = 100;
    const SWIRL_RAD_MIN     = 20;       // starting radius
    const SWIRL_RAD_MAX     = 220;
    const SWIRL_DR_MIN      = 16;       // baseline radial expansion (px/s)
    const SWIRL_DR_MAX      = 42;
    const SWIRL_DA_MIN      = 2.2;      // angular vel (rad/s)
    const SWIRL_DA_MAX      = 4.2;
    const SWIRL_SPIN_MIN    = -1.6;     // self-rotation (rad/s)
    const SWIRL_SPIN_MAX    =  1.6;
    const SWIRL_CENTER_DRIFT_Y = 12;    // gentle downward drift (px/s)

    // Strong outward burst controls
    const BURST_START_T     = 0.60;     // fraction of intro when burst begins
    const BURST_MAX_OUT_PX  = 1800;     // additional outward speed at peak (px/s)
    const BURST_SPINUP_MUL  = 1.6;      // multiplies angular velocity during burst
    const FINAL_BLAST_MS    = 350;      // last ms window for a final kick
    const FINAL_BLAST_OUT   = 2200;     // extra outward speed (px/s) in last window

    // Off-screen margin for culling
    const OFF_MARGIN = 320;

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    let resizeRAF = 0;
    window.addEventListener('resize', () => {
      cancelAnimationFrame(resizeRAF);
      resizeRAF = requestAnimationFrame(() => {
        W = canvas.width  = window.innerWidth;
        H = canvas.height = window.innerHeight;
      });
    });

    // Assets
    const img = new Image(); img.src = IMG_SRC;
    const bgImg = new Image(); bgImg.src = BG_SRC;

    // Audio
    const slashAudio = new Audio(SLASH_SOUND);
    slashAudio.volume = 0.6;
    function playSlash() {
      const s = slashAudio.cloneNode(true);
      s.volume = slashAudio.volume;
      s.play().catch(()=>{});
    }

    // Background music
    const bgSong = new Audio(SONG_SRC);
    bgSong.volume = 0.75;   // 75%
    bgSong.loop = true;

    // Katana draw SFX (for the moment the sword cursor appears)
    const katanaDraw = new Audio(KATANA_DRAW_SRC);
    katanaDraw.volume = 0.9;

    // Pointer / cursor flip
    const pointer = { x: -9999, y: -9999, prevX: -9999, inside: false };
    const MOVE_THRESH = 2;
    let cursorOrient = 'left';

    canvas.addEventListener('pointermove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top)  * (canvas.height / rect.height);
      const dx = (pointer.prevX === -9999) ? 0 : (x - pointer.prevX);

      pointer.x = x; pointer.y = y; pointer.inside = true;

      if (gameState === 'play' && katanaReady && katanaRevealed) {
        if (dx > MOVE_THRESH && cursorOrient !== 'right') { cursorOrient = 'right'; applyKatanaCursor(); }
        else if (dx < -MOVE_THRESH && cursorOrient !== 'left') { cursorOrient = 'left'; applyKatanaCursor(); }
      }
      pointer.prevX = x;
    });
    canvas.addEventListener('pointerleave', () => pointer.inside = false);

    const blossoms = [];
    const shards = [];
    const rand = (a, b) => a + Math.random() * (b - a);
    const nowSec = () => performance.now()/1000;

    /* =======================
       KATANA CURSOR
    ======================= */
    let katanaReady = false;
    let katanaLeft = null;   // {url, hx, hy}
    let katanaRight = null;  // {url, hx, hy}
    let katanaRevealed = false; // becomes true once we show the katana cursor + play SFX

    const katanaImg = new Image();
    katanaImg.onload = () => {
      const iw = katanaImg.width, ih = katanaImg.height;
      const scale = Math.min(1, CURSOR_MAX_PX / Math.max(iw, ih));
      const dw = Math.round(iw * scale);
      const dh = Math.round(ih * scale);

      const leftCanvas = document.createElement('canvas');
      leftCanvas.width = dw; leftCanvas.height = dh;
      const lctx = leftCanvas.getContext('2d');
      lctx.imageSmoothingEnabled = true;
      lctx.drawImage(katanaImg, 0, 0, dw, dh);

      const rightCanvas = document.createElement('canvas');
      rightCanvas.width = dw; rightCanvas.height = dh;
      const rctx = rightCanvas.getContext('2d');
      rctx.imageSmoothingEnabled = true;
      rctx.translate(dw, 0); rctx.scale(-1, 1);
      rctx.drawImage(katanaImg, 0, 0, dw, dh);

      const hxLeft  = Math.max(0, Math.min(dw - 1, Math.round(HOTSPOT_ORIG.x * scale)));
      const hyLeft  = Math.max(0, Math.min(dh - 1, Math.round(HOTSPOT_ORIG.y * scale)));
      const hxRight = (dw - 1) - hxLeft;
      const hyRight = hyLeft;

      katanaLeft  = { url: leftCanvas.toDataURL('image/png'),  hx: hxLeft,  hy: hyLeft };
      katanaRight = { url: rightCanvas.toDataURL('image/png'), hx: hxRight, hy: hyRight };
      katanaReady = true;

      // If we are already in play and haven't revealed yet, do it now
      if (gameState === 'play' && !katanaRevealed) {
        revealKatanaCursorWithSfx();
      }
    };
    katanaImg.onerror = () => { katanaReady = false; };
    katanaImg.src = KATANA_SRC;

    function applyKatanaCursor() {
      if (!katanaReady) return;
      const k = (cursorOrient === 'right') ? katanaRight : katanaLeft;
      canvas.style.cursor = `url("${k.url}") ${k.hx} ${k.hy}, crosshair`;
    }

    function revealKatanaCursorWithSfx() {
      if (!katanaReady) return; // will be retried via onload above
      applyKatanaCursor();
      katanaRevealed = true;
      // Play the katana drawing sound when the sword appears
      try { katanaDraw.currentTime = 0; katanaDraw.play(); } catch(e) {}
    }

    /* =======================
       HUD: SLICE COUNTER
    ======================= */
    let sliceCount = 0;
    function drawHUD() {
      const pad = Math.max(12, Math.min(20, Math.floor(W * 0.01 + H * 0.01)));
      const iconSize = Math.max(24, Math.min(36, Math.floor((W + H) * 0.02)));
      const textSize = Math.max(18, Math.min(28, Math.floor((W + H) * 0.018)));

      const xRight = W - pad;
      const yTop = pad + iconSize * 0.1;

      ctx.save();
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.font = `700 ${textSize}px ui-rounded, ui-sans-serif, system-ui, Segoe UI, Roboto, Arial`;
      ctx.fillStyle = '#d40000';
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 2;

      // Number
      ctx.fillText(`${sliceCount}`, xRight, yTop + iconSize * 0.5);

      // Icon left of the number
      if (img.complete && img.naturalWidth > 0) {
        const iconX = xRight - ctx.measureText(`${sliceCount}`).width - 10 - iconSize;
        const iconY = pad;
        ctx.shadowColor = 'rgba(0,0,0,0.18)';
        ctx.drawImage(img, iconX, iconY, iconSize, iconSize);
      }
      ctx.restore();
    }

    /* =======================
       GAME ENTITIES
    ======================= */
    function spawnBlossom() {
      if (!img.complete) return;
      const size = rand(BLOSSOM_SIZE_MIN, BLOSSOM_SIZE_MAX);
      const aspect = img.width / img.height || 1;
      const w = aspect >= 1 ? size*aspect : size;
      const h = aspect >= 1 ? size : size/aspect;
      blossoms.push({
        x: rand(w * 0.5, W - w * 0.5),
        y: -h - rand(0, 100),
        w, h,
        angle: rand(-Math.PI, Math.PI),
        rot: rand(-0.5, 0.5),
        vy: rand(FALL_SPEED_MIN, FALL_SPEED_MAX),
        vx: rand(-12, 12),
        cut: false
      });
    }

    function cutBlossom(b) {
      playSlash();
      sliceCount++;

      const leftRect  = { sx: 0, sy: 0, sw: img.width/2, sh: img.height };
      const rightRect = { sx: img.width/2, sy: 0, sw: img.width/2, sh: img.height };
      const tw = b.w, th = b.h, tBorn = nowSec();
      shards.push({clip:leftRect,x:b.x-tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx:-SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot:-SHARD_ROT_SPEED,born:tBorn,life:SHARD_FADE_TIME});
      shards.push({clip:rightRect,x:b.x+tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx: SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot: SHARD_ROT_SPEED,born:tBorn,life: SHARD_FADE_TIME});
      b.cut = true;
    }

    /* =======================
       INTRO: TORNADO SWIRL (FLY-OFF)
    ======================= */
    let gameState = 'idle';  // 'idle' | 'intro' | 'play'
    let introStartMs = 0;

    let swirlCenter = { x: 0, y: 0 };
    let swirlPetals = []; // {r,a,w,h,spin,dr,da,angle,done}

    function smoothstep01(t){ return t*t*(3-2*t); } // 0..1 -> smooth 0..1

    function initSwirl() {
      swirlCenter.x = W * 0.5;
      swirlCenter.y = H * 0.55;
      swirlPetals = [];

      for (let i = 0; i < SWIRL_PETALS; i++) {
        const r  = rand(SWIRL_RAD_MIN, SWIRL_RAD_MAX);
        const a  = rand(0, Math.PI * 2);
        const size = rand(SWIRL_SIZE_MIN, SWIRL_SIZE_MAX);
        const aspect = (img.width || 1) / (img.height || 1);
        const w = aspect >= 1 ? size*aspect : size;
        const h = aspect >= 1 ? size : size/aspect;

        swirlPetals.push({
          r, a, w, h,
          spin: rand(SWIRL_SPIN_MIN, SWIRL_SPIN_MAX),              // self-rotation
          dr:   rand(SWIRL_DR_MIN, SWIRL_DR_MAX),                  // base radial expansion
          da:   rand(SWIRL_DA_MIN, SWIRL_DA_MAX) * (Math.random()<0.5?-1:1), // angular velocity
          angle: rand(-Math.PI, Math.PI),
          done: false
        });
      }
    }

    function updateSwirl(dt, t01) {
      // gentle vertical drift of the whole column
      swirlCenter.y += SWIRL_CENTER_DRIFT_Y * dt;

      // ramped burst strength 0..1 after BURST_START_T
      const burstPhase = Math.max(0, (t01 - BURST_START_T) / (1 - BURST_START_T));
      const burst = smoothstep01(burstPhase); // smooth ramp-up

      // final blast window
      const remainingMs = INTRO_DURATION_MS * (1 - t01);
      const finalBlast = remainingMs <= FINAL_BLAST_MS ? (1 - remainingMs / FINAL_BLAST_MS) : 0;

      for (const p of swirlPetals) {
        if (p.done) continue;

        // spin-up during burst (tighter/twitchier swirl)
        const daNow = p.da * (1 + (BURST_SPINUP_MUL - 1) * burst);

        // strong outward push during burst + final blast
        const outward = p.dr + (BURST_MAX_OUT_PX * burst) + (FINAL_BLAST_OUT * finalBlast);

        // integrate polar motion
        p.a     += daNow * dt;     // orbit
        p.r     += outward * dt;   // spiral out faster and then explode
        p.angle += p.spin * dt;    // petal self-rotation

        // compute position for off-screen test
        const x = swirlCenter.x + Math.cos(p.a) * p.r;
        const y = swirlCenter.y + Math.sin(p.a) * p.r;

        if (x < -OFF_MARGIN || x > W + OFF_MARGIN || y < -OFF_MARGIN || y > H + OFF_MARGIN) {
          p.done = true; // out of view; stop drawing
        }
      }
    }

    function drawSwirl() {
      drawBackgroundImage();
      for (const p of swirlPetals) {
        if (p.done) continue;
        const x = swirlCenter.x + Math.cos(p.a) * p.r;
        const y = swirlCenter.y + Math.sin(p.a) * p.r;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(p.angle);
        ctx.drawImage(img, -p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      // HUD during intro (shows 0)
      drawHUD();
    }

    /* =======================
       GAME LOOP STATE
    ======================= */
    let lastT = performance.now(), spawnTimer = 0;

    function tick(tMs) {
      const dt = Math.min(0.033, (tMs - lastT) / 1000);
      lastT = tMs;

      if (gameState === 'intro') {
        const elapsed = tMs - introStartMs;
        const t01 = Math.min(1, Math.max(0, elapsed / INTRO_DURATION_MS));
        updateSwirl(dt, t01);
        drawSwirl();

        if (elapsed >= INTRO_DURATION_MS) {
          gameState = 'play';

          // Reveal sword cursor + SFX if ready, or as soon as it becomes ready
          if (katanaReady) revealKatanaCursorWithSfx();

          spawnTimer = SPAWN_EVERY_MS + 1; // seed first blossom soon
        }
      } else if (gameState === 'play') {
        spawnTimer += dt * 1000;
        if (spawnTimer > SPAWN_EVERY_MS && blossoms.length < MAX_FALLING) {
          spawnTimer = 0;
          spawnBlossom();
        }
        updateBlossoms(dt);
        updateShards(dt);
        render();
      }

      requestAnimationFrame(tick);
    }

    /* =======================
       BACKGROUND IMAGE (cover)
    ======================= */
    function drawBackgroundImage() {
      if (bgImg.complete && bgImg.naturalWidth > 0) {
        const iw = bgImg.width, ih = bgImg.height;
        const scale = Math.max(W / iw, H / ih); // cover
        const dw = iw * scale, dh = ih * scale;
        const dx = (W - dw) * 0.5;
        const dy = (H - dh) * 0.5;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(bgImg, dx, dy, dw, dh);
      } else {
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, W, H);
      }
    }

    /* =======================
       PLAY RENDER/UPDATE
    ======================= */
    function updateBlossoms(dt) {
      for (let i = blossoms.length-1; i>=0; i--) {
        const b = blossoms[i];
        b.y += b.vy * dt;
        b.x += b.vx * dt;
        b.angle += b.rot * dt;
        const dx = pointer.x - b.x, dy = pointer.y - b.y;
        if (pointer.inside && !b.cut && dx*dx+dy*dy<=HOVER_CUT_RADIUS*HOVER_CUT_RADIUS) cutBlossom(b);
        if (b.cut || b.y - b.h/2 > H+40) blossoms.splice(i, 1);
      }
    }

    function updateShards(dt) {
      const t = nowSec();
      for (let i = shards.length-1; i>=0; i--) {
        const s = shards[i];
        s.x += s.vx * dt; s.y += s.vy * dt; s.vy += 420*dt; s.angle += s.rot * dt;
        if (t - s.born > s.life) shards.splice(i, 1);
      }
    }

    function render() {
      drawBackgroundImage();
      // Whole blossoms
      for (const b of blossoms) {
        ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle);
        ctx.drawImage(img,-b.w/2,-b.h/2,b.w,b.h); ctx.restore();
      }
      // Shards
      const t = nowSec();
      for (const s of shards) {
        const alpha = Math.max(0,1-(t-s.born)/s.life);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.translate(s.x,s.y); ctx.rotate(s.angle);
        ctx.drawImage(img,s.clip.sx,s.clip.sy,s.clip.sw,s.clip.sh,-s.w/2,-s.h/2,s.w,s.h);
        ctx.restore();
      }
      // HUD over everything
      drawHUD();
    }

    /* ===== FULLSCREEN START ===== */
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    async function enterFullscreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    }

    startBtn.addEventListener('click', async () => {
      try { await enterFullscreen(); } catch(e) {}

      // Hide overlay
      startOverlay.style.display = 'none';

      // Hide cursor during the entire intro animation
      canvas.style.cursor = 'none';

      // Start music (user gesture exists, so this should be allowed)
      try { bgSong.currentTime = 0; bgSong.play(); } catch(e) {}

      // Start tornado swirl; katana appears when play begins
      gameState = 'intro';
      introStartMs = performance.now();
      initSwirl();

      lastT = performance.now();
      // ensure assets are ready before loop
      if (img.complete && bgImg.complete) requestAnimationFrame(tick);
      else {
        let pending = 0;
        const tryStart = () => { if (--pending <= 0) requestAnimationFrame(tick); };
        if (!img.complete)  { pending++; img.onload  = tryStart; }
        if (!bgImg.complete){ pending++; bgImg.onload = tryStart; }
        if (pending === 0) requestAnimationFrame(tick);
      }
    });

  })();
  </script>
</body>
</html>
  </template>

  <template id="tpl-meditation">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Samurai Focus — One Orb → Moon (Shaded Sphere, Moonrocks, Random Impact SFX, Large Pointer)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #game { display:block; width:100vw; height:100vh; cursor: none; background:#000; } /* hide OS cursor */
    #startOverlay { position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(0,0,0,0.75); z-index:10; }
    #startBtn { padding:14px 22px; border:2px solid #6ad1c9; color:#6ad1c9; background:#000;
      border-radius:12px; font-size:18px; font-weight:700; box-shadow:0 6px 24px rgba(0,0,0,.25); cursor:pointer; }
    #startBtn:active{ transform:translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay"><button id="startBtn">Start • Fullscreen</button></div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       ASSETS
    ======================= */
    const BG_SRC = "../../images/samurai/lampbg.png";

    // Pointer image (square, per your update)
    const POINTER_SRC = "../../images/samurai/chi.png";

    // Moonrock shards (random)
    const ROCK_SRCS = [
      "../../images/samurai/moonrock1.png",
      "../../images/samurai/moonrock2.png",
      "../../images/samurai/moonrock3.png",
    ];

    // Moon HUD icon (add an icon file here)
    const MOON_ICON_SRC = "../../images/samurai/transparentchi.png";

    // SFX
    const SFX_RELEASE = "../../sounds/samurai/energyball.mp3";
    const SFX_IMPACT_SRCS = [
      "../../sounds/samurai/spacerockexplosion1.mp3",
      "../../sounds/samurai/spacerockexplosion2.mp3",
    ];

    /* =======================
       TUNABLES
    ======================= */
    const MIN_DIAMETER = 100;
    const MAX_DIAMETER = 200;
    const DWELL_MS     = 2000;
    const DECAY_PER_SEC= 0.5;
    const ENTRY_GRACE_MS = 200;

    // Spawn area (bottom third)
    const SPAWN_X_MIN_FRAC = 0.20;
    const SPAWN_X_MAX_FRAC = 0.80;
    const SPAWN_Y_MIN_FRAC = 0.68;
    const SPAWN_Y_MAX_FRAC = 0.90;

    // Launch path → to the moon (constant speed along curve)
    const LAUNCH_SPEED_PX  = 360;   // px/s
    const END_RADIUS       = 10;    // size at the moon
    const BEZIER_PEAK      = 0.34;  // arc height (fraction of screen)
    const RESPAWN_DELAY_MS = 2500;  // wait before next orb

    // For glow stops
    const BALL_RGB       = "120,220,210";

    // Local jitter only
    const ORB_SHAKE_MAX  = 8;
    const ORB_SHAKE_FX   = 23, ORB_SHAKE_FY = 17;

    // Audio (crescendo while charging)
    const HUM_GAIN_MAX   = 0.6;

    // Moon (bigger + designed halo)
    const MOON_R         = 140;
    const MOON_GLOW_R    = 560;
    const MOON_X_FRAC    = 0.78;
    const MOON_Y_FRAC    = 0.24;

    // Impact FX
    const IMPACT_PETALS  = 180;
    const IMPACT_SPEED   = 460;
    const IMPACT_LIFE    = 1.9;
    const SHOCKWAVE_MAX_R= 340;
    const FLASH_MAX_ALPHA= 0.7;

    // Craters
    const MAX_CRATERS      = 24;
    const CRATER_FADE_MS   = 250;
    const CRATER_R_MIN_FR  = 0.06;
    const CRATER_R_MAX_FR  = 0.14;
    const CRATER_MARGIN_FR = 0.04;

    // Moon-only shake — STRONGER and SLOWER
    const SHAKE_STIFFNESS = 8;
    const SHAKE_DAMPING   = 5;
    const SHAKE_IMPULSE   = 240;
    let mShake = { ox: 0, oy: 0, vx: 0, vy: 0 };

    /* ==== Energy Sphere Look (no border) ==== */
    const LIGHT_DIR = { x: -0.6, y: -0.8 }; // normalized later
    const CORE_COLOR      = { r:255, g:255, b:255 };
    const MID_COLOR       = { r:160, g:230, b:255 };
    const EDGE_COLOR      = { r: 70, g:150, b:210 };
    const AURA_COLOR      = { r:120, g:220, b:255 };
    const RING_COUNT      = 3;
    const RING_ALPHA      = 0.18;
    const RING_PULSE_HZ   = 1.0;

    // Inflow particles: near-rim and outer ring
    const INFLOW_RATE      = 60;
    const INFLOW_MAX       = 260;
    const INFLOW_ALPHA     = 0.55;
    const INFLOW_INNER_MIN = 0.90;
    const INFLOW_INNER_MAX = 1.20;
    const INFLOW_OUTER_MIN = 1.40;
    const INFLOW_OUTER_MAX = 2.30;

    // Pointer sizing
    const POINTER_PX_MAX = 120;      // hard cap
    const POINTER_BASE_PX = 96;      // nominal size before breathing/charge
    const POINTER_BREATH = 0.04;     // ±4% breathing
    const POINTER_CHARGE_SCALE = 0.15; // up to +15% with full charge

    // Hover / charge zone tuning
    const HOVER_RADIUS_MULT   = 1.30; // 1.0 = exact ball radius; 1.3 = +30% larger
    const HOVER_PAD_PX        = 48;   // extra fixed pixels beyond the scaled radius
    const CHARGE_EDGE_FALLOFF = 0.6;  // 0..1 min charge-rate at the outer hover edge

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    const bgImg = new Image(); bgImg.src = BG_SRC;

    // Pointer image
    const pointerImg = new Image(); pointerImg.src = POINTER_SRC;

    // Load moonrock images
    const rockImgs = ROCK_SRCS.map(src => { const im = new Image(); im.src = src; return im; });

    // Moon HUD icon
    const moonIcon = new Image(); moonIcon.src = MOON_ICON_SRC;

    // Audio
    const sfxRelease = new Audio(SFX_RELEASE); sfxRelease.volume = 0.7;
    const sfxImpactClips = SFX_IMPACT_SRCS.map(p => { const a = new Audio(p); a.volume = 0.75; return a; });
    const play = a => { try { a.currentTime = 0; a.play(); } catch(_){} };
    const playImpact = () => {
      const i = (Math.random() * sfxImpactClips.length) | 0;
      play(sfxImpactClips[i]);
    };

    const rand  = (a,b)=>a+Math.random()*(b-a);
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const nowS  = ()=> performance.now()/1000;

    // normalize light dir
    (function(){ const L = Math.hypot(LIGHT_DIR.x, LIGHT_DIR.y)||1; LIGHT_DIR.x/=L; LIGHT_DIR.y/=L; })();

    // Pointer / eye-gaze
    const pointer = { x:-9999, y:-9999, px:-9999, py:-9999, moved:0, inside:false };
    canvas.addEventListener('pointermove', e=>{
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top ) * (canvas.height / r.height);
      if (pointer.px !== -9999) pointer.moved = Math.hypot(x-pointer.px, y-pointer.py);
      pointer.x=x; pointer.y=y; pointer.px=x; pointer.py=y; pointer.inside=true;
    });
    canvas.addEventListener('pointerleave', ()=> pointer.inside=false);

    // Moon position (responsive)
    let moon = { x: W*MOON_X_FRAC, y: H*MOON_Y_FRAC };
    function resize(){
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      moon.x = W*MOON_X_FRAC; moon.y = H*MOON_Y_FRAC;
      if (orb && !launching){
        orb.cx = clamp(orb.cx, W*SPAWN_X_MIN_FRAC, W*SPAWN_X_MAX_FRAC);
        orb.cy = clamp(orb.cy, H*SPAWN_Y_MIN_FRAC, H*SPAWN_Y_MAX_FRAC);
      }
    }
    window.addEventListener('resize', resize);

    /* =======================
       AUDIO — charging hum
    ======================= */
    let audioCtx=null, masterGain=null;
    let chargeGain=null, filter=null, osc1=null, osc2=null, o1g=null, o2g=null;

    function setupAudio(){
      audioCtx   = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(audioCtx.destination);

      osc1 = audioCtx.createOscillator(); osc1.type = 'sawtooth'; osc1.frequency.value = 90;
      osc2 = audioCtx.createOscillator(); osc2.type = 'triangle';  osc2.frequency.value = 180;

      o1g = audioCtx.createGain(); o1g.gain.value = 0.35;
      o2g = audioCtx.createGain(); o2g.gain.value = 0.25;

      filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 700; filter.Q.value = 0.7;

      chargeGain = audioCtx.createGain(); chargeGain.gain.value = 0.0;

      osc1.connect(o1g); osc2.connect(o2g);
      o1g.connect(filter); o2g.connect(filter);
      filter.connect(chargeGain); chargeGain.connect(masterGain);

      osc1.start(); osc2.start();
    }
    function updateHum(level){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const gTarget = clamp(HUM_GAIN_MAX * Math.pow(level,1.15), 0, HUM_GAIN_MAX);
      chargeGain.gain.setTargetAtTime(gTarget, t, 0.06);

      const f1 = 90  + (240-90)  * level;
      const f2 = 180 + (520-180) * level;
      const ff = 700 + (4200-700)* level;
      osc1.frequency.setTargetAtTime(f1, t, 0.05);
      osc2.frequency.setTargetAtTime(f2, t, 0.05);
      filter.frequency.setTargetAtTime(ff, t, 0.08);
    }
    function cutHumPunch(){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const cur = chargeGain.gain.value || 0.0001;
      chargeGain.gain.setValueAtTime(cur, t);
      chargeGain.gain.exponentialRampToValueAtTime(Math.max(0.001, cur*1.6), t+0.05);
      chargeGain.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      filter.frequency.setTargetAtTime(6000, t, 0.03);
    }

    /* =======================
       ORB (single)
    ======================= */
    let orb = null;            // {cx,cy,charge,inZone,enterMs,launching,launchT0,startR,trail,renderR, path, s}
    let launching = false;
    let respawnAtMs = 0;

    function spawnOrb(){
      orb = {
        cx: W*rand(SPAWN_X_MIN_FRAC, SPAWN_X_MAX_FRAC),
        cy: H*SPAWN_Y_MIN_FRAC + rand(0, (H*SPAWN_Y_MAX_FRAC - H*SPAWN_Y_MIN_FRAC)),
        charge: 0, inZone:false, enterMs:0,
        launching:false, launchT0:0, startR:MIN_DIAMETER*0.5,
        trail: [], renderR: MIN_DIAMETER*0.5,
        path: null, s: 0
      };
    }
    function radiusFromCharge(o){ return (MIN_DIAMETER + (MAX_DIAMETER - MIN_DIAMETER)*o.charge) * 0.5; }

    /* =======================
       IMPACT FX
    ======================= */
    const shards=[];
    function burstAt(x,y){
      const tBorn = nowS();
      for (let i=0;i<IMPACT_PETALS;i++){
        const a = Math.random()*Math.PI*2;
        const sp= IMPACT_SPEED*(0.4+0.6*Math.random());
        const size=rand(24,72);
        shards.push({
          x, y, w:size, h:size, ang:rand(-Math.PI,Math.PI),
          vx:Math.cos(a)*sp, vy:Math.sin(a)*sp - rand(60,120),
          rot:rand(-1.6,1.6), born:tBorn, life:IMPACT_LIFE,
          img: rockImgs[(Math.random()*rockImgs.length)|0]
        });
      }
    }
    let flashLife=0, flashT=0, shockLife=0, shockT=0, shockX=0, shockY=0;
    function flash(a=FLASH_MAX_ALPHA, life=0.16){ flashLife=life; flashT=0; }
    function shock(cx,cy,life=0.9){ shockLife=life; shockT=0; shockX=cx; shockY=cy; }

    /* =======================
       CRATERS
    ======================= */
    const craters = [];
    function addCraterFromImpact() {
      let ang = -Math.PI/2;
      if (orb && orb.trail && orb.trail.length >= 2) {
        const a = orb.trail[orb.trail.length - 1];
        const b = orb.trail[orb.trail.length - 2];
        ang = Math.atan2(a.y - b.y, a.x - b.x);
      }
      const rFrac = rand(CRATER_R_MIN_FR, CRATER_R_MAX_FR);
      const distMax = Math.max(0, 1 - rFrac - CRATER_MARGIN_FR);
      const dist = rand(0.10, distMax);
      craters.push({ ang, dist, rFrac, bornMs: performance.now() });
      if (craters.length > MAX_CRATERS) craters.shift();
    }

    function drawCraters() {
      if (!craters.length) return;
      const LVX = -0.5, LVY = -0.9;
      const lvLen = Math.hypot(LVX, LVY) || 1;
      const lx = LVX / lvLen, ly = LVY / lvLen;
      const nowMs = performance.now();

      for (const c of craters) {
        const age = nowMs - c.bornMs;
        const k = Math.min(1, age / CRATER_FADE_MS);
        const scale = 0.7 + 0.3 * k;
        const alpha = k;

        const cx = moon.x + Math.cos(c.ang) * c.dist * MOON_R;
        const cy = moon.y + Math.sin(c.ang) * c.dist * MOON_R;
        const r  = c.rFrac * MOON_R * scale;

        const g = ctx.createRadialGradient(
          cx - (lx * r * 0.25), cy - (ly * r * 0.25), r * 0.15,
          cx, cy, r
        );
        g.addColorStop(0, `rgba(185,190,205,${0.45*alpha})`);
        g.addColorStop(1, `rgba(160,165,185,0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

        const shadowAng = Math.atan2(-ly, -lx);
        ctx.strokeStyle = `rgba(90,100,130,${0.20*alpha})`;
        ctx.lineWidth = Math.max(1, r * 0.12);
        ctx.beginPath();
        ctx.arc(cx, cy, r, shadowAng - 0.9, shadowAng + 0.9);
        ctx.stroke();

        const lightAng = Math.atan2(ly, lx);
        ctx.strokeStyle = `rgba(255,255,255,${0.12*alpha})`;
        ctx.lineWidth = Math.max(1, r * 0.08);
        ctx.beginPath();
        ctx.arc(cx, cy, r, lightAng - 0.9, lightAng + 0.9);
        ctx.stroke();
      }
    }

    /* =======================
       MOON SHAKE HELPERS
    ======================= */
    function moonKick(ix, iy, power = 1) {
      const len = Math.hypot(ix, iy) || 1;
      const ux = ix / len, uy = iy / len;
      mShake.vx += ux * SHAKE_IMPULSE * power;
      mShake.vy += uy * SHAKE_IMPULSE * power;
    }
    function updateMoonShake(dt) {
      mShake.vx += (-SHAKE_STIFFNESS * mShake.ox - SHAKE_DAMPING * mShake.vx) * dt;
      mShake.vy += (-SHAKE_STIFFNESS * mShake.oy - SHAKE_DAMPING * mShake.vy) * dt;
      mShake.ox += mShake.vx * dt;
      mShake.oy += mShake.vy * dt;
      if (Math.abs(mShake.ox) < 0.01) mShake.ox = 0;
      if (Math.abs(mShake.oy) < 0.01) mShake.oy = 0;
    }

    /* =======================
       LEGACY HELPERS (kept)
    ======================= */
    function orbJitter(charge01){
      const t = performance.now()/1000;
      const amp = ORB_SHAKE_MAX * Math.pow(charge01,1.2);
      const ox = Math.sin(t*ORB_SHAKE_FX*2*Math.PI + 0.31) * amp;
      const oy = Math.cos(t*ORB_SHAKE_FY*2*Math.PI + 1.13) * amp * 0.8;
      return [ox, oy];
    }

    /* =======================
       MOON + DESIGNED HALO
    ======================= */
    function drawMoonHaloLayers(){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      let g = ctx.createRadialGradient(moon.x, moon.y, MOON_R*0.8, moon.x, moon.y, MOON_GLOW_R);
      g.addColorStop(0.00, 'rgba(255,244,220,0.22)');
      g.addColorStop(0.45, 'rgba(230,240,255,0.10)');
      g.addColorStop(1.00, 'rgba(190,210,255,0.00)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_GLOW_R, 0, Math.PI*2); ctx.fill();

      const coronaR = MOON_R * 1.35;
      g = ctx.createRadialGradient(moon.x, moon.y, MOON_R*0.95, moon.x, moon.y, coronaR);
      g.addColorStop(0.00, 'rgba(255,248,235,0.42)');
      g.addColorStop(1.00, 'rgba(255,248,235,0.00)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(moon.x, moon.y, coronaR, 0, Math.PI*2); ctx.fill();

      ctx.save();
      ctx.translate(moon.x, moon.y);
      ctx.rotate(-0.12);
      ctx.scale(1.35, 0.85);
      const ellR = MOON_R * 2.4;
      g = ctx.createRadialGradient(0, 0, MOON_R*0.9, 0, 0, ellR);
      g.addColorStop(0.00, 'rgba(255,240,210,0.10)');
      g.addColorStop(1.00, 'rgba(180,200,255,0.00)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(0, 0, ellR, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.strokeStyle = 'rgba(255,255,255,0.16)';
      ctx.lineWidth = Math.max(1, MOON_R * 0.04);
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_R * 1.05, 0, Math.PI*2); ctx.stroke();

      const RAY_COUNT = 6;
      for (let i=0;i<RAY_COUNT;i++){
        const ang = i * (Math.PI / RAY_COUNT);
        ctx.save();
        ctx.translate(moon.x, moon.y);
        ctx.rotate(ang + 0.2);
        const grad = ctx.createLinearGradient(0, 0, MOON_R * 3.2, 0);
        grad.addColorStop(0, 'rgba(255,240,210,0.08)');
        grad.addColorStop(1, 'rgba(255,240,210,0.00)');
        ctx.fillStyle = grad;
        ctx.globalAlpha = 0.22;
        ctx.fillRect(0, -1.5, MOON_R * 3.2, 3);
        ctx.restore();
      }

      ctx.restore();
    }

    function drawMoon(){
      ctx.save();
      ctx.translate(mShake.ox, mShake.oy);
      drawMoonHaloLayers();
      ctx.save();
      ctx.fillStyle = 'rgb(245,245,250)';
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_R, 0, Math.PI*2); ctx.fill();
      ctx.restore();
      drawCraters();
      ctx.restore();
    }

    /* =======================
       BACKGROUND + FX
    ======================= */
    function drawBackground(){
      if (bgImg.complete && bgImg.naturalWidth>0){
        const iw=bgImg.width, ih=bgImg.height;
        const sc=Math.max(W/iw, H/ih);
        ctx.drawImage(bgImg, (W-iw*sc)/2, (H-ih*sc)/2, iw*sc, ih*sc);
      } else {
        ctx.fillStyle="#041017"; ctx.fillRect(0,0,W,H);
      }
    }

    function drawShards(){
      const t=nowS();
      for (let i=shards.length-1; i>=0; i--){
        const s = shards[i];
        const a = Math.max(0, 1 - (t - s.born)/s.life);
        ctx.save(); ctx.globalAlpha = a;
        ctx.translate(s.x, s.y); ctx.rotate(s.ang);
        const img = s.img;
        if (img && img.complete && img.naturalWidth>0) {
          ctx.drawImage(img, -s.w/2, -s.h/2, s.w, s.h);
        }
        ctx.restore();
        if (a<=0) shards.splice(i,1);
      }
    }
    function drawFlash(){
      if (flashLife<=0) return;
      const p = Math.min(1, flashT/flashLife);
      const a = FLASH_MAX_ALPHA*(1-p);
      if (a<=0.01) return;
      ctx.save(); ctx.fillStyle=`rgba(255,255,255,${a})`; ctx.fillRect(0,0,W,H); ctx.restore();
    }
    function drawShockwave(){
      if (shockLife<=0) return;
      const p = Math.min(1, shockT/shockLife);
      const r = SHOCKWAVE_MAX_R*p;
      const a = 0.35*(1-p);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,255,255,${a})`;
      ctx.lineWidth = 6*(1-p);
      ctx.beginPath(); ctx.arc(shockX, shockY, r, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    /* =======================
       CONSTANT-SPEED PATH HELPERS
    ======================= */
    function bezierPoint(p0, p1, p2, t){
      const u = 1 - t;
      const x = u*u*p0.x + 2*u*t*p1.x + t*t*p2.x;
      const y = u*u*p0.y + 2*u*t*p1.y + t*t*p2.y;
      return { x, y };
    }
    function makePathLUT(p0, p1, p2, segments = 260){
      const ts = [], xs = [], ys = [], cum = [];
      let total = 0;
      let prev = bezierPoint(p0, p1, p2, 0);
      ts.push(0); xs.push(prev.x); ys.push(prev.y); cum.push(0);
      for (let i=1;i<=segments;i++){
        const t = i/segments;
        const p = bezierPoint(p0, p1, p2, t);
        total += Math.hypot(p.x - prev.x, p.y - prev.y);
        ts.push(t); xs.push(p.x); ys.push(p.y); cum.push(total);
        prev = p;
      }
      return { ts, xs, ys, cum, total };
    }
    function samplePathByS(lut, s){
      const target = Math.max(0, Math.min(lut.total, s));
      let lo = 0, hi = lut.cum.length - 1;
      while (lo < hi){
        const mid = (lo + hi) >> 1;
        if (lut.cum[mid] < target) lo = mid + 1; else hi = mid;
      }
      if (lo === 0) return { x: lut.xs[0], y: lut.ys[0], t: lut.ts[0] };
      const i = lo, j = lo - 1;
      const c0 = lut.cum[j], c1 = lut.cum[i];
      const ratio = (target - c0) / Math.max(1e-6, (c1 - c0));
      const x = lut.xs[j] + (lut.xs[i] - lut.xs[j]) * ratio;
      const y = lut.ys[j] + (lut.ys[i] - lut.ys[j]) * ratio;
      const t = lut.ts[j] + (lut.ts[i] - lut.ts[j]) * ratio;
      return { x, y, t };
    }

    /* =======================
       ENERGY SPHERE RENDERER (no border)
    ======================= */
    const inflow = []; // {x,y,vx,vy,life}
    function rgbStr(c, a=1){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

    function drawEnergySphere(cx, cy, r, charge=0, vel=null){
      ctx.save();

      if (vel){
        const vlen = Math.hypot(vel.vx, vel.vy);
        const stretch = clamp(1 + Math.min(0.35, vlen/900), 1, 1.35);
        const ang = Math.atan2(vel.vy, vel.vx);
        ctx.translate(cx, cy);
        ctx.rotate(ang);
        ctx.scale(stretch, 1/stretch);
        cx = 0; cy = 0;
      }

      // 1) Opaque body shading
      ctx.globalCompositeOperation = 'source-over';
      const lightOffset = 0.35 * r;
      const gx = cx - LIGHT_DIR.x * lightOffset;
      const gy = cy - LIGHT_DIR.y * lightOffset;
      let g = ctx.createRadialGradient(gx, gy, r*0.05, cx, cy, r*1.02);
      g.addColorStop(0.00, rgbStr(CORE_COLOR, 0.98));
      g.addColorStop(0.35, rgbStr(MID_COLOR, 0.98));
      g.addColorStop(1.00, rgbStr(EDGE_COLOR, 0.98));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

      // 2) Rim occlusion
      const ao = ctx.createRadialGradient(cx, cy, r*0.70, cx, cy, r*1.02);
      ao.addColorStop(0.0, 'rgba(0,0,0,0)');
      ao.addColorStop(1.0, 'rgba(0,0,0,0.16)');
      ctx.fillStyle = ao;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

      // 3) Specular
      ctx.globalCompositeOperation = 'lighter';
      const hx = cx - LIGHT_DIR.x * r*0.35;
      const hy = cy - LIGHT_DIR.y * r*0.35;
      const spec = ctx.createRadialGradient(hx, hy, 0, hx, hy, r*0.45);
      spec.addColorStop(0.00, 'rgba(255,255,255,0.65)');
      spec.addColorStop(1.00, 'rgba(255,255,255,0)');
      ctx.fillStyle = spec;
      ctx.beginPath(); ctx.arc(hx, hy, r*0.48, 0, Math.PI*2); ctx.fill();

      // 4) Hot core glow
      const coreR = r * (0.40 + 0.10*charge);
      const core = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
      core.addColorStop(0.00, 'rgba(255,255,255,0.90)');
      core.addColorStop(1.00, `rgba(${BALL_RGB},0.00)`);
      ctx.fillStyle = core;
      ctx.beginPath(); ctx.arc(cx, cy, coreR, 0, Math.PI*2); ctx.fill();

      // 5) Outer aura
      const auraR = r * (1.25 + 0.10*charge);
      const aura = ctx.createRadialGradient(cx, cy, r*0.9, cx, cy, auraR);
      aura.addColorStop(0.00, rgbStr(AURA_COLOR, 0.22 + 0.18*charge));
      aura.addColorStop(1.00, 'rgba(120,220,255,0)');
      ctx.fillStyle = aura;
      ctx.beginPath(); ctx.arc(cx, cy, auraR, 0, Math.PI*2); ctx.fill();

      // 6) Pressure rings (no border)
      const t = performance.now()/1000;
      for (let i=0;i<RING_COUNT;i++){
        const k = (i+1)/(RING_COUNT+1);
        const pr = r*(1.05 + 0.25*k + 0.03*Math.sin(2*Math.PI*(RING_PULSE_HZ*t + i*0.17)));
        ctx.globalAlpha = (RING_ALPHA*(0.6 + 0.4*charge));
        ctx.beginPath(); ctx.arc(cx, cy, pr, 0, Math.PI*2); ctx.strokeStyle = rgbStr(AURA_COLOR, 1);
        ctx.lineWidth = Math.max(1, r*0.02*(1-k));
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    /* =======================
       POINTER DRAW (uses expanded hover zone)
    ======================= */
    function drawPointer(){
      if (!pointer.inside) return;
      const ready = pointerImg && pointerImg.complete && pointerImg.naturalWidth > 0;

      const t = performance.now()/1000;
      const breathe = 1 + POINTER_BREATH * Math.sin(t*2*Math.PI*0.8);
      const charge  = (orb && !launching) ? orb.charge : 0;
      const scale   = breathe * (1 + POINTER_CHARGE_SCALE * charge);

      // final side length, clamped to max
      const size = Math.min(POINTER_PX_MAX, POINTER_BASE_PX * scale);
      const w = size, h = size;

      // mild pull toward the orb over expanded hover zone
      let x = pointer.x, y = pointer.y;
      if (orb && !launching){
        const dx = orb.cx - x, dy = orb.cy - y;
        const d  = Math.hypot(dx,dy) || 1;
        const r  = radiusFromCharge(orb);
        const exR = r * HOVER_RADIUS_MULT + HOVER_PAD_PX;

        const near = 1 - Math.min(1, d / exR); // 0..1 inside expanded zone
        const pull = 6 * (0.35 + 0.65*near) * (charge || 0); // up to ~6px
        x += (dx/d)*pull; y += (dy/d)*pull;
      }

      // glow scales with size
      const glowR = size * 0.8;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(x, y, 0, x, y, glowR);
      g.addColorStop(0, `rgba(255,255,255,${0.22 + 0.28*charge})`);
      g.addColorStop(1, 'rgba(120,220,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x, y, glowR, 0, Math.PI*2); ctx.fill();

      ctx.globalCompositeOperation = 'source-over';
      if (ready){
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(pointerImg, x - w/2, y - h/2, w, h);
      } else {
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(x, y, Math.max(2, size*0.08), 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    /* =======================
       UPDATE (expanded hover zone + rate falloff)
    ======================= */
    let started=false, lastT=performance.now(), lastDt=0;

    function maybeCharge(dt){
      if (!orb || launching) return;

      const r   = radiusFromCharge(orb);
      const exR = r * HOVER_RADIUS_MULT + HOVER_PAD_PX;

      const dx = pointer.x - orb.cx, dy = pointer.y - orb.cy;
      const dist = Math.hypot(dx, dy);

      const inside = pointer.inside && dist <= exR;   // expanded hover area

      if (inside){
        if (!orb.inZone){ orb.inZone = true; orb.enterMs = performance.now(); }
        const ok = (performance.now() - orb.enterMs) >= ENTRY_GRACE_MS;
        if (ok){
          // prox = 1 at center/ball, 0 at expanded edge
          const prox = 1 - Math.min(1, Math.max(0, (dist - r) / Math.max(1, exR - r)));
          const rateScale = CHARGE_EDGE_FALLOFF + (1 - CHARGE_EDGE_FALLOFF) * prox;

          orb.charge = Math.min(1, orb.charge + dt * (1000 / DWELL_MS) * rateScale);

          if (orb.charge >= 1 && !launching){
            launching = true;
            cutHumPunch();
            play(sfxRelease);
            orb.launching = true;
            orb.launchT0 = performance.now();
            orb.startR  = radiusFromCharge(orb);
            orb.trail.length = 0;

            const p0   = { x:orb.cx, y:orb.cy };
            const ctrl = { x:orb.cx + (moon.x - orb.cx)*0.35, y: Math.min(orb.cy, moon.y) - H*BEZIER_PEAK };
            const p1   = { x:moon.x, y:moon.y };
            orb.path = makePathLUT(p0, ctrl, p1, 260);
            orb.s = 0;
          }
        }
      } else {
        orb.inZone = false;
        if (!launching) orb.charge = Math.max(0, orb.charge - DECAY_PER_SEC*dt);
      }
    }

    function update(dt){
      if (!orb && !launching && respawnAtMs && performance.now() >= respawnAtMs){
        respawnAtMs = 0;
        spawnOrb();
      } else if (!orb && !launching && !respawnAtMs){
        spawnOrb();
      }

      maybeCharge(dt);

      // inflow while charging
      if (orb && !launching){
        const r = radiusFromCharge(orb);
        const want = Math.min(INFLOW_MAX, inflow.length + INFLOW_RATE*dt*clamp(orb.charge*1.2, 0.2, 1.0));
        while (inflow.length < want){
          const ang = Math.random()*Math.PI*2;
          const useInner = Math.random() < 0.6;
          const bandMin = useInner ? INFLOW_INNER_MIN : INFLOW_OUTER_MIN;
          const bandMax = useInner ? INFLOW_INNER_MAX : INFLOW_OUTER_MAX;
          const rrMul = rand(bandMin, bandMax);
          const rr  = r * rrMul;
          const x = orb.cx + Math.cos(ang)*rr;
          const y = orb.cy + Math.sin(ang)*rr;

          const toCdx = orb.cx - x, toCdy = orb.cy - y;
          const d = Math.hypot(toCdx, toCdy) || 1;
          const sp = (useInner ? 220 : 160) + Math.random()*200;
          const jitterA = (Math.random()-0.5)*0.25;
          const cosJ = Math.cos(jitterA), sinJ = Math.sin(jitterA);
          const ux = toCdx/d, uy = toCdy/d;
          const jx = ux*cosJ - uy*sinJ, jy = ux*sinJ + uy*cosJ;

          inflow.push({ x, y, vx:jx*sp, vy:jy*sp, life: 0.35 + Math.random()*0.45 });
        }
      }

      updateHum(orb && !launching ? orb.charge : 0);

      if (launching && orb && orb.path){
        orb.s += LAUNCH_SPEED_PX * dt;
        const done = orb.s >= orb.path.total - 0.5;
        const P = samplePathByS(orb.path, orb.s);

        const u = Math.min(1, orb.s / Math.max(1e-6, orb.path.total));
        const r = orb.startR + (END_RADIUS - orb.startR) * u;

        orb.trail.push({ x:P.x, y:P.y, r, a:1 });
        if (orb.trail.length>18) orb.trail.shift();
        for (const tr of orb.trail) tr.a *= 0.9;

        orb.cx = P.x; orb.cy = P.y; orb.renderR = r;

        if (done){
          let ix = 0, iy = -1;
          if (orb.trail.length >= 2) {
            const a = orb.trail[orb.trail.length - 1];
            const b = orb.trail[orb.trail.length - 2];
            ix = a.x - b.x; iy = a.y - b.y;
          }

          const len = Math.hypot(ix, iy) || 1;
          const ux = ix/len, uy = iy/len;
          mShake.ox += ux * 12;
          mShake.oy += uy * 12;
          moonKick(ix, iy, 1.6);

          addCraterFromImpact();
          burstAt(moon.x, moon.y);
          flash(); shock(moon.x, moon.y);
          playImpact();

          // ===== INCREMENT HUD COUNTER HERE =====
          launchCount++;

          launching = false;
          orb = null;
          respawnAtMs = performance.now() + RESPAWN_DELAY_MS;
        }
      }

      if (flashLife>0){ flashT += dt; if (flashT>=flashLife) flashLife=0; }
      if (shockLife>0){ shockT += dt; if (shockT>=shockLife) shockLife=0; }

      const t = nowS();
      for (let i=shards.length-1;i>=0;i--){
        const s=shards[i];
        s.x += s.vx*dt; s.y += s.vy*dt; s.vy += 360*dt; s.ang += s.rot*dt;
        if (t - s.born > s.life) shards.splice(i,1);
      }

      updateMoonShake(dt);
    }

    /* =======================
       HUD (Moon icon + launch count)
    ======================= */
    let launchCount = 0;
    function drawHUD(){
      const pad = Math.max(10, Math.min(24, Math.floor((W + H) * 0.012)));
      const iconSize = Math.max(22, Math.min(40, Math.floor((W + H) * 0.02)));
      const textSize = Math.max(18, Math.min(30, Math.floor((W + H) * 0.018)));

      const xRight = W - pad;
      const yTop = pad;

      ctx.save();
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.font = `700 ${textSize}px ui-rounded, ui-sans-serif, system-ui, Segoe UI, Roboto, Arial`;
      ctx.fillStyle = '#6ad1c9';
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 2;

      // Number
      const text = `${launchCount}`;
      ctx.fillText(text, xRight, yTop + iconSize/2);

      // Icon to the left of the number
      if (moonIcon.complete && moonIcon.naturalWidth > 0) {
        const textW = ctx.measureText(text).width;
        const iconX = xRight - textW - 10 - iconSize;
        const iconY = yTop;
        ctx.shadowColor = 'rgba(0,0,0,0.18)';
        ctx.drawImage(moonIcon, iconX, iconY, iconSize, iconSize);
      }
      ctx.restore();
    }

    /* =======================
       RENDER
    ======================= */
    function drawInflow(){
      for (let i=inflow.length-1; i>=0; i--){
        const p = inflow[i];
        p.life -= lastDt;
        p.x += p.vx*lastDt; p.y += p.vy*lastDt;
        if (p.life <= 0){ inflow.splice(i,1); }
      }
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const p of inflow){
        const a = INFLOW_ALPHA * Math.max(0, Math.min(1, p.life/0.5));
        if (a <= 0.01) continue;
        ctx.globalAlpha = a;
        ctx.beginPath(); ctx.arc(p.x, p.y, 1.6, 0, Math.PI*2);
        ctx.fillStyle = 'white'; ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawOrb(){
      if (!orb) return;
      if (!launching){
        const r = radiusFromCharge(orb);
        const [ox, oy] = orbJitter(orb.charge);
        const cx = orb.cx + ox, cy = orb.cy + oy;
        drawEnergySphere(cx, cy, r, orb.charge, null);
      } else {
        ctx.save();
        ctx.globalCompositeOperation='source-over';
        for (const tr of orb.trail){
          if (tr.a<=0.02) continue;
          ctx.globalAlpha = 0.10 * tr.a;
          drawEnergySphere(tr.x, tr.y, tr.r*0.9, 1, null);
        }
        ctx.restore(); ctx.globalAlpha=1;

        const v = (orb.trail.length>=2)
          ? { vx: orb.trail.at(-1).x - orb.trail.at(-2).x,
              vy: orb.trail.at(-1).y - orb.trail.at(-2).y }
          : null;
        drawEnergySphere(orb.cx, orb.cy, orb.renderR||END_RADIUS, 1, v);
      }
    }

    function render(){
      drawBackground();
      drawMoon();
      drawInflow();
      drawOrb();        // draw the ball first
      drawPointer();    // then pointer on top of the ball
      drawShards();
      drawShockwave();
      drawFlash();
      drawHUD();        // HUD above everything
    }

    function tick(tMs){
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT)/1000);
      lastT = tMs;
      lastDt = dt;
      update(dt);
      render();
      requestAnimationFrame(tick);
    }

    /* =======================
       START
    ======================= */
    const startOverlay=document.getElementById('startOverlay');
    const startBtn=document.getElementById('startBtn');

    async function enterFullscreen(){
      const el=document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    }

    startBtn.addEventListener('click', async ()=>{
      try{ await enterFullscreen(); }catch(e){}
      startOverlay.style.display='none';
      started = true;

      // ensure images then start
      let pending = 0;
      const tryStart = ()=>{ if (--pending<=0) requestAnimationFrame(tick); };

      // background
      if (!bgImg.complete){ pending++; bgImg.onload = tryStart; }

      // pointer
      if (!pointerImg.complete){ pending++; pointerImg.onload = tryStart; }

      // rocks
      rockImgs.forEach(im => { if (!im.complete){ pending++; im.onload = tryStart; }});

      // moon icon
      if (!moonIcon.complete){ pending++; moonIcon.onload = tryStart; }

      if (pending===0) requestAnimationFrame(tick);

      // audio on gesture
      try { setupAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      resize();
    });
  })();
  </script>
</body>
</html>
  </template>

  <template id="tpl-lamp">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sky Lanterns — Dual Lamps + Scattered + Colored Fireflies + BG Lanterns + Shooting Star + Ropes</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { display: flex; }
    #layout { display: flex; width: 100vw; height: 100vh; background: #000; overflow: hidden; }
    #modePanel {
      width: 20vw; min-width: 180px; max-width: 320px; background: #050505;
      border-right: 1px solid rgba(255,255,255,0.04); box-shadow: 10px 0 26px rgba(0,0,0,0.55);
      display: flex; align-items: center; justify-content: center;
      padding: clamp(32px, 5vh, 72px) clamp(16px, 1.8vw, 32px); position: relative; z-index: 12;
    }
    #modePanel .panel-ornaments { position: absolute; inset: 0; pointer-events: none; }
    #modePanel .panel-ornaments img { position: absolute; width: clamp(110px, 14vw, 160px); opacity: 0.18; filter: blur(0.2px) drop-shadow(0 6px 10px rgba(0,0,0,0.55)); }
    #modePanel .panel-ornaments .branch-corner { bottom: clamp(18px, 6vh, 32px); left: clamp(12px, 2vw, 28px); transform: rotate(-12deg); }

    #playArea { flex: 1; position: relative; height: 100vh; background: #000; overflow: hidden; z-index: 20; }
    #game { display: block; width: 100%; height: 100%; background: #000; position: relative; }

    #startOverlay { position: absolute; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.75); z-index: 30; }
    #startBtn {
      padding: 14px 22px; border: 2px solid #d4a100; color: #d4a100; background: #000;
      border-radius: 12px; font-size: 18px; font-weight: 700; box-shadow: 0 6px 24px rgba(0,0,0,0.25); cursor: pointer;
    }
    #startBtn:active { transform: translateY(1px); }

    #modeSelector {
      display: flex; flex-direction: column; gap: clamp(24px, 5vh, 48px); width: 100%; align-items: center;
      pointer-events: none; color: #f8eacb; font-size: 16px; text-transform: uppercase; letter-spacing: 0.08em;
    }
    .mode-tile {
      position: relative; width: clamp(120px, 16vw, 220px); aspect-ratio: 1; border-radius: 24px;
      background: rgba(18,18,22,0.92); border: 1px solid rgba(255,255,255,0.08);
      display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto;
      transition: transform 0.22s ease, border-color 0.22s ease, box-shadow 0.22s ease; box-shadow: 0 12px 26px rgba(0,0,0,0.5);
    }
    .mode-tile img { width: 68%; height: 68%; object-fit: contain; filter: drop-shadow(0 6px 10px rgba(0,0,0,0.55)); pointer-events: none; user-select: none; }
    .mode-tile .label {
      position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%);
      font-size: 13px; letter-spacing: 0.12em; color: rgba(255,240,200,0.75); text-shadow: 0 2px 6px rgba(0,0,0,0.6); pointer-events: none;
    }
    .mode-tile.active { border-color: rgba(255,210,120,0.5); box-shadow: 0 16px 36px rgba(255,180,60,0.24); }
    .mode-tile.hovering { transform: translateY(-6px); border-color: rgba(255,120,120,0.65); }
    .mode-tile .progress {
      position: absolute; top: 50%; left: 50%; width: 0; height: 0; opacity: 0; transform: translate(-50%, -50%);
      border-radius: 20px; pointer-events: none; background: rgba(220,20,20,0.55);
      transition: width 0.08s linear, height 0.08s linear, opacity 0.12s ease;
    }
    .mode-tile.hovering .progress { opacity: 0.75; }
  </style>
</head>
<body>
  <div id="layout">
    <aside id="modePanel">
      <div class="panel-ornaments" aria-hidden="true">
        <img src="../../images/samurai/cherryblossom.png" alt="" class="branch-corner" />
      </div>
      <div id="modeSelector" role="group" aria-label="Interaction mode">
        <div class="mode-tile active" data-mode="chi" aria-pressed="true" role="button">
          <img src="../../images/samurai/transparentchi.png" alt="Chi mode" />
          <div class="progress"></div>
          <span class="label">Chi</span>
        </div>
        <div class="mode-tile" data-mode="katana" aria-pressed="false" role="button">
          <img src="../../images/samurai/katana.png" alt="Katana mode" />
          <div class="progress"></div>
          <span class="label">Katana</span>
        </div>
      </div>
    </aside>
    <div id="playArea">
      <div id="startOverlay">
        <button id="startBtn">Start • Fullscreen</button>
      </div>
      <canvas id="game"></canvas>
    </div>
  </div>

  <script>
  (() => {
    /* =======================
       TUNABLES
    ======================= */
    const BG_SRC      = "../../images/samurai/lampbg.png";

    // Two lamp variants
    const CLOSED1_SRC = "../../images/samurai/closedlamp1.png";
    const LIT1_SRC    = "../../images/samurai/litlamp1.png";
    const CLOSED2_SRC = "../../images/samurai/closedlamp2.png";
    const LIT2_SRC    = "../../images/samurai/litlamp2.png";

    const LANTERN_COUNT   = 5;
    const LAMP_H_MIN      = 180;
    const LAMP_H_MAX      = 300;
    const HOVER_RADIUS    = 60;

    const ASCEND_SPEED_MIN = 60;
    const ASCEND_SPEED_MAX = 100;
    const DRIFT_X_MIN      = 20;
    const DRIFT_X_MAX      = 30;
    const SWAY_FREQ_MIN    = 0.6;
    const SWAY_FREQ_MAX    = 1.2;
    const SWAY_AMP_MIN     = 12;
    const SWAY_AMP_MAX     = 28;

    // Scattering along bottom — raised baseline (rope stop)
    const SIDE_PAD_H   = 24;
    const BOTTOM_PAD_V = 140;  // rope-limited rest height
    const SEP_EXTRA    = 40;

    // Stars
    const STAR_DENSITY_PER_MPX = 55;
    const STAR_MIN_SIZE = 0.8, STAR_MAX_SIZE = 2.0;
    const STAR_MIN_AMP  = 0.25, STAR_MAX_AMP = 0.55;
    const STAR_MIN_FREQ = 0.30, STAR_MAX_FREQ = 0.95; // Hz
    const STAR_BASE_MIN = 0.06, STAR_BASE_MAX = 0.14;
    const STAR_HALO_CORE = 0.35;
    const STAR_HALO_RING = 0.10;

    // Fireflies (soft, colored)
    const FIREFLY_COUNT = 22;
    const FIREFLY_Y_MIN_FRAC = 0.68, FIREFLY_Y_MAX_FRAC = 0.92;
    const FIREFLY_SPEED = 12;
    const FIREFLY_PULSE_MIN = 0.6, FIREFLY_PULSE_MAX = 1.2;
    const FIREFLY_SIZE_MIN = 1.8, FIREFLY_SIZE_MAX = 3.2;
    const FIREFLY_COLORS = [
      { core: '255,230,140', halo: '255,230,140' },
      { core: '185,255,185', halo: '185,255,185' },
      { core: '255,185,185', halo: '255,185,185' },
      { core: '185,220,255', halo: '185,220,255' },
    ];

    // Idle motion
    const IDLE_BOB_AMP_CLOSED = 2.2;
    const IDLE_BOB_AMP_LIT    = 3.6;
    const IDLE_BOB_FREQ_MIN   = 0.2;
    const IDLE_BOB_FREQ_MAX   = 0.35;
    const IDLE_ROT_AMP        = 0.015;

    // Constant lamp glow
    const GLOW_BASE_ALPHA = 0.22;
    const GLOW_RADIUS_MULT = 1.25;

    const HOVER_COOLDOWN_MS = 250;

    // Distant background lanterns
    const BG_LANTERN_COUNT = 10;
    const BG_LANTERN_SIZE_MIN = 14, BG_LANTERN_SIZE_MAX = 26; // px
    const BG_LANTERN_SPEED_MIN = 10, BG_LANTERN_SPEED_MAX = 22; // px/s
    const BG_LANTERN_HALO_ALPHA = 0.10;
    const BG_LANTERN_CORE_ALPHA = 0.20;

    // Shooting star
    const SHOOTING_STAR_MIN_INTERVAL = 18; // seconds
    const SHOOTING_STAR_MAX_INTERVAL = 45;
    const SHOOTING_STAR_SPEED_MIN = 600, SHOOTING_STAR_SPEED_MAX = 900; // px/s
    const SHOOTING_STAR_LEN_MIN = 120, SHOOTING_STAR_LEN_MAX = 200; // px
    const SHOOTING_STAR_LIFE = 1.2; // seconds

    // === ROPE (tethers) ===
    const ROPE_COLOR_RGB = '210,180,140';
    const ROPE_ALPHA     = 0.85;
    const ROPE_WIDTH     = 4.0;    // thicker rope
    const ROPE_SAG_MAX   = 120;
    const ROPE_SAG_RATIO = 0.36;
    const ROPE_SNAP_LIFE = 0.6;
    const ROPE_ATTACH_FROM_BOTTOM_FRAC = 0.10;
    const ROPE_ANCHOR_BOTTOM_OFFSET    = 0;

    // Katana must hit rope
    const ROPE_HIT_RADIUS = 12; // px distance from rope to register a cut

    // Dwell + audio
    const LAMP_DWELL_MS = 1000;  // hover to light (Chi)
    const LIFT_DURATION = 2.0;   // seconds to rise to rope-limited position

    const MODE_DWELL_MS = 500;

    const KATANA_CURSOR_SRC = "../../images/samurai/katana.png";
    const KATANA_CURSOR_MAX_PX = 124;
    const KATANA_CURSOR_HOTSPOT = { x: 12, y: 28 };
    const KATANA_MOVE_THRESHOLD = 2;

    const POINTER_EDGE_GRACE = 22;

    // ▼ UPDATED: use the exact same Chi image as the tile
    const CHI_POINTER_SRC = "../../images/samurai/transparentchi.png";
    const CHI_POINTER_BASE = 96;
    const CHI_POINTER_MAX = 118;
    const CHI_POINTER_BREATH = 0.05;
    const CHI_POINTER_BREATH_FREQ = 0.8;

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const initialRect = canvas.getBoundingClientRect();
    let W = canvas.width  = initialRect.width  || window.innerWidth;
    let H = canvas.height = initialRect.height || window.innerHeight;

    function resize() {
      const rect = canvas.getBoundingClientRect();
      const displayW = rect.width  || W;
      const displayH = rect.height || H;
      W = canvas.width  = displayW;
      H = canvas.height = displayH;
      rebuildStars();
      rebuildFireflies();
      rebuildBgLanterns();
      // keep rope anchors at bottom & inside margins and recompute rest/ground positions
      for (const l of lanterns) {
        if (!l.anchor) continue;
        l.anchor.y = H - ROPE_ANCHOR_BOTTOM_OFFSET;
        l.anchor.x = Math.max(SIDE_PAD_H, Math.min(W - SIDE_PAD_H, l.anchor.x));
        l.restY  = H - BOTTOM_PAD_V - l.h * 0.5;
        l.groundY = H - l.h * 0.5 + 2;
        if (l.state === 'closed') l.y = l.groundY; // keep closed lamps at ground after resize
      }
    }
    window.addEventListener('resize', resize);

    const bgImg  = new Image(); bgImg.src  = BG_SRC;

    const imgClosed1 = new Image(); imgClosed1.src = CLOSED1_SRC;
    const imgLit1    = new Image(); imgLit1.src    = LIT1_SRC;
    const imgClosed2 = new Image(); imgClosed2.src = CLOSED2_SRC;
    const imgLit2    = new Image(); imgLit2.src    = LIT2_SRC;

    function getClosedImg(type){ return type===1 ? imgClosed1 : imgClosed2; }
    function getLitImg(type){    return type===1 ? imgLit1    : imgLit2; }

    const modeSelector = document.getElementById('modeSelector');
    const modeTileNodes = Array.from(modeSelector.querySelectorAll('.mode-tile'));
    const modeTiles = modeTileNodes.map(el => ({
      el,
      mode: el.dataset.mode,
      progressEl: el.querySelector('.progress'),
      dwellStart: 0
    }));
    let hoveredTile = null;
    let currentMode = 'chi';

    function refreshModeTiles() {
      for (const tile of modeTiles) {
        const active = tile.mode === currentMode;
        tile.el.classList.toggle('active', active);
        tile.el.setAttribute('aria-pressed', active ? 'true' : 'false');
      }
    }

    const pointer = { x: -9999, y: -9999, inside: false, prevX: -9999 };
    let cursorOrient = 'left';

    function applyCurrentCursor() { canvas.style.cursor = 'none'; }

    function updatePointerFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const displayW = rect.width || 1;
      const displayH = rect.height || 1;
      const scaleX = displayW ? W / displayW : 1;
      const scaleY = displayH ? H / displayH : 1;
      const relX = e.clientX - rect.left;
      const relY = e.clientY - rect.top;

      const clampedX = Math.max(0, Math.min(displayW, relX));
      const clampedY = Math.max(0, Math.min(displayH, relY));
      pointer.x = clampedX * scaleX;
      pointer.y = clampedY * scaleY;

      const insideNow =
        relX >= -POINTER_EDGE_GRACE && relX <= displayW + POINTER_EDGE_GRACE &&
        relY >= -POINTER_EDGE_GRACE && relY <= displayH + POINTER_EDGE_GRACE;

      if (currentMode === 'katana' && pointer.prevX !== -9999 && insideNow) {
        const dx = pointer.x - pointer.prevX;
        if (Math.abs(dx) > KATANA_MOVE_THRESHOLD) {
          const wantOrient = dx > 0 ? 'right' : 'left';
          if (wantOrient !== cursorOrient) {
            cursorOrient = wantOrient;
            applyCurrentCursor();
          }
        }
      }

      pointer.prevX = insideNow ? pointer.x : -9999;
      pointer.inside = insideNow;
    }
    window.addEventListener('pointermove', updatePointerFromEvent, { passive: true });

    function setTileProgress(tile, progress) {
      if (!tile.progressEl) return;
      const clamped = Math.max(0, Math.min(1, progress));
      const pct = (clamped * 100).toFixed(1) + '%';
      if (clamped <= 0) {
        tile.progressEl.style.width = '0%';
        tile.progressEl.style.height = '0%';
        tile.progressEl.style.opacity = '';
        return;
      }
      tile.progressEl.style.width = pct;
      tile.progressEl.style.height = pct;
    }

    function clearTileProgress(tile) {
      tile.dwellStart = 0;
      tile.el.classList.remove('hovering');
      if (tile.progressEl) {
        tile.progressEl.style.width = '0%';
        tile.progressEl.style.height = '0%';
        tile.progressEl.style.opacity = '';
      }
    }

    /* ========= Mode switch + slice SFX ========= */
    const KATANA_DRAW_SRC  = "../../sounds/katana.mp3";
    const CHI_SELECT_SRC   = "../../sounds/samurai/energyball.mp3";
    const KATANA_SLICE_SRC = "../../sounds/blade.mp3"; // <-- NEW: rope cut slice

    const sfxKatanaDraw  = new Audio(KATANA_DRAW_SRC);  sfxKatanaDraw.volume  = 0.9; sfxKatanaDraw.preload  = "auto";
    const sfxChiSelect   = new Audio(CHI_SELECT_SRC);   sfxChiSelect.volume   = 0.7; sfxChiSelect.preload   = "auto";
    const sfxKatanaSlice = new Audio(KATANA_SLICE_SRC); sfxKatanaSlice.volume = 0.9; sfxKatanaSlice.preload = "auto";

    function playSfx(a){ try{ const n=a.cloneNode(true); n.volume=a.volume; n.play().catch(()=>{});}catch(_){} }
    /* ========================================== */

    function setMode(mode) {
      if (mode === currentMode) { applyCurrentCursor(); return; }
      currentMode = mode;

      // Play the requested sounds on mode change
      if (mode === 'katana') playSfx(sfxKatanaDraw);
      else if (mode === 'chi') playSfx(sfxChiSelect);

      refreshModeTiles();
      applyCurrentCursor();
    }

    function updateModeHover() {
      if (!hoveredTile) return;
      const tile = hoveredTile;
      if (!tile.dwellStart) tile.dwellStart = performance.now();
      const elapsed = performance.now() - tile.dwellStart;
      const progress = Math.min(1, elapsed / MODE_DWELL_MS);
      setTileProgress(tile, progress);
      if (progress >= 1) {
        clearTileProgress(tile);
        hoveredTile = null;
        setMode(tile.mode);
      }
    }

    for (const tile of modeTiles) {
      tile.el.addEventListener('pointerenter', () => {
        if (hoveredTile && hoveredTile !== tile) clearTileProgress(hoveredTile);
        hoveredTile = tile;
        tile.dwellStart = performance.now();
        tile.el.classList.add('hovering');
        setTileProgress(tile, 0.02);
      });
      tile.el.addEventListener('pointerleave', () => {
        if (hoveredTile === tile) hoveredTile = null;
        clearTileProgress(tile);
      });
    }

    const katanaCursor = { left: null, right: null };
    let katanaCursorReady = false;
    const katanaCursorImg = new Image();
    katanaCursorImg.src = KATANA_CURSOR_SRC;
    katanaCursorImg.onload = () => {
      const iw = katanaCursorImg.width;
      const ih = katanaCursorImg.height;
      if (!iw || !ih) return;
      const scale = Math.min(1, KATANA_CURSOR_MAX_PX / Math.max(iw, ih));
      const dw = Math.round(iw * scale);
      const dh = Math.round(ih * scale);

      const makeCanvas = flipX => {
        const c = document.createElement('canvas');
        c.width = dw; c.height = dh;
        const cctx = c.getContext('2d');
        cctx.imageSmoothingEnabled = true;
        if (flipX) { cctx.translate(dw, 0); cctx.scale(-1, 1); }
        cctx.drawImage(katanaCursorImg, 0, 0, dw, dh);
        return c;
      };

      const hx = Math.max(0, Math.min(dw - 1, Math.round(KATANA_CURSOR_HOTSPOT.x * scale)));
      const hy = Math.max(0, Math.min(dh - 1, Math.round(KATANA_CURSOR_HOTSPOT.y * scale)));

      katanaCursor.left = { canvas: makeCanvas(false), hx, hy };
      katanaCursor.right = { canvas: makeCanvas(true), hx: (dw - 1) - hx, hy };
      katanaCursorReady = true;
      if (currentMode === 'katana') applyCurrentCursor();
    };

    const chiPointerImg = new Image();
    chiPointerImg.src = CHI_POINTER_SRC;

    refreshModeTiles();
    applyCurrentCursor();

    const rand = (a, b) => a + Math.random() * (b - a);
    const clamp01 = v => Math.max(0, Math.min(1, v));
    const nowMs = () => performance.now();
    const nowSec = () => performance.now()/1000;

    /* =======================
       AUDIO (lamp lit)
    ======================= */
    const lampLitSounds = [1,2,3].map(i => {
      const a = new Audio(`../../sounds/samurai/lamplit${i}.mp3`);
      a.preload = 'auto';
      a.volume = 0.8;
      return a;
    });
    function playRandomLampLit() {
      const base = lampLitSounds[Math.floor(Math.random() * lampLitSounds.length)];
      if (!base) return;
      const a = base.cloneNode(true);
      a.volume = base.volume;
      a.play().catch(() => {});
    }

    /* =======================
       LANTERNS (foreground)
    ======================= */
    const lanterns = [];

    function chooseScatteredX(w) {
      const minX = SIDE_PAD_H + w * 0.5;
      const maxX = W - SIDE_PAD_H - w * 0.5;
      const tries = 24;
      for (let t = 0; t < tries; t++) {
        const x = rand(minX, maxX);
        let ok = true;
        for (const l of lanterns) {
          const minSep = (w + l.w) * 0.5 + SEP_EXTRA;
          if (Math.abs(x - l.x) < minSep) { ok = false; break; }
        }
        if (ok) return x;
      }
      return rand(minX, maxX);
    }

    function spawnLanternBottom() {
      const type = Math.random() < 0.5 ? 1 : 2;
      const closedImg = getClosedImg(type);

      const dispH = rand(LAMP_H_MIN, LAMP_H_MAX);
      const iw = closedImg.naturalWidth  || 1;
      const ih = closedImg.naturalHeight || 1;
      const aspect = iw / ih;
      const dispW = dispH * aspect;

      const x = chooseScatteredX(dispW);

      // Rest (rope-limited) position and ground position
      const restY   = H - BOTTOM_PAD_V - dispH * 0.5; // where the rope stops it
      const groundY = H - dispH * 0.5 + 2;           // at the floor

      const born = nowMs();

      lanterns.push({
        type, x, y: groundY, w: dispW, h: dispH,
        state: "closed",
        lastHover: 0,
        ascendVy: rand(ASCEND_SPEED_MIN, ASCEND_SPEED_MAX),
        driftBase: Math.random() < 0.5 ? -1 : 1,
        driftSpeed: rand(DRIFT_X_MIN, DRIFT_X_MAX),
        swayFreq: rand(SWAY_FREQ_MIN, SWAY_FREQ_MAX),
        swayAmp: rand(SWAY_AMP_MIN, SWAY_AMP_MAX),
        bobFreq: rand(IDLE_BOB_FREQ_MIN, IDLE_BOB_FREQ_MAX),
        bobPhase: Math.random() * Math.PI * 2,
        born,
        dwellStartChi: 0,
        anchor: { x: x + rand(-30,30), y: H - ROPE_ANCHOR_BOTTOM_OFFSET },
        snap: null,
        _ropeHovered: false,

        // lift animation data
        restY, groundY, liftT0: 0, liftDur: LIFT_DURATION
      });
    }

    function ensureCount() { while (lanterns.length < LANTERN_COUNT) spawnLanternBottom(); }
    function resetOne(i) { lanterns.splice(i, 1); ensureCount(); }

    function isHovering(l) {
      const dx = pointer.x - l.x;
      const dy = pointer.y - l.y;
      return (dx*dx + dy*dy) <= (HOVER_RADIUS * HOVER_RADIUS);
    }

    /* ---------- Rope math helpers ---------- */
    function quadBezierPoint(p0, p1, p2, t) {
      const it = 1 - t;
      return { x: it*it*p0.x + 2*it*t*p1.x + t*t*p2.x, y: it*it*p0.y + 2*it*t*p1.y + t*t*p2.y };
    }
    function pointSegDist(px, py, ax, ay, bx, by) {
      const vx = bx - ax, vy = by - ay;
      const wx = px - ax, wy = py - ay;
      const c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.hypot(px - ax, py - ay);
      const c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.hypot(px - bx, py - by);
      const t = c1 / c2;
      const ix = ax + t*vx, iy = ay + t*vy;
      return Math.hypot(px - ix, py - iy);
    }
    function ropePoints(l, t) {
      const p0 = { x: l.anchor.x, y: l.anchor.y };
      const p2 = { x: l.x, y: l.y + l.h * (0.5 - ROPE_ATTACH_FROM_BOTTOM_FRAC) };
      const len = Math.hypot(p2.x - p0.x, p2.y - p0.y);
      const sag = Math.min(ROPE_SAG_MAX, len * ROPE_SAG_RATIO);
      const sway = Math.sin((t + l.bobPhase) * 2 * Math.PI * l.bobFreq) * 4;
      const p1 = { x: (p0.x + p2.x)/2 + sway * 0.6, y: (p0.y + p2.y)/2 + sag + sway * 0.2 };
      return { p0, p1, p2 };
    }
    function ropeHitTest(l, tSec) {
      const { p0, p1, p2 } = ropePoints(l, tSec);
      const minX = Math.min(p0.x, p1.x, p2.x) - ROPE_HIT_RADIUS;
      const maxX = Math.max(p0.x, p1.x, p2.x) + ROPE_HIT_RADIUS;
      const minY = Math.min(p0.y, p1.y, p2.y) - ROPE_HIT_RADIUS;
      const maxY = Math.max(p0.y, p1.y, p2.y) + ROPE_HIT_RADIUS;
      if (pointer.x < minX || pointer.x > maxX || pointer.y < minY || pointer.y > maxY) return false;
      const STEPS = 24;
      let prev = quadBezierPoint(p0, p1, p2, 0);
      for (let i = 1; i <= STEPS; i++) {
        const tt = i / STEPS;
        const cur = quadBezierPoint(p0, p1, p2, tt);
        const d = pointSegDist(pointer.x, pointer.y, prev.x, prev.y, cur.x, cur.y);
        if (d <= ROPE_HIT_RADIUS) return true;
        prev = cur;
      }
      return false;
    }
    // Closest point on rope to pointer (sampled)
    function ropeClosestPoint(l, tSec) {
      const { p0, p1, p2 } = ropePoints(l, tSec);
      const STEPS = 48;
      let best = { d: Infinity, pt: {x: p0.x, y: p0.y} };
      let prev = quadBezierPoint(p0, p1, p2, 0);
      for (let i = 1; i <= STEPS; i++) {
        const tt = i / STEPS;
        const cur = quadBezierPoint(p0, p1, p2, tt);
        const d = pointSegDist(pointer.x, pointer.y, prev.x, prev.y, cur.x, cur.y);
        if (d < best.d) {
          best = d < pointSegDist(pointer.x, pointer.y, cur.x, cur.y, prev.x, prev.y)
            ? { d, pt: prev } : { d, pt: cur };
        }
        prev = cur;
      }
      return best.pt;
    }

    function easeOutCubic(u) { const t = 1 - Math.max(0, Math.min(1, u)); return 1 - t*t*t; }

    function handleHoverActions(l) {
      const t = nowMs();
      if (currentMode === 'chi') {
        if (l.state !== 'closed' && l.state !== 'lifting') { l.dwellStartChi = 0; return; }
        if (!pointer.inside || !isHovering(l)) { l.dwellStartChi = 0; return; }

        if (!l.dwellStartChi) l.dwellStartChi = t;
        const elapsed = t - l.dwellStartChi;

        // When dwell completes: start lifting animation (if not already lifting)
        if (elapsed >= LAMP_DWELL_MS && (t - l.lastHover) >= HOVER_COOLDOWN_MS) {
          l.lastHover = t;
          l.dwellStartChi = 0;
          if (l.state !== 'lifting' && l.y > l.restY + 1) {
            l.state = 'lifting';
            l.liftT0 = nowSec();
            playRandomLampLit();
          }
        }
      } else if (currentMode === 'katana') {
        l.dwellStartChi = 0; // no dwell in katana; reset any progress fill
        if (l.state !== 'lit') return;                 // can cut only after it has finished lifting
        if (t - l.lastHover < HOVER_COOLDOWN_MS) return;

        const tSec = performance.now()/1000;
        const overRope = ropeHitTest(l, tSec);
        l._ropeHovered = !!overRope;
        if (!overRope) return;

        // === Freeze rope geometry at the cut moment ===
        const frozen = ropePoints(l, tSec);               // snapshot of curve
        const breakPt = ropeClosestPoint(l, tSec);        // point on snapshot nearest pointer

        l.lastHover = t;
        l.state = 'ascend';
        l.ascendVy = rand(ASCEND_SPEED_MIN, ASCEND_SPEED_MAX);
        l.snap = {
          t0: nowSec(),
          life: ROPE_SNAP_LIFE,
          breakPt,
          frozen   // {p0,p1,p2} frozen at cut time
        };

        // ▼ NEW: play slice SFX right when the rope is cut
        playSfx(sfxKatanaSlice);
      }
    }

    /* =======================
       AMBIENT: STARS & FIREFLIES
    ======================= */
    let stars = [];
    function rebuildStars() {
      const areaMPx = (W * H) / 1_000_000;
      const count = Math.max(40, Math.round(STAR_DENSITY_PER_MPX * areaMPx));
      stars = Array.from({length: count}, () => ({
        x: Math.random() * W,
        y: Math.random() * H * 0.9,
        r: rand(STAR_MIN_SIZE, STAR_MAX_SIZE),
        base: rand(STAR_BASE_MIN, STAR_BASE_MAX),
        amp:  rand(STAR_MIN_AMP, STAR_MAX_AMP),
        freq: rand(STAR_MIN_FREQ, STAR_MAX_FREQ),
        phase: Math.random() * Math.PI * 2
      }));
    }

    let fireflies = [];
    function rebuildFireflies() {
      fireflies = Array.from({length: FIREFLY_COUNT}, () => {
        const color = FIREFLY_COLORS[Math.floor(Math.random() * FIREFLY_COLORS.length)];
        return {
          x: Math.random() * W,
          y: rand(H * FIREFLY_Y_MIN_FRAC, H * FIREFLY_Y_MAX_FRAC),
          dir: Math.random() * Math.PI * 2,
          speed: FIREFLY_SPEED * rand(0.8, 1.25),
          pulseF: rand(FIREFLY_PULSE_MIN, FIREFLY_PULSE_MAX),
          phase: Math.random() * Math.PI * 2,
          size: rand(FIREFLY_SIZE_MIN, FIREFLY_SIZE_MAX),
          color
        };
      });
    }

    function updateAmbient(dt) {
      for (const f of fireflies) {
        f.dir += (Math.random() - 0.5) * 0.15 * dt;
        f.x += Math.cos(f.dir) * f.speed * dt;
        f.y += Math.sin(f.dir) * f.speed * dt * 0.5;

        if (f.x < -20) f.x = W + 20;
        if (f.x > W + 20) f.x = -20;
        if (f.y < H * FIREFLY_Y_MIN_FRAC) f.y = H * FIREFLY_Y_MIN_FRAC + 4;
        if (f.y > H * FIREFLY_Y_MAX_FRAC) f.y = H * FIREFLY_Y_MAX_FRAC - 4;
      }
    }

    function drawGlow(x, y, r, alpha, rgb="255,210,120") {
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0, `rgba(${rgb},${alpha})`);
      g.addColorStop(1, `rgba(${rgb},0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawChiPointer() {
      if (currentMode !== 'chi' || !pointer.inside) return;
      const ready = chiPointerImg && chiPointerImg.complete && chiPointerImg.naturalWidth > 0;
      const t = performance.now() / 1000;
      const breathe = 1 + CHI_POINTER_BREATH * Math.sin(t * 2 * Math.PI * CHI_POINTER_BREATH_FREQ);
      const size = Math.min(CHI_POINTER_MAX, CHI_POINTER_BASE * breathe);
      const x = pointer.x, y = pointer.y;

      const glowR = size * 0.75;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(x, y, 0, x, y, glowR);
      g.addColorStop(0, 'rgba(180,255,255,0.35)');
      g.addColorStop(1, 'rgba(140,200,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x, y, glowR, 0, Math.PI * 2); ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.imageSmoothingQuality = 'high';
      if (ready) ctx.drawImage(chiPointerImg, x - size/2, y - size/2, size, size);
      else { ctx.fillStyle = '#cfefff'; ctx.beginPath(); ctx.arc(x, y, Math.max(6, size * 0.12), 0, Math.PI * 2); ctx.fill(); }
      ctx.restore();
    }

    function drawKatanaPointer() {
      if (currentMode !== 'katana' || !pointer.inside) return;
      const data = cursorOrient === 'right' ? katanaCursor.right : katanaCursor.left;
      const ready = katanaCursorReady && data && data.canvas;
      const hx = data ? data.hx : 0, hy = data ? data.hy : 0;
      const drawX = pointer.x - hx, drawY = pointer.y - hy;

      ctx.save();
      ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
      if (ready) ctx.drawImage(data.canvas, drawX, drawY, data.canvas.width, data.canvas.height);
      else {
        ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pointer.x - 18, pointer.y - 18); ctx.lineTo(pointer.x + 22, pointer.y + 22);
        ctx.moveTo(pointer.x + 22, pointer.y - 18); ctx.lineTo(pointer.x - 18, pointer.y + 22);
        ctx.stroke();
      }
      ctx.restore();
    }

    function renderStars(t) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const s of stars) {
        const p = 0.5 + 0.5 * Math.sin(s.phase + t * 2 * Math.PI * s.freq);
        const a = Math.min(1, s.base + s.amp * p);
        const r = s.r * (0.8 + 0.6 * p);

        const R = r * 3.2;
        const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, R);
        g.addColorStop(0.0, `rgba(255,240,200,${a * STAR_HALO_CORE})`);
        g.addColorStop(1.0, `rgba(255,240,200,${a * STAR_HALO_RING})`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(s.x, s.y, R, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = Math.max(0.18, a);
        ctx.beginPath(); ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgb(255,240,210)'; ctx.fill();
      }
      ctx.restore();
    }

    /* =======================
       BACKGROUND LANTERNS
    ======================= */
    let bgLanterns = [];
    function rebuildBgLanterns() { bgLanterns = []; for (let i = 0; i < BG_LANTERN_COUNT; i++) spawnBgLantern(true); }
    function spawnBgLantern(initial=false) {
      const type = Math.random() < 0.5 ? 1 : 2;
      const size = rand(BG_LANTERN_SIZE_MIN, BG_LANTERN_SIZE_MAX);
      const x = Math.random() * W;
      const y = initial ? rand(H * 0.15, H - 60) : H - 40 - size;
      const vy = rand(BG_LANTERN_SPEED_MIN, BG_LANTERN_SPEED_MAX);
      const swayFreq = rand(0.1, 0.25);
      const swayAmp = rand(4, 9);
      const phase = Math.random() * Math.PI * 2;
      bgLanterns.push({ type, x, y, size, vy, swayFreq, swayAmp, phase });
    }
    function updateBgLanterns(dt) {
      const t = performance.now() / 1000;
      for (let i = bgLanterns.length - 1; i >= 0; i--) {
        const b = bgLanterns[i];
        b.y -= b.vy * dt;
        b.x += Math.sin(t * 2 * Math.PI * b.swayFreq + b.phase) * b.swayAmp * dt;
        if (b.y + b.size < -20) { bgLanterns.splice(i, 1); spawnBgLantern(false); }
      }
    }
    function renderBgLanterns() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const b of bgLanterns) {
        drawGlow(b.x, b.y, b.size * 2.6, BG_LANTERN_HALO_ALPHA);
        ctx.globalAlpha = BG_LANTERN_CORE_ALPHA;
        const img = getLitImg(b.type);
        ctx.drawImage(img, b.x - b.size/2, b.y - b.size/2, b.size, b.size);
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }

    /* =======================
       SHOOTING STAR
    ======================= */
    let activeShootingStar = null;
    let nextStarTime = 0;
    function scheduleShootingStar() {
      nextStarTime = performance.now() / 1000 + rand(SHOOTING_STAR_MIN_INTERVAL, SHOOTING_STAR_MAX_INTERVAL);
    }
    function maybeSpawnShootingStar() {
      const t = performance.now() / 1000;
      if (activeShootingStar || t < nextStarTime) return;
      const y = rand(H * 0.05, H * 0.35);
      const dir = Math.random() < 0.5 ? 1 : -1;
      const x = dir > 0 ? -60 : W + 60;
      activeShootingStar = {
        x, y,
        vx: dir * rand(SHOOTING_STAR_SPEED_MIN, SHOOTING_STAR_SPEED_MAX),
        len: rand(SHOOTING_STAR_LEN_MIN, SHOOTING_STAR_LEN_MAX),
        age: 0, life: SHOOTING_STAR_LIFE, dir
      };
    }
    function updateShootingStar(dt) {
      if (!activeShootingStar) return;
      const s = activeShootingStar;
      s.x += s.vx * dt;
      s.age += dt;
      if (s.age > s.life || s.x < -200 || s.x > W + 200) {
        activeShootingStar = null;
        scheduleShootingStar();
      }
    }
    function renderShootingStar() {
      if (!activeShootingStar) return;
      const s = activeShootingStar;
      const a = Math.max(0, 1 - s.age / s.life);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.65 * a;
      ctx.beginPath(); ctx.arc(s.x, s.y, 1.8, 0, Math.PI * 2); ctx.fillStyle = 'rgb(255,240,210)'; ctx.fill();
      const x2 = s.x - s.dir * s.len;
      const y2 = s.y + 0.25 * s.len;
      const grad = ctx.createLinearGradient(x2, y2, s.x, s.y);
      grad.addColorStop(0, 'rgba(255,240,210,0)');
      grad.addColorStop(1, 'rgba(255,240,210,0.6)');
      ctx.strokeStyle = grad; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x2, y2); ctx.lineTo(s.x, s.y); ctx.stroke();
      ctx.restore();
    }

    /* =======================
       ROPES
    ======================= */
    function drawIntactRope(l, t) {
      const { p0, p1, p2 } = ropePoints(l, t);
      ctx.save();
      ctx.lineWidth = ROPE_WIDTH; ctx.lineCap = 'round';
      ctx.strokeStyle = `rgba(${ROPE_COLOR_RGB},${ROPE_ALPHA})`;
      ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y); ctx.stroke();

      if (l._ropeHovered && currentMode === 'katana') {
        ctx.strokeStyle = 'rgba(255,230,160,0.9)';
        ctx.lineWidth = ROPE_WIDTH + 1.5;
        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawSnappingRope(l, t) {
      if (!l.snap) return;
      const age = t - l.snap.t0;
      const p = Math.min(1, age / l.snap.life); // 0→1
      const frozen = l.snap.frozen || ropePoints(l, t); // fallback, but frozen is expected
      const { p0, p1, p2 } = frozen;
      const B = l.snap.breakPt || { x: (p0.x + p2.x)/2, y: (p0.y + p2.y)/2 };

      // endpoints retreat towards their anchors along the FROZEN curve direction
      const topEnd = { x: p2.x + (B.x - p2.x) * (1 - p), y: p2.y + (B.y - p2.y) * (1 - p) };
      const botEnd = { x: p0.x + (B.x - p0.x) * (1 - p), y: p0.y + (B.y - p0.y) * (1 - p) };

      // slight recoil offsets
      const recoil = (1 - p) * 6;
      const topOff = { x: 0, y: -recoil };
      const botOff = { x: 0, y: recoil * 0.6 };

      ctx.save();
      ctx.lineWidth = ROPE_WIDTH; ctx.lineCap = 'round';
      ctx.strokeStyle = `rgba(${ROPE_COLOR_RGB},${ROPE_ALPHA * (1 - p)})`;

      // top piece (near lantern)
      ctx.beginPath();
      ctx.moveTo(p2.x, p2.y);
      ctx.lineTo(topEnd.x + topOff.x, topEnd.y + topOff.y);
      ctx.stroke();

      // bottom piece (near anchor)
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(botEnd.x + botOff.x, botEnd.y + botOff.y);
      ctx.stroke();
      ctx.restore();

      if (p >= 1) l.snap = null; // done
    }

function drawRopes(t) {
  for (const l of lanterns) {
    // Lantern is flying away. Show snap animation while it lives; otherwise, no rope.
    if (l.state === 'ascend') {
      if (l.snap) drawSnappingRope(l, t);
      continue; // <-- prevent drawing an intact rope after snap ends
    }

    // Rope should be visible only while the lantern is still tethered
    // (closed at ground, lifting to rest, or sitting lit at rest).
    if (l.state === 'closed' || l.state === 'lifting' || l.state === 'lit') {
      drawIntactRope(l, t);
    }
  }
}

    /* =======================
       INTERNAL FILL (progress inside lantern)
    ======================= */
    function renderLampFillInside(l) {
      if (l.state !== 'closed' || !l.dwellStartChi) return;
      const elapsed = performance.now() - l.dwellStartChi;
      const p = clamp01(elapsed / LAMP_DWELL_MS);

      if (!l._fillC) l._fillC = document.createElement('canvas');
      const oc = l._fillC;
      const w = Math.max(2, Math.round(l.w));
      const h = Math.max(2, Math.round(l.h));
      if (oc.width !== w || oc.height !== h) { oc.width = w; oc.height = h; }
      const octx = oc.getContext('2d');
      octx.clearRect(0, 0, w, h);

      const fillH = Math.max(1, Math.floor(h * p));
      const y0 = h - fillH;
      const grad = octx.createLinearGradient(0, h, 0, y0);
      grad.addColorStop(0.00, 'rgba(255,220,140,0.95)');
      grad.addColorStop(0.60, 'rgba(255,205,120,0.65)');
      grad.addColorStop(1.00, 'rgba(255,180,100,0.35)');

      octx.globalCompositeOperation = 'source-over';
      octx.fillStyle = grad;
      octx.fillRect(0, y0, w, fillH);

      octx.globalCompositeOperation = 'destination-in';
      const closedImg = getClosedImg(l.type);
      octx.drawImage(closedImg, 0, 0, w, h);

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.drawImage(oc, -l.w/2, -l.h/2, l.w, l.h);
      ctx.restore();
    }

    /* =======================
       LOOP
    ======================= */
    let lastT = performance.now();
    let started = false;

    function drawBackgroundImage() {
      if (bgImg.complete && bgImg.naturalWidth > 0) {
        const iw = bgImg.width, ih = bgImg.height;
        const scale = Math.max(W / iw, H / ih); // cover
        const dw = iw * scale, dh = ih * scale;
        const dx = (W - dw) * 0.5;
        const dy = (H - dh) * 0.5;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(bgImg, dx, dy, dw, dh);
      } else {
        ctx.fillStyle = "#001028";
        ctx.fillRect(0, 0, W, H);
      }
    }

    function update(dt) {
      updateModeHover();

      // ambient
      updateAmbient(dt);
      updateBgLanterns(dt);
      maybeSpawnShootingStar();
      updateShootingStar(dt);

      const tSec = performance.now()/1000;

      // foreground lanterns
      for (let i = lanterns.length - 1; i >= 0; i--) {
        const l = lanterns[i];

        // Track rope hover for visual feedback in katana mode (only when lit)
        l._ropeHovered = (currentMode === 'katana' && l.state === 'lit' && pointer.inside) ? ropeHitTest(l, tSec) : false;

        if (pointer.inside && (isHovering(l) || l._ropeHovered)) {
          handleHoverActions(l);
        } else {
          if (l.state === 'closed') l.dwellStartChi = 0;
        }

        // Clamp X inside play area at all times
        const minX = SIDE_PAD_H + l.w * 0.5;
        const maxX = W - SIDE_PAD_H - l.w * 0.5;

        if (l.state === "ascend") {
          // free-ascend into the sky after the cut
          const t = (performance.now() - l.born) / 1000;
          const sway = Math.sin(2 * Math.PI * l.swayFreq * t) * l.swayAmp;
          l.y -= l.ascendVy * dt;
          l.x += l.driftBase * l.driftSpeed * dt + sway * dt * 0.6;
          l.x = Math.max(minX, Math.min(maxX, l.x));
          if (l.y + l.h * 0.5 < -30) { resetOne(i); continue; }
        } else if (l.state === 'lifting') {
          // animate from groundY -> restY over LIFT_DURATION
          const p = easeOutCubic((nowSec() - l.liftT0) / l.liftDur);
          const prevY = l.y;
          l.y = l.groundY + (l.restY - l.groundY) * Math.min(1, p);
          const sway = Math.sin((nowSec() - l.liftT0) * 2 * Math.PI * l.swayFreq) * 0.25;
          l.x += sway;
          l.x = Math.max(minX, Math.min(maxX, l.x));
          if (l.y <= l.restY + 0.5 || (l.y === prevY && p >= 1)) {
            l.y = l.restY;
            l.state = 'lit';
          }
        } else if (l.state === 'lit') {
          const dy = l.restY - l.y;
          if (Math.abs(dy) > 0.5) l.y += Math.sign(dy) * Math.min(120 * dt, Math.abs(dy));
          l.x = Math.max(minX, Math.min(maxX, l.x));
        } else { // 'closed' at ground
          l.y = l.groundY;
          l.x = Math.max(minX, Math.min(maxX, l.x));
        }
      }
    }

    function render() {
      const t = performance.now() / 1000;

      drawBackgroundImage();
      renderStars(t);
      renderShootingStar();
      renderBgLanterns();

      // Ropes behind lamps
      drawRopes(t);

      // Constant glow for lit/ascending lamps
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const l of lanterns) {
        if (l.state === "lit" || l.state === "ascend" || l.state === "lifting") {
          drawGlow(l.x, l.y, l.h * GLOW_RADIUS_MULT, GLOW_BASE_ALPHA);
        }
      }
      ctx.restore();

      // Foreground lamps
      for (const l of lanterns) {
        const bobAmp = (l.state === "lit" || l.state === "ascend" || l.state === "lifting")
          ? IDLE_BOB_AMP_LIT : IDLE_BOB_AMP_CLOSED;
        const yOff = Math.sin(l.bobPhase + t * 2 * Math.PI * l.bobFreq) * bobAmp;
        const rot  = Math.sin(l.bobPhase * 0.7 + t * 2 * Math.PI * l.bobFreq * 0.8) * IDLE_ROT_AMP;

        const img = (l.state === "closed") ? getClosedImg(l.type) : getLitImg(l.type);

        ctx.save();
        ctx.translate(l.x, l.y + yOff);
        ctx.rotate(rot);

        // draw lantern image first
        ctx.drawImage(img, -l.w/2, -l.h/2, l.w, l.h);

        // if closed and dwelling, overlay the internal fill
        if (l.state === 'closed' && l.dwellStartChi) {
          renderLampFillInside(l);
        }

        ctx.restore();
      }

      // Fireflies on top
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const f of fireflies) {
        const a = 0.12 + 0.18 * (0.5 + 0.5 * Math.sin(f.phase + t * 2 * Math.PI * f.pulseF));
        const haloR = f.size * 4.5;
        const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, haloR);
        g.addColorStop(0, `rgba(${f.color.halo},${a})`);
        g.addColorStop(1, `rgba(${f.color.halo},0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(f.x, f.y, haloR, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${f.color.core})`; ctx.fill();
      }
      ctx.restore();

      drawChiPointer();
      drawKatanaPointer();
    }

    function tick(tMs) {
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT) / 1000);
      lastT = tMs;

      ensureCount();
      update(dt);
      render();

      requestAnimationFrame(tick);
    }

    /* ===== FULLSCREEN START ===== */
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    async function enterFullscreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    }

    startBtn.addEventListener('click', async () => {
      try { await enterFullscreen(); } catch(e) {}
      startOverlay.style.display = 'none';
      started = true;

      lastT = performance.now();
      resize();
      scheduleShootingStar();

      // Wait for images once
      let pending = 0;
      const tryStart = () => { if (--pending <= 0) requestAnimationFrame(tick); };
      const imgs = [bgImg, imgClosed1, imgLit1, imgClosed2, imgLit2];
      for (const im of imgs) if (!im.complete) { pending++; im.onload = tryStart; }
      if (pending === 0) requestAnimationFrame(tick);
    });
  })();
  </script>
</body>
</html>
  </template>
</body>
</html>
