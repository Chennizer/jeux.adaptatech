<!doctype html>
<meta charset="utf-8">
<title>Contrôleur vidéo (WS)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
  /* ================= THEME TOKENS ================= */
  :root{
    --bg: #000000; --fg: #ffffff;
    --card-bg: #ffffff; --card-fg: #000000; --card-border: #cccccc; --card-hover: #e2e8f0;
    --accent: #294936; /* buttons */
    /* otherswitch palette */
    --c-cyan: #00bfff;
    --c-teal: #008080;
    --c-teal-dark: #006666;
    --c-track: #009688;
    --c-thumb: #00796B;
    --c-thumb-border: #004D40;
  }
  body.theme-light{
    --bg: #ffffff; --fg: #000000;
    --card-bg: #f8f9fb; --card-fg: #111111; --card-border: #c9d1db; --card-hover: #e9eef5;
  }
  body.theme-dark{
    --bg: #000000; --fg: #ffffff;
    --card-bg: #ffffff; --card-fg: #000000; --card-border: #cccccc; --card-hover: #e2e8f0;
  }

  /* Reset & base */
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
  body { background: var(--bg); color: var(--fg); font: 16px system-ui; user-select: none; }

  /* Start overlay */
  #startOverlay { position: fixed; inset: 0; display: grid; place-items: center; background: var(--bg); z-index: 10; }
  #startBtn { appearance: none; border: 0; border-radius: 14px; cursor: pointer; padding: 14px 22px; font: 600 18px system-ui; color: #fff; background: var(--accent); box-shadow: 0 6px 24px rgba(0,0,0,.45); }
  #startBtn:active { transform: translateY(1px); opacity: .95; }

  /* Connection indicator */
  #controllerIndicator{
    position:fixed; top:10px; left:10px;
    width:12px; height:12px; border-radius:50%;
    background:#bdbdbd;
    box-shadow:0 0 0 2px #000, 0 0 6px rgba(0,0,0,.25);
    z-index: 20; pointer-events:none;
  }
  #controllerIndicator.on{ background:#18c36e; }
  #controllerIndicator.pulse{ animation:ci-ping 900ms ease-out 1; }
  @keyframes ci-ping{
    0%   { box-shadow:0 0 0 2px #000, 0 0 12px rgba(24,195,110,.9); }
    70%  { box-shadow:0 0 0 2px #000, 0 0 0 rgba(24,195,110,0); }
    100% { box-shadow:0 0 0 2px #000, 0 0 0 rgba(24,195,110,0); }
  }

  /* ===== Choice grid ===== */
  #chooser{
    --card-size: clamp(320px, 34vmin, 520px);
    --gap: clamp(60px, 12vmin, 200px);
    --cols: 2; --rows: 2;

    position: fixed; inset: 0;
    display: grid;
    grid-template-columns: repeat(var(--cols), var(--card-size));
    grid-template-rows:    repeat(var(--rows), var(--card-size));
    gap: var(--gap);
    place-content: center;
    justify-items: center;
    align-items: center;
    padding: 0;
    background: var(--bg);
    z-index: 5; display: none;
  }
  #chooser.count-1 { --cols:1; --rows:1; }
  #chooser.count-2 { --cols:2; --rows:1; }
  #chooser.count-3 { --cols:3; --rows:1; }
  #chooser.count-4 { --cols:2; --rows:2; }

  .card{
    width: 100%; height: 100%; aspect-ratio: 1 / 1;
    background: var(--card-bg); color: var(--card-fg);
    border: 2px solid var(--card-border); border-radius: 12px;
    position: relative; overflow: hidden;
    transition: transform .15s ease, background-color .2s, box-shadow .2s, border-color .2s;
    display: flex; align-items: center; justify-content: center;
  }
  @media (hover:hover) and (pointer:fine){
    .card:hover { background: var(--card-hover); transform: translateY(-2px); box-shadow:0 8px 22px rgba(0,0,0,.45); }
  }
  .card:active { transform: scale(.985); }
/* if you prefer no cropping, just shrink the padding */
#chooser .card{
  position: relative;
  overflow: hidden;
  /* keep your existing look */
  width: 100%;
  height: 100%;
  aspect-ratio: 1/1;
  background: var(--card-bg);
  border: 2px solid var(--card-border);
  border-radius: 12px;
}
#chooser .card img{
  position: absolute;   /* key */
  inset: 0;             /* top:0 right:0 bottom:0 left:0 */
  width: 100%;
  height: 100%;
  object-fit: cover;    /* full-bleed; will crop edges */
  display: block;
  padding: 0;
  background: transparent;
  border-radius: inherit;
}
  /* Dwell overlay (red fill) */
  .dwell-fill{
    position:absolute; pointer-events:none; border-radius: 8px;
    background-color: rgba(255, 0, 0, 0.5);
    top:50%; left:50%; width:0; height:0; transform: translate(-50%, -50%);
  }

  /* ========= Quick Settings (toggle with M) – VISUALS ONLY ========= */
  #menuMask{
    position: fixed; inset: 0; background: rgba(0,0,0,.45);
    display: none; z-index: 30;
  }

  /* Base container styled like otherswitch menu */
  #quickMenu{
    position: fixed; right: 18px; top: 18px; z-index: 31;
    width: min(380px, 92vw); max-width: 92vw;
    /* otherswitch look */
    background: rgba(0,0,0,0.85);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,.35);
    padding: 18px 18px 14px;
    display: none;
    backdrop-filter: blur(2px);
  }
  body.theme-light #quickMenu{
    background: rgba(255,255,255,0.96);
    color: #222;
    border: 2px solid var(--c-teal);
  }

  /* Header + headings */
  #quickMenu header{
    display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:6px;
  }
  #quickMenu h3{ margin:0; font: 700 16px/1.1 system-ui; color: var(--c-cyan); }
  #quickMenu .hint{ font: 500 12px/1.2 system-ui; opacity:.85; }

  /* Rows */
  #quickMenu .row{
    display:grid; grid-template-columns: 1fr auto; align-items:center; gap:12px;
    padding: 10px 0;
  }
  #quickMenu label{ font: 600 14px/1.2 system-ui; }

  /* Value pill */
  #quickMenu .value{
    min-width:72px; text-align:right; font-variant-numeric: tabular-nums;
    padding: 2px 8px; border-radius: 6px; background: rgba(0,0,0,.25);
  }
  body.theme-light #quickMenu .value{ background: rgba(0,0,0,.06); }

  /* Buttons */
  #quickMenu .btn{
    appearance:none; border:0; border-radius:8px; padding:8px 12px; cursor:pointer;
    font:600 13px system-ui; color:#fff; background: #0077be;
    transition: transform .1s ease, opacity .2s ease, filter .2s ease;
  }
  #quickMenu .btn:hover{ filter: brightness(1.05); }
  #quickMenu .btn:active{ transform: translateY(1px); opacity:.95; }

  /* ===== Sliders skinned like otherswitch ===== */
  #quickMenu input[type="range"]{
    -webkit-appearance: none; -moz-appearance: none; appearance: none;
    width: 100%; background: transparent; height: 28px; /* give room for thumb */
  }
  /* WebKit track + thumb */
  #quickMenu input[type="range"]::-webkit-slider-runnable-track{
    height: 8px; background: var(--c-track); border-radius: 5px;
  }
  #quickMenu input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance: none; width: 20px; height: 20px; margin-top: -6px;
    border-radius: 50%; background: var(--c-thumb); border: 2px solid var(--c-thumb-border); cursor: pointer;
  }
  /* Firefox track + thumb */
  #quickMenu input[type="range"]::-moz-range-track{
    height: 8px; background: var(--c-track); border-radius: 5px;
  }
  #quickMenu input[type="range"]::-moz-range-thumb{
    width: 20px; height: 20px; border-radius: 50%;
    background: var(--c-thumb); border: 2px solid var(--c-thumb-border); cursor: pointer;
  }
  /* Focus glow */
  #quickMenu input[type="range"]:focus{ outline: none; }
  #quickMenu input[type="range"]:focus::-webkit-slider-thumb{ box-shadow: 0 0 6px rgba(0,150,136,0.8); }
  #quickMenu input[type="range"]:focus::-moz-range-thumb{ box-shadow: 0 0 6px rgba(0,150,136,0.8); }

  /* Checkbox (theme toggle) */
  #quickMenu input[type="checkbox"]{
    width: 18px; height: 18px; cursor: pointer;
    accent-color: var(--c-cyan);
  }

  /* ===== Gaze pointer overlay ===== */
  .hide-native-cursor,
  .hide-native-cursor * {
    cursor: none !important;
  }

  #gazePointerOverlay {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 2147483647;
    overflow: visible;
  }

  #gazePointer {
    position: absolute;
    left: 0;
    top: 0;
    width: var(--gp-size, 36px);
    height: var(--gp-size, 36px);
    transform: translate(-50%, -50%);
    pointer-events: none;
    opacity: 0;
    will-change: transform, opacity;
  }

  #gazePointer::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background: #ff0000;
  }

  #gazePointer.gp-dwell::before {
    animation: gpPulse 700ms ease-in-out infinite alternate;
  }

  @keyframes gpPulse {
    from { transform: scale(1); }
    to   { transform: scale(1.06); }
  }

  @media (prefers-reduced-motion: reduce) {
    #gazePointer.gp-dwell::before { animation: none; }
  }

  /* Small screens */
  @media (max-width: 680px) {
    #chooser { --cols:1 !important; --rows:auto; grid-auto-rows: var(--card-size); }
  }
</style>

<div id="startOverlay"><button id="startBtn">Start</button></div>
<span id="controllerIndicator" title="Contrôleur : déconnecté" aria-label="État du contrôleur"></span>
<div id="chooser" aria-hidden="true"></div>

<!-- Quick settings menu (toggle with 'M') -->
<div id="menuMask" aria-hidden="true"></div>
<div id="quickMenu" role="dialog" aria-modal="true" aria-labelledby="qmTitle">
  <header>
    <h3 id="qmTitle">Options du contrôleur</h3>
    <div class="hint">Appuyez <strong>M</strong> pour fermer · <strong>Échap</strong> aussi</div>
  </header>

  <div class="row">
    <label for="dwellSlider">Temps de fixation (ms)</label>
    <span class="value" id="dwellVal">1500</span>
    <input id="dwellSlider" type="range" min="300" max="5000" step="50" value="1500" aria-describedby="dwellHelp">
  </div>
  <div class="row" id="dwellHelp" style="padding-top:0; font: 500 12px system-ui; opacity:.8;">
    Ajuste la durée de survol nécessaire pour sélectionner une tuile.
  </div>

  <div class="row">
    <label for="themeToggle">Mode sombre</label>
    <input id="themeToggle" type="checkbox" aria-describedby="themeHelp">
  </div>
  <div class="row" id="themeHelp" style="padding-top:0; font: 500 12px system-ui; opacity:.8;">
    Active/désactive le thème sombre (persistance locale).
  </div>

  <div style="display:flex; gap:8px; justify-content:flex-end; padding-top:8px;">
    <button class="btn" id="btnReset">Réinitialiser</button>
    <button class="btn" id="btnClose">Fermer (M)</button>
  </div>
</div>

<div id="gazePointerOverlay" aria-hidden="true">
  <div id="gazePointer"></div>
</div>

<script>
  /* ---------- Fullscreen ---------- */
  async function enterFullscreen(){ try{ if(!document.fullscreenElement && document.documentElement.requestFullscreen){ await document.documentElement.requestFullscreen(); } }catch{} }
  const startOverlay = document.getElementById('startOverlay');
  document.getElementById('startBtn').addEventListener('click', async ()=>{
    await enterFullscreen();
    startOverlay.style.display='none';
    activatePointer();
  });
  window.addEventListener('keydown', (e)=>{ if(e.key==='f'||e.key==='F'){ e.preventDefault(); enterFullscreen(); }});

  /* ---------- Indicator ---------- */
  const ind = document.getElementById('controllerIndicator');
  const setIndicator = (state)=>{ if(!ind) return; ind.classList.toggle('on', state==='on'); ind.title = state==='on' ? 'Contrôleur : connecté' : 'Contrôleur : déconnecté'; };
  const pulseIndicator = ()=>{ if(!ind) return; ind.classList.add('pulse'); setTimeout(()=> ind.classList.remove('pulse'), 900); };

  /* ---------- Image base + normalization with auto-retry ---------- */
  const PATH = location.pathname;
  const PREFIX_MATCH = PATH.match(/^\/(jeux\.adaptatech|jeuxadaptes)\//);
  const PRIMARY_PREFIX = PREFIX_MATCH ? `/${PREFIX_MATCH[1]}/` : '/';
  const IMG_BASE = `${PRIMARY_PREFIX}images/`;
  const ALT_PREFIXES = Array.from(new Set([PRIMARY_PREFIX,'/jeuxadaptes/','/jeux.adaptatech/','/']))
    .map(p => p.endsWith('/') ? p : p + '/');

  function normalizeThumb(thumb, keyIfWeather){
    if (thumb && (/^https?:\/\//i.test(thumb) || /^data:/i.test(thumb))) return thumb;
    if (thumb && thumb.startsWith(IMG_BASE)) return thumb;
    if (thumb && thumb.startsWith('/images/')) return thumb.replace('/images/', IMG_BASE);
    if (thumb) { const name = thumb.split('/').pop(); return IMG_BASE + name; }
    if (keyIfWeather) return IMG_BASE + keyIfWeather + '.png';
    return null;
  }

  function makeImg(srcCandidate, title){
    const img = document.createElement('img');
    img.alt = title || '';
    let tried = 0;
    const candidates = [];
    if (srcCandidate && /^https?:\/\//i.test(srcCandidate)) {
      candidates.push(srcCandidate);
    } else {
      const filename = (srcCandidate || '').split('/').pop();
      ALT_PREFIXES.forEach(pref => candidates.push(`${pref}images/${filename}`));
    }
    function tryNext(){ if (tried >= candidates.length) return; img.src = candidates[tried++]; }
    img.addEventListener('error', tryNext);
    tryNext();
    return img;
  }

  /* ---------- Settings state (dwell + theme) ---------- */
  const qs = new URL(location.href).searchParams;
  const DEFAULT_DWELL = 1500;
  const LS_DWELL = 'controller.dwell';
  const LS_THEME = 'controller.theme';

  // Global settings object (if other scripts want it)
  const eyegazeSettings = (window.eyegazeSettings = window.eyegazeSettings || {});

  function readInitialDwell(){
    const urlOverride = parseInt(qs.get('dwell'), 10);
    if (!Number.isNaN(urlOverride) && urlOverride > 0) return urlOverride;
    const saved = parseInt(localStorage.getItem(LS_DWELL), 10);
    if (!Number.isNaN(saved) && saved > 0) return saved;
    if (Number.isFinite(eyegazeSettings.dwellTime) && eyegazeSettings.dwellTime > 0) return eyegazeSettings.dwellTime;
    return DEFAULT_DWELL;
  }
  function setDwell(ms, persist=true){
    eyegazeSettings.dwellTime = Math.max(1, Math.floor(ms));
    if (persist) localStorage.setItem(LS_DWELL, String(eyegazeSettings.dwellTime));
    // update UI if open
    const slider = document.getElementById('dwellSlider');
    const val = document.getElementById('dwellVal');
    if (slider){ slider.value = eyegazeSettings.dwellTime; }
    if (val){ val.textContent = eyegazeSettings.dwellTime; }
  }

  function readInitialTheme(){
    const urlTheme = (qs.get('theme') || '').toLowerCase();
    if (urlTheme === 'light' || urlTheme === 'dark') return urlTheme;
    const saved = (localStorage.getItem(LS_THEME) || '').toLowerCase();
    if (saved === 'light' || saved === 'dark') return saved;
    // default to dark
    return 'dark';
  }
  function applyTheme(theme, persist=true){
    const t = (theme === 'light') ? 'light' : 'dark';
    document.body.classList.remove('theme-light','theme-dark');
    document.body.classList.add(`theme-${t}`);
    if (persist) localStorage.setItem(LS_THEME, t);
    // update toggle if open
    const chk = document.getElementById('themeToggle');
    if (chk) chk.checked = (t === 'dark');
  }

  // Initialize settings
  setDwell(readInitialDwell(), false);
  applyTheme(readInitialTheme(), false);

  const DEFAULT_POINTER_ENABLED = true;
  const DEFAULT_POINTER_SIZE = 36;
  const DEFAULT_POINTER_ALPHA = 1;

  const gazePointer = document.getElementById('gazePointer');
  const pointerState = {
    enabled: DEFAULT_POINTER_ENABLED,
    size: DEFAULT_POINTER_SIZE,
    alpha: DEFAULT_POINTER_ALPHA,
    started: false,
    showingChoices: false,
  };
  let pointerLastPosition = { x: null, y: null };

  const clamp = (value, min, max) => {
    if (!Number.isFinite(value)) return min;
    return Math.min(max, Math.max(min, value));
  };

  const clampAlpha = (value) => {
    if (!Number.isFinite(value)) return DEFAULT_POINTER_ALPHA;
    return Math.min(1, Math.max(0, value));
  };

  function loadPointerSettings(){
    pointerState.enabled = DEFAULT_POINTER_ENABLED;
    pointerState.size = DEFAULT_POINTER_SIZE;
    pointerState.alpha = DEFAULT_POINTER_ALPHA;

    if (Number.isFinite(eyegazeSettings.gazePointerSize)){
      pointerState.size = clamp(eyegazeSettings.gazePointerSize, 16, 120);
    }
    if (Number.isFinite(eyegazeSettings.gazePointerAlpha)){
      pointerState.alpha = clampAlpha(eyegazeSettings.gazePointerAlpha);
    }

    // Force the custom pointer to be visible on this page with default values
    pointerState.enabled = true;
    pointerState.size = clamp(pointerState.size, 16, 120);
    pointerState.alpha = clampAlpha(pointerState.alpha);

    eyegazeSettings.showGazePointer = true;
    eyegazeSettings.gazePointerSize = pointerState.size;
    eyegazeSettings.gazePointerAlpha = pointerState.alpha;
  }

  function setPointerPos(x, y){
    if (!gazePointer) return;
    gazePointer.style.left = `${x}px`;
    gazePointer.style.top  = `${y}px`;
  }

  function setPointerDwell(active){
    if (!gazePointer) return;
    if (!(pointerState.started && pointerState.enabled && pointerState.showingChoices)){
      gazePointer.classList.remove('gp-dwell');
      return;
    }
    gazePointer.classList.toggle('gp-dwell', !!active);
  }

  function applyPointerStyles(){
    if (!gazePointer) return;
    gazePointer.style.setProperty('--gp-size', `${pointerState.size}px`);
    const hasPosition = pointerLastPosition.x !== null && pointerLastPosition.y !== null;
    const visible = pointerState.started && pointerState.enabled && pointerState.showingChoices && hasPosition;
    if (visible){
      setPointerPos(pointerLastPosition.x, pointerLastPosition.y);
    }
    gazePointer.style.opacity = visible ? pointerState.alpha : 0;
    document.documentElement.classList.toggle('hide-native-cursor', visible);
    if (!visible){
      gazePointer.classList.remove('gp-dwell');
    }
  }

  function activatePointer(){
    pointerState.started = true;
    applyPointerStyles();
  }

  loadPointerSettings();
  applyPointerStyles();

  if (gazePointer){
    const pointerMoveHandler = (event) => {
      pointerLastPosition.x = event.clientX;
      pointerLastPosition.y = event.clientY;
      setPointerPos(event.clientX, event.clientY);
      if (pointerState.started){
        applyPointerStyles();
      }
    };

    if ('onpointerrawupdate' in window){
      window.addEventListener('pointerrawupdate', pointerMoveHandler, { passive: true });
    }
    window.addEventListener('pointermove', pointerMoveHandler, { passive: true });

    window.addEventListener('pointerleave', () => {
      if (!pointerState.started) return;
      gazePointer.style.opacity = 0;
      document.documentElement.classList.remove('hide-native-cursor');
    });

    window.addEventListener('pointerenter', (event) => {
      if (event && typeof event.clientX === 'number' && typeof event.clientY === 'number'){
        pointerLastPosition.x = event.clientX;
        pointerLastPosition.y = event.clientY;
        setPointerPos(event.clientX, event.clientY);
      } else if (pointerLastPosition.x !== null && pointerLastPosition.y !== null) {
        setPointerPos(pointerLastPosition.x, pointerLastPosition.y);
      }
      if (pointerState.started){
        applyPointerStyles();
      }
    });
  }

  /* ---------- UI (chooser) ---------- */
  const chooser = document.getElementById('chooser');
  let locked = false;
  let currentMode = 'video';

  function hideChooser(){
    chooser.style.display = 'none';
    chooser.setAttribute('aria-hidden','true');
    chooser.innerHTML = '';
    chooser.classList.remove('count-1','count-2','count-3','count-4');
    pointerState.showingChoices = false;
    applyPointerStyles();
  }
  function applyLayoutClass(count){
    chooser.classList.remove('count-1','count-2','count-3','count-4');
    if (count===1) chooser.classList.add('count-1');
    else if (count===2) chooser.classList.add('count-2');
    else if (count===3) chooser.classList.add('count-3');
    else if (count===4) chooser.classList.add('count-4');
  }

  /* ===== Dwell helpers ===== */
  const getDwellTime = () => Number.isFinite(eyegazeSettings.dwellTime) ? eyegazeSettings.dwellTime : DEFAULT_DWELL;

  function beginDwell(card, onComplete){
    if (!card || card.dataset.dwellActive === '1') return;
    const hoverTime = getDwellTime();
    const overlay = document.createElement('div');
    overlay.className = 'dwell-fill';
    card.appendChild(overlay);

    requestAnimationFrame(()=>{
      overlay.style.transition = `width ${hoverTime}ms linear, height ${hoverTime}ms linear`;
      overlay.style.width = '0'; overlay.style.height = '0';
      requestAnimationFrame(()=>{
        overlay.style.width = '100%';
        overlay.style.height = '100%';
      });
    });

    setPointerDwell(true);

    const t = setTimeout(()=>{
      cleanup();
      onComplete();
    }, hoverTime);

    function cleanup(){
      clearTimeout(t);
      if (overlay.parentElement){ overlay.parentElement.removeChild(overlay); }
      card.dataset.dwellActive = '0';
      card._dwell = null;
      setPointerDwell(false);
    }

    card.dataset.dwellActive = '1';
    card._dwell = { t, overlay, cleanup };
    return cleanup;
  }

  function cancelDwell(card){
    if (!card || card.dataset.dwellActive !== '1') return;
    if (card._dwell){
      clearTimeout(card._dwell.t);
      if (card._dwell.overlay && card._dwell.overlay.parentElement){
        card._dwell.overlay.parentElement.removeChild(card._dwell.overlay);
      }
      card._dwell = null;
    }
    card.dataset.dwellActive = '0';
    setPointerDwell(false);
  }

  /* ---------- WebSocket with heartbeat + debounced reconnect ---------- */
  const room = qs.get('room') || 'test';
  const WS_URL = `wss://ws-relay.gui98789.workers.dev/ws/${encodeURIComponent(room)}`;

  let ws = null;
  let hbInterval = null;
  let watchdogInterval = null;
  let lastActivity = 0;
  let backoffMs = 1000;
  const backoffMax = 15000;
  let reconnectTimer = null;
  let connecting = false;

  function clearTimers(){
    if (hbInterval) { clearInterval(hbInterval); hbInterval = null; }
    if (watchdogInterval){ clearInterval(watchdogInterval); watchdogInterval = null; }
    if (reconnectTimer){ clearTimeout(reconnectTimer); reconnectTimer = null; }
  }

  function scheduleReconnect(){
    if (connecting) return;
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(()=>{ reconnectTimer = null; connect(); }, backoffMs);
    backoffMs = Math.min(backoffMs * 2, backoffMax);
    console.warn('[controller] WS closed; reconnect in', backoffMs/2, 'ms');
  }

  function connect(){
    if (connecting) return;
    connecting = true;

    try{
      ws = new WebSocket(WS_URL);
      window.__ws = ws;
    }catch(e){
      connecting = false;
      scheduleReconnect();
      return;
    }

    ws.onopen = () => {
      connecting = false;
      setIndicator('on'); pulseIndicator();
      locked = false;
      lastActivity = Date.now();

      try{ ws.send(JSON.stringify({type:'hello', role:'controller'})); lastActivity = Date.now(); }catch{}

      clearTimers();

      hbInterval = setInterval(()=>{
        try{ ws.readyState===1 && ws.send(JSON.stringify({type:'ping'})); lastActivity = Date.now(); }catch{}
      }, 20000);

      watchdogInterval = setInterval(()=>{
        if (Date.now() - lastActivity > 60000){
          console.warn('[controller] WS idle >60s, reconnecting…');
          try{ ws.close(); }catch{}
        }
      }, 5000);

      backoffMs = 1000;
    };

    ws.onmessage = (e)=>{
      pulseIndicator();
      lastActivity = Date.now();
      let msg; try{ msg = JSON.parse(e.data); }catch{ return; }
      if (msg.type === 'pong' || msg.type === 'ping') return;

      if (msg.type === 'request_video'){
        locked = false;
        const options = Array.isArray(msg.options) && msg.options.length
          ? msg.options
          : [
              { title:'Africa', url:'https://bucket.adaptatech.org/africa.mp4', thumb: IMG_BASE+'africa-image.png' },
              { title:'Binou',  url:'https://bucket.adaptatech.org/amyliz-slipperyfish.mp4', thumb: IMG_BASE+'binou.png' }
            ];
        showChooserFor(options, 'video');
        return;
      }

      if (msg.type === 'request_weather' || (msg.type === 'request_choice' && msg.group === 'weather')){
        locked = false;
        const options = Array.isArray(msg.options) && msg.options.length
          ? msg.options
          : [
              { title:'Soleil', key:'sun',   thumb: IMG_BASE+'sun.png'   },
              { title:'Nuages', key:'cloud', thumb: IMG_BASE+'cloud.png' },
              { title:'Pluie',  key:'rain',  thumb: IMG_BASE+'rain.png'  },
              { title:'Neige',  key:'snow',  thumb: IMG_BASE+'snow.png'  }
            ];
        showChooserFor(options, 'weather');
        return;
      }

      if (msg.type === 'stop_video' || msg.type === 'stop_weather'){
        hideChooser(); locked = false; return;
      }
    };

    ws.onerror = () => { setIndicator('off'); };
    ws.onclose = () => {
      setIndicator('off');
      hideChooser();
      clearTimers();
      connecting = false;
      scheduleReconnect();
    };
  }

  window.addEventListener('online', ()=>{ if(!ws || ws.readyState !== 1) connect(); });
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden && (!ws || ws.readyState !== 1)) connect(); });
  connect();

  console.log('[controller] PATH=', location.pathname, 'PRIMARY_PREFIX=', PRIMARY_PREFIX, 'IMG_BASE=', IMG_BASE, 'WS_URL=', WS_URL);

  /* ---------- Quick Menu wiring (unchanged behaviour) ---------- */
  const menuMask    = document.getElementById('menuMask');
  const quickMenu   = document.getElementById('quickMenu');
  const dwellSlider = document.getElementById('dwellSlider');
  const dwellVal    = document.getElementById('dwellVal');
  const btnClose    = document.getElementById('btnClose');
  const btnReset    = document.getElementById('btnReset');
  const themeToggle = document.getElementById('themeToggle');

  function openMenu(){
    dwellSlider.value = eyegazeSettings.dwellTime || DEFAULT_DWELL;
    dwellVal.textContent = dwellSlider.value;
    themeToggle.checked = document.body.classList.contains('theme-dark');
    menuMask.style.display = 'block';
    quickMenu.style.display = 'block';
    quickMenu.focus();
  }
  function closeMenu(){
    menuMask.style.display = 'none';
    quickMenu.style.display = 'none';
  }

  dwellSlider.addEventListener('input', ()=>{
    dwellVal.textContent = dwellSlider.value;
    setDwell(parseInt(dwellSlider.value,10));
  });
  themeToggle.addEventListener('change', ()=>{
    applyTheme(themeToggle.checked ? 'dark' : 'light');
  });
  btnClose.addEventListener('click', closeMenu);
  btnReset.addEventListener('click', ()=>{
    setDwell(DEFAULT_DWELL);
    applyTheme('dark'); // default preference – adjust if you prefer light
    loadPointerSettings();
    applyPointerStyles();
    openMenu(); // refresh displayed values
  });

  menuMask.addEventListener('click', closeMenu);

  window.addEventListener('keydown', (e)=>{
    if (e.key === 'm' || e.key === 'M'){
      e.preventDefault();
      (quickMenu.style.display === 'block') ? closeMenu() : openMenu();
    } else if (e.key === 'Escape'){
      if (quickMenu.style.display === 'block'){ e.preventDefault(); closeMenu(); }
    }
  });

  // Apply initial theme class to body
  document.body.classList.add('theme-' + readInitialTheme());

  /* =========================
     >>> Anti "pointeur figé" (12 px) <<<
     ========================= */
  let pointerTracker = { x: 0, y: 0, lastMove: 0 };
  const MOTION_ARM_PX = 12;          // seuil de micro-mouvement pour "armer"
  let needMotionArm = false;         // on exige un mouvement après affichage du chooser
  let motionArmed   = false;         // devient true après >= 12 px
  let armOrigin     = { x: 0, y: 0 };// position au moment d'afficher le chooser

  window.addEventListener('pointermove', (e) => {
    pointerTracker.x = e.clientX;
    pointerTracker.y = e.clientY;
    pointerTracker.lastMove = Date.now();

    if (needMotionArm && !motionArmed) {
      const dx = pointerTracker.x - armOrigin.x;
      const dy = pointerTracker.y - armOrigin.y;
      if ((dx*dx + dy*dy) >= (MOTION_ARM_PX * MOTION_ARM_PX)) {
        motionArmed = true; // la sélection par dwell est autorisée
      }
    }
  }, { passive: true });

  /* ---------- showChooserFor (on arme le filtre ici) ---------- */
  const _orig_showChooserFor = showChooserFor; // si déjà défini plus haut par hoisting
  function showChooserFor(options, mode){
    if (locked) return;
    currentMode = mode || 'video';

    // Armer l’anti-immobilité avant d’afficher
    needMotionArm = true;
    motionArmed = false;
    armOrigin.x = pointerTracker.x;
    armOrigin.y = pointerTracker.y;

    const opts = options.slice(0, 12);
    chooser.innerHTML = '';
    applyLayoutClass(opts.length);
    chooser.style.display = 'grid';
    chooser.setAttribute('aria-hidden','false');

    const fallbacks = currentMode==='weather'
      ? [IMG_BASE+'sun.png', IMG_BASE+'cloud.png', IMG_BASE+'rain.png', IMG_BASE+'snow.png']
      : [IMG_BASE+'africa-image.png', IMG_BASE+'binou.png'];

    opts.forEach((opt, i)=>{
      const card = document.createElement('div');
      card.className = 'card';
      card.setAttribute('role','button');
      card.setAttribute('tabindex','-1');
      const title = opt.title || `Choix ${i+1}`;
      card.setAttribute('aria-label', title);

      const key = (currentMode==='weather' ? (opt.key || opt.id || '').toLowerCase() : null);
      const normalized = normalizeThumb(opt.thumb, key) || fallbacks[i % fallbacks.length];

      const img = makeImg(normalized, title);
      card.appendChild(img);

      const send = ()=>{
        if (locked) return;
        locked = true; hideChooser();
        try {
          if (currentMode === 'weather') {
            window.__ws && window.__ws.send(JSON.stringify({
              type: 'weather_choice',
              key: key || '',
              title,
              goto: opt.goto || undefined,
              from: 'controller'
            }));
          } else {
            window.__ws && window.__ws.send(JSON.stringify({
              type: 'play_video',
              url: opt.url,
              title,
              from: 'controller'
            }));
          }
          pulseIndicator();
        } catch { locked = false; }
      };

      // >>> Seuil 12 px : ne pas démarrer le dwell tant que non armé
      const onEnter = ()=> { if(!locked && motionArmed) beginDwell(card, send); };
      const onLeave = ()=> cancelDwell(card);

      card.addEventListener('pointerenter', onEnter);
      card.addEventListener('pointerleave', onLeave);
      card.addEventListener('mouseenter', onEnter);
      card.addEventListener('mouseleave', onLeave);

      chooser.appendChild(card);
    });

    pointerState.showingChoices = opts.length > 0;
    applyPointerStyles();
  }
</script>
