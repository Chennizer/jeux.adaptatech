<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title
    class="translate"
    data-fr="Construction de ruche - Compétitif"
    data-en="Hive Builder - Competitive"
    data-ja="ハチの巣づくり：対戦モード">
    Construction de ruche - Compétitif
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Common styles (same file as other switch games) -->
  <link rel="stylesheet" href="../../css/otherswitch.css">

  <style>
    :root {
      --c1: #fbbf24; --c2: #d97706; --c3: #FFCA3A; --c4: #8AC926;
      --c5: #1982C4; --c6: #6A4C93; --c7: #B5179E; --c8: #2EC4B6;
      --gap: 3rem;
      --side-pad: 3rem;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      touch-action: manipulation;
    }

    /* -------- LANG BUTTON (copied from Window example) -------- */
    #langToggle {
      position: fixed;
      top: 14px;
      right: 44px;
      z-index: 11;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      border: 2px solid #04c8bb;
      background: #0b0f12;
      color: #04c8bb;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 0 0 0 rgba(4, 200, 187, 0);
      transition: box-shadow 0.2s ease, transform 0.05s ease, background 0.2s ease;
    }

    #langToggle:hover {
      box-shadow: 0 0 0 3px rgba(4, 200, 187, 0.2);
    }

    #langToggle:active {
      transform: translateY(1px);
    }

    /* -------- LANDING OVERLAY (same design as xylophone) -------- */
    #promptOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1rem;
      z-index: 10;
    }
    #promptOverlay p {
      font-size: 1.25rem;
      max-width: 80%;
      margin-bottom: 1.5rem;
    }
    #modeSelect {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
    }
    #modeSelect button {
      flex: 1;
      min-width: 120px;
      padding: 0.75rem 1rem;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 8px;
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    #modeSelect button:hover {
      background: rgba(255,255,255,0.2);
    }
    #modeSelect button.active {
      background: #00bfff;
      color: #000;
      font-weight: bold;
    }
    .goal-setting {
      margin: 0.5rem 0 1.25rem;
      display: flex;
      gap: 0.6rem;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    .goal-setting label {
      font-weight: 700;
      font-size: 1rem;
    }
    .goal-setting input[type="number"] {
      width: 72px;
      padding: 0.4rem 0.5rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: 1rem;
      text-align: center;
    }
    #editPlayers {
      display: none;
      padding: 0.65rem 1rem;
      background: rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      margin-bottom: 1rem;
    }
    #promptOverlay button#startButton {
      padding: 1rem 2rem;
      font-size: 1.25rem;
      margin-top: 1rem;
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }

    /* -------- Player Modal -------- */
    #playerConfigModal {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 12;
    }
    #playerConfigModal .modal-content {
      background: #0f172a;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 14px;
      padding: 1.5rem;
      width: min(720px, 90vw);
      box-shadow: 0 15px 40px rgba(0,0,0,0.5);
    }
    #playerConfigModal h3 {
      margin-bottom: 1rem;
      font-size: 1.25rem;
      text-align: center;
    }
    .player-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }
    .player-card {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 1rem;
    }
    .player-card label {
      display: block;
      margin-bottom: 0.35rem;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .player-card input[type="text"] {
      width: 100%;
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: #0b1220;
      color: #fff;
      font-size: 1rem;
    }
    .player-card input[type="color"] {
      width: 100%;
      height: 42px;
      border: none;
      border-radius: 8px;
      padding: 0;
      background: #0b1220;
      cursor: pointer;
    }
    .modal-actions {
      margin-top: 1rem;
      text-align: center;
      display: flex;
      gap: 0.75rem;
      justify-content: center;
    }
    #goalDisplay {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.45rem 0.9rem;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px;
      font-weight: 700;
      letter-spacing: 0.02em;
      z-index: 9;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    }
    #endBanner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.92);
      padding: 1rem 1.5rem;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: 800;
      letter-spacing: 0.03em;
      color: #fefefe;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 10;
    }
    #endBanner.visible {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    .modal-actions button {
      padding: 0.75rem 1.6rem;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      font-weight: 700;
    }

    /* -------- GAME CANVAS -------- */
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .controls-hint {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
      line-height: 1.6;
    }
    .key {
      display: inline-block;
      padding: 2px 6px;
      border: 1px solid #666;
      border-radius: 4px;
      background: #222;
      font-family: monospace;
      color: #fbbf24;
    }
  </style>
</head>

<body>
  <!-- Language toggle button -->
  <button id="langToggle" title="Changer de langue / Change language">FR / EN / JA</button>

  <!-- Landing overlay -->
  <div id="promptOverlay">
    <p class="translate"
       data-fr="Choisissez un mode puis appuyez sur Commencer."
       data-en="Select a mode then press Start."
       data-ja="モードを選んで「開始」を押してください。">
      Choisissez un mode puis appuyez sur Commencer.
    </p>

    <div id="modeSelect">
      <button data-mode="1p" class="active">
        <span class="translate"
              data-fr="1 joueur"
              data-en="1 player"
              data-ja="1人プレイ">1 joueur</span>
      </button>
      <button data-mode="2p">
        <span class="translate"
              data-fr="2 joueurs"
              data-en="2 players"
              data-ja="2人プレイ">2 joueurs</span>
      </button>
    </div>

    <div class="goal-setting">
      <label for="tripGoalInput" class="translate"
             data-fr="Allers-retours requis :"
             data-en="Flower trips needed:"
             data-ja="花への往復回数：">
        Allers-retours requis :
      </label>
      <input id="tripGoalInput" type="number" min="1" max="15" value="5">
    </div>

    <div id="controlsText" class="controls-hint">
      <span class="translate"
            data-fr="Construisez la plus grande ruche !"
            data-en="Build the biggest hive!"
            data-ja="いちばん大きなハチの巣を作ろう！">
        Construisez la plus grande ruche !
      </span>
      <br>
      <span class="translate"
            data-fr="Joueur 1 : appuyez sur"
            data-en="Player 1: Press"
            data-ja="プレイヤー1：押すキー">
        Joueur 1 : appuyez sur
      </span>
      <span class="key">SPACE</span>
      <br>
      <span id="p2hint" style="display:none;">
        <span class="translate"
              data-fr="Joueur 2 : appuyez sur"
              data-en="Player 2: Press"
              data-ja="プレイヤー2：押すキー">
          Joueur 2 : appuyez sur
        </span>
        <span class="key">ENTER</span>
      </span>
    </div>

    <button id="editPlayers">Configurer les joueurs</button>

    <button id="startButton" class="translate"
            data-fr="Commencer"
            data-en="Start"
            data-ja="開始">
      Commencer
    </button>
  </div>

  <div id="playerConfigModal">
    <div class="modal-content">
      <h3>Configurer les joueurs</h3>
      <div class="player-grid">
        <div class="player-card">
          <label for="p1Name">Nom du joueur 1</label>
          <input id="p1Name" type="text" value="Joueur 1" maxlength="20">
          <label for="p1Color" style="margin-top:0.75rem;">Couleur du miel</label>
          <input id="p1Color" type="color" value="#fbbf24">
        </div>
        <div class="player-card">
          <label for="p2Name">Nom du joueur 2</label>
          <input id="p2Name" type="text" value="Joueur 2" maxlength="20">
          <label for="p2Color" style="margin-top:0.75rem;">Couleur du miel</label>
          <input id="p2Color" type="color" value="#6a4c93">
        </div>
      </div>
      <div class="modal-actions">
        <button id="closeModal">Fermer</button>
        <button id="savePlayers">Enregistrer</button>
      </div>
    </div>
  </div>

  <canvas id="simCanvas"></canvas>
  <div id="goalDisplay"></div>
  <div id="endBanner" aria-live="polite"></div>
  <div id="restartHint" class="controls-hint" style="display:none;">
    <span class="translate"
          data-fr="Maintenez votre contacteur pour recommencer"
          data-en="Hold your switch to restart"
          data-ja="スイッチを長押しして再スタート">Hold your switch to restart</span>
  </div>

  <script>
    /**
     * CONFIGURATION & ASSETS (original game logic)
     */
    const COLORS = {
      bgLeft: '#120a02',
      bgRight: '#4a7c25', // Green
      bgDark: '#120a02',  // Dark
      hexBorderLight: '#ffd700',
      hexBorderDark: '#b45309',
      waxBase: '#fbbf24',
      waxDeep: '#78350f',
      beeYellowBright: '#ffdf00',
      beeYellowDark: '#c7a008',
      beeBlack: '#0a0a0a'
    };

    const playerConfigs = [
      { name: 'Joueur 1', color: COLORS.waxBase },
      { name: 'Joueur 2', color: '#6a4c93' }
    ];

    // ----- Color helpers -----
    function hexToRgb(hex) {
      const cleaned = hex.replace('#','');
      const bigint = parseInt(cleaned, 16);
      return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }

    function rgbToHex(r, g, b) {
      const toHex = (c) => c.toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function mixHex(base, target, amount) {
      const a = hexToRgb(base);
      const b = hexToRgb(target);
      const clamp = (v) => Math.max(0, Math.min(255, v));
      return rgbToHex(
        clamp(Math.round(a.r + (b.r - a.r) * amount)),
        clamp(Math.round(a.g + (b.g - a.g) * amount)),
        clamp(Math.round(a.b + (b.b - a.b) * amount))
      );
    }

    function createWaxTexture(baseColor) {
      const canvasPattern = document.createElement('canvas');
      canvasPattern.width = 128;
      canvasPattern.height = 128;
      const pCtx = canvasPattern.getContext('2d');

      const deep = mixHex(baseColor, '#000000', 0.45);
      const waxGrad = pCtx.createRadialGradient(64,64,0, 64,64,90);
      waxGrad.addColorStop(0, baseColor);
      waxGrad.addColorStop(1, deep);
      pCtx.fillStyle = waxGrad;
      pCtx.fillRect(0,0,128,128);

      for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 128;
        const y = Math.random() * 128;
        const alpha = Math.random() * 0.25;
        const light = mixHex(baseColor, '#ffffff', 0.4);
        const dark = mixHex(baseColor, '#000000', 0.6);
        const lightRgb = hexToRgb(light);
        const darkRgb = hexToRgb(dark);
        pCtx.fillStyle = Math.random() > 0.5
          ? `rgba(${lightRgb.r}, ${lightRgb.g}, ${lightRgb.b}, ${alpha})`
          : `rgba(${darkRgb.r}, ${darkRgb.g}, ${darkRgb.b}, ${alpha})`;
        pCtx.beginPath();
        pCtx.arc(x, y, Math.random()*1.5, 0, Math.PI*2);
        pCtx.fill();
      }
      return pCtx.createPattern(canvasPattern, 'repeat');
    }

    // ----- Canvas Setup -----
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    let width, height;

    // ----- Game State -----
    let gameRunning = false;
    let gameMode = '1p'; // '1p' or '2p'
    let gameEnded = false;
    let tripGoal = 5;

    // Hives and other entities
    let hives = [];
    const flowers = [];
    const particles = [];

    let hexRadius = 45;

    // ----- DOM Elements for Menu -----
    const modeButtons = document.querySelectorAll('#modeSelect button');
    const p2Hint = document.getElementById('p2hint');
    const startButton = document.getElementById('startButton');
    const overlay = document.getElementById('promptOverlay');
    const editPlayersBtn = document.getElementById('editPlayers');
    const playerModal = document.getElementById('playerConfigModal');
    const p1NameInput = document.getElementById('p1Name');
    const p2NameInput = document.getElementById('p2Name');
    const p1ColorInput = document.getElementById('p1Color');
    const p2ColorInput = document.getElementById('p2Color');
    const closeModalBtn = document.getElementById('closeModal');
    const savePlayersBtn = document.getElementById('savePlayers');
    const langToggle = document.getElementById('langToggle');
    const tripGoalInput = document.getElementById('tripGoalInput');
    const goalDisplay = document.getElementById('goalDisplay');
    const endBanner = document.getElementById('endBanner');
    const restartHint = document.getElementById('restartHint');

    // Audio placeholders
    const buttonPlaylist = [
      '../../sounds/startactivity.mp3',
      '../../sounds/spacewalk.mp3'
    ];
    let buttonMusic;
    let buttonTrackIndex = 0;
    const finishSound = new Audio('../../sounds/victory.mp3');
    finishSound.volume = 0.5;

    // ----- UI Logic -----
    function applyPlayerConfig() {
      playerConfigs[0].name = (p1NameInput.value || 'Joueur 1').trim() || 'Joueur 1';
      playerConfigs[1].name = (p2NameInput.value || 'Joueur 2').trim() || 'Joueur 2';
      playerConfigs[0].color = p1ColorInput.value || playerConfigs[0].color;
      playerConfigs[1].color = p2ColorInput.value || playerConfigs[1].color;
    }

    function openPlayerModal() {
      p1NameInput.value = playerConfigs[0].name;
      p2NameInput.value = playerConfigs[1].name;
      p1ColorInput.value = playerConfigs[0].color;
      p2ColorInput.value = playerConfigs[1].color;
      playerModal.style.display = 'flex';
    }

    function closePlayerModal() {
      playerModal.style.display = 'none';
    }

    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        p2Hint.style.display = (gameMode === '2p') ? 'inline' : 'none';
        editPlayersBtn.style.display = (gameMode === '2p') ? 'inline-block' : 'none';
        if (gameMode === '2p') openPlayerModal();
        else closePlayerModal();
      });
    });

    editPlayersBtn.addEventListener('click', openPlayerModal);
    closeModalBtn.addEventListener('click', closePlayerModal);
    savePlayersBtn.addEventListener('click', () => {
      applyPlayerConfig();
      closePlayerModal();
    });

    function readTripGoal() {
      const value = parseInt(tripGoalInput.value, 10);
      if (isNaN(value)) return 5;
      return Math.min(15, Math.max(1, value));
    }

    function updateGoalDisplay() {
      if (!gameRunning) return;
      const goalText = [];
      if (gameMode === '1p' && hives[0]) {
        goalText.push(`${playerConfigs[0].name}: ${Math.min(hives[0].voyagesCompleted, tripGoal)}/${tripGoal}`);
      }
      if (gameMode === '2p' && hives.length === 2) {
        goalText.push(`${playerConfigs[0].name}: ${Math.min(hives[0].voyagesCompleted, tripGoal)}/${tripGoal}`);
        goalText.push(`${playerConfigs[1].name}: ${Math.min(hives[1].voyagesCompleted, tripGoal)}/${tripGoal}`);
      }
      goalDisplay.textContent = goalText.join('  •  ');
    }

    function endGame(message) {
      gameEnded = true;
      endBanner.textContent = message;
      endBanner.className = 'visible';
      restartHint.style.display = 'block';
    }

    function checkGameEnd() {
      if (gameMode === '1p') {
        if (hives[0] && hives[0].finished) {
          endGame(`${playerConfigs[0].name} a terminé sa ruche !`);
        }
        return;
      }
      if (hives.length === 2 && hives[0].finished && hives[1].finished) {
        endGame('Les deux ruches sont complètes !');
      }
    }

    function startButtonMusic() {
      if (!buttonMusic) {
        buttonMusic = new Audio(buttonPlaylist[buttonTrackIndex]);
        buttonMusic.volume = 0.35;
        buttonMusic.addEventListener('ended', () => {
          buttonTrackIndex = (buttonTrackIndex + 1) % buttonPlaylist.length;
          buttonMusic.src = buttonPlaylist[buttonTrackIndex];
          buttonMusic.play().catch(()=>{});
        });
      }
      if (buttonMusic.paused) {
        buttonMusic.play().catch(()=>{});
      }
    }

    let restartHoldTimer = null;
    const RESTART_HOLD_MS = 3000;

    function cancelRestartHold() {
      if (restartHoldTimer) {
        clearTimeout(restartHoldTimer);
        restartHoldTimer = null;
      }
    }

    function beginGame() {
      overlay.style.display = 'none';
      gameRunning = true;
      gameEnded = false;
      endBanner.className = '';
      restartHint.style.display = 'none';
      cancelRestartHold();
      langToggle?.remove();
      initGame();
      updateGoalDisplay();
    }

    startButton.addEventListener('click', (e) => {
      e.preventDefault();
      applyPlayerConfig();
      tripGoal = readTripGoal();
      tripGoalInput.value = tripGoal;

      // Fullscreen request (like your other games)
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(()=>{});
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
      }

      closePlayerModal();
      beginGame();
    });

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * window.devicePixelRatio;
      canvas.height = height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      // If game is running, re-init to adjust positions
      if (gameRunning) initGame();
    }
    window.addEventListener('resize', resize);

    // ----- HIVE CLASS -----
    class Hive {
      constructor(centerX, isRightSide, options = {}) {
        this.centerX = centerX;
        this.centerY = height * 0.5;
        this.isRightSide = isRightSide;
        this.label = options.name || 'Joueur';
        this.waxColor = options.color || COLORS.waxBase;
        this.waxPattern = createWaxTexture(this.waxColor);
        this.borderLight = mixHex(this.waxColor, '#ffffff', 0.35);
        this.borderDark = mixHex(this.waxColor, '#000000', 0.4);
        this.beeAccentLight = mixHex(this.waxColor, '#ffffff', 0.25);
        this.beeAccentDeep = mixHex(this.waxColor, '#000000', 0.35);
        this.cells = [];
        this.bees = [];
        this.occupiedMap = new Set();
        this.reservedMap = new Set();
        this.voyagesCompleted = 0;
        this.voyageLogged = false;
        this.finishing = false;
        this.finished = false;

        // Initial Cell
        this.addCell(0,0);

        // Initial Bees
        for(let i=0; i<6; i++) this.bees.push(this.createBee());
      }

      hexToPixel(q, r) {
        // Pointy topped hex math
        const x = this.centerX + hexRadius * (3/2 * q);
        const y = this.centerY + hexRadius * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
        return { x, y };
      }

      addCell(q, r) {
        const pos = this.hexToPixel(q, r);
        this.cells.push({
          q, r, x: pos.x, y: pos.y,
          scale: 0,
          variation: Math.random(),
          wobble: Math.random() * Math.PI*2
        });
        const key = `${q},${r}`;
        this.occupiedMap.add(key);
        if(this.reservedMap.has(key)) this.reservedMap.delete(key);
      }

      findNextBuildSpot() {
        const HEX_DIRECTIONS = [
          {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
          {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
        ];

        // Spiral search
        let queue = [{q:0, r:0}];
        let visited = new Set(['0,0']);
        let iterations = 0;

        while (queue.length > 0 && iterations < 3000) {
          iterations++;
          let current = queue.shift();
          for (let dir of HEX_DIRECTIONS) {
            let nq = current.q + dir.q;
            let nr = current.r + dir.r;
            let key = `${nq},${nr}`;

            if (!visited.has(key)) {
              visited.add(key);
              if (!this.occupiedMap.has(key) && !this.reservedMap.has(key)) {
                return { q: nq, r: nr };
              }
              if (this.occupiedMap.has(key)) {
                queue.push({q: nq, r: nr});
              }
            }
          }
        }
        return null;
      }

      createBee() {
        const home = this.hexToPixel(0, 0);
        return {
          x: home.x + (Math.random()-0.5)*50,
          y: home.y + (Math.random()-0.5)*50,
          vx: 0, vy: 0,
          state: 'idle',
          target: null,
          targetGrid: null,
          angle: this.isRightSide ? Math.PI : 0, // Face center initially
          wobblePhase: Math.random() * Math.PI * 2,
          wingSpeed: 1,
          sizeScale: 1.3 + Math.random() * 0.4,
          accentLight: this.beeAccentLight,
          accentDeep: this.beeAccentDeep
        };
      }

      sendBees() {
        if (this.finished || this.finishing) return;
        let launched = false;
        this.bees.forEach(b => {
          if (b.state === 'idle' && flowers.length > 0) {
            b.state = 'outbound';
            b.wingSpeed = 3.5;
            const flower = flowers[Math.floor(Math.random() * flowers.length)];
            const bloom = getFlowerBloom(flower);
            b.target = {
              x: bloom.x + (Math.random()-0.5)*10,
              y: bloom.y + (Math.random()-0.5)*10 - 15
            };
            launched = true;
          }
        });

        // A voyage counts once per launch input, not per individual bee.
        if (launched) {
          this.voyageLogged = false;
        }
      }

      update(dt) {
        // Animate Cells
        this.cells.forEach(c => {
          if (c.scale < 1) c.scale += (1 - c.scale) * 0.1;
        });

        // Update Bees
        const homeCenter = this.hexToPixel(0,0);

        this.bees.forEach(b => {
          b.wobblePhase += dt * 5 * b.wingSpeed;

          if (b.state === 'idle') {
            b.wingSpeed = 1;
            // Hover near center of hive
            const hoverX = homeCenter.x + Math.cos(b.wobblePhase*0.2)*70;
            const hoverY = homeCenter.y + Math.sin(b.wobblePhase*0.3)*50;
            const dx = hoverX - b.x;
            const dy = hoverY - b.y;
            b.x += dx * 0.03;
            b.y += dy * 0.03;

            // Face towards center (flowers)
            const desiredAngle = this.isRightSide ? Math.PI : 0;
            let angleDiff = desiredAngle - b.angle;
            if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
            if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
            b.angle += angleDiff * 0.05;
          }
          else {
            const dx = b.target.x - b.x;
            const dy = b.target.y - b.y;
            const dist = Math.hypot(dx, dy);
            const speed = 180 * dt;

            if (dist < 20) {
              if (b.state === 'outbound') {
                if (!this.finished && !this.voyageLogged) {
                  this.voyagesCompleted = Math.min(tripGoal, this.voyagesCompleted + 1);
                  this.voyageLogged = true;
                  if (this.voyagesCompleted >= tripGoal) {
                    this.finishing = true;
                  }
                  updateGoalDisplay();
                }
                b.state = 'returning';
                const nextSpot = this.findNextBuildSpot();
                if (nextSpot) {
                  this.reservedMap.add(`${nextSpot.q},${nextSpot.r}`);
                  b.targetGrid = nextSpot;
                  b.target = this.hexToPixel(nextSpot.q, nextSpot.r);
                } else {
                  b.target = homeCenter;
                  b.targetGrid = null;
                }
                spawnParticles(b.x, b.y, ['#fff', this.borderLight]);
              } else if (b.state === 'returning') {
                b.state = 'idle';
                if (b.targetGrid) {
                  this.addCell(b.targetGrid.q, b.targetGrid.r);
                  b.targetGrid = null;
                }
                spawnParticles(b.x, b.y, [this.borderLight, this.waxColor]);
              }
            } else {
              b.vx = (dx/dist) * speed;
              b.vy = (dy/dist) * speed;
              b.x += b.vx;
              b.y += b.vy;
              const targetAngle = Math.atan2(dy, dx);
              let angleDiff = targetAngle - b.angle;
              if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
              if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
              b.angle += angleDiff * 0.15;
            }
          }
        });

        if (this.finishing && !this.finished) {
          const allHome = this.bees.every(b => b.state === 'idle');
          if (allHome) {
            this.finished = true;
            this.finishing = false;
            finishSound.currentTime = 0;
            finishSound.play().catch(()=>{});
            checkGameEnd();
          }
        }
      }

      draw(ctx) {
        // Draw Shadows/Base
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 25;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 10;
        this.cells.forEach(c => drawOrganicHexBase(c.x, c.y, hexRadius * c.scale, c.wobble));
        ctx.restore();

        // Draw Cells
        this.cells.forEach(c => drawOrganicHexDetail(
          c.x,
          c.y,
          hexRadius * c.scale,
          c.variation,
          c.wobble,
          this.waxPattern,
          this.borderLight,
          this.borderDark
        ));

        // Draw Bees
        this.bees.forEach(b => drawBee(b));
      }
    }

    // ----- Logic Initialization -----
    function initGame() {
      hives = [];
      flowers.length = 0;
      particles.length = 0;

      if (gameMode === '1p') {
        // 1 Player: Hive Left (20%), Flowers Right
        hives.push(new Hive(width * 0.2, false, playerConfigs[0]));
        generateFlowers(width * 0.4, width * 0.95);
      } else {
        // 2 Player: Hive Left (15%), Hive Right (85%), Flowers Middle
        hives.push(new Hive(width * 0.15, false, playerConfigs[0])); // P1
        hives.push(new Hive(width * 0.85, true, playerConfigs[1]));  // P2
        generateFlowers(width * 0.35, width * 0.65);
      }
    }

    function getFieldZone() {
      if (gameMode === '1p') {
        const startX = width * 0.4;
        return { startX, zoneWidth: width - startX };
      }
      const startX = width * 0.3;
      return { startX, zoneWidth: width * 0.4 };
    }

    // ----- Flower Generation -----
    function generateFlowers(minX, maxX) {
      const count = 25;
      const daisyPalette = ['#ffb4e6', '#ffd6a5', '#c1fba4', '#b5dfff'];
      const tulipPalette = ['#ff7aa2', '#ff9f1c', '#ffcad4', '#c99bff'];

      for(let i=0; i<count; i++) {
        const type = Math.random() > 0.5 ? 'daisy' : 'tulip';
        const size = 12 + Math.random() * 10;
        const stemHeight = 90 + Math.random() * 70;
        flowers.push({
          x: minX + Math.random() * (maxX - minX),
          stemHeight,
          type: type,
          colorMain: type === 'daisy'
            ? daisyPalette[Math.floor(Math.random()*daisyPalette.length)]
            : tulipPalette[Math.floor(Math.random()*tulipPalette.length)],
          colorCenter: type === 'daisy' ? '#f6c453' : '#ffd166',
          size,
          stemCurve: (Math.random() - 0.5) * 80
        });
      }
    }

    // ----- Controls -----
    function restartGame() {
      if (!gameEnded) return;
      beginGame();
    }

    window.addEventListener('keydown', (e) => {
      if (gameEnded) {
        if (e.code === 'Space') {
          e.preventDefault();
          if (!restartHoldTimer) {
            restartHoldTimer = setTimeout(() => restartGame(), RESTART_HOLD_MS);
          }
        }
        return;
      }
      if (!gameRunning) return;

      // Player 1 (Space)
      if (e.code === 'Space') {
        e.preventDefault();
        startButtonMusic();
        hives[0].sendBees();
      }

      // Player 2 (Enter) - Only in 2p mode
      if (e.code === 'Enter' && gameMode === '2p') {
        e.preventDefault();
        startButtonMusic();
        hives[1].sendBees();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (gameEnded && e.code === 'Space') {
        cancelRestartHold();
      }
    });

    // Touch/Mouse fallback (Triggers both or P1)
    window.addEventListener('mousedown', () => {
      if(!gameRunning || gameEnded) return;
      startButtonMusic();
      hives[0].sendBees();
      if(gameMode === '2p') hives[1].sendBees();
    });

    // ----- Particles -----
    function spawnParticles(x, y, colorPalette) {
      for(let i=0; i<15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 80;
        const size = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.0,
          decay: 0.8 + Math.random()*0.5,
          color: colorPalette[Math.floor(Math.random()*colorPalette.length)],
          size
        });
      }
    }

    // ----- Main Update -----
    function update(dt) {
      hives.forEach(h => h.update(dt));

      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 80 * dt;
        p.life -= dt * p.decay;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // ----- Drawing -----
    function draw() {
      // 1. Draw Background Zones
      let layoutInfo;
      if (gameMode === '1p') {
        const splitX = width * 0.4;
        layoutInfo = { type: '1p', splitX };
        ctx.fillStyle = COLORS.bgLeft;
        ctx.fillRect(0, 0, splitX, height);
        drawFieldBackdrop(splitX, width - splitX);
      } else {
        // 2 Player Background: Dark | Lush Field | Dark
        const leftEdge = width * 0.3;
        const rightEdge = width * 0.7;
        layoutInfo = { type: '2p', leftEdge, rightEdge };

        // Left Hive
        ctx.fillStyle = COLORS.bgDark;
        ctx.fillRect(0, 0, leftEdge, height);

        // Right Hive
        ctx.fillStyle = COLORS.bgDark;
        ctx.fillRect(rightEdge, 0, width - rightEdge, height);

        // Middle Field
        drawFieldBackdrop(leftEdge, rightEdge - leftEdge);
      }

      drawPlayerLabels(layoutInfo);
      drawFlowers();
      hives.forEach(h => h.draw(ctx));
      drawParticles();
    }

    function drawPlayerLabels(layoutInfo) {
      if (!layoutInfo) return;
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = '700 18px sans-serif';

      if (layoutInfo.type === '2p') {
        const padY = 16;
        const leftX = layoutInfo.leftEdge * 0.5;
        const rightX = layoutInfo.rightEdge + (width - layoutInfo.rightEdge) * 0.5;

        [{x: leftX, config: playerConfigs[0]}, {x: rightX, config: playerConfigs[1]}].forEach(({x, config}) => {
          const badgeWidth = 210;
          const badgeHeight = 46;
          const radius = 12;
          const left = x - badgeWidth * 0.5;
          const top = padY;
          const labelY = top + badgeHeight * 0.5;
          const accentBright = mixHex(config.color, '#ffffff', 0.35);
          const accentDark = mixHex(config.color, '#000000', 0.45);

          ctx.save();
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.font = '700 18px "Segoe UI", "Nunito", sans-serif';

          // Badge shell
          ctx.beginPath();
          ctx.moveTo(left + radius, top);
          ctx.lineTo(left + badgeWidth - radius, top);
          ctx.quadraticCurveTo(left + badgeWidth, top, left + badgeWidth, top + radius);
          ctx.lineTo(left + badgeWidth, top + badgeHeight - radius);
          ctx.quadraticCurveTo(left + badgeWidth, top + badgeHeight, left + badgeWidth - radius, top + badgeHeight);
          ctx.lineTo(left + radius, top + badgeHeight);
          ctx.quadraticCurveTo(left, top + badgeHeight, left, top + badgeHeight - radius);
          ctx.lineTo(left, top + radius);
          ctx.quadraticCurveTo(left, top, left + radius, top);
          ctx.closePath();

          ctx.shadowColor = 'rgba(0,0,0,0.35)';
          ctx.shadowBlur = 12;
          ctx.fillStyle = 'rgba(0,0,0,0.55)';
          ctx.fill();

          const shine = ctx.createLinearGradient(left, top, left + badgeWidth, top + badgeHeight);
          shine.addColorStop(0, mixHex(config.color, '#ffffff', 0.18));
          shine.addColorStop(1, mixHex(config.color, '#000000', 0.35));
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = shine;
          ctx.fill();
          ctx.globalAlpha = 1;

          ctx.lineWidth = 2;
          ctx.strokeStyle = accentBright;
          ctx.stroke();

          // Accent circle
          ctx.beginPath();
          ctx.shadowColor = accentDark;
          ctx.shadowBlur = 8;
          ctx.fillStyle = config.color;
          ctx.arc(left + 22, labelY, 11, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = accentBright;
          ctx.stroke();

          // Player name
          ctx.fillStyle = '#fdfdfd';
          ctx.shadowColor = 'rgba(0,0,0,0.45)';
          ctx.shadowBlur = 4;
          ctx.fillText(config.name, left + 44, labelY);
          ctx.shadowBlur = 0;
          ctx.restore();
        });
      }

      ctx.restore();
    }

    function groundHeightAt(x) {
      const { startX, zoneWidth } = getFieldZone();
      const baseY = height * 0.86;
      const relX = Math.max(0, Math.min(zoneWidth, x - startX));
      const midX = zoneWidth * 0.5;

      if (relX <= midX) {
        const t = relX / midX;
        const p0 = baseY + 20;
        const p1 = baseY - 40;
        const p2 = baseY;
        return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
      }

      const t = (relX - midX) / (zoneWidth - midX);
      const p0 = baseY;
      const p1 = baseY + 40;
      const p2 = baseY - 10;
      return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
    }

    function drawFieldBackdrop(startX, zoneWidth) {
      const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
      skyGrad.addColorStop(0, '#cde9ff');
      skyGrad.addColorStop(0.6, '#93d2ff');
      skyGrad.addColorStop(1, '#7fc8ff');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(startX, 0, zoneWidth, height);

      // Sun glow
      const sunX = startX + zoneWidth * 0.18;
      const sunY = height * 0.18;
      const sunRadius = Math.min(120, zoneWidth * 0.25);
      const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);
      sunGrad.addColorStop(0, 'rgba(255, 240, 180, 0.95)');
      sunGrad.addColorStop(0.5, 'rgba(255, 220, 120, 0.75)');
      sunGrad.addColorStop(1, 'rgba(255, 200, 80, 0)');
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();

      // Grass hill similar to the plants game
      const groundY = height * 0.86;
      ctx.save();
      ctx.translate(startX, 0);
      ctx.fillStyle = '#5fb34b';
      ctx.beginPath();
      ctx.moveTo(0, groundY + 20);
      ctx.quadraticCurveTo(zoneWidth * 0.25, groundY - 40, zoneWidth * 0.5, groundY);
      ctx.quadraticCurveTo(zoneWidth * 0.8, groundY + 40, zoneWidth, groundY - 10);
      ctx.lineTo(zoneWidth, height);
      ctx.lineTo(0, height);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      for (let i = 0; i < zoneWidth; i += 80) {
        const ripple = Math.sin((i + startX) * 0.01) * 8;
        ctx.beginPath();
        ctx.ellipse(i + 30, groundY - 25 + ripple, 50, 14, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function getFlowerBloom(f) {
      const groundY = groundHeightAt(f.x);
      return {
        x: f.x + f.stemCurve,
        y: groundY - f.stemHeight
      };
    }

    function drawLeaf(x, y, w, h, angle, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-w * 0.4, -h * 0.2, 0, -h);
      ctx.quadraticCurveTo(w * 0.4, -h * 0.2, 0, 0);
      ctx.fill();
      ctx.restore();
    }

    function drawFlowers() {
      const leafColor = '#3b7a2a';

      flowers.forEach(f => {
        const groundY = groundHeightAt(f.x);
        const bloomY = groundY - f.stemHeight;
        const controlY = groundY - f.stemHeight * 0.55;
        const sway = f.stemCurve;

        // Stem
        ctx.beginPath();
        ctx.moveTo(f.x, groundY);
        ctx.quadraticCurveTo(f.x + sway * 0.35, controlY, f.x + sway, bloomY);
        ctx.strokeStyle = '#2d5e1c';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Leaves
        const leafY = groundY - f.stemHeight * 0.45;
        drawLeaf(f.x + sway * 0.15, leafY, f.size * 2.2, f.size * 1.8, -0.9, leafColor);
        drawLeaf(f.x + sway * 0.05, leafY - f.size * 3, f.size * 2.4, f.size * 1.6, 1.1, leafColor);

        // Flower heads inspired by the plants game
        if (f.type === 'daisy') {
          const petalCount = 12;
          for(let i=0; i<petalCount; i++) {
            const angle = (Math.PI*2 / petalCount) * i;
            ctx.fillStyle = f.colorMain;
            ctx.beginPath();
            ctx.ellipse(
              f.x + sway + Math.cos(angle)*f.size*1.2,
              bloomY + Math.sin(angle)*f.size*1.2,
              f.size*1.1,
              f.size*0.6,
              angle,
              0, Math.PI*2
            );
            ctx.fill();
          }
          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.arc(f.x + sway, bloomY, f.size*0.9, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.35)';
          ctx.beginPath();
          ctx.arc(f.x + sway - f.size*0.2, bloomY - f.size*0.2, f.size*0.3, 0, Math.PI*2);
          ctx.fill();
        }
        else if (f.type === 'tulip') {
          const baseX = f.x + sway;
          ctx.fillStyle = f.colorMain;
          ctx.beginPath();
          ctx.moveTo(baseX, bloomY + f.size*1.4);
          ctx.bezierCurveTo(
            baseX - f.size*2.2, bloomY,
            baseX - f.size*0.8, bloomY - f.size*2.2,
            baseX, bloomY - f.size
          );
          ctx.bezierCurveTo(
            baseX + f.size*0.8, bloomY - f.size*2.2,
            baseX + f.size*2.2, bloomY,
            baseX, bloomY + f.size*1.4
          );
          ctx.fill();

          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.ellipse(
            baseX, bloomY - f.size,
            f.size*0.6, f.size*0.35,
            0, 0, Math.PI*2
          );
          ctx.fill();
        }
      });
    }

    function getHexPath(x, y, r, wobbleOffset) {
      const path = new Path2D();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i + Math.PI/6;
        const nextAngle = (Math.PI / 3) * (i+1) + Math.PI/6;
        const r1 = r + Math.sin(wobbleOffset + i)*r*0.05;
        const r2 = r + Math.sin(wobbleOffset + i+1)*r*0.05;
        const px1 = x + r1 * Math.cos(angle);
        const py1 = y + r1 * Math.sin(angle);
        const px2 = x + r2 * Math.cos(nextAngle);
        const py2 = y + r2 * Math.sin(nextAngle);

        if (i === 0) path.moveTo(px1, py1);
        const cpX = (px1 + px2) / 2 + Math.cos(angle+Math.PI/6)*r*0.1;
        const cpY = (py1 + py2) / 2 + Math.sin(angle+Math.PI/6)*r*0.1;
        path.quadraticCurveTo(cpX, cpY, px2, py2);
      }
      path.closePath();
      return path;
    }

    function drawOrganicHexBase(x, y, r, wobble) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);
      ctx.fillStyle = COLORS.bgDark; // Use dark background for base
      ctx.fill(path);
    }

    function drawOrganicHexDetail(x, y, r, variance, wobble, pattern, borderLight, borderDark) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);

      ctx.save();
      ctx.fillStyle = pattern;
      ctx.fill(path);
      ctx.fillStyle = `rgba(255, 220, 0, ${variance * 0.2})`;
      ctx.fill(path);

      ctx.clip(path);
      const grad = ctx.createRadialGradient(x, y, 0, x, y, r*1.2);
      grad.addColorStop(0, 'rgba(255, 240, 150, 0.3)');
      grad.addColorStop(0.6, borderLight);
      grad.addColorStop(1, borderDark);
      ctx.fillStyle = grad;
      ctx.fillRect(x-r*2, y-r*2, r*4, r*4);

      ctx.lineWidth = r * 0.1;
      ctx.strokeStyle = 'rgba(50, 20, 0, 0.5)';
      ctx.stroke(path);
      ctx.restore();

      ctx.lineCap = 'round';
      ctx.lineWidth = r * 0.15;
      ctx.strokeStyle = borderDark;
      ctx.stroke(path);

      const pathHighlight = getHexPath(x-r*0.02, y-r*0.05, r*0.98, wobble);
      ctx.lineWidth = r * 0.05;
      ctx.strokeStyle = borderLight;
      ctx.stroke(pathHighlight);
    }

    function drawBee(b) {
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);
      ctx.scale(b.sizeScale, b.sizeScale);

      const accentLight = b.accentLight || COLORS.beeYellowBright;
      const accentDeep = b.accentDeep || mixHex(accentLight, '#000000', 0.45);
      const abdomenBright = mixHex(accentLight, COLORS.beeYellowBright, 0.5);
      const abdomenDark = mixHex(accentDeep, COLORS.beeYellowDark, 0.5);

      const wingCycle = Math.sin(b.wobblePhase*1.5);

      // Legs/Antennae (Behind)
      ctx.strokeStyle = COLORS.beeBlack;
      ctx.lineCap = 'round';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, -3); ctx.lineTo(18, -6);
      ctx.moveTo(10,  3); ctx.lineTo(18,  6);
      ctx.stroke();
      ctx.fillStyle = COLORS.beeBlack;
      ctx.beginPath(); ctx.arc(18,-6, 2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(18, 6, 2, 0, Math.PI*2); ctx.fill();

      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(4, -6); ctx.lineTo(6, -12);
      ctx.moveTo(4,  6); ctx.lineTo(6,  12);
      ctx.stroke();

      // Thorax
      const thoraxGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
      thoraxGrad.addColorStop(0, accentLight);
      thoraxGrad.addColorStop(1, accentDeep);
      ctx.fillStyle = thoraxGrad;
      ctx.beginPath();
      ctx.arc(0, 0, 10, 0, Math.PI*2);
      ctx.fill();

      // Head
      ctx.fillStyle = COLORS.beeBlack;
      ctx.beginPath();
      ctx.arc(12, 0, 6, 0, Math.PI*2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(14, -3, 3, 4, 0, 0, Math.PI*2);
      ctx.ellipse(14,  3, 3, 4, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(15, -4, 1.5, 0, Math.PI*2);
      ctx.arc(15,  2, 1.5, 0, Math.PI*2);
      ctx.fill();

      // Abdomen with stripes
      const abX = -12;
      const abY = 0;
      const abRX = 14;
      const abRY = 11;

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(abX, abY, abRX, abRY, 0, 0, Math.PI*2);
      ctx.clip();

      const abdomenGrad = ctx.createRadialGradient(abX, abY, 5, abX, abY, abRX);
      abdomenGrad.addColorStop(0, abdomenBright);
      abdomenGrad.addColorStop(1, abdomenDark);
      ctx.fillStyle = abdomenGrad;
      ctx.fill();

      ctx.fillStyle = accentDeep;
      const stripeWidth = 4;
      const stripeSpacing = 4;
      let currentStripeX = abX + abRX - stripeWidth/2 - stripeSpacing;

      for(let i = 0; i < 3; i++) {
        ctx.fillRect(
          currentStripeX - stripeWidth,
          -abRY,
          stripeWidth,
          abRY * 2
        );
        currentStripeX -= (stripeWidth + stripeSpacing);
      }

      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      currentStripeX = abX + abRX - stripeWidth/2 - stripeSpacing;
      for(let i = 0; i < 3; i++) {
        ctx.fillRect(
          currentStripeX - stripeWidth * 0.35,
          -abRY,
          stripeWidth * 0.7,
          abRY * 2
        );
        currentStripeX -= (stripeWidth + stripeSpacing);
      }
      ctx.restore();

      // Wings
      const wingGrad = ctx.createLinearGradient(-10, -10, 10, 10);
      wingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      wingGrad.addColorStop(0.5, 'rgba(200, 255, 255, 0.5)');
      wingGrad.addColorStop(1, 'rgba(255, 200, 255, 0.8)');
      ctx.fillStyle = wingGrad;

      ctx.beginPath();
      ctx.ellipse(-4, -10, 16, 8, 0.3 + wingCycle * 0.4, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-4,  10, 16, 8, -0.3 - wingCycle * 0.4, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.65;
      ctx.fillStyle = accentLight;
      ctx.beginPath();
      ctx.ellipse(-10, 0, 6, 3.5, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      });
    }

    let lastTime = 0;
    function loop(timestamp) {
      requestAnimationFrame(loop);
      if (!gameRunning) return;

      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;
      update(dt);
      draw();
    }

    // Kickoff
    resize();
    loop(0);
  </script>

  <!-- Translation system wired exactly like the Window example -->
  <script src="../../js/translationmain.js"></script>
  <script>
    document.getElementById('langToggle')?.addEventListener('pointerup', toggleLanguage);
    document.addEventListener('DOMContentLoaded', updateLanguage);
  </script>
  <script src="../../js/translationonly.js"></script>
</body>
</html>
