<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chasse aux lettres</title>

  <!-- Shared styles -->
  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    /* Page theming applied after Start */
    body.light { background-color: #fff; color: #000; }
    body.dark  { background-color: #000; color: #fff; }
    body.light .letter-cell { background-color: #eee; color: #000; }
    body.dark  .letter-cell { background-color: #222; color: #fff; }

    /* Game container layout */
    .game-container {
      width: 100%;
      max-width: 100vw;
      height: 100%;
      display: none;             /* shown after Start */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px;
      opacity: 1;
      transition: opacity 2000ms ease;
    }
    .game-container.fading { opacity: 0; }

    .letter-grid {
      display: none;             /* shown after Start */
      grid-template-columns: repeat(2, 1fr);
      gap: 40px;
      width: 100%;
      height: 100%;
      align-items: center;
      justify-items: center;
    }
    .letter-grid.no-input { pointer-events: none; }

    .letter-cell {
      position: relative;        /* needed for dwell-fill & confetti */
      width: 200px;
      height: 200px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 6rem;
      cursor: none;              /* hide pointer for eyegaze */
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;          /* clip dwell-fill and confetti inside */
      transform: translateZ(0);
      background-clip: padding-box;
      background-color: #fff;    /* base white look for tiles */
      color: #000;
    }
    body.dark .letter-cell { background-color: #222; color: #fff; }

    /* Prompt */
    #prompt {
      text-align: center;
      margin: 5vh 0;
      display: none; /* shown after Start */
      transition: opacity 200ms ease;
    }
    #prompt .prompt-text {
      font-size: 2rem;
      font-weight: 500;
      color: #444;
    }
    #prompt .target-letter {
      display: block;
      font-size: 6rem;
      font-weight: bold;
      color: #009688;
      margin-top: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.15);
    }

    /* Dwell overlay */
    .dwell-fill {
      position: absolute;
      background-color: rgba(255, 0, 0, 0.5);
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      transform: translate(-50%, -50%);
      pointer-events: none;
      border-radius: 8px;
    }

    /* Inputs */
    .styled-input {
      width: 100%;
      max-width: 160px;
      padding: 10px 14px;
      font-size: 18px;
      font-weight: bold;
      color: #000;
      border: 2px solid #009688;
      border-radius: 8px;
      background-color: #fff;
      text-align: center;
      box-shadow: none;
      transition: border-color .2s, box-shadow .2s;
    }
    .styled-input:focus {
      border-color: #14b8a6;
      box-shadow: 0 0 0 3px rgba(0,150,136,0.15);
      outline: none;
    }

    /* Correct = RED (hold 1s) */
    .letter-cell.correct {
      color: #fff !important;
      background-color: #c62828;     /* red */
    }

    /* Confetti pieces */
    .confetti-piece {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 2px;
      opacity: 0;
      animation: confettiBurst 700ms ease-out forwards;
      pointer-events: none;
    }
    @keyframes confettiBurst {
      0%   { opacity: 0; transform: translate(0, 0) rotate(0deg) scale(0.6); }
      10%  { opacity: 1; }
      100% { opacity: 0; transform: translate(var(--dx), var(--dy)) rotate(var(--rot)) scale(1); }
    }

    /* Dim others */
    .letter-cell.dim {
      opacity: 0;
      transform: scale(0.92);
      filter: blur(1px);
      transition: opacity 600ms ease, transform 600ms ease, filter 600ms ease;
    }

    /* Flying CLONE (whole tile) */
    .flying-tile {
      position: fixed;
      left: 0; top: 0;
      transform: translate(-50%, -50%) scale(1);
      z-index: 9999;
      pointer-events: none;
      will-change: transform, left, top;
      border-radius: 12px;
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;
      background-color: inherit;
      color: inherit;
    }
  </style>
</head>
<body>

<!-- Options modal -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title">Chasse aux lettres</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Column 1: Audio + TTS -->
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span>Désactiver les sons</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span>Volume des sons: </span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>

        <!-- TTS controls -->
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="ttsEnabled">
            <span>Lecture vocale de l’instruction</span>
          </label>
        </div>
        <div class="option-item">
          <label for="ttsVoice" class="teal-label label-block">Voix</label>
          <select id="ttsVoice" class="styled-select"></select>
        </div>
        <div class="option-item">
          <label for="ttsRate" class="teal-label">
            <span>Vitesse: </span>
            <span id="ttsRateVal">1.00</span>x
          </label>
          <input type="range" id="ttsRate" class="styled-slider" min="0.7" max="1.3" step="0.05" value="1.00">
        </div>
      </div>

      <!-- Column 2: Letters -->
      <div class="options-column">
        <div class="option-item">
          <label for="letterSet" class="teal-label label-block">Lettres à afficher</label>
          <input id="letterSet" type="text" value="ABCD" maxlength="26" class="styled-input">
        </div>
      </div>

      <!-- Column 3: Theme & dwell -->
      <div class="options-column">
        <div class="option-item">
          <label for="themeSelect" class="teal-label label-block">Mode</label>
          <select id="themeSelect" class="styled-select">
            <option value="light" selected>Clair</option>
            <option value="dark">Sombre</option>
          </select>
        </div>
        <div class="option-item">
          <label for="dwellTimeSlider" class="teal-label">
            <span>Temps de fixation: </span>
            <span id="dwellTimeVal">1500</span> ms
          </label>
          <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="5000" step="100" value="1500">
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button">Commencer</button>
  </div>
</div>

<!-- Game area -->
<div class="game-container">
  <h2 id="prompt">
    <span class="prompt-text">Trouve la lettre</span><br>
    <span class="target-letter"></span>
  </h2>
  <div class="letter-grid"></div>
</div>

<!-- Audio -->
<audio id="correctSound" src="../../sounds/victory.mp3"></audio>
<audio id="wrongSound"   src="../../sounds/error.mp3"></audio>

<!-- Eyegaze helpers -->
<script src="../../js/eyegaze-menu.js"></script>

<script>
/* =========================
   Controls & UI bindings
   ========================= */
const muteSFX      = document.getElementById('muteSFX');
const sfxVol       = document.getElementById('sfxVol');
const sfxVolVal    = document.getElementById('sfxVolVal');
const dwellSlider  = document.getElementById('dwellTimeSlider');
const dwellTimeVal = document.getElementById('dwellTimeVal');
const themeSelect  = document.getElementById('themeSelect');
const startButton  = document.getElementById('startButton');

const ttsEnabled   = document.getElementById('ttsEnabled');
const ttsVoiceSel  = document.getElementById('ttsVoice');
const ttsRate      = document.getElementById('ttsRate');
const ttsRateVal   = document.getElementById('ttsRateVal');

/* =========================
   Local storage keys
   ========================= */
const LS_KEYS = {
  ttsEnabled:   'chasselettres:ttsEnabled',
  ttsRate:      'chasselettres:ttsRate',
  ttsVoiceURI:  'chasselettres:ttsVoiceURI'
};

/* Prefill persisted settings */
(function initPersistedControls(){
  try {
    const en = localStorage.getItem(LS_KEYS.ttsEnabled);
    if (en !== null) ttsEnabled.checked = (en === 'true');

    const rt = localStorage.getItem(LS_KEYS.ttsRate);
    if (rt !== null) {
      ttsRate.value = rt;
      ttsRateVal.textContent = parseFloat(rt).toFixed(2);
    }
  } catch(e){}
})();

sfxVol.addEventListener('input', () => sfxVolVal.textContent = sfxVol.value);
dwellSlider.addEventListener('input', () => dwellTimeVal.textContent = dwellSlider.value);
ttsRate.addEventListener('input', () => {
  ttsRateVal.textContent = parseFloat(ttsRate.value).toFixed(2);
  try { localStorage.setItem(LS_KEYS.ttsRate, String(ttsRate.value)); } catch(e){}
});
ttsEnabled.addEventListener('change', () => {
  try { localStorage.setItem(LS_KEYS.ttsEnabled, String(ttsEnabled.checked)); } catch(e){}
});

function syncEyegazeSettingsFromUI() {
  try {
    if (window.eyegazeSettings) {
      eyegazeSettings.sfxMuted  = !!muteSFX.checked;
      eyegazeSettings.sfxVolume = parseInt(sfxVol.value, 10) || 50;
      eyegazeSettings.dwellTime = parseInt(dwellSlider.value, 10) || 1500;
      eyegazeSettings.ttsEnabled= !!ttsEnabled.checked;
    }
  } catch(e) {}
}

/* =========================
   Game state
   ========================= */
let letters = [];
let targetLetter;
let hoverTimeout;
let selectedTheme = 'light';

const correctAudio = document.getElementById('correctSound');
const wrongAudio   = document.getElementById('wrongSound');

function applyTheme(theme) {
  document.body.classList.remove('light','dark');
  document.body.classList.add(theme);
}

/* =========================
   TTS helpers
   ========================= */
let cachedVoices = [];
let selectedVoiceURI = null;

ttsVoiceSel.addEventListener('change', () => {
  selectedVoiceURI = ttsVoiceSel.value || null;
  try { localStorage.setItem(LS_KEYS.ttsVoiceURI, selectedVoiceURI || ''); } catch(e){}
});

function populateVoices() {
  const ss = window.speechSynthesis;
  if (!ss || !ss.getVoices) return;

  const voices = ss.getVoices();
  if (!voices || !voices.length) return;

  cachedVoices = voices.slice();

  const frVoices = voices.filter(v => (v.lang || '').toLowerCase().startsWith('fr'));
  const others   = voices.filter(v => !(v.lang || '').toLowerCase().startsWith('fr'));

  const ordered = [
    ...frVoices.sort((a,b) => (a.lang === 'fr-CA' ? -1 : 0) - (b.lang === 'fr-CA' ? -1 : 0)),
    ...others
  ];

  const savedURI = (function(){ try { return localStorage.getItem(LS_KEYS.ttsVoiceURI); } catch(e){ return null; } })();
  const wantURI = selectedVoiceURI || savedURI;

  ttsVoiceSel.innerHTML = '';
  ordered.forEach(v => {
    const opt = document.createElement('option');
    opt.value = v.voiceURI;
    opt.textContent = `${v.name} (${v.lang})`;
    ttsVoiceSel.appendChild(opt);
  });

  if (wantURI && ordered.some(v => v.voiceURI === wantURI)) {
    ttsVoiceSel.value = wantURI;
  } else {
    const prefer = ['fr-CA', 'fr-FR'];
    let chosen = ordered.find(v => prefer.includes(v.lang)) || ordered[0];
    if (chosen) ttsVoiceSel.value = chosen.voiceURI;
  }

  selectedVoiceURI = ttsVoiceSel.value || null;
  try { localStorage.setItem(LS_KEYS.ttsVoiceURI, selectedVoiceURI || ''); } catch(e){}
}

function getSelectedVoice() {
  const uri = selectedVoiceURI || ttsVoiceSel.value;
  return cachedVoices.find(v => v.voiceURI === uri) || null;
}

function speak(text) {
  if (!window.speechSynthesis || !('SpeechSynthesisUtterance' in window)) return;

  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;
  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number') ? sfxSetting : (isNaN(uiVol) ? 50 : uiVol);
  const volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));

  try { speechSynthesis.cancel(); } catch(e) {}

  const u = new SpeechSynthesisUtterance(text);
  const v = getSelectedVoice();
  if (v) {
    u.voice = v;
    u.lang = v.lang || 'fr-CA';
  } else {
    u.lang = 'fr-CA';
  }
  u.rate = parseFloat(ttsRate.value) || 1.0;
  u.volume = volume;

  try { speechSynthesis.speak(u); } catch(e) {}
}

function speakPromptIfEnabled() {
  const enabled = !!ttsEnabled.checked || !!(window.eyegazeSettings?.ttsEnabled);
  if (!enabled || !targetLetter) return;
  speak(`Trouve la lettre ${targetLetter}`);
}

if ('speechSynthesis' in window) {
  speechSynthesis.addEventListener('voiceschanged', populateVoices);
  populateVoices();
}

/* =========================
   Startup & rounds
   ========================= */
function startGame() {
  // Request fullscreen
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.webkitRequestFullscreen) {
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) {
    document.documentElement.msRequestFullscreen();
  }

  // Sync options
  syncEyegazeSettingsFromUI();

  selectedTheme = themeSelect.value;
  applyTheme(selectedTheme);

  // Parse letters
  const inputVal = document.getElementById('letterSet').value.toUpperCase().replace(/[^A-Z]/g,'');
  letters = inputVal.split('');
  if (letters.length === 0) letters = ['A','B','C','D'];

  // Show game container & grid
  document.querySelector('.game-container').style.display = 'flex';
  document.querySelector('.letter-grid').style.display = 'grid';
  document.getElementById('prompt').style.display = 'block';

  buildGrid();
  nextRound();

  try { if (window.eyegazeSettings?.hideOverlay) eyegazeSettings.hideOverlay(); } catch(e) {}

  populateVoices();
}
startButton.addEventListener('click', startGame);

function buildGrid() {
  const grid = document.querySelector('.letter-grid');
  grid.innerHTML = '';

  const cols = Math.ceil(Math.sqrt(letters.length));
  grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

  letters.forEach(letter => {
    const cell = document.createElement('div');
    cell.className = 'letter-cell';
    cell.innerHTML = `<span class="cell-char">${letter}</span>`;

    cell.addEventListener('mouseover', () => startHover(cell));
    cell.addEventListener('mouseout', stopHover);

    grid.appendChild(cell);
  });
}

function nextRound() {
  targetLetter = letters[Math.floor(Math.random() * letters.length)];
  document.querySelector("#prompt .target-letter").textContent = targetLetter;
  speakPromptIfEnabled();
}

/* ====== Dwell hover handling (tile overlay) ====== */
let currentOverlay;

function startHover(tile) {
  const hoverTime = (window.eyegazeSettings?.dwellTime) || parseInt(dwellSlider.value, 10) || 1500;

  stopHover(); // clean any previous overlay
  currentOverlay = document.createElement('div');
  currentOverlay.className = 'dwell-fill';
  tile.appendChild(currentOverlay);

  requestAnimationFrame(() => {
    currentOverlay.style.transition = `width ${hoverTime}ms linear, height ${hoverTime}ms linear`;
    currentOverlay.style.width = '0';
    currentOverlay.style.height = '0';
    requestAnimationFrame(() => {
      currentOverlay.style.width = '100%';
      currentOverlay.style.height = '100%';
    });
  });

  hoverTimeout = setTimeout(() => {
    handleSelection(tile);
    stopHover();
  }, hoverTime);
}

function stopHover() {
  clearTimeout(hoverTimeout);
  if (currentOverlay) {
    if (currentOverlay.parentElement) {
      currentOverlay.parentElement.removeChild(currentOverlay);
    }
    currentOverlay = null;
  }
}

/* ====== Timings (ms) ====== */
const TIMING = {
  holdRed: 1000,        // tuile rouge immobile
  sfxConfetti: 2000,    // durée son + confettis
  glide: 3000,          // glisser vers centre
  grow: 2000            // grossir x2
};

/* ====== On correct selection: run the choreography ====== */
function handleSelection(el) {
  const letter = el.textContent.trim();
  if (letter !== targetLetter) { playSound(wrongAudio); return; }

  const grid = document.querySelector('.letter-grid');
  const promptEl = document.getElementById('prompt');

  // Lock interactions & dim others
  grid.classList.add('no-input');
  grid.querySelectorAll('.letter-cell').forEach(cell => {
    if (cell !== el) cell.classList.add('dim');
  });

  // ---- STEP 1: red hold (1s) ----
  el.classList.add('correct'); // red
  setTimeout(() => {
    // back to white (explicit pour éviter l'héritage sombre)
    el.classList.remove('correct');
    el.style.backgroundColor = '#fff';
    el.style.color = '#000';

    // ---- STEP 2: 2s victory sound + confetti ----
    playSound(correctAudio);
    // Couper le son à 2s si le fichier est plus long
    const stopTimer = setTimeout(() => {
      try { correctAudio.pause(); correctAudio.currentTime = 0; } catch(e){}
    }, TIMING.sfxConfetti);

    spawnConfetti(el, 24, TIMING.sfxConfetti);

    setTimeout(() => {
      // ---- STEP 3: prompt disparaît, clone glisse & grandit ----
      promptEl.style.display = 'none';

      glideTileToCenter(el, TIMING.glide, TIMING.grow).then(() => {
        // Fin animation : cleanup + prochain set
        clearTimeout(stopTimer);
        grid.querySelectorAll('.letter-cell').forEach(cell => cell.classList.remove('dim'));

        // Remettre la tuile originale visible & sans style forcé
        el.style.opacity = '';
        // Si tu veux revenir à la couleur thème au prochain tour :
        el.style.backgroundColor = '';
        el.style.color = '';

        grid.classList.remove('no-input');

        // Prochain set + prompt revient + relire la lettre
        nextRound();
        promptEl.style.display = 'block';   // ré-affiche le prompt (nouvelle lettre)
        // speakPromptIfEnabled() est déjà appelé dans nextRound()
      });

    }, TIMING.sfxConfetti);

  }, TIMING.holdRed);
}

/* ====== Clone whole tile, glide to center, then grow 2x ====== */
function glideTileToCenter(tile, glideMs = 3000, growMs = 2000) {
  return new Promise(resolve => {
    const r = tile.getBoundingClientRect();

    // Deep clone the WHOLE tile (visual only)
    const clone = tile.cloneNode(true);
    clone.className = tile.className.replace(/\bdim\b/g, '').trim();
    clone.classList.add('flying-tile');
    clone.style.width  = r.width + 'px';
    clone.style.height = r.height + 'px';
    clone.style.left   = (r.left + r.width / 2) + 'px';
    clone.style.top    = (r.top  + r.height / 2) + 'px';

    // Match colors
    const cs = getComputedStyle(tile);
    clone.style.backgroundColor = cs.backgroundColor;
    clone.style.color = cs.color;

    document.body.appendChild(clone);

    // Hide original during flight
    tile.style.opacity = '0';

    // Glide to center
    const centerX = window.innerWidth  / 2;
    const centerY = window.innerHeight / 2;
    const dx = centerX - (r.left + r.width / 2);
    const dy = centerY - (r.top  + r.height / 2);

    const a1 = clone.animate(
      [
        { transform: 'translate(-50%, -50%) translate(0,0) scale(1)' },
        { transform: `translate(-50%, -50%) translate(${dx}px, ${dy}px) scale(1)` }
      ],
      { duration: glideMs, easing: 'cubic-bezier(.2,.7,.2,1)', fill: 'forwards' }
    );

    a1.onfinish = () => {
      const a2 = clone.animate(
        [
          { transform: `translate(-50%, -50%) translate(${dx}px, ${dy}px) scale(1)` },
          { transform: `translate(-50%, -50%) translate(${dx}px, ${dy}px) scale(2)` }
        ],
        { duration: growMs, easing: 'ease', fill: 'forwards' }
      );

      a2.onfinish = () => {
        if (clone.parentNode) clone.parentNode.removeChild(clone);
        resolve();
      };
    };
  });
}

/* Confetti burst for a given duration */
function spawnConfetti(el, count = 12, durationMs = 1800) {
  const colors = ['#ffffff', '#009688', '#14b8a6', '#2e7d32', '#f1f5f9'];
  const rect = el.getBoundingClientRect();

  for (let i = 0; i < count; i++) {
    const piece = document.createElement('div');
    piece.className = 'confetti-piece';
    piece.style.background = colors[i % colors.length];
    piece.style.animationDuration = durationMs + 'ms';

    const angle = Math.random() * Math.PI * 2;
    const dist  = 60 + Math.random() * 70;
    const dx = Math.cos(angle) * dist;
    const dy = Math.sin(angle) * dist;
    const rot = (Math.random() * 360 - 180) + 'deg';

    const centerX = rect.width / 2 - 5;
    const centerY = rect.height / 2 - 5;

    piece.style.left = centerX + 'px';
    piece.style.top  = centerY + 'px';

    piece.style.setProperty('--dx', dx + 'px');
    piece.style.setProperty('--dy', dy + 'px');
    piece.style.setProperty('--rot', rot);

    // position inside the element
    piece.style.position = 'absolute';
    el.appendChild(piece);

    piece.addEventListener('animationend', () => {
      if (piece.parentElement) piece.parentElement.removeChild(piece);
    });
  }
}

function playSound(audioEl) {
  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;

  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number')
    ? sfxSetting
    : (isNaN(uiVol) ? 50 : uiVol);

  audioEl.volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));
  try {
    audioEl.currentTime = 0;
    audioEl.play();
  } catch(e) {}
}
</script>
</body>
</html>
