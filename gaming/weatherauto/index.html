<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-fr="Jeux météo automatiques" data-en="Automatic Weather Games">Jeux météo automatiques</title>
  <link rel="stylesheet" href="../../css/menu.css">
  <link rel="stylesheet" href="../../css/global.css">
  <link rel="stylesheet" href="../../css/layout.css">
  <link rel="stylesheet" href="../../css/components.css">
  <style>
    :root {
      --weather-accent: #d36135;
      --weather-accent-dark: #b04d29;
      --weather-highlight: #ff4d4d;
    }

    body.weather-menu {
      background-color: #dff3e4;
      color: #294936;
    }

    main[hidden] {
      display: none;
    }

    .hero-minimalist.weather-hero {
      background: #dff3e4;
      padding-bottom: 12px;
    }

    .hero-minimalist.weather-hero h1 {
      margin-bottom: 6px;
    }

    .hero-minimalist.weather-hero p {
      max-width: 720px;
      margin: 0 auto;
    }

    .mode-info {
      margin-top: 16px;
      display: grid;
      gap: 10px;
      justify-items: center;
    }

    .mode-chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 22px;
      border-radius: 999px;
      background: #623b5a;
      color: #ffffff;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: clamp(0.85rem, 2vmin, 1rem);
    }

    .mode-detail {
      margin: 0;
      text-align: center;
      max-width: 680px;
      font-size: clamp(0.95rem, 2.2vmin, 1.1rem);
      color: #3c5c46;
    }

    .start-wrapper {
      max-width: 1080px;
      margin: 0 auto;
      padding: clamp(28px, 6vw, 60px) clamp(18px, 6vw, 48px);
      display: flex;
      flex-direction: column;
      gap: clamp(24px, 5vw, 44px);
      text-align: center;
    }

    .start-header h1 {
      margin: 0 0 clamp(12px, 3vw, 20px);
      font-size: clamp(1.8rem, 4vw, 2.6rem);
      color: #ffffff;
    }

    .start-header p {
      margin: 0;
      font-size: clamp(1rem, 2.4vmin, 1.2rem);
      color: rgba(255, 255, 255, 0.78);
    }

    .mode-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: clamp(16px, 3vw, 28px);
    }

    .mode-card {
      all: unset;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 12px;
      padding: clamp(22px, 4vw, 30px);
      border-radius: 18px;
      border: 3px solid rgba(255, 255, 255, 0.28);
      background: linear-gradient(160deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
      color: #ffffff;
      cursor: pointer;
      min-height: 180px;
      transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
    }

    .mode-card:focus-visible {
      outline: 4px solid rgba(242, 209, 107, 0.6);
      outline-offset: 4px;
    }

    @media (hover: hover) and (pointer: fine) {
      .mode-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 18px 36px rgba(0, 0, 0, 0.3);
      }
    }

    .mode-card.is-active {
      border-color: var(--weather-highlight);
      box-shadow: 0 0 0 4px rgba(255, 77, 77, 0.35), 0 24px 40px rgba(0, 0, 0, 0.42);
    }

    .mode-card h3 {
      margin: 0;
      font-size: clamp(1.1rem, 2.6vmin, 1.4rem);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .mode-card p {
      margin: 0;
      font-size: clamp(0.95rem, 2.1vmin, 1.1rem);
      color: rgba(255, 255, 255, 0.8);
    }

    .start-actions {
      display: grid;
      gap: 12px;
      justify-items: center;
    }

    .start-hint {
      margin: 0;
      font-size: clamp(0.95rem, 2vmin, 1.05rem);
      color: rgba(255, 255, 255, 0.72);
    }

    .tile-container.weather-grid {
      max-width: 1080px;
      margin: 0 auto 40px;
      padding: 0 24px 40px;
    }

    .weather-card {
      all: unset;
      display: block;
      width: 100%;
      max-width: 300px;
      height: 250px;
      border-radius: 12px;
      border: 3px solid #623b5a;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
      overflow: hidden;
      cursor: pointer;
      position: relative;
      transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
      background: #ffffff;
    }

    @media (hover: hover) and (pointer: fine) {
      .weather-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.16);
      }

      .weather-card:hover img {
        transform: scale(1.06);
      }
    }

    .weather-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      transition: transform 260ms ease;
    }

    .tile-title {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 14px 10px;
      background: rgba(0, 0, 0, 0.65);
      color: #dff3e4;
      text-align: center;
    }

    .tile-title h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .tile-title small {
      display: block;
      margin-top: 4px;
      font-size: 0.9rem;
      color: rgba(223, 243, 228, 0.85);
    }

    .weather-card:focus-visible {
      outline: 4px solid rgba(211, 97, 53, 0.35);
      outline-offset: 4px;
    }

    .weather-card.is-selected {
      border-color: var(--weather-highlight);
      box-shadow: 0 0 0 4px rgba(255, 77, 77, 0.35), 0 16px 32px rgba(0, 0, 0, 0.22);
    }

    .game-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      background: #000;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms ease;
    }

    .game-overlay[hidden] {
      display: none;
    }

    .game-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 18px;
      padding: clamp(14px, 3vmin, 26px) clamp(16px, 4vmin, 32px);
      background: linear-gradient(180deg, rgba(0,0,0,0.92) 0%, rgba(0,0,0,0.6) 100%);
      color: #ffffff;
      flex-wrap: wrap;
    }

    .overlay-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }

    .overlay-meta h2 {
      margin: 0;
      font-size: clamp(1.2rem, 2.6vmin, 1.8rem);
    }

    .overlay-meta p {
      margin: 0;
      font-size: clamp(1rem, 2.2vmin, 1.2rem);
      opacity: 0.8;
    }

    .overlay-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .back-button {
      border: none;
      border-radius: 999px;
      padding: 12px 24px;
      background: rgba(255,255,255,0.15);
      color: #ffffff;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      cursor: pointer;
      transition: background 160ms ease, transform 160ms ease;
    }

    .back-button:focus-visible {
      outline: 3px solid rgba(255, 255, 255, 0.5);
      outline-offset: 3px;
    }

    @media (hover: hover) and (pointer: fine) {
      .back-button:hover {
        background: rgba(255,255,255,0.22);
        transform: translateY(-1px);
      }
    }

    .overlay-hint {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.7);
    }

    iframe {
      flex: 1;
      border: none;
      width: 100%;
      background: #000;
    }

    .start-screen {
      position: fixed;
      inset: 0;
      padding: clamp(20px, 6vw, 48px);
      background: radial-gradient(circle at top, rgba(242, 209, 107, 0.15), rgba(0, 0, 0, 0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 60;
      transition: opacity 320ms ease;
      overflow-y: auto;
    }

    .start-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #startButton {
      font-size: clamp(1.3rem, 2.6vmin, 1.6rem);
      letter-spacing: 0.2em;
      padding: clamp(14px, 3.2vmin, 18px) clamp(36px, 8vmin, 52px);
      border-radius: 999px;
      border: none;
      color: #000000;
      background: #f2d16b;
      cursor: pointer;
      font-weight: 700;
      text-transform: uppercase;
      transition: transform 160ms ease, box-shadow 160ms ease;
    }

    #startButton:focus-visible {
      outline: 3px solid rgba(242, 209, 107, 0.55);
      outline-offset: 4px;
    }

    @media (hover: hover) and (pointer: fine) {
      #startButton:hover {
        transform: translateY(-2px);
        box-shadow: 0 18px 36px rgba(242, 209, 107, 0.35);
      }
    }

    @media (max-width: 680px) {
      .start-wrapper {
        gap: 28px;
      }

      .mode-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body class="menu weather-menu">
  <nav class="top-menu">
    <div class="top-menu-title" data-fr="Adaptatech" data-en="Adaptatech">Portail de jeux adaptés</div>
    <ul>
      <li><a href="../../index.html" data-fr="Accueil" data-en="Home">Accueil</a></li>
      <li><a href="../../contact/index.html" data-fr="Contact" data-en="Contact">Contact</a></li>
      <li>
        <a href="#" id="language-toggle" onclick="toggleLanguage(); return false;"></a>
      </li>
    </ul>
  </nav>

  <div class="start-screen" id="startScreen">
    <div class="start-wrapper">
      <div class="start-header">
        <h1 data-fr="Jeux météo automatiques" data-en="Automatic weather games">Jeux météo automatiques</h1>
        <p data-fr="Choisis comment naviguer puis appuie sur START pour passer en plein écran." data-en="Pick how you want to navigate, then press START to enter fullscreen.">Choisis comment naviguer puis appuie sur START pour passer en plein écran.</p>
      </div>
      <div class="mode-grid" role="list">
        <button class="mode-card is-active" type="button" role="listitem" data-index="0" data-mode-id="touch" aria-pressed="true">
          <h3 data-fr="Mode tactile" data-en="Touch mode">Mode tactile</h3>
          <p data-fr="Utilise l'écran tactile ou la souris pour choisir un jeu." data-en="Use the touchscreen or mouse to choose a game.">Utilise l'écran tactile ou la souris pour choisir un jeu.</p>
        </button>
        <button class="mode-card" type="button" role="listitem" data-index="1" data-mode-id="multiple" aria-pressed="false">
          <h3 data-fr="Mode choix multiples" data-en="Multiple choice mode">Mode choix multiples</h3>
          <p data-fr="Appuie sur Entrée pour faire défiler la sélection et sur Espace pour lancer le jeu en surbrillance." data-en="Press Enter to move the highlight forward and Space to start the highlighted game.">Appuie sur Entrée pour faire défiler la sélection et sur Espace pour lancer le jeu en surbrillance.</p>
        </button>
        <button class="mode-card" type="button" role="listitem" data-index="2" data-mode-id="scan" aria-pressed="false">
          <h3 data-fr="Mode balayage" data-en="Scanning mode">Mode balayage</h3>
          <p data-fr="La sélection avance automatiquement toutes les 10 secondes. Appuie sur Espace pour lancer le jeu en surbrillance." data-en="The selection advances every 10 seconds. Press Space to launch the highlighted game.">La sélection avance automatiquement toutes les 10 secondes. Appuie sur Espace pour lancer le jeu en surbrillance.</p>
        </button>
      </div>
      <div class="start-actions">
        <button id="startButton" data-fr="START" data-en="START">START</button>
        <p class="start-hint" id="startHint" data-fr="Le mode sélectionné sera utilisé pour choisir la météo." data-en="The selected mode will be used to choose the weather.">Le mode sélectionné sera utilisé pour choisir la météo.</p>
      </div>
    </div>
  </div>

  <main id="mainContent" hidden>
    <div class="hero-minimalist weather-hero">
      <h1 data-fr="Choisis la météo" data-en="Choose the weather">Choisis la météo</h1>
      <p data-fr="Reste en plein écran et utilise les commandes choisies pour naviguer dans les jeux." data-en="Stay in fullscreen and use the controls you picked to browse the games.">Reste en plein écran et utilise les commandes choisies pour naviguer dans les jeux.</p>
      <div class="mode-info">
        <span id="modeChip" class="mode-chip" data-fr="Mode tactile" data-en="Touch mode">Mode tactile</span>
        <p id="modeDetails" class="mode-detail" data-fr="Utilise l'écran tactile ou la souris pour choisir un jeu." data-en="Use the touchscreen or mouse to choose a game.">Utilise l'écran tactile ou la souris pour choisir un jeu.</p>
      </div>
    </div>

    <div class="tile-container weather-grid" role="list">
      <button class="weather-card" type="button" role="listitem"
        data-index="0"
        data-src="../sunauto/index.html"
        data-title-fr="Soleil"
        data-title-en="Sun"
        data-description-fr="Ambiance lumineuse"
        data-description-en="Warm sunshine"
        aria-label="Soleil - Ambiance lumineuse">
        <img src="../../images/sun.png" alt="Icône de soleil">
        <div class="tile-title">
          <h3 data-fr="Soleil" data-en="Sun">Soleil</h3>
          <small data-fr="Ambiance lumineuse" data-en="Warm sunshine">Ambiance lumineuse</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="1"
        data-src="../cloudauto/index.html"
        data-title-fr="Nuages"
        data-title-en="Clouds"
        data-description-fr="Douce brise"
        data-description-en="Soft breeze"
        aria-label="Nuages - Douce brise">
        <img src="../../images/cloud.png" alt="Icône de nuage">
        <div class="tile-title">
          <h3 data-fr="Nuages" data-en="Clouds">Nuages</h3>
          <small data-fr="Douce brise" data-en="Soft breeze">Douce brise</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="2"
        data-src="../stormauto/index.html"
        data-title-fr="Pluie"
        data-title-en="Rain"
        data-description-fr="Orage relaxant"
        data-description-en="Relaxing storm"
        aria-label="Pluie - Orage relaxant">
        <img src="../../images/rain.png" alt="Icône de pluie">
        <div class="tile-title">
          <h3 data-fr="Pluie" data-en="Rain">Pluie</h3>
          <small data-fr="Orage relaxant" data-en="Relaxing storm">Orage relaxant</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="3"
        data-src="../snowauto/index.html"
        data-title-fr="Neige"
        data-title-en="Snow"
        data-description-fr="Flocons scintillants"
        data-description-en="Shimmering snow"
        aria-label="Neige - Flocons scintillants">
        <img src="../../images/snow.png" alt="Icône de neige">
        <div class="tile-title">
          <h3 data-fr="Neige" data-en="Snow">Neige</h3>
          <small data-fr="Flocons scintillants" data-en="Shimmering snow">Flocons scintillants</small>
        </div>
      </button>
    </div>
  </main>

  <div class="game-overlay" id="gameOverlay" hidden>
    <div class="overlay-bar">
      <div class="overlay-meta">
        <h2 id="overlayTitle" data-fr="" data-en=""></h2>
        <p id="overlayDescription" data-fr="" data-en=""></p>
      </div>
      <div class="overlay-actions">
        <p class="overlay-hint" id="overlayHint" data-fr="Appuie sur Q pour revenir au menu ou sur Échap pour quitter le jeu." data-en="Press Q to return to the menu or Escape to quit the game.">Appuie sur Q pour revenir au menu ou sur Échap pour quitter le jeu.</p>
        <button class="back-button" id="backButton" type="button" data-fr="Retour" data-en="Back">Retour</button>
      </div>
    </div>
    <iframe id="gameFrame" title="Jeu météo automatique" allow="autoplay; fullscreen" allowfullscreen sandbox="allow-scripts allow-same-origin allow-pointer-lock allow-orientation-lock allow-popups" tabindex="-1"></iframe>
  </div>

  <button id="langToggle" class="floating-button lang-toggle" title="Changer la langue / Switch language">EN</button>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const langBtn = document.getElementById('langToggle');
      const siteLang = localStorage.getItem('siteLanguage') || 'en';
      langBtn.textContent = (siteLang === 'fr') ? 'EN' : 'FR';

      langBtn.addEventListener('click', () => {
        toggleLanguage();
        const updatedLang = localStorage.getItem('siteLanguage') || 'en';
        langBtn.textContent = (updatedLang === 'fr') ? 'EN' : 'FR';
      });
    });
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      fetch('../../footer.html')
        .then(response => response.text())
        .then(data => {
          document.body.insertAdjacentHTML('beforeend', data);
        });
    });
  </script>

  <script>
    (function() {
      const startScreen = document.getElementById('startScreen');
      const startButton = document.getElementById('startButton');
      const mainContent = document.getElementById('mainContent');
      const gameOverlay = document.getElementById('gameOverlay');
      const gameFrame = document.getElementById('gameFrame');
      const backButton = document.getElementById('backButton');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayDescription = document.getElementById('overlayDescription');
      const modeChip = document.getElementById('modeChip');
      const modeDetails = document.getElementById('modeDetails');
      const startHint = document.getElementById('startHint');
      const modeCards = Array.from(document.querySelectorAll('.mode-card'));
      const fsKey = 'weatherAutoFS';
      const cards = Array.from(document.querySelectorAll('.weather-card'));

      const getSiteLanguage = () => (localStorage.getItem('siteLanguage') || 'fr');

      const applyCurrentLanguage = element => {
        if (!element) return;
        const lang = getSiteLanguage();
        const attr = lang === 'fr' ? 'data-fr' : 'data-en';
        const text = element.getAttribute(attr);
        if (text) {
          element.textContent = text;
        }
      };

      const updateModeCardAria = () => {
        const lang = getSiteLanguage();
        modeCards.forEach(card => {
          const heading = card.querySelector('h3');
          const description = card.querySelector('p');
          if (!heading) return;
          const labelText = heading.getAttribute(lang === 'fr' ? 'data-fr' : 'data-en') || heading.textContent || '';
          const descriptionText = description ? (description.getAttribute(lang === 'fr' ? 'data-fr' : 'data-en') || description.textContent || '') : '';
          const composed = descriptionText ? `${labelText}. ${descriptionText}` : labelText;
          card.setAttribute('aria-label', composed);
        });
      };

      const modes = [
        {
          id: 'touch',
          labelFr: 'Mode tactile',
          labelEn: 'Touch mode',
          descriptionFr: "Utilise l'écran tactile ou la souris pour choisir un jeu.",
          descriptionEn: 'Use the touchscreen or mouse to choose a game.'
        },
        {
          id: 'multiple',
          labelFr: 'Mode choix multiples',
          labelEn: 'Multiple choice mode',
          descriptionFr: 'Appuie sur Entrée pour faire défiler la sélection. Appuie sur Espace pour lancer le jeu surligné.',
          descriptionEn: 'Press Enter to move the highlight forward. Press Space to launch the highlighted game.'
        },
        {
          id: 'scan',
          labelFr: 'Mode balayage',
          labelEn: 'Scanning mode',
          descriptionFr: 'La sélection avance automatiquement toutes les 10 secondes. Appuie sur Espace pour lancer le jeu en surbrillance.',
          descriptionEn: 'The selection advances every 10 seconds. Press Space to start the highlighted game.'
        }
      ];

      let modeIndex = 0;
      let highlightIndex = 0;
      let scanTimer = null;
      let lastCard = null;
      let gameActive = false;

      function focusGameFrame() {
        if (!gameActive) return;
        const tryFocus = () => {
          try {
            gameFrame.contentWindow?.focus();
          } catch {}
          if (typeof gameFrame.focus === 'function') {
            try {
              gameFrame.focus({ preventScroll: true });
            } catch {
              gameFrame.focus();
            }
          }
        };
        tryFocus();
        setTimeout(tryFocus, 120);
      }

      function revealMain() {
        startScreen.classList.add('hidden');
        mainContent.hidden = false;
        setTimeout(() => startScreen.remove(), 420);
      }

      async function enterFullscreen() {
        const el = document.documentElement;
        if (document.fullscreenElement === el) return true;
        const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
        if (!req) return false;
        try {
          await req.call(el);
          return true;
        } catch {
          return false;
        }
      }

      function setOverlayLabels(card) {
        overlayTitle.setAttribute('data-fr', card.dataset.titleFr || '');
        overlayTitle.setAttribute('data-en', card.dataset.titleEn || '');
        overlayDescription.setAttribute('data-fr', card.dataset.descriptionFr || '');
        overlayDescription.setAttribute('data-en', card.dataset.descriptionEn || '');
        applyCurrentLanguage(overlayTitle);
        applyCurrentLanguage(overlayDescription);
        if (typeof updateLanguage === 'function') {
          updateLanguage();
        }
      }

      function clearSelection() {
        cards.forEach(card => {
          card.classList.remove('is-selected');
          card.removeAttribute('aria-selected');
        });
      }

      function highlightCard(index) {
        if (!cards.length) return;
        const normalized = ((index % cards.length) + cards.length) % cards.length;
        clearSelection();
        const card = cards[normalized];
        if (card) {
          card.classList.add('is-selected');
          card.setAttribute('aria-selected', 'true');
        }
        highlightIndex = normalized;
      }

      function stopScanTimer() {
        if (scanTimer) {
          clearInterval(scanTimer);
          scanTimer = null;
        }
      }

      function startScanTimer() {
        stopScanTimer();
        scanTimer = setInterval(() => {
          advanceHighlight();
        }, 10000);
      }

      function applyMode(newIndex) {
        modeIndex = ((newIndex % modes.length) + modes.length) % modes.length;
        const mode = modes[modeIndex];

        if (modeChip) {
          modeChip.setAttribute('data-fr', mode.labelFr);
          modeChip.setAttribute('data-en', mode.labelEn);
          applyCurrentLanguage(modeChip);
        }

        if (modeDetails) {
          modeDetails.setAttribute('data-fr', mode.descriptionFr);
          modeDetails.setAttribute('data-en', mode.descriptionEn);
          applyCurrentLanguage(modeDetails);
        }

        if (typeof updateLanguage === 'function') {
          updateLanguage();
        }

        stopScanTimer();
        if (!mainContent.hidden) {
          clearSelection();
          if (mode.id === 'multiple' || mode.id === 'scan') {
            highlightCard(0);
            if (mode.id === 'scan' && !gameActive) {
              startScanTimer();
            }
          }
        } else {
          clearSelection();
        }
      }

      function advanceHighlight() {
        if (!cards.length) return;
        const nextIndex = (highlightIndex + 1) % cards.length;
        highlightCard(nextIndex);
      }

      function updateModeCardStates() {
        if (!modeCards.length) return;
        modeCards.forEach((card, index) => {
          const isActive = index === modeIndex;
          card.classList.toggle('is-active', isActive);
          card.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      function setSelectedMode(newIndex, options = {}) {
        applyMode(newIndex);
        updateModeCardStates();
        if (options.focus && modeCards.length) {
          const normalized = ((modeIndex % modeCards.length) + modeCards.length) % modeCards.length;
          const card = modeCards[normalized];
          if (card && typeof card.focus === 'function') {
            try {
              card.focus({ preventScroll: true });
            } catch {
              card.focus();
            }
          }
        }
      }

      function refreshLanguageDependentText() {
        if (modeChip) {
          applyCurrentLanguage(modeChip);
        }
        if (modeDetails) {
          applyCurrentLanguage(modeDetails);
        }
        if (startButton) {
          applyCurrentLanguage(startButton);
        }
        if (startHint) {
          applyCurrentLanguage(startHint);
        }
        updateModeCardAria();
      }

      async function showGame(card) {
        if (!card) return;
        lastCard = card;
        stopScanTimer();
        setOverlayLabels(card);
        const src = card.dataset.src;
        if (src) {
          gameFrame.src = src;
        }
        gameActive = true;
        sessionStorage.setItem(fsKey, '1');
        await enterFullscreen();
        gameOverlay.removeAttribute('hidden');
        requestAnimationFrame(() => {
          gameOverlay.classList.add('visible');
          focusGameFrame();
        });
      }

      function closeGame() {
        if (!gameActive) return;
        gameOverlay.classList.remove('visible');
        setTimeout(() => {
          if (!gameOverlay.classList.contains('visible')) {
            gameActive = false;
            gameOverlay.setAttribute('hidden', '');
            gameFrame.src = 'about:blank';
            const focusTarget = lastCard && mainContent.contains(lastCard) ? lastCard : cards[0];
            if (focusTarget && typeof focusTarget.focus === 'function') {
              try {
                focusTarget.focus({ preventScroll: true });
              } catch {
                focusTarget.focus();
              }
            }
            if (modes[modeIndex].id === 'scan') {
              startScanTimer();
            }
          }
        }, 240);
      }

      function selectHighlightedCard() {
        const card = cards[highlightIndex];
        if (card) {
          showGame(card);
        }
      }

      startButton.addEventListener('click', async () => {
        sessionStorage.setItem(fsKey, '1');
        await enterFullscreen();
        revealMain();
        applyMode(modeIndex);
        updateModeCardStates();
        setTimeout(() => {
          const focusTarget = cards[highlightIndex] || cards[0];
          if (focusTarget && typeof focusTarget.focus === 'function') {
            try {
              focusTarget.focus({ preventScroll: true });
            } catch {
              focusTarget.focus();
            }
          }
        }, 200);
      });

      if (startScreen) {
        startScreen.addEventListener('keydown', event => {
          const key = event.key;
          if (!key) return;
          if (key === 'ArrowRight' || key === 'ArrowDown') {
            event.preventDefault();
            setSelectedMode(modeIndex + 1, { focus: true });
          } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
            event.preventDefault();
            setSelectedMode(modeIndex - 1, { focus: true });
          }
        });
      }

      modeCards.forEach((card, index) => {
        card.addEventListener('click', () => {
          setSelectedMode(index);
        });

        card.addEventListener('keydown', event => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setSelectedMode(index);
            if (startButton && document.body.contains(startButton)) {
              try {
                startButton.focus({ preventScroll: true });
              } catch {
                startButton.focus();
              }
            }
          }
        });
      });

      cards.forEach(card => {
        card.addEventListener('click', () => {
          if (!mainContent.hidden) {
            if (modes[modeIndex].id !== 'touch') {
              highlightIndex = cards.indexOf(card);
              highlightCard(highlightIndex);
            }
            showGame(card);
          }
        });
      });

      backButton.addEventListener('click', () => {
        closeGame();
      });

      document.addEventListener('click', event => {
        const target = event.target;
        if (!target) return;
        if (target.id === 'language-toggle' || target.id === 'langToggle') {
          setTimeout(() => {
            refreshLanguageDependentText();
            updateModeCardStates();
          }, 0);
        }
      });

      document.addEventListener('keydown', event => {
        if (!gameOverlay.hasAttribute('hidden')) {
          const key = event.key ? event.key.toLowerCase() : '';
          if (key === 'escape' || key === 'esc') {
            event.preventDefault();
            closeGame();
          } else if (key === 'q') {
            event.preventDefault();
            closeGame();
          }
          return;
        }

        if (mainContent.hidden) {
          return;
        }

        const mode = modes[modeIndex];
        if (mode.id === 'multiple') {
          if (event.key === 'Enter') {
            event.preventDefault();
            advanceHighlight();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            selectHighlightedCard();
          }
        } else if (mode.id === 'scan') {
          if (event.key === 'Enter') {
            event.preventDefault();
            advanceHighlight();
            startScanTimer();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            selectHighlightedCard();
          }
        }
      });

      gameOverlay.addEventListener('click', event => {
        if (event.target === gameOverlay) {
          closeGame();
        }
      });

      gameFrame.addEventListener('load', () => {
        if (!gameActive) return;
        try {
          const frameWindow = gameFrame.contentWindow;
          if (frameWindow) {
            const keyListener = event => {
              if (!gameActive) {
                frameWindow.removeEventListener('keydown', keyListener);
                return;
              }
              const key = event.key ? event.key.toLowerCase() : '';
              if (key === 'escape' || key === 'esc') {
                event.preventDefault();
                closeGame();
              } else if (key === 'q') {
                event.preventDefault();
                closeGame();
              }
            };
            frameWindow.addEventListener('keydown', keyListener);
          }
        } catch {}
        focusGameFrame();
      });

      setSelectedMode(0);
      refreshLanguageDependentText();
    })();
  </script>

  <script src="../../js/translationmain.js"></script>
</body>
</html>
