<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title class="translate"
          data-fr="Cartes mémoire"
          data-en="Memory cards" data-ja="神経衰弱カード">Cartes mémoire</title>

  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">
  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    /* Lang toggle */
    #langToggle {
      position: fixed;
      top: 10px; right: 10px;
      z-index: 99999;
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 10px; border: 2px solid #009688;
      background: #fff; color: #009688; font-weight: 700; cursor: pointer;
      user-select: none;
    }
    .game-container {
      width: 100%;
      max-width: 100vw;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px;
    }

    /* GRID: le seul espacement visible est le gap */
    .game-grid {
      display: grid;
      gap: 16px;                 /* sera écrasé par JS */
      width: 100%;
      height: 100%;
      place-content: center;
      justify-items: stretch;
      align-items: stretch;
      box-sizing: border-box;
    }

    .card {
      background-color: #ffffff;
      border: 2px solid #cccccc;
      border-radius: 10px;
      position: relative;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      width: 100%;
      height: 100%;
      aspect-ratio: 1 / 1;
    }

    .card-front, .card-back {
      position: absolute;
      inset: 0;
      border-radius: 10px;
      transition: opacity 0.6s ease;
    }
    .card-front { background-color: #f0f0f0; opacity: 1; }
    .card-back  {
      background-color: #ffffff;
      opacity: 0;
      display: flex; align-items: center; justify-content: center;
    }
    .card-back img { width: 100%; height: 100%; object-fit: contain; }
    .card.flipped .card-front { opacity: 0; }
    .card.flipped .card-back  { opacity: 1; }

    /* Dwell overlay */
    .dwell-fill {
      position: absolute;
      background-color: rgba(255, 0, 0, 0.5);
      top: 50%; left: 50%;
      width: 0; height: 0;
      transform: translate(-50%, -50%);
      pointer-events: none;
      border-radius: 8px;
    }

    .eyegaze-frozen #eyegaze-overlay *,
    .eyegaze-frozen .dwell-fill {
      animation-play-state: paused !important;
      transition: none !important;
    }
  </style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>
<body>

<button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title" class="translate"
        data-fr="Cartes mémoire"
        data-en="Memory cards" data-ja="神経衰弱カード">Cartes mémoire</h2>
  </div>
  <div id="control-panel-options">
    <div id="mode-divider"></div>
    <div id="options-inline-container">
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span class="translate" data-fr="Désactiver les sons" data-en="Disable sounds" data-ja="効果音をオフ">Désactiver les sons</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span class="translate" data-fr="Volume des sons:" data-en="Sound volume:" data-ja="効果音の音量：">Volume des sons:</span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>
          <div class="option-item">
          <label for="layoutScale" class="teal-label">
            <span class="translate" data-fr="Taille" data-en="Size" data-ja="サイズ">Taille</span>
            <span id="layoutScaleVal">1.00</span>
          </label>
          <input type="range" id="layoutScale" class="styled-slider" min="0.6" max="1.6" step="0.05" value="1.0">
        </div>
      </div>

      <div class="options-column">
        <div class="option-item">
          <label for="categorySelect" class="teal-label label-block translate"
                 data-fr="Catégorie" data-en="Category" data-ja="カテゴリー">Catégorie</label>
          <select id="categorySelect" class="styled-select"></select>
        </div>

        <div class="option-item">
          <label for="pairCount" class="teal-label">
            <span class="translate" data-fr="Nombre de paires:" data-en="Number of pairs:" data-ja="ペアの数：">Nombre de paires:</span>
            <span id="pairCountVal">2</span>
          </label>
          <input type="range" id="pairCount" class="styled-slider" min="2" max="6" value="2">
        </div>

        <!-- Slider unique taille + espace -->

      </div>

      <div class="options-column">
        <div class="option-item">
          <label for="dwellTimeSlider" class="teal-label">
            <span class="translate" data-fr="Temps de fixation:" data-en="Dwell time:" data-ja="注視時間：">Temps de fixation:</span>
            <span id="dwellTimeVal">1500</span> ms
          </label>
          <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="5000" step="100" value="1500">
        </div>
        <div class="option-item">
          <label for="themeSelect" class="teal-label label-block translate"
                 data-fr="Mode" data-en="Theme" data-ja="テーマ">Mode</label>
          <select id="themeSelect" class="styled-select">
            <option value="light" selected class="translate" data-fr="Clair" data-en="Light" data-ja="ライト">Clair</option>
            <option value="dark" class="translate" data-fr="Sombre" data-en="Dark" data-ja="ダーク">Sombre</option>
          </select>
        </div>

        <div class="option-item gp-compact">
          <label class="teal-label">
            <input type="checkbox" id="showGazePointer" checked>
            <span class="translate" data-fr="Afficher le pointeur (cache la souris)" data-en="Show gaze pointer (hide mouse)" data-ja="視線ポインターを表示（マウスを非表示）">
              Afficher le pointeur (cache la souris)
            </span>
          </label>

          <details id="gpDetails">
            <summary class="gp-summary">
              <span class="translate" data-fr="Options avancées du pointeur" data-en="Pointer advanced options" data-ja="ポインターの詳細設定">
                Options avancées du pointeur
              </span>
            </summary>

            <div class="gp-advanced">
              <div class="gp-row">
                <label for="gazeSize" class="teal-label gp-label">
                  <span class="translate" data-fr="Taille" data-en="Size" data-ja="サイズ">Taille</span>:
                  <span id="gazeSizeVal">36</span> px
                </label>
                <input type="range" id="gazeSize" class="styled-slider gp-range" min="16" max="100" step="2" value="36">
              </div>

              <div class="gp-row">
                <label for="gazeOpacity" class="teal-label gp-label">
                  <span class="translate" data-fr="Opacité" data-en="Opacity" data-ja="不透明度">Opacité</span>:
                  <span id="gazeOpacityVal">100</span>%
                </label>
                <input type="range" id="gazeOpacity" class="styled-slider gp-range" min="20" max="100" step="5" value="100">
              </div>
            </div>
          </details>
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
  </div>
</div>

<div class="game-container">
  <div id="game-grid" class="game-grid"></div>
</div>

<div id="gazePointer" aria-hidden="true"></div>

<script src="../../js/eyegaze-menu.js"></script>
<script src="../../js/translationmain.js"></script>
<script>
/* =========================
   Translations (same approach)
   ========================= */
const LS_LANG_KEY = 'siteLanguage';

const languages = ['fr', 'en', 'ja'];
const langToggle  = document.getElementById('langToggle');

function getLang(){
  try {
    const saved = localStorage.getItem(LS_LANG_KEY);
    if (saved === 'en' || saved === 'fr' || saved === 'ja') return saved;
  } catch(e){}
  return (['en','fr','ja'].includes(document.documentElement.lang)) ? document.documentElement.lang : 'fr';
}
function setLang(lang){
  const safe = (lang === 'en' || lang === 'fr' || lang === 'ja') ? lang : 'fr';
  document.documentElement.lang = safe;
  try { localStorage.setItem(LS_LANG_KEY, safe); } catch(e){}
  document.querySelectorAll('.translate').forEach(el=>{
      const text = el.getAttribute(`data-${safe}`);
      if (text != null) el.textContent = text;
    });
  if (window.pictosData) populateCategoriesSelect(document.getElementById('categorySelect').value);
}
(function normalizeLangOnLoad(){
  let initial = 'fr';
  try {
    const saved = localStorage.getItem(LS_LANG_KEY);
    if (saved === 'en' || saved === 'fr' || saved === 'ja') initial = saved;
    else {
      initial = (['en','fr','ja'].includes(document.documentElement.lang)) ? document.documentElement.lang : 'fr';
      localStorage.setItem(LS_LANG_KEY, initial);
    }
  } catch(e){ initial = (['en','fr','ja'].includes(document.documentElement.lang)) ? document.documentElement.lang : 'fr'; }
  setLang(initial);
})();
langToggle.addEventListener('click', ()=> {
    const current = getLang();
    const next = languages[(languages.indexOf(current) + 1) % languages.length];
    setLang(next);
  });

/* =========================
   Pictos JSON (new shape)
   ========================= */
var pictosData = null; // declare early to avoid TDZ
const PICTOS_JSON_PATH = '../../images/pictos/index.json';

function populateCategoriesSelect(preserveKey){
  const select = document.getElementById('categorySelect');
  if (!select || !pictosData) return;
  const lang = getLang();
  const prev = preserveKey || select.value;
  select.innerHTML = '';
  Object.entries(pictosData.categories).forEach(([key, obj])=>{
    const opt = document.createElement('option');
    opt.value = key;
    opt.textContent = obj.label?.[lang] || obj.label?.fr || obj.label?.en || key;
    select.appendChild(opt);
  });
  if (prev && pictosData.categories[prev]) select.value = prev;
}

fetch(PICTOS_JSON_PATH)
  .then(r => r.json())
  .then(data => { pictosData = data; populateCategoriesSelect(); })
  .catch(e => console.error('Erreur JSON pictos:', e));

/* =========================
   UI bindings & shared settings
   ========================= */
const pairCount     = document.getElementById('pairCount');
const pairCountVal  = document.getElementById('pairCountVal');
pairCount.addEventListener('input', () => pairCountVal.textContent = pairCount.value);

const layoutScaleEl = document.getElementById('layoutScale');
const layoutScaleVal= document.getElementById('layoutScaleVal');
layoutScaleEl.addEventListener('input', () => {
  layoutScaleVal.textContent = parseFloat(layoutScaleEl.value).toFixed(2);
  if (document.querySelector('.game-container').style.display === 'flex') {
    layoutScale = parseFloat(layoutScaleEl.value);
    cardSizeMultiplier = layoutScale;
    adjustCardSizes();
  }
});

const showGazePointer = document.getElementById('showGazePointer');
const gazeSize        = document.getElementById('gazeSize');
const gazeSizeVal     = document.getElementById('gazeSizeVal');
const gazeOpacity     = document.getElementById('gazeOpacity');
const gazeOpacityVal  = document.getElementById('gazeOpacityVal');
const gpDetails       = document.getElementById('gpDetails');
const gazePointer     = document.getElementById('gazePointer');

function ensurePointerOverlay() {
  if (!gazePointer) return null;
  let overlay = document.getElementById('gazePointerOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'gazePointerOverlay';
    overlay.setAttribute('aria-hidden', 'true');
    overlay.style.position = 'fixed';
    overlay.style.inset = '0';
    overlay.style.pointerEvents = 'none';
    overlay.style.zIndex = '2147483647';
    overlay.style.overflow = 'visible';
    document.body.appendChild(overlay);
  }
  if (gazePointer.parentElement !== overlay) {
    overlay.appendChild(gazePointer);
  }
  return overlay;
}

ensurePointerOverlay();

const dwellSlider  = document.getElementById('dwellTimeSlider');
const dwellTimeVal = document.getElementById('dwellTimeVal');
dwellSlider.addEventListener('input', () => {
  dwellTimeVal.textContent = dwellSlider.value;
  const dwellVal = parseInt(dwellSlider.value, 10) || 1500;
  try {
    if (typeof setEyegazeDwellTime === 'function') {
      setEyegazeDwellTime(dwellVal);
    } else if (window.eyegazeSettings) {
      eyegazeSettings.dwellTime = dwellVal;
      localStorage.setItem('eyegazeDwellTime', dwellVal);
    }
  } catch(e){}
});

const muteSFX   = document.getElementById('muteSFX');
const sfxVol    = document.getElementById('sfxVol');
const sfxVolVal = document.getElementById('sfxVolVal');
sfxVol.addEventListener('input', () => {
  sfxVolVal.textContent = sfxVol.value;
  try { if (window.eyegazeSettings) eyegazeSettings.sfxVolume = parseInt(sfxVol.value,10)||50; } catch(e){}
});
muteSFX.addEventListener('change', () => {
  try { if (window.eyegazeSettings) eyegazeSettings.sfxMuted = !!muteSFX.checked; } catch(e){}
});

const themeSelect = document.getElementById('themeSelect');
document.getElementById('startButton').addEventListener('click', startGame);

(function initShared(){
  try {
    if (window.eyegazeSettings) {
      if (typeof eyegazeSettings.dwellTime !== 'number') eyegazeSettings.dwellTime = 1500;
      if (typeof eyegazeSettings.sfxVolume !== 'number') eyegazeSettings.sfxVolume = 50;
      if (typeof eyegazeSettings.sfxMuted  !== 'boolean') eyegazeSettings.sfxMuted = false;
      if (typeof eyegazeSettings.showGazePointer !== 'boolean') eyegazeSettings.showGazePointer = true;
      if (typeof eyegazeSettings.gazePointerSize !== 'number') eyegazeSettings.gazePointerSize = 36;
      if (typeof eyegazeSettings.gazePointerAlpha !== 'number') eyegazeSettings.gazePointerAlpha = 1;
      dwellSlider.value   = eyegazeSettings.dwellTime;
      dwellTimeVal.textContent = eyegazeSettings.dwellTime;
      sfxVol.value = eyegazeSettings.sfxVolume;
      sfxVolVal.textContent = eyegazeSettings.sfxVolume;
      muteSFX.checked = !!eyegazeSettings.sfxMuted;
      if (showGazePointer) showGazePointer.checked = !!eyegazeSettings.showGazePointer;
      if (gazeSize) {
        const min = parseInt(gazeSize.min || '16', 10);
        const max = parseInt(gazeSize.max || '100', 10);
        const stored = Math.round(eyegazeSettings.gazePointerSize);
        if (!Number.isNaN(stored)) {
          gazeSize.value = Math.max(min, Math.min(max, stored));
        }
      }
      if (gazeOpacity) {
        const min = parseInt(gazeOpacity.min || '0', 10);
        const max = parseInt(gazeOpacity.max || '100', 10);
        const stored = Math.round(Math.max(0, Math.min(1, eyegazeSettings.gazePointerAlpha)) * 100);
        gazeOpacity.value = Math.max(min || 0, Math.min(max || 100, stored));
      }
    }
  } catch(e){}
})();

initEyegazeMenu();

/* =========================
   Game state
   ========================= */
let firstCard = null;
let secondCard = null;
let lockBoard = false;
let matchesFound = 0;

let currentPairs = 0;
let cardSizeMultiplier = 1;
let currentTheme = 'light';
let currentCategory = null;

let layoutScale = 1.0;
let controlsLocked = false;

let pointerLastPosition = { x: null, y: null };

const BASE_GAP = 100; // px
const EDGE_PAD = 10;  // px

function pointerSizeFromControls() {
  return parseInt(gazeSize?.value, 10) || 36;
}

function pointerOpacityFromControls() {
  const raw = parseInt(gazeOpacity?.value, 10);
  return Math.max(0, Math.min(1, (isNaN(raw) ? 100 : raw) / 100));
}

function setPointerPos(x, y) {
  if (!gazePointer) return;
  gazePointer.style.left = `${x}px`;
  gazePointer.style.top = `${y}px`;
}

function setPointerDwell(active) {
  if (!gazePointer) return;
  gazePointer.classList.toggle('gp-dwell', !!active);
}

function isGameActive() {
  return document.querySelector('.game-container')?.style.display === 'flex';
}

function applyPointerToggle() {
  if (!gazePointer) return;
  const size = pointerSizeFromControls();
  const opct = pointerOpacityFromControls();
  if (gazeSizeVal) gazeSizeVal.textContent = size;
  if (gazeOpacityVal) gazeOpacityVal.textContent = Math.round(opct * 100);
  gazePointer.style.setProperty('--gp-size', `${size}px`);
  const enable = !!showGazePointer?.checked && isGameActive();
  document.documentElement.classList.toggle('hide-native-cursor', enable);
  if (!enable) {
    setPointerDwell(false);
    if (gpDetails) gpDetails.open = false;
  }
  gazePointer.style.opacity = enable ? opct : 0;
  if (enable && pointerLastPosition.x !== null && pointerLastPosition.y !== null) {
    setPointerPos(pointerLastPosition.x, pointerLastPosition.y);
  }
}

if (gazePointer) {
  const rawHandler = (event) => {
    pointerLastPosition.x = event.clientX;
    pointerLastPosition.y = event.clientY;
    setPointerPos(event.clientX, event.clientY);
  };

  if ('onpointerrawupdate' in window) {
    window.addEventListener('pointerrawupdate', rawHandler, { passive: true });
  }
  window.addEventListener('pointermove', rawHandler, { passive: true });

  window.addEventListener('pointerleave', () => {
    gazePointer._savedOpacity = gazePointer.style.opacity;
    gazePointer.style.opacity = 0;
  });

  window.addEventListener('pointerenter', () => {
    applyPointerToggle();
    if (pointerLastPosition.x !== null && pointerLastPosition.y !== null) {
      setPointerPos(pointerLastPosition.x, pointerLastPosition.y);
    }
  });
}

if (showGazePointer) {
  showGazePointer.addEventListener('change', () => {
    try { if (window.eyegazeSettings) eyegazeSettings.showGazePointer = !!showGazePointer.checked; } catch(e){}
    applyPointerToggle();
  });
}

[gazeSize, gazeOpacity].forEach(ctrl => {
  if (!ctrl) return;
  ctrl.addEventListener('input', () => {
    try {
      if (window.eyegazeSettings) {
        if (ctrl === gazeSize) eyegazeSettings.gazePointerSize = pointerSizeFromControls();
        if (ctrl === gazeOpacity) eyegazeSettings.gazePointerAlpha = pointerOpacityFromControls();
      }
    } catch(e){}
    applyPointerToggle();
  });
});

applyPointerToggle();

function startGame() {
  // Hide language toggle once the game starts (menu-only display)
  document.getElementById('langToggle').style.display = 'none';

  // Plein écran
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.webkitRequestFullscreen) {
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) {
    document.documentElement.msRequestFullscreen();
  }

  try { if (eyegazeSettings?.hideOverlay) eyegazeSettings.hideOverlay(); } catch(e){}
  document.querySelector('.game-container').style.display = 'flex';
  applyPointerToggle();

  currentCategory    = document.getElementById('categorySelect').value;
  currentPairs       = parseInt(pairCount.value);
  layoutScale        = parseFloat(layoutScaleEl.value);
  cardSizeMultiplier = layoutScale;
  currentTheme       = themeSelect.value;

  applyTheme(currentTheme);

  const images = getImages(currentCategory, currentPairs);
  setupBoard(images);
}

function applyTheme(theme) {
  const bg = theme === 'dark' ? '#000' : '#fff';
  const fg = theme === 'dark' ? '#fff' : '#000';
  document.body.style.backgroundColor = bg;
  document.body.style.color = fg;
  const container = document.querySelector('.game-container');
  container.style.backgroundColor = bg;
  container.style.color = fg;
}

/* Use new JSON shape */
function getImages(category, pairs) {
  const base = pictosData.base || '';
  const items = (pictosData.categories[category]?.items || []).slice();
  // randomize, take N, duplicate, shuffle
  items.sort(() => Math.random() - 0.5);
  const selected = items.slice(0, pairs);
  const doubled  = [...selected, ...selected].map(it => base + it.file);
  return doubled.sort(() => Math.random() - 0.5);
}

function setupBoard(images) {
  const grid = document.getElementById('game-grid');
  grid.innerHTML = '';
  matchesFound = 0;
  firstCard = null;
  secondCard = null;
  lockBoard = false;
  controlsLocked = false;
  unfreezeEyegaze();

  grid.style.padding = EDGE_PAD + 'px';

  const total   = images.length;
  const columns = Math.ceil(Math.sqrt(total));
  grid.dataset.columns = String(columns);

  images.forEach(src => {
    const card = document.createElement('div');
    card.classList.add('card');
    card.dataset.image = src;

    const front = document.createElement('div');
    front.classList.add('card-front');

    const back = document.createElement('div');
    back.classList.add('card-back');
    const img = document.createElement('img');
    img.src = src;
    img.alt = ''; // pictos only; we’re not voicing here
    back.appendChild(img);

    card.appendChild(front);
    card.appendChild(back);
    grid.appendChild(card);

    card.addEventListener('pointerenter', () => startHover(card));
    card.addEventListener('pointerleave', stopHover);
  });

  adjustCardSizes();
}

/* Taille + gap pilotés par la même échelle, gap inverse de la taille + marge bord */
function adjustCardSizes() {
  const grid = document.getElementById('game-grid');
  const cards = grid.querySelectorAll('.card');
  if (!cards.length) return;

  const columns = parseInt(grid.dataset.columns || '2', 10);
  const rows    = Math.ceil(cards.length / columns);

  const GAP = Math.round(BASE_GAP / layoutScale);
  grid.style.gap = GAP + 'px';

  const containerW = grid.clientWidth;
  const containerH = grid.clientHeight || grid.parentElement.clientHeight;

  const contentW = Math.max(0, containerW - 2 * EDGE_PAD);
  const contentH = Math.max(0, containerH - 2 * EDGE_PAD);

  const maxCellW = (contentW - (columns - 1) * GAP) / columns;
  const maxCellH = (contentH - (rows    - 1) * GAP) / rows;

  const baseSize = Math.min(maxCellW, maxCellH) * 0.9;
  const size = Math.min(baseSize * cardSizeMultiplier, maxCellW, maxCellH);

  const track = Math.floor(size) + 'px';
  grid.style.gridTemplateColumns = `repeat(${columns}, ${track})`;
  grid.style.gridAutoRows        = track;

  cards.forEach(card => {
    card.style.width  = '100%';
    card.style.height = '100%';
  });
}
window.addEventListener('resize', adjustCardSizes);

function flipCard(card) {
  if (lockBoard || controlsLocked || card === firstCard) return;
  card.classList.add('flipped', 'selected');
  playSound('flip');
  if (!firstCard) { firstCard = card; return; }
  secondCard = card;
  checkForMatch();
}

function checkForMatch() {
  const isMatch = firstCard.dataset.image === secondCard.dataset.image;
  if (isMatch) {
    disableCards();
    freezeEyegaze();
    controlsLocked = true;

    /* Play per-pair success sound (NOT victory) timed with flip animation */
    setTimeout(() => playSound('pair'), 1400);

    setTimeout(() => {
      resetBoard();
      controlsLocked = false;
      unfreezeEyegaze();

      matchesFound++;
      if (matchesFound === currentPairs) {
        /* All matches found → play the existing final victory sound */
        playSound('victory');
        setTimeout(startNewSet, 1200);
      }
    }, 3000);

  } else {
    freezeEyegaze();
    controlsLocked = true;
    stopHover();

    setTimeout(() => playSound('error'), 1400);

    setTimeout(() => {
      if (firstCard)  firstCard.classList.remove('flipped','selected');
      if (secondCard) secondCard.classList.remove('flipped','selected');
      resetBoard();
      controlsLocked = false;
      unfreezeEyegaze();
    }, 3000);
  }
}

function disableCards() {
  firstCard.style.pointerEvents = 'none';
  secondCard.style.pointerEvents = 'none';
  resetBoard();
}

function resetBoard() {
  [firstCard, secondCard] = [null, null];
  lockBoard = false;
}

/* Nouvelle manche avec mêmes réglages */
function startNewSet() {
  applyTheme(currentTheme);
  const images = getImages(currentCategory, currentPairs);
  setupBoard(images);
  applyPointerToggle();
}

/* ====== Gel oculométrie ====== */
function freezeEyegaze() {
  document.documentElement.classList.add('eyegaze-frozen');
  try {
    if (window.eyegazeSettings?.pauseInput)   eyegazeSettings.pauseInput(true);
    if (window.eyegazeSettings?.freezeOverlay)eyegazeSettings.freezeOverlay(true);
  } catch (e) {}
}

function unfreezeEyegaze() {
  document.documentElement.classList.remove('eyegaze-frozen');
  try {
    if (window.eyegazeSettings?.pauseInput)   eyegazeSettings.pauseInput(false);
    if (window.eyegazeSettings?.freezeOverlay)eyegazeSettings.freezeOverlay(false);
  } catch (e) {}
}

/* ====== Dwell (shared time) ====== */
let hoverTimeout;
let currentOverlay;

function startHover(card) {
  if (controlsLocked) return;

  const hoverTime = (window.eyegazeSettings?.dwellTime) || parseInt(dwellSlider.value, 10) || 1500;
  stopHover();
  setPointerDwell(true);
  currentOverlay = document.createElement('div');
  currentOverlay.className = 'dwell-fill';
  card.appendChild(currentOverlay);
  requestAnimationFrame(() => {
    currentOverlay.style.transition = `width ${hoverTime}ms linear, height ${hoverTime}ms linear`;
    currentOverlay.style.width = '0';
    currentOverlay.style.height = '0';
    requestAnimationFrame(() => {
      currentOverlay.style.width = '100%';
      currentOverlay.style.height = '100%';
    });
  });
  hoverTimeout = setTimeout(() => {
    flipCard(card);
    stopHover();
  }, hoverTime);
}

function stopHover() {
  clearTimeout(hoverTimeout);
  setPointerDwell(false);
  if (currentOverlay) {
    currentOverlay.style.transition = '';
    currentOverlay.style.width = '0';
    currentOverlay.style.height = '0';
    if (currentOverlay.parentElement) currentOverlay.parentElement.removeChild(currentOverlay);
    currentOverlay = null;
  }
}

function playSound(name) {
  const volume = (window.eyegazeSettings?.sfxMuted) ? 0 : Math.max(0, Math.min(1, (window.eyegazeSettings?.sfxVolume || 50) / 100));
  let src;
  if (name === 'flip')        src = '../../sounds/success4.mp3';
  else if (name === 'error')  src = '../../sounds/error.mp3';
  else if (name === 'pair')   src = '../../sounds/flip.mp3'; // per-pair success
  else if (name === 'victory')src = '../../sounds/victory.mp3';  // final/all matched
  if (!src) return;
  const audio = new Audio(src);
  audio.volume = volume;
  audio.play().catch(()=>{});
}
</script>
<script src="../../js/eyegaze-quickstart.js"></script>
</body>
</html>
