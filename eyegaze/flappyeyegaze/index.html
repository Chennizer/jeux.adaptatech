<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title class="translate" data-fr="Vol d'oiseau" data-en="Birds" data-ja="È≥•">Birds</title>

  <!-- Shared styles (optional in your setup) -->
  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    :root { --fg:#e0fbfc; --ui-font: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    *{ box-sizing:border-box; }
    html,body { margin:0; height:100%; background:#0b1522; color:var(--fg); font-family:var(--ui-font); }

    #wrap { position:fixed; inset:0; }
    canvas#game { width:100vw; height:100vh; display:block; background:#87ceeb; }

    .hud {
      position:absolute; inset:0; pointer-events:none;
      display:flex; align-items:flex-start; justify-content:space-between; padding:12px 14px;
      font-weight:700; text-shadow:0 2px 0 rgba(0,0,0,.25);
    }
    #language-toggle{
      position:fixed; top:10px; right:10px; z-index:99999;
      padding:6px 10px; border-radius:10px; border:2px solid #009688;
      background:#fff; color:#009688; font-weight:700; cursor:pointer;
      user-select:none;
    }
    .badge{
      pointer-events:none;
      background:rgba(0,0,0,.35);
      padding:.35rem .6rem; border-radius:999px; font-size:14px;
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(2px);
    }

    .footer { position:absolute; bottom:8px; left:0; right:0; display:flex; gap:8px; justify-content:center; pointer-events:none; }
    .kbd{ pointer-events:none; font-size:12px; padding:.2rem .45rem; border:1px solid rgba(255,255,255,.18); border-bottom-width:2px; background:rgba(255,255,255,.06); border-radius:6px; }

    .small-note{ font-family:var(--ui-font); font-weight:700; letter-spacing:.25px; line-height:1.25; }

    /* Stacked bird pills */
    .bird-list{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:4px 0;
    }
    .bird-list .bird-chip{
      width:100%;
      display:flex;
      align-items:center;
      gap:10px;
      padding:.55rem .9rem;
      border-radius:999px;
      border:2px solid rgba(0,0,0,0.15);
      background:#fff;
      color:#000;
      cursor:pointer;
      user-select:none;
      font-weight:800;
      box-shadow:0 2px 10px rgba(0,0,0,0.06);
      transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease, color .2s ease;
    }
    .bird-list .bird-chip:hover{ transform: translateY(-1px); }
    .bird-list .bird-chip:focus{ outline: none; box-shadow:0 0 0 3px rgba(20,184,166,0.35); }
    .bird-list .bird-chip[data-active="true"]{
      background:#14b8a6;
      color:#ffffff;
      border-color:#0d9488;
      box-shadow:0 6px 20px rgba(20,184,166,0.35);
    }
    .bird-emoji{ font-size:1.25rem; line-height:1; }

    /* Dark mode fallback if you ever toggle .dark */
    .dark .bird-list .bird-chip{ background:#111; color:#fff; border-color:rgba(255,255,255,.18); }
    .dark .bird-list .bird-chip[data-active="true"]{ background:#0f766e; border-color:#14b8a6; }

    /* ===== Custom red circle pointer (shown only while game is active) ===== */
    #cursorPointer{
      position:fixed;
      top:0; left:0;
      width:18px; height:18px;
      border:2px solid #ff3b3b;
      border-radius:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      opacity:0;
      transition:opacity .15s ease, transform .06s ease;
      z-index:2147483647;
      box-shadow:0 0 0 3px rgba(255,59,59,0.12);
    }
    #cursorPointer::after{
      content:'';
      position:absolute;
      left:50%; top:50%;
      width:4px; height:4px;
      background:#ff3b3b;
      border-radius:50%;
      transform:translate(-50%,-50%);
    }
    #cursorPointer.click{ transform:translate(-50%,-50%) scale(0.85); }
    .game-active #wrap, .game-active canvas#game{ cursor:none; }
    .game-active #cursorPointer{ opacity:1; }
  </style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>
<body>

<button id="language-toggle" title="Changer de langue / Change language">FR / EN</button>

<!-- Options modal -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title" class="translate" data-fr="Vol d'oiseau" data-en="Birds" data-ja="È≥•">Birds</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Column 1: Audio -->
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span class="translate" data-fr="D√©sactiver les sons" data-en="Disable sounds" data-ja="ÂäπÊûúÈü≥„Çí„Ç™„Éï">D√©sactiver les sons</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span class="translate" data-fr="Volume des sons:" data-en="Sound volume:" data-ja="ÂäπÊûúÈü≥„ÅÆÈü≥ÈáèÔºö">Volume des sons:</span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>

        <!-- Music controls -->
        <div class="option-item" style="margin-top:8px;">
          <label class="teal-label">
            <input type="checkbox" id="muteMusic">
            <span class="translate" data-fr="D√©sactiver la musique" data-en="Disable music" data-ja="Èü≥Ê•Ω„Çí„Ç™„Éï">D√©sactiver la musique</span>
          </label>
        </div>
        <div class="option-item">
          <label for="musicVol" class="teal-label">
            <span class="translate" data-fr="Volume musique:" data-en="Music volume:" data-ja="Èü≥Ê•Ω„ÅÆÈü≥ÈáèÔºö">Volume musique:</span>
            <span id="musicVolVal">35</span>
          </label>
          <input type="range" id="musicVol" class="styled-slider" min="0" max="100" value="35">
        </div>
      </div>

      <!-- Column 2 (middle): Bird selector (STACKED PILLS) -->
      <div class="options-column">
        <div class="option-item">
          <div class="teal-label translate" data-fr="Oiseau / Th√®me" data-en="Bird / Theme" data-ja="È≥• / „ÉÜ„Éº„Éû">Oiseau / Th√®me</div>

          <div id="birdList" class="bird-list" role="listbox" aria-label="Bird">
            <button class="bird-chip" type="button" role="option" aria-selected="true" data-bird="classic" data-active="true">
              <span class="bird-emoji">üê•</span>
              <span class="translate" data-fr="Classique" data-en="Classic" data-ja="„ÇØ„É©„Ç∑„ÉÉ„ÇØ">Classique </span>
            </button>

            <button class="bird-chip" type="button" role="option" aria-selected="false" data-bird="owl">
              <span class="bird-emoji">ü¶â</span>
              <span class="translate" data-fr="Chouette" data-en="Owl" data-ja="„Éï„ÇØ„É≠„Ç¶">Chouette</span>
            </button>

            <button class="bird-chip" type="button" role="option" aria-selected="false" data-bird="parrot">
              <span class="bird-emoji">üê¶</span>
              <span class="translate" data-fr="Colibri" data-en="Hummingbird" data-ja="„Éè„ÉÅ„Éâ„É™">Perroquet </span>
            </button>
          </div>
        </div>
      </div>

      <!-- Column 3 (right): Difficulty + Controls -->
      <div class="options-column">
        <div class="option-item">
          <label for="difficultySelect" class="teal-label label-block translate" data-fr="Difficult√©" data-en="Difficulty" data-ja="Èõ£ÊòìÂ∫¶">Difficult√©</label>
          <select id="difficultySelect" class="styled-select">
            <option value="easy" selected class="translate" data-fr="Facile" data-en="Easy" data-ja="„Åã„Çì„Åü„Çì">Facile</option>
            <option value="normal" class="translate" data-fr="Normal" data-en="Normal" data-ja="„Åµ„Å§„ÅÜ">Normal</option>
            <option value="hard" class="translate" data-fr="Difficile" data-en="Hard" data-ja="„ÇÄ„Åö„Åã„Åó„ÅÑ">Difficile</option>
          </select>
        </div>

      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" data-ja="ÈñãÂßã">Commencer</button>
  </div>
</div>

<!-- Game area -->
<div id="wrap" aria-label="Flappy style game">
  <canvas id="game"></canvas>

  <div class="hud" aria-live="polite">
    <div class="badge"> <span class="translate" data-fr="Score:" data-en="Score:" data-ja="„Çπ„Ç≥„Ç¢Ôºö">Score:</span> <span id="score">0</span></div>
    <div class="badge"> <span class="translate" data-fr="Meilleur:" data-en="Best:" data-ja="„Éô„Çπ„ÉàÔºö">Meilleur:</span> <span id="best">0</span></div>
  </div>


</div>

<!-- Custom cursor element -->
<div id="cursorPointer" aria-hidden="true"></div>

<!-- Shared scripts (optional in your setup) -->
<script src="../../js/eyegaze-menu.js"></script>
<script src="../../js/translationmain.js"></script>
<script>
  document.getElementById('language-toggle')?.addEventListener('pointerup', toggleLanguage);
</script>

<script>
(() => {
  const languageToggleButton = document.getElementById('language-toggle');
  /* =========================
     Controls & UI
     ========================= */
  const muteSFX        = document.getElementById('muteSFX');
  const sfxVol         = document.getElementById('sfxVol');
  const sfxVolVal      = document.getElementById('sfxVolVal');
  const startButton    = document.getElementById('startButton');
  const difficultySel  = document.getElementById('difficultySelect');

  // Music controls (new)
  const muteMusic   = document.getElementById('muteMusic');
  const musicVol    = document.getElementById('musicVol');
  const musicVolVal = document.getElementById('musicVolVal');

  // Bird selector (STACKED PILLS)
  const birdList  = document.getElementById('birdList');
  const birdChips = Array.from(birdList.querySelectorAll('.bird-chip'));
  let birdSet = 'classic';

  birdChips.forEach(ch => {
    ch.addEventListener('click', () => {
      birdChips.forEach(c => { c.dataset.active = 'false'; c.setAttribute('aria-selected', 'false'); });
      ch.dataset.active = 'true';
      ch.setAttribute('aria-selected', 'true');
      birdSet = ch.dataset.bird || 'classic';
      loadSpriteSet(birdSet); // live preview swap
      // If music already playing, crossfade to matching track
      if (state === State.PLAYING && musicElA) musicCrossfade(themeForSet(birdSet), 0.6);
    });
  });

  sfxVol.addEventListener('input', () => sfxVolVal.textContent = sfxVol.value);
  if (musicVol) musicVol.addEventListener('input', () => (musicVolVal.textContent = musicVol.value));

  if (typeof initEyegazeMenu === 'function') initEyegazeMenu();

  /* =========================
     Canvas & Game
     ========================= */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let W = window.innerWidth;
  let H = window.innerHeight;
  let GH = Math.max(60, Math.round(H * 0.12)); // ground height
  let PIPE_W = Math.max(28, Math.round(W * 0.035)); // obstacle width basis
  let dpr = 1;

  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');

  let difficulty = 'easy';
  difficultySel.addEventListener('change', () => {
    difficulty = difficultySel.value;
    rescaleConfig();
  });

  /* =========================
     Custom red circle pointer
     ========================= */
  const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  const cursorEl = document.getElementById('cursorPointer');

  function onMouseMove(e){
    if (!cursorEl) return;
    cursorEl.style.left = e.clientX + 'px';
    cursorEl.style.top  = e.clientY + 'px';
  }
  function enableCustomCursor(){
    if (hasTouch) return;
    document.body.classList.add('game-active');
    window.addEventListener('mousemove', onMouseMove, { passive:true });
  }
  function disableCustomCursor(){
    if (hasTouch) return;
    document.body.classList.remove('game-active');
    window.removeEventListener('mousemove', onMouseMove, { passive:true });
  }
  if (!hasTouch){
    window.addEventListener('mousedown', ()=> cursorEl.classList.add('click'));
    window.addEventListener('mouseup',   ()=> cursorEl.classList.remove('click'));
  }

  // ---------- Audio: SFX ----------
  let AC, masterGain;
  function ensureAudio() {
    if (!AC) {
      AC = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = AC.createGain();
      masterGain.gain.value = effectiveVolume();
      masterGain.connect(AC.destination);
    }
    if (AC.state === 'suspended') AC.resume();
    updateMasterGain();
  }
  function effectiveVolume(){
    const muted = !!muteSFX.checked;
    const volPercent = parseInt(sfxVol.value, 10);
    return muted ? 0 : Math.max(0, Math.min(1, (isNaN(volPercent)?50:volPercent) / 100));
  }
  function updateMasterGain(){
    if (masterGain) masterGain.gain.value = effectiveVolume();
  }
  muteSFX.addEventListener('change', updateMasterGain);
  sfxVol.addEventListener('input', updateMasterGain);

  function beep(freq=600, dur=0.08, type='sine', vol=0.6) {
    if (!AC) return;
    const t0 = AC.currentTime + 0.001;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(masterGain);
    o.start(t0); o.stop(t0 + dur + 0.02);
  }
  function scoreChime(){ ensureAudio(); beep(850, .07, 'square', .5); setTimeout(()=>beep(1100,.06,'square',.45), 30); }
  function hitSfx(){ ensureAudio(); beep(200, .18, 'sawtooth', .35); setTimeout(()=>beep(120,.22,'sawtooth',.3), 40); }

  // ---------- Music: external MP3s with fade ----------
  // Put your mp3 files here:
  // ../../audio/flappy/classic.mp3, owl.mp3, parrot.mp3
  const THEME_MP3 = {
    classic: "../../songs/bird1.mp3",
    night:   "../../songs/bird2.mp3",
    sunny:   "../../songs/bird3.mp3"
  };

  let musicElA = null; // active track
  let musicElB = null; // crossfade target
  let musicFadeTimer = null;

  function effectiveMusicVolume(){
    if (!musicVol) return 0.35; // fallback default
    const muted = !!muteMusic.checked;
    const v = parseInt(musicVol.value, 10);
    return muted ? 0 : Math.max(0, Math.min(1, (isNaN(v)?35:v)/100));
  }
  function setMusicVolImmediate(v){
    if (musicElA) musicElA.volume = v;
    if (musicElB) musicElB.volume = Math.min(musicElB.volume, v);
  }
  if (muteMusic) muteMusic.addEventListener('change', ()=> setMusicVolImmediate(effectiveMusicVolume()));
  if (musicVol)  musicVol.addEventListener('input',  ()=> setMusicVolImmediate(effectiveMusicVolume()));

  function createMusicEl(src){
    const a = new Audio();
    a.src = src;
    a.preload = "auto";
    a.loop = true;
    a.volume = effectiveMusicVolume();
    a.crossOrigin = "anonymous";
    return a;
  }
  function fadeVolume(el, from, to, sec, onEnd){
    if (!el) return;
    if (musicFadeTimer) cancelAnimationFrame(musicFadeTimer);
    const start = performance.now();
    const dur = Math.max(50, sec*1000);
    function step(now){
      const k = Math.min(1, (now - start)/dur);
      el.volume = from + (to - from) * k;
      if (k < 1) musicFadeTimer = requestAnimationFrame(step);
      else if (onEnd) onEnd();
    }
    musicFadeTimer = requestAnimationFrame(step);
  }
  function crossfade(outEl, inEl, sec, targetVol, startVol=0.0001){
    if (outEl) fadeVolume(outEl, outEl.volume, 0.0001, sec);
    if (inEl)  fadeVolume(inEl, startVol, targetVol, sec);
  }
  function themeForSet(setName){
    if (setName === 'owl') return 'night';
    if (setName === 'parrot') return 'sunny';
    return 'classic';
  }
  function startMusic(themeName, fadeInSec=0.8){
    const theme = themeName || themeForSet(birdSet);
    const src = THEME_MP3[theme];
    if (!src) return;

    // If same src already playing, just fade to current volume
    if (musicElA && musicElA.src.includes(src)) {
      fadeVolume(musicElA, musicElA.volume, effectiveMusicVolume(), fadeInSec);
      return;
    }

    if (musicElB) { musicElB.pause(); musicElB = null; }
    musicElB = createMusicEl(src);
    musicElB.volume = 0.0001;
    musicElB.play().catch(()=>{ /* will start after user interaction (Start) */ });

    crossfade(musicElA, musicElB, fadeInSec, effectiveMusicVolume(), 0.0001);
    setTimeout(()=>{
      if (musicElA && musicElA !== musicElB) musicElA.pause();
      musicElA = musicElB;
      musicElB = null;
    }, Math.max(50, fadeInSec*1000 + 50));
  }
  function musicCrossfade(themeName, fadeSec=0.6){
    if (!musicElA) return;
    startMusic(themeName, fadeSec);
  }
  function stopMusic(fadeOutSec=1.0){
    if (!musicElA) return;
    fadeVolume(musicElA, musicElA.volume, 0.0001, fadeOutSec, ()=> musicElA.pause());
  }

  // ---------- Game core ----------
  const rand = (a,b)=>a + Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  const State = { READY:0, PLAYING:1, PAUSED:2, DEAD:3 };
  let state = State.READY;
  let score = 0, best = parseInt(localStorage.getItem('flappy-best')||'0',10);
  bestEl.textContent = best;

  const presetsBase = {
    easy:   { gap: 240, speed: 1.0 },
    normal: { gap: 170, speed: 2.4 },
    hard:   { gap: 140, speed: 3.6 }
  };
  const SPACING_FACTOR = { easy: 0.42, normal: 0.33, hard: 0.27 };
  const FLOWER_GAP_MULT = { easy: 1.30, normal: 1.38, hard: 1.50 };

  let cfg = { gap: 220, speed: 2.4, spawn: 1.5 };

  function rescaleConfig() {
    const base = presetsBase[difficulty];
    cfg.gap   = Math.round(base.gap * (H / 640));
    cfg.speed = base.speed;
    const spacingPx = Math.max(200, Math.round(W * SPACING_FACTOR[difficulty]));
    const vx = cfg.speed * 60; // px/s
    cfg.spawn = spacingPx / vx; // seconds
  }

  const bird = { x: Math.round(W*0.25), y: Math.round(H*0.45), r: 14, angle: 0, wingPhase: 0 };
  let targetY = bird.y;
  function setTargetY(y){ targetY = clamp(y, bird.r+5, H - GH - bird.r - 5); }

  /* =========================
     Sprite sets (classic vs owl vs parrot)
     ========================= */
  const SPRITE_EXTS = [".png", ".webp", ".jpg", ".jpeg"];

  const BIRD_SETS = {
    classic: {
      bases: [
        "../../images/flappybird/birdup",
        "../../images/flappybird/birdmid",
        "../../images/flappybird/birddown"
      ],
      cycle: [1, 0, 1, 2],
      scaleH: 6,
      theme: 'day-pipes'
    },
    owl: {
      bases: [
        "../../images/flappybird/owlsprite1",
        "../../images/flappybird/owlsprite2",
        "../../images/flappybird/owlsprite3"
      ],
      cycle: [0, 1, 2],
      scaleH: 6.5,
      theme: 'night-flowers'   // owl = night sky + FLOWERS
    },
    parrot: {
      bases: [
        "../../images/flappybird/hummingbird1",
        "../../images/flappybird/hummingbird2",
        "../../images/flappybird/hummingbird3"
      ],
      cycle: [0, 1, 2],
      scaleH: 6.2,
      theme: 'sunny-flowers'
    }
  };

  let spriteFrames = [];
  let spriteReady  = false;
  let currentSet   = 'classic';
  let currentCycle = BIRD_SETS.classic.cycle;
  let currentScaleH= BIRD_SETS.classic.scaleH;
  let currentTheme = BIRD_SETS.classic.theme;

  function loadWithFallback(base){
    return new Promise(resolve=>{
      let i = 0;
      function tryNext(){
        if (i >= SPRITE_EXTS.length){ resolve(null); return; }
        const src = base + SPRITE_EXTS[i++]; const img = new Image();
        img.onload = ()=>resolve(img); img.onerror = tryNext; img.src = src;
      }
      tryNext();
    });
  }

  async function loadSpriteSet(name){
    const def = BIRD_SETS[name] || BIRD_SETS.classic;
    const imgs = await Promise.all(def.bases.map(loadWithFallback));
    const ok = imgs.filter(Boolean);
    spriteReady = (ok.length === def.bases.length);
    if (spriteReady) {
      spriteFrames = ok;
      currentSet   = name;
      currentCycle = def.cycle;
      currentScaleH= def.scaleH;
      currentTheme = def.theme;
    } else {
      spriteFrames = [];
      currentTheme = def.theme;
    }
  }

  // Obstacles
  const pipes = [];         let pipeTimer    = 0;
  const flowerTunnels = []; let flowerTimer  = 0;

  // Clouds & stars
  const clouds = [];
  function makeCloud() {
    const y = rand(20, H*0.55);
    const s = rand(0.6, 1.4);
    const w = rand(100, 200)*s;
    const h = rand(24, 42)*s;
    clouds.push({ x: W + w, y, w, h, speed: rand(12, 22)*s });
  }
  for(let i=0;i<8;i++) makeCloud();

  const stars = Array.from({length: 120}, () => ({
    x: Math.random(),
    y: Math.random()*0.7,
    r: Math.random()*1.2 + 0.3,
    tw: Math.random()*2*Math.PI
  }));

  let groundOffset = 0;

  function fit() {
    W = window.innerWidth; H = window.innerHeight;
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    GH = Math.max(60, Math.round(H * 0.12));
    PIPE_W = Math.max(28, Math.round(W * 0.035));
    rescaleConfig();
    bird.r = Math.max(10, Math.round(14 * (H / 640)));
    bird.x = Math.round(W * 0.25);
    setTargetY(targetY);
  }
  window.addEventListener('resize', fit, { passive:true });

  async function goFullscreen(){
    try{
      if (document.fullscreenElement) return;
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      setTimeout(()=>window.scrollTo(0,1), 50);
    }catch(e){}
  }

  function resetGameState(){
    rescaleConfig();
    score = 0; scoreEl.textContent = '0';
    pipes.length = 0; pipeTimer = 0;
    flowerTunnels.length = 0; flowerTimer = 0;
    groundOffset = 0;
    bird.x = Math.round(W*0.25);
    bird.y = Math.round(H*0.45);
    targetY = bird.y;
    bird.angle = 0; bird.wingPhase = 0;
    disableCustomCursor();
  }

  function restart(){ resetGameState(); state = State.READY; }

  async function startGame(){
    ensureAudio();
    await goFullscreen();
    try { document.getElementById('game-options').style.display = 'none'; } catch(e){}
    if (languageToggleButton) languageToggleButton.style.display = 'none';
    await loadSpriteSet(birdSet);
    if (state === State.DEAD) resetGameState();

    // Start music & custom cursor
    startMusic(themeForSet(birdSet), 0.8);
    enableCustomCursor();

    state = State.PLAYING;
  }

  // Keyboard
  window.addEventListener('keydown', e=>{
    if (e.key === 'p' || e.key === 'P'){
      if (state === State.PLAYING){
        state = State.PAUSED;
        disableCustomCursor();
      } else if (state === State.PAUSED){
        state = State.PLAYING;
        enableCustomCursor();
      }
    } else if (e.key === 'r' || e.key === 'R'){
      restart();
      stopMusic(0.5);
      disableCustomCursor();
    } else if (e.code === 'Space' || e.code === 'Enter'){
      if (state === State.READY || state === State.PAUSED || state === State.DEAD){
        e.preventDefault();
        startGame();
      }
    }
  });

  // Pointer
  window.addEventListener('mousedown', (e)=>{ if (state === State.PLAYING) setTargetY(e.clientY); });
  window.addEventListener('mousemove', (e)=>{ setTargetY(e.clientY); }, { passive:true });
  window.addEventListener('touchstart', (e)=>{ if (state === State.PLAYING && e.touches[0]) setTargetY(e.touches[0].clientY); }, { passive:true });
  window.addEventListener('touchmove', (e)=>{ if (e.touches[0]) setTargetY(e.touches[0].clientY); }, { passive:true });

  // Start button
  startButton.addEventListener('click', startGame);

  /* =========================
     Skies
     ========================= */
  function drawSkyDay() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#78c6ff');
    g.addColorStop(0.6, '#8ed0ff');
    g.addColorStop(1, '#b1e1ff');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
  function drawSun() {
    ctx.save();
    const cx = W*0.12, cy = H*0.16, r = Math.max(48, Math.min(W,H)*0.06);
    const glow = ctx.createRadialGradient(cx,cy,6, cx,cy,r*2.4);
    glow.addColorStop(0, 'rgba(255,230,170,.95)');
    glow.addColorStop(1, 'rgba(255,230,170,0)');
    ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(cx,cy,r*2.4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawSkyNight() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0b1020');
    g.addColorStop(1, '#081331');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // Twinkling stars
    ctx.save();
    for (const s of stars) {
      const tw = (Math.sin(performance.now()/600 + s.tw)+1)/2;
      ctx.globalAlpha = 0.4 + 0.6*tw;
      ctx.beginPath();
      ctx.arc(s.x*W, s.y*H, s.r, 0, Math.PI*2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
    }
    ctx.restore();

    // Moon
    const mx = W*0.16, my = H*0.18;
    ctx.save();
    const mr = Math.max(28, Math.min(W,H)*0.05);
    const mglow = ctx.createRadialGradient(mx,my,4, mx,my,mr*2.2);
    mglow.addColorStop(0,'rgba(255,255,230,0.85)');
    mglow.addColorStop(1,'rgba(255,255,230,0)');
    ctx.fillStyle = mglow; ctx.beginPath(); ctx.arc(mx,my,mr*2.2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#f6f1d5'; ctx.beginPath(); ctx.arc(mx,my,mr,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawSkySunny() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#7fd3ff');
    g.addColorStop(0.6, '#9fe0ff');
    g.addColorStop(1, '#c7ecff');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    drawSun();
  }

  /* =========================
     Ground
     ========================= */
  function drawGround() {
    const y0 = H - GH;
    const g = ctx.createLinearGradient(0,y0,0,H);
    g.addColorStop(0,'#3b7f3b'); g.addColorStop(1,'#2c5f2c');
    ctx.fillStyle = g; ctx.fillRect(0,y0, W, GH);
    ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(0, y0, W, 2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0, y0+2, W, 2);

    const step = Math.max(60, Math.round(W * 0.06));
    const offset = groundOffset % step;
    function pebble(cx, cy, w, h, color){
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(cx, cy, w, h, 0, 0, Math.PI*2);
      ctx.fill();
    }
    for (let x = -offset; x < W + step; x += step) {
      pebble(x + 10, y0 + Math.round(GH*0.62), 14, 5, 'rgba(255,255,255,0.08)');
      pebble(x + 36, y0 + Math.round(GH*0.72), 10, 4, 'rgba(0,0,0,0.08)');
      pebble(x + 70, y0 + Math.round(GH*0.58), 8, 3,  'rgba(255,255,255,0.06)');
    }
  }

  /* =========================
     Pipes (day mode)
     ========================= */
  function drawPipe(x, topH, w=PIPE_W, gap=cfg.gap) {
    const bottomY = topH + gap;
    const capH = Math.max(10, Math.round(w * 0.36));
    const over = Math.max(6,  Math.round(w * 0.22));
    const bevelW = Math.max(3, Math.round(w * 0.10));

    const bodyGrad = ctx.createLinearGradient(x,0,x+w,0);
    bodyGrad.addColorStop(0.00, '#064f18');
    bodyGrad.addColorStop(0.16, '#0f8a2d');
    bodyGrad.addColorStop(0.50, '#39e15e');
    bodyGrad.addColorStop(0.84, '#0f8a2d');
    bodyGrad.addColorStop(1.00, '#064f18');

    ctx.fillStyle = bodyGrad;
    ctx.fillRect(x, 0, w, topH);
    ctx.fillRect(x, bottomY, w, H - bottomY);

    const stripeX1 = x + Math.round(w * 0.24);
    const stripeX2 = x + Math.round(w * 0.70);
    const stripeG1 = ctx.createLinearGradient(stripeX1-2,0,stripeX1+2,0);
    stripeG1.addColorStop(0,'rgba(255,255,255,0)');
    stripeG1.addColorStop(0.5,'rgba(255,255,255,0.22)');
    stripeG1.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = stripeG1;
    ctx.fillRect(stripeX1-2, 0, 4, topH);
    ctx.fillRect(stripeX1-2, bottomY, 4, H - bottomY);

    const stripeG2 = ctx.createLinearGradient(stripeX2-1,0,stripeX2+1,0);
    stripeG2.addColorStop(0,'rgba(255,255,255,0)');
    stripeG2.addColorStop(0.5,'rgba(255,255,255,0.12)');
    stripeG2.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = stripeG2;
    ctx.fillRect(stripeX2-1, 0, 2, topH);
    ctx.fillRect(stripeX2-1, bottomY, 2, H - bottomY);

    function roundRectPath(x, y, w, h, r){
      const rr = Math.min(r, h/2, w/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.lineTo(x+w-rr, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
      ctx.lineTo(x+w, y+h-rr);
      ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
      ctx.lineTo(x+rr, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
      ctx.lineTo(x, y+rr);
      ctx.quadraticCurveTo(x, y, x+rr, y);
      ctx.closePath();
    }

    function drawRim(cx, cy, cw, ch, facingDown){
      let base = ctx.createLinearGradient(cx, cy, cx, cy+ch);
      if (facingDown){
        base.addColorStop(0.00, '#6df279');
        base.addColorStop(0.45, '#2bd24f');
        base.addColorStop(1.00, '#18a83a');
      } else {
        base.addColorStop(0.00, '#18a83a');
        base.addColorStop(0.55, '#2bd24f');
        base.addColorStop(1.00, '#6df279');
      }
      ctx.fillStyle = base;
      roundRectPath(cx, cy, cw, ch, Math.round(ch*0.35));
      ctx.fill();

      function sideBevel(bx){
        const sg = ctx.createLinearGradient(bx, cy, bx+bevelW, cy);
        sg.addColorStop(0, 'rgba(0,0,0,0.45)');
        sg.addColorStop(0.6, 'rgba(0,0,0,0.0)');
        ctx.fillStyle = sg;
        roundRectPath(bx, cy+1, bevelW, ch-2, Math.round((ch-2)*0.33));
        ctx.fill();
      }
      sideBevel(cx);
      ctx.save(); ctx.translate(cx+cw,0); ctx.scale(-1,1); sideBevel(0); ctx.restore();

      const gloss = ctx.createLinearGradient(cx, cy, cx, cy+ch);
      gloss.addColorStop(0.15,'rgba(255,255,255,0.30)');
      gloss.addColorStop(0.35,'rgba(255,255,255,0.10)');
      gloss.addColorStop(0.65,'rgba(255,255,255,0.05)');
      gloss.addColorStop(1.00,'rgba(255,255,255,0.00)');
      ctx.fillStyle = gloss;
      roundRectPath(cx+2, cy+1, cw-4, Math.max(2, ch-2), Math.max(1, Math.round((ch-2)*0.28)));
      ctx.fill();

      ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(cx, cy, cw, 1);
      ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(cx+3, cy+Math.round(ch*0.28), cw-6, 1);

      const inner = facingDown
        ? ctx.createLinearGradient(cx, cy+ch-4, cx, cy+ch+6)
        : ctx.createLinearGradient(cx, cy-6, cx, cy+4);
      inner.addColorStop(0, 'rgba(0,0,0,0.35)');
      inner.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = inner;
      ctx.fillRect(cx, facingDown ? (cy+ch-4) : (cy-6), cw, 10);
    }

    drawRim(x - over, topH - capH, w + over*2, capH, true);
    drawRim(x - over, bottomY,      w + over*2, capH, false);
  }

  /* =========================
     Flowers (used by parrot & owl themes)
     ========================= */
  function makeFlowerStyle(){
    const petals = ['#ff5e7e','#ff9f1c','#ffd166','#06d6a0','#7b5cff','#ff66c4','#ff7f50'];
    const centers= ['#fff176','#ffe066','#faf3dd','#ffd6a5','#ffd97d'];
    return {
      petal: petals[Math.floor(Math.random()*petals.length)],
      center: centers[Math.floor(Math.random()*centers.length)],
      leaf: '#2f8f2f'
    };
  }

  function drawLeafShape(w, h) {
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.quadraticCurveTo(w*0.55, -h*0.25, 0, -h);
    ctx.quadraticCurveTo(-w*0.55, -h*0.25, 0, 0);
    ctx.closePath();
    ctx.fill();
  }

  function drawFlowerHead(size, style){
    const petals = 8;
    const petalR = size * 0.58;
    const petalSize = size * 0.95;
    ctx.fillStyle = style.petal;
    for (let i=0;i<petals;i++){
      const a = (i / petals) * Math.PI*2;
      const px = Math.cos(a) * petalR;
      const py = Math.sin(a) * petalR;
      ctx.beginPath();
      ctx.ellipse(px, py, petalSize*0.46, petalSize*0.36, a, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.fillStyle = style.center;
    ctx.beginPath();
    ctx.arc(0,0, size*0.42, 0, Math.PI*2);
    ctx.fill();
  }

  function drawStemAndLeaves(x, yBase, height, style, top=false){
    const stemW = Math.max(12, Math.round(PIPE_W * 0.55));
    const grad = ctx.createLinearGradient(x, top ? yBase-height : yBase, x, top ? yBase : yBase+height);
    grad.addColorStop(0, '#2e7d32');
    grad.addColorStop(1, '#1b5e20');
    ctx.fillStyle = grad;
    ctx.fillRect(x - stemW/2, top ? yBase - height : yBase, stemW, height);

    ctx.fillStyle = style.leaf;
    const leafW = stemW * 1.8;
    const leafH = stemW * 2.2;
    const baseY = top ? (yBase - height + leafH * 1.2) : (yBase + height - leafH * 1.2);

    ctx.save();
    ctx.translate(x - stemW*0.9, baseY);
    ctx.rotate(top ? Math.PI*0.9 : -Math.PI*0.1);
    drawLeafShape(leafW, leafH);
    ctx.restore();

    ctx.save();
    ctx.translate(x + stemW*0.9, baseY);
    ctx.rotate(top ? Math.PI*0.1 : -Math.PI*0.9);
    drawLeafShape(leafW, leafH);
    ctx.restore();

    return stemW;
  }

  function drawFlowerTunnel(t){
    const {x, topH, gap, style} = t;
    const bottomY = topH + gap;

    const topStemHeight    = topH;
    const bottomStemHeight = H - GH - bottomY;

    const cx = x + Math.floor(t.w/2);

    const stemWTop = drawStemAndLeaves(cx, topStemHeight, topStemHeight, style, true);
    const stemWBot = drawStemAndLeaves(cx, bottomY, bottomStemHeight, style, false);

    const headSize = Math.max(28, PIPE_W * 1.2);

    ctx.save(); ctx.translate(cx, topStemHeight); ctx.scale(1, -1); drawFlowerHead(headSize, style); ctx.restore();
    ctx.save(); ctx.translate(cx, bottomY); drawFlowerHead(headSize, style); ctx.restore();

    t._hit = {
      stemTop:    {x: cx - stemWTop/2, y: 0, w: stemWTop, h: topStemHeight},
      stemBottom: {x: cx - stemWBot/2, y: bottomY, w: stemWBot, h: H - GH - bottomY},
      headTop:    {cx, cy: topStemHeight, r: headSize*0.46},
      headBottom: {cx, cy: bottomY,      r: headSize*0.46}
    };
  }

  /* =========================
     Bird drawing
     ========================= */
  function drawBirdSprite(b) {
    const idx = currentCycle[Math.floor((b.wingPhase * 1) % currentCycle.length)];
    const img = spriteFrames[idx] || spriteFrames[0];
    if (!img) { drawBirdVector(b); return; }

    const desiredH = b.r * currentScaleH;
    const scale = desiredH / img.naturalHeight;
    const dw = img.naturalWidth * scale;
    const dh = img.naturalHeight * scale;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);
    ctx.drawImage(img, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  }

  function drawBirdVector(b) {
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);

    const bodyR = b.r;
    const bodyGrad = ctx.createRadialGradient(0,0, bodyR*0.2, 0,0, bodyR*1.1);
    bodyGrad.addColorStop(0, '#ffd166'); bodyGrad.addColorStop(1, '#f4a261');
    ctx.fillStyle = bodyGrad; ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.beginPath(); ctx.ellipse(0, bodyR*0.2, bodyR*0.9, bodyR*0.7, 0, 0, Math.PI*2); ctx.fill();

    ctx.save();
    const wingA = Math.sin(b.wingPhase)*0.6 - 0.2;
    ctx.rotate(wingA); ctx.translate(-bodyR*0.1, 0);
    ctx.fillStyle = '#f77f00';
    ctx.beginPath(); ctx.ellipse(-bodyR*0.1, 0, bodyR*0.7, bodyR*0.45, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(bodyR*0.35, -bodyR*0.25, bodyR*0.28, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(bodyR*0.45, -bodyR*0.25, bodyR*0.12, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#ff7f00';
    ctx.beginPath(); ctx.moveTo(bodyR*0.9, 0);
    ctx.lineTo(bodyR*1.4, -bodyR*0.1);
    ctx.lineTo(bodyR*0.9, -bodyR*0.25);
    ctx.closePath(); ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawBird(b) {
    if (spriteReady && spriteFrames.length) drawBirdSprite(b);
    else drawBirdVector(b);
  }

  /* =========================
     Collision helpers
     ========================= */
  function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  /* =========================
     Loop
     ========================= */
  let last = performance.now();
  fit();

  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt, now);
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function usingFlowers(){ return currentTheme === 'sunny-flowers' || currentTheme === 'night-flowers'; }
  function isNight(){ return currentTheme === 'night-flowers'; }

  function update(dt, now){
    rescaleConfig();

    const flapSpeed = (currentSet === 'owl') ? 10 : (currentSet === 'parrot' ? 9.5 : 8.5);
    bird.wingPhase += (state === State.PLAYING ? flapSpeed : 10)*dt;

    groundOffset += (cfg.speed * 60) * dt * 0.18;

    for (const c of clouds){ c.x -= c.speed*dt; }
    while (clouds.length && clouds[0].x + clouds[0].w < -10) clouds.shift();
    if (clouds.length < 8 && Math.random() < 0.02) makeCloud();

    if (state === State.PAUSED || state === State.READY || state === State.DEAD){
      if (state === State.READY){
        bird.y += Math.sin(now*0.004)*0.3;
        bird.angle = Math.sin(now*0.004)*0.05;
      }
      return;
    }

    const followSpeed = 8;
    const t = clamp(followSpeed * dt, 0, 1);
    const dy = targetY - bird.y;
    bird.y += dy * t;
    bird.angle = clamp(dy * 0.0025, -0.6, 0.6);

    bird.y = clamp(bird.y, bird.r+5, H - GH - bird.r - 5);

    if (usingFlowers()){
      // FLOWER SPAWN
      flowerTimer -= dt;
      if (flowerTimer <= 0){
        const gap = Math.round(cfg.gap * (FLOWER_GAP_MULT[difficulty] || 1.35));
        const margin = 30;
        const minY = margin + 30, maxY = H - margin - 30 - GH;
        const center = rand(minY + gap/2, Math.max(minY + gap/2, maxY - gap/2));
        flowerTunnels.push({
          x: W + 8, topH: center - gap/2, w: PIPE_W, gap,
          scored: false, style: makeFlowerStyle(), _hit: null
        });
        if (flowerTunnels.length > 12) flowerTunnels.shift();
        flowerTimer = cfg.spawn;
      }
      for (const f of flowerTunnels){
        f.x -= (cfg.speed * 60) * dt;
        if (!f.scored && f.x + f.w < bird.x - bird.r){
          f.scored = true; score++; scoreEl.textContent = score; scoreChime();
        }
      }
      while (flowerTunnels.length && flowerTunnels[0].x + flowerTunnels[0].w < -10) flowerTunnels.shift();

    } else {
      // PIPES
      pipeTimer -= dt;
      if (pipeTimer <= 0){
        const gap = cfg.gap;
        const margin = 30;
        const minY = margin + 30, maxY = H - margin - 30 - GH;
        const center = rand(minY + gap/2, Math.max(minY + gap/2, maxY - gap/2));
        pipes.push({ x: W + 8, topH: center - gap/2, w: PIPE_W, gap, scored:false });
        if (pipes.length > 12) pipes.shift();
        pipeTimer = cfg.spawn;
      }
      for (const p of pipes){
        p.x -= (cfg.speed * 60) * dt;
        if (!p.scored && p.x + p.w < bird.x - bird.r){
          p.scored = true; score++; scoreEl.textContent = score; scoreChime();
        }
      }
      while (pipes.length && pipes[0].x + pipes[0].w < -10) pipes.shift();
    }

    // Collisions
    const hitTop = bird.y - bird.r < 0;
    const hitGround = bird.y + bird.r > H - GH;
    let hitObstacle = false;

    if (usingFlowers()){
      for (const f of flowerTunnels){
        if (!f._hit){
          const headSize = Math.max(28, PIPE_W*1.2);
          const stemW = Math.max(12, Math.round(PIPE_W*0.55));
          const bottomY = f.topH + f.gap;
          const cx = f.x + f.w/2;
          f._hit = {
            stemTop:    {x: cx - stemW/2, y: 0, w: stemW, h: f.topH},
            stemBottom: {x: cx - stemW/2, y: bottomY, w: stemW, h: H - GH - bottomY},
            headTop:    {cx, cy: f.topH, r: headSize*0.46},
            headBottom: {cx, cy: bottomY, r: headSize*0.46}
          };
        }
        const h = f._hit;
        if ( circleRectCollide(bird.x, bird.y, bird.r, h.stemTop.x, h.stemTop.y, h.stemTop.w, h.stemTop.h) ||
             circleRectCollide(bird.x, bird.y, bird.r, h.stemBottom.x, h.stemBottom.y, h.stemBottom.w, h.stemBottom.h) ){
          hitObstacle = true; break;
        }
        const c1 = ( (bird.x - h.headTop.cx)**2 + (bird.y - h.headTop.cy)**2 <= (bird.r + h.headTop.r)**2 );
        const c2 = ( (bird.x - h.headBottom.cx)**2 + (bird.y - h.headBottom.cy)**2 <= (bird.r + h.headBottom.r)**2 );
        if (c1||c2){ hitObstacle = true; break; }
      }
    } else {
      for (const p of pipes){
        if (circleRectCollide(bird.x, bird.y, bird.r, p.x, 0, p.w, p.topH) ||
            circleRectCollide(bird.x, bird.y, bird.r, p.x, p.topH + p.gap, p.w, H - GH - (p.topH + p.gap)) ){
          hitObstacle = true; break;
        }
      }
    }

    if (hitTop || hitGround || hitObstacle){
      if (state !== State.DEAD){
        state = State.DEAD;
        hitSfx();
        stopMusic(1.2); // fade out track on game over
        disableCustomCursor(); // restore system cursor
        if (score > best){ best = score; localStorage.setItem('flappy-best', String(best)); bestEl.textContent = best; }
        setTimeout(()=>{
          try { document.getElementById('game-options').style.display = 'flex'; } catch(e){}
          if (languageToggleButton) languageToggleButton.style.display = '';
        }, 450);
      }
    }
  }

  function draw(){
    if (isNight()) drawSkyNight();
    else if (currentTheme === 'sunny-flowers') drawSkySunny();
    else { drawSkyDay(); drawSun(); }

    if (!isNight()) {
      ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.92)';
      for (const c of clouds) roundedCloud(c);
      ctx.restore();
    }

    if (usingFlowers()){
      for (const f of flowerTunnels) drawFlowerTunnel(f);
    } else {
      for (const p of pipes) drawPipe(p.x, p.topH, p.w, p.gap);
    }

    drawBird(bird);
    drawGround();

    if (state === State.DEAD){
      const W2 = window.innerWidth, H2 = window.innerHeight;
      ctx.save();
      const g = ctx.createRadialGradient(W2/2,H2/2, 50, W2/2,H2/2, Math.max(W2,H2)*0.6);
      g.addColorStop(0, 'rgba(239,71,111,0)');
      g.addColorStop(1, 'rgba(239,71,111,0.25)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W2,H2);
      ctx.restore();
    }
  }

  function roundedCloud(c){
    const {x,y,w,h} = c;
    ctx.beginPath();
    const r = h/2;
    ctx.moveTo(x, y+h);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.quadraticCurveTo(x+w*0.35, y-h*.8, x+w*0.55, y);
    ctx.quadraticCurveTo(x+w-r, y, x+w, y+h);
    ctx.quadraticCurveTo(x+w, y+h*1.2, x+w-r, y+h*1.25);
    ctx.quadraticCurveTo(x+w*.55, y+h*1.6, x+w*.4, y+h*1.25);
    ctx.quadraticCurveTo(x+r, y+h*1.4, x, y+h);
    ctx.closePath(); ctx.fill();
  }

  // Init
  function initialLoad(){
    loadSpriteSet(birdSet);
    restart();
  }
  initialLoad();
})();
</script>
</body>
</html>
