
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title data-fr="Initiation à la programmation physique" data-en="Introduction to Physical Programming" data-ja="Introduction to Physical Programming">Initiation à la programmation physique</title>

  <!-- CSS Files -->
  <link rel="stylesheet" href="../../css/menu.css" />
  <link rel="stylesheet" href="../../css/global.css" />
  <link rel="stylesheet" href="../../css/layout.css" />
  <link rel="stylesheet" href="../../css/components.css" />
  <link rel="stylesheet" href="../../css/instructions.css" />

  <!-- Custom Styles for the new layout structure -->
  <style>
    /* Clearfix for the main container */
    .instruction-container::after {
      content: "";
      display: table;
      clear: both;
    }
    /* Two-column flex layout for sections if needed */
    .two-col {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 20px;
      margin-bottom: 40px;
    }
    .two-col .text {
      flex: 1;
      min-width: 250px;
    }
    .two-col .image {
      flex: 0 0 30vw;
      max-width: 30vw;
    }
    .two-col .image img {
      width: 100%;
      height: auto;
      display: block;
    }
    @media (max-width: 800px) {
      .two-col {
        flex-direction: column;
      }
      .two-col .image {
        flex: none;
        width: 100%;
        max-width: 100%;
      }
    }
    /* Styling for inline floated images */
    .img-float-right {
      float: right;
      width: 30vw;
      max-width: 100%;
      margin-right: 50px;
      margin-bottom: 20px;
      padding-top: 20px;
      padding-left: 20px;
    }
    /* Styling for side-by-side images */
    .images-row {
      display: flex;
      margin-top: 10px;
      margin-bottom: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 5px;
    }
    .images-row img {
      width: 20vw;
      margin: 0;
    }
    pre code {
      display: block;
      background-color: #2d2d2d;  /* Dark background for contrast */
      color: #f8f8f2;             /* Light text color */
      padding: 1rem;              /* Space inside the code block */
      border-radius: 8px;         /* Rounded corners */
      font-family: 'Source Code Pro', monospace; /* Monospaced font */
      overflow-x: auto;           /* Horizontal scroll if content exceeds width */
    }
    pre {
      margin: 1rem 0;             /* Vertical spacing around code blocks */
    }
  </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
<body class="menu">
  <!-- Top Navigation -->
  <nav class="top-menu">
    <div class="top-menu-title" data-fr="Portail de jeux adaptés" data-en="Adapted Games Portal" data-ja="Adapted Games Portal">Portail de jeux adaptés</div>
    <ul>
      <li>
        <strong><a href="../index.html" data-fr="Accueil" data-en="Home" data-ja="Home">Accueil</a></strong>
      </li>
      <li>
        <strong><a href="#" id="language-toggle" onclick="toggleLanguage(); return false;" data-fr="Anglais" data-en="Français" data-ja="Français">Anglais</a></strong>
      </li>
    </ul>
  </nav>

  <!-- Hero Section -->
  <div class="hero-minimalist">
    <h1 data-fr="Initiation à la programmation physique" data-en="Introduction to Physical Programming" data-ja="Introduction to Physical Programming">Initiation à la programmation physique</h1>
  </div>

  <!-- Main Content Container -->
  <main class="instruction-container">
  
    <!-- Section: Programmation physique -->
    <section>
      <h3 data-fr="Programmation physique" data-en="Physical Programming" data-ja="Physical Programming">Programmation physique</h3>
      <p data-fr="
La programmation physique consiste à développer le logiciel qui contrôle un microcontrôleur. Cet outil est essentiel pour concevoir du matériel adapté. 
Par exemple, il permet de créer des switchs numériques qui peuvent être pertinentes dans de nombreux contextes.
      
Grâce à cette approche, les possibilités créatives sont vastes. Les technologies adaptées deviennent accessibles à un public large, y compris aux personnes à force manuelle limitée. Par exemple, des capteurs de proximité (infrarouge, ultrasons) requièrent moins d'effort qu'un bouton classique, tandis que des switchs de type <em>Sip and Puff</em> (souffle et aspiration) – associées à un capteur barométrique – offrent une alternative pour ceux dont la mobilité est réduite.
      <br/>
De plus, la programmation physique permet de développer des projets technologiques au-delà des switchs adaptées. 
Il est possible d'exploiter ce dispositif pour concevoir des projets interactifs variés, qu'il s'agisse de piloter des moteurs, de moduler l'éclairage ou d'activer des haut-parleurs.¨En programmant comme entrée une switch adaptée, un appareil peut recevoir un signal qui, en retour, déclenche l'action d'un mécanisme – qu'il s'agisse d'un moteur, d'une pompe, de luminaires ou de tout autre petit équipement électronique – offrant ainsi des possibilités infinies et laissant libre cours à une créativité sans limite. 
      
Cet article présente une vue d'ensemble des principes de base de la programmation physique et son potentiel. L'objectif n'est pas d'offrir un tutoriel complet, mais de montrer comment démarrer. Des ressources supplémentaires (en anglais) seront indiquées en conclusion.
      " data-en="Physical programming means developing the software that controls a microcontroller. This tool is essential for designing adaptive hardware. For example, it makes it possible to create digital switches that can be useful in many contexts.

Thanks to this approach, creative possibilities are vast. Assistive technologies become accessible to a broad audience, including individuals with limited manual strength. For instance, proximity sensors (infrared or ultrasonic) require less effort than a traditional push button, while Sip-and-Puff switches—paired with a barometric sensor—offer an alternative for users with reduced mobility.
<br/>
Beyond adapted switches, physical programming supports many interactive technology projects. You can use it to control motors, lighting, or speakers. By programming an adaptive switch as an input, a device can receive a signal that triggers an action—whether it’s a motor, a pump, lighting, or other small electronic equipment—opening the door to endless possibilities and creativity.
<br/>
This article presents an overview of the basics of physical programming and its potential. The goal is not to provide a full tutorial, but to show how to get started. Additional English resources are listed at the end.">
      </p>
    </section>

    <section>
      <h3 data-fr="Choix de langage de programmation" data-en="Choosing a Programming Language" data-ja="Choosing a Programming Language">Choix de langage de programmation</h3>
      <p data-fr="
      Pour construire un dispositif numérique efficace, il faut choisir des technologies de base : le capteur, le microcontrôleur et le langage de programmation. Le microcontrôleur, qui exécute le code et contrôle les composants électroniques, constitue le cœur de l'appareil. Dans ce projet, le Raspberry Pico est utilisé, apprécié pour sa polyvalence et son prix abordable (environ 6 à 7 dollars). Un capteur de proximité, tel que le KY-032, est également intégré pour sa fiabilité et sa simplicité, permettant de détecter la présence ou le mouvement et d'interagir avec le dispositif.      " data-en="To build an effective digital device, you need to pick three core technologies: the sensor, the microcontroller, and the programming language. The microcontroller runs the code and drives the electronic components, so it’s the heart of the device. In this project, we use the Raspberry Pi Pico for its versatility and low cost (about $6–$7). A proximity sensor such as the KY-032 is also included for its reliability and simplicity, allowing you to detect presence or motion and interact with the device." data-ja="To build an effective digital device, you need to pick three core technologies: the sensor, the microcontroller, and the programming language. The microcontroller runs the code and drives the electronic components, so it’s the heart of the device. In this project, we use the Raspberry Pi Pico for its versatility and low cost (about $6–$7). A proximity sensor such as the KY-032 is also included for its reliability and simplicity, allowing you to detect presence or motion and interact with the device.">
      </p>
      <img src="CPU_programmation.webp" alt="Programming CPU" />
      <p data-fr="
      Pour le langage de programmation, de nombreuses options sont disponibles selon l'expérience du développeur. Des langages comme le C/C++ ou l'Assembly assurent des performances élevées, mais leur apprentissage peut être plus difficile. Dans le domaine des switchs numériques et du matériel adapté, trois langages se distinguent particulièrement:
        <ul class=&quot;list-disc&quot;>
        <li><strong>Micropython :</strong> Une implémentation complète de Python 3 optimisée pour les microcontrôleurs, idéale pour ceux ayant déjà une expérience de Python ou d’autres langages orientés objet.</li>
        <li><strong>Arduino :</strong> Basé sur le C/C++, cette plateforme est largement utilisée pour ses performances, même si elle demande plus de temps d'apprentissage et offre moins d'outils de débogage.</li>
        <li><strong>Circuitpython :</strong> Une version de Micropython développée par Adafruit pour rendre la programmation plus accessible, notamment aux amateurs, avec plusieurs outils facilitant le processus de programmation</li>
        </ul>
      " data-en="For the programming language, you have several options depending on your experience. C/C++ and Assembly offer high performance but are harder to learn. For digital switches and adaptive hardware, three languages stand out:
        <ul class=&quot;list-disc&quot;>
          <li><strong>MicroPython:</strong> A full Python 3 implementation optimized for microcontrollers—great if you already know Python or other object-oriented languages.</li>
          <li><strong>Arduino:</strong> Based on C/C++, widely used for performance and ecosystem support, though it has a steeper learning curve and fewer debugging tools.</li>
          <li><strong>CircuitPython:</strong> Adafruit’s beginner-friendly fork of MicroPython with lots of helpful tooling and documentation.</li>
        </ul>">
      </p>
    </section>
  
    <section>
      <h3 data-fr="Exemple : switch qui détecte le mouvement" data-en="Example: Motion-Detecting Switch" data-ja="Example: Motion-Detecting Switch">Exemple : switch qui détecte le mouvement</h3>
      <p data-fr="
Pour cet exemple, le code sera pour un détecteur de mouvement qui active un relai. Concrètement, cela permet de faire un appareil qui a le même prince qu'une switch détectrice de mouvement comme la HoneyBee. Avant de programmer, il faut choisir un éditeur de code. Bien qu'il soit possible d'écrire du code dans un éditeur de texte simple, des outils spécialisés facilitent grandement le processus. Pour Circuitpython, l'éditeur Mu est recommandé, car il permet de sauvegarder le code directement sur le microcontrôleur et de le tester facilement. Pour télécharger Mu, cliquez <strong><a href='https://codewith.mu/en/download' download>ici</a></strong>.
      " data-en="In this example, we’ll write code for a motion detector that activates a relay—essentially creating a motion-sensing switch similar in principle to the HoneyBee. Before coding, choose an editor. While a plain text editor can work, specialized tools make things easier. For CircuitPython, the Mu editor is recommended because it lets you save code directly to the microcontroller and test quickly. To download Mu, click <strong><a href='https://codewith.mu/en/download' download>here</a></strong>.">
      </p>
    </section>
  
    <!-- Section: Bibliothèques -->
    <section>
      <h4 data-fr="Bibliothèques" data-en="Libraries" data-ja="Libraries">Bibliothèques</h4>
      <p data-fr="
      Une bibliothèque (ou module) est un ensemble de fonctions et de classes pré-écrites qui facilite le développement en masquant les détails bas-niveau. Sans elles, chaque fonctionnalité (temporisation, gestion des broches, communication I²C, etc.) devrait être codée manuellement, ce qui alourdit et complique le projet.

      CircuitPython propose un <em>Library Bundle</em> officiel : un ZIP contenant toutes les bibliothèques de base à télécharger, ce qui permet de sélectionner celles qui sont utiles au projet et de les copier sur le microcontrôleur. Parmi les plus courantes : <em>time</em>, <em>board</em> et <em>digitalio</em>.
      
      time pour gérer les délais,
    
        <em>board</em> pour accéder aux broches GPxx,
        <em>digitalio</em> pour configurer les entrées/sorties numériques.
        D’autres modules, comme <em>analogio</em> (capteurs analogiques), <em>busio</em> (I²C/SPI) ou <em>neopixel</em> (rubans LED), peuvent également être utiles.

      " data-en="A library (or module) is a collection of pre-written functions and classes that hide low-level details. Without them, you’d have to hand-write every feature (timing, pin handling, I²C communication, etc.), making projects heavy and complex.

CircuitPython provides an official <em>Library Bundle</em>—a ZIP of core libraries you can download and copy to your device. Common ones include <em>time</em>, <em>board</em>, and <em>digitalio</em>:
<br/>
– <em>time</em> for delays,<br/>
– <em>board</em> for accessing GPxx pins,<br/>
– <em>digitalio</em> for digital inputs/outputs.<br/>
Other modules like <em>analogio</em> (analog sensors), <em>busio</em> (I²C/SPI), or <em>neopixel</em> (LED strips) can also be useful.">
      </p>
      <pre><code class="language-python">import board
import time
from digitalio import DigitalInOut, Direction, Pull
      </code></pre>
    </section>
  
    <!-- Section: Initialisation du matériel -->
    <section>
      <h4 data-fr="Initialisation du matériel" data-en="Hardware Initialization" data-ja="Hardware Initialization">Initialisation du matériel</h4>
      <img  src="../../images/hugo/circuit_digital.png" alt="Description" style="float: right; width:60vh; margin-right: 50px; padding-top: 20px; padding-left: 20px;"/>

      <p data-fr="
      Une broche (ou « pin ») est un point de connexion physique sur le microcontrôleur, identifié par GP suivi d’un numéro (GP0, GP1, GP2, etc.). C’est sur l’une de ces broches que l’on soude le fil reliant l’élément externe (capteur, relais, moteur, LED…) au microcontrôleur. Dans le code, chaque broche doit être définie comme :

      INPUT (entrée) : pour recevoir un signal (par exemple la détection d’un capteur, un état haut/bas).
      
      OUTPUT (sortie) : pour envoyer un signal (par exemple fermer un relais, piloter un moteur, allumer une LED).
      
      En configurant correctement chaque broche en mode INPUT ou OUTPUT, on prépare le système à dialoguer avec ses capteurs et actionneurs.      " data-en="A pin is a physical connection point on the microcontroller, identified by GP followed by a number (GP0, GP1, GP2, etc.). You solder the wire from the external part (sensor, relay, motor, LED…) to one of these pins. In code, each pin must be set as:

INPUT – to receive a signal (e.g., detection from a sensor, high/low state).
<br/>
OUTPUT – to send a signal (e.g., close a relay, drive a motor, turn on an LED).
<br/>
By configuring each pin as INPUT or OUTPUT, you prepare the system to communicate with its sensors and actuators.">
      </p>
      
      <pre><code class="language-python">sensor = DigitalInOut(board.GP22)
sensor.direction = Direction.INPUT

relay = DigitalInOut(board.GP0)
relay.direction = Direction.OUTPUT
      </code></pre>
    </section>
  
    <!-- Section: Définir les fonctions et les variables -->
    <section>
      <h4 data-fr="Définir les fonctions et les variables" data-en="Defining Functions and Variables" data-ja="Defining Functions and Variables">Définir les fonctions et les variables</h4>
      <p data-fr="
      En programmation, une <em>variable</em> est un espace nommé en mémoire qui stocke une valeur et permet de la réutiliser et de la modifier facilement tout au long du code. Organiser son programme autour de variables et de fonctions renforce la lisibilité, facilite la maintenance et limite les répétitions.  
      Dans cet exemple, la variable <em>activation_time</em> définit clairement la durée pendant laquelle le relais reste actif, ce qui permet d’ajuster ce délai en un seul endroit sans toucher au reste du code. La fonction <em>relay_activation</em>, quant à elle, encapsule la logique de détection et d’action : elle lit l’état du capteur, active le relais pendant l’intervalle spécifié, puis le désactive. Ce découpage en blocs logiques favorise la compréhension et la réutilisation de chaque composant de code.      " data-en="In programming, a <em>variable</em> is a named space in memory that stores a value you can reuse and modify throughout the code. Structuring your program around variables and functions improves readability, simplifies maintenance, and reduces repetition.
<br/>
In this example, the <em>activation_time</em> variable clearly defines how long the relay stays on, so you can tweak this delay in one place. The <em>relay_activation</em> function encapsulates the detection-and-action logic: it reads the sensor state, turns the relay on for the specified interval, then turns it off. This modular approach supports understanding and reuse.">
      </p>
      <pre><code class="language-python">activation_time = 5

def relay_activation():
    if sensor.value:
        relay.value = True
        time.sleep(activation_time)
        relay.value = False
      </code></pre>
    </section>
  
    <!-- Section: Boucle principale -->
    <section>
      <h4 data-fr="Boucle principale" data-en="Main Loop" data-ja="Main Loop">Boucle principale</h4>
      <p data-fr="
      En programmation embarquée, la <em>boucle principale</em> est un cycle infini qui s’exécute tant que le microcontrôleur reste sous tension. Elle organise en continu les mêmes étapes :  
      lecture de l’état du capteur pour récupérer une valeur,  
      appel de la fonction de contrôle pour activer ou désactiver le relais  
      et retour automatique au début du cycle.  
      Grâce à ce mécanisme, le dispositif reste constamment à l’écoute et peut réagir immédiatement dès qu’un mouvement ou une présence est détecté. On peut également insérer une courte pause entre chaque itération pour limiter la fréquence de vérification et économiser de l’énergie.
      </p>      " data-en="In embedded programming, the <em>main loop</em> is an infinite cycle that runs while the microcontroller is powered. It repeatedly:
<br/>– reads the sensor state,
<br/>– calls the control function to toggle the relay,
<br/>– then returns to the start.
<br/>This keeps the device responsive so it can react immediately when movement or presence is detected. You can also insert a short delay to reduce polling frequency and save energy.">
      </p>
      <pre><code class="language-python">while True:
    relay_activation()
    time.sleep(0.01)
      </code></pre>
    </section>
  
    <!-- Section: Code final -->
    <section>
      <h4 data-fr="Code final" data-en="Final Code" data-ja="Final Code">Code final</h4>
      <p data-fr="
Voici le code complet qui réunit toutes les étapes présentées ci-dessus :
      " data-en="Here is the complete code that brings together all the steps above:" data-ja="Here is the complete code that brings together all the steps above:">
      </p>
      <pre><code class="language-python">import board
from digitalio import DigitalInOut, Direction, Pull
import time

sensor = DigitalInOut(board.GP22)
sensor.direction = Direction.INPUT

relay = DigitalInOut(board.GP0)
relay.direction = Direction.OUTPUT

activation_time = 5

def relay_activation():
    if sensor.value:
        relay.value = True
        time.sleep(activation_time)
        relay.value = False

while True:
    relay_activation()
    time.sleep(0.01)
      </code></pre>
      <p data-fr="
      En à peine vingt lignes, ce programme met en place une switch numérique fonctionnelle et démontre à quel point la programmation physique peut être accessible. Il constitue une base modulable : on peut ajuster la durée d’activation, ajouter des retours visuels ou sonores, intégrer d’autres capteurs ou piloter de nouveaux actionneurs. À partir de cet exemple, il est possible d'explorer des projets plus élaborés, de l’automatisation d’objets du quotidien à la création d’installations interactives sur mesure. Il suffit de garder à l'esprit qu'on programme une entrée (normalement un senseur ou une switch adaptée) qui va activer une sortie (l'effet que l'on désire sur l'environnement).
      " data-en="In just about twenty lines, this program builds a functional digital switch and shows how accessible physical programming can be. It’s a flexible starting point: adjust the activation time, add visual or audio feedback, integrate other sensors, or drive new actuators. From here you can explore more elaborate projects—from automating everyday objects to creating custom interactive installations. Keep in mind you program an input (usually a sensor or adaptive switch) that triggers an output (the effect you want in the environment)." data-ja="In just about twenty lines, this program builds a functional digital switch and shows how accessible physical programming can be. It’s a flexible starting point: adjust the activation time, add visual or audio feedback, integrate other sensors, or drive new actuators. From here you can explore more elaborate projects—from automating everyday objects to creating custom interactive installations. Keep in mind you program an input (usually a sensor or adaptive switch) that triggers an output (the effect you want in the environment).">
      </p>
    </section>
  
    <!-- Section: Ressources -->
    <section>
      <h3 data-fr="Ressources" data-en="Resources" data-ja="Resources">Ressources</h3>
      <p data-fr="
John Gallagher, enseignant au Boston College, propose plusieurs tutoriels sur sa <strong><a href='https://www.youtube.com/watch?v=eU1e6xPvZEU&amp;list=PL9VJ9OpT-IPSsQUWqQcNrVJqy4LhBjPX2&amp;ab_channel=JohnGallaugher' download>chaîne YouTube</a></strong> destinée aux débutants.
      " data-en="John Gallagher, a teacher at Boston College, offers several tutorials on his <strong><a href='https://www.youtube.com/watch?v=eU1e6xPvZEU&amp;list=PL9VJ9OpT-IPSsQUWqQcNrVJqy4LhBjPX2&amp;ab_channel=JohnGallaugher' download>YouTube channel</a></strong> for beginners.">
      </p>
      <p data-fr="
Adafruit offre <strong><a href='https://learn.adafruit.com/welcome-to-circuitpython/what-is-circuitpython' download>des instructions détaillées</a></strong> pour utiliser CircuitPython, accompagnées d'une documentation complète pour les bibliothèques.
      " data-en="Adafruit provides <strong><a href='https://learn.adafruit.com/welcome-to-circuitpython/what-is-circuitpython' download>detailed instructions</a></strong> for using CircuitPython, along with complete documentation for the libraries.">
      </p>
      <p data-fr="
Pour aller plus loin, consultez <strong><a href='https://github.com/adafruit/circuitpython' download>la page GitHub</a></strong> de CircuitPython, qui recense une multitude de ressources d'apprentissage.
      " data-en="For further exploration, see the <strong><a href='https://github.com/adafruit/circuitpython' download>CircuitPython GitHub page</a></strong>, which lists a wealth of learning resources.">
      </p>
    </section>
  
  </main>
  
  <!-- Footer inclusion (if available) -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      fetch('../../footer.html')
        .then(response => response.text())
        .then(data => {
          document.body.insertAdjacentHTML('beforeend', data);
        });
    });
  </script>
  <script src="../../js/translationmain.js"></script>
</body>
</html>
