<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Flappy-ish — Fullscreen + Mario Pipes + Sprite Bird</title>
<style>
  :root { --fg:#e0fbfc; }
  *{ box-sizing:border-box; }
  html,body { margin:0; height:100%; background:#0b1522; color:var(--fg); font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #wrap { position:fixed; inset:0; display:grid; place-items:center; background:radial-gradient(1400px 900px at 50% 20%, #16324f 0%, #0e2034 45%, #0b1522 100%); }
  canvas { width:100vw; height:100vh; display:block; background:#87ceeb; }
  .hud {
    position:absolute; inset:0; pointer-events:none; display:flex; align-items:flex-start; justify-content:space-between; padding:12px 14px;
    font-weight:700; text-shadow:0 2px 0 rgba(0,0,0,.25);
  }
  .badge{ pointer-events:none; background:rgba(0,0,0,.35); padding:.35rem .6rem; border-radius:999px; font-size:14px; }
  #centerOverlay { position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
  .panel {
    pointer-events:auto;
    background:rgba(9,14,22,.78);
    backdrop-filter: blur(8px);
    border:1px solid rgba(255,255,255,.08);
    border-radius:18px;
    padding:18px 18px 14px;
    width:min(92vw, 520px);
    text-align:center;
    box-shadow: 0 20px 60px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.05);
  }
  .title{ font-size:26px; font-weight:800; margin:4px 0 8px; letter-spacing:.2px; }
  .subtitle{ font-size:14px; opacity:.85; margin:0 0 10px; }
  .row{ display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin:10px 0 6px; }
  .chip{
    padding:.45rem .8rem; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); cursor:pointer; user-select:none;
    transition:transform .08s ease, background .2s; font-weight:700; font-size:14px;
  }
  .chip[data-active="true"]{ background:linear-gradient(180deg, #1b2b45, #15243b); border-color:rgba(255,255,255,.2); box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); }
  .cta{
    display:inline-flex; align-items:center; justify-content:center; gap:.55rem;
    padding:.8rem 1.1rem; border:none; border-radius:12px; font-weight:800; letter-spacing:.25px; font-size:15px;
    background:linear-gradient(180deg, #ffd166, #ffb703); color:#1a1a1a; cursor:pointer; margin-top:8px;
    box-shadow:0 8px 24px rgba(255,179,3,.35);
    transition:transform .04s ease;
  }
  .cta:active{ transform:translateY(1px) }
  .hint{ font-size:12px; opacity:.75; margin-top:8px; }
  .footer { position:absolute; bottom:8px; left:0; right:0; display:flex; gap:8px; justify-content:center; pointer-events:none; }
  .kbd{ pointer-events:none; font-size:12px; padding:.2rem .45rem; border:1px solid rgba(255,255,255,.18); border-bottom-width:2px; background:rgba(255,255,255,.06); border-radius:6px; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" aria-label="Flappy style game"></canvas>

  <div class="hud">
    <div class="badge">Score: <span id="score">0</span></div>
    <div class="badge">Best: <span id="best">0</span></div>
  </div>

  <div id="centerOverlay" aria-live="polite">
    <div class="panel" id="menuPanel">
      <div class="title">Flappy-ish</div>
      <div class="subtitle">Pick a difficulty, then press <b>Start</b>. Steer with your <b>mouse/finger</b> (fullscreen on start).</div>
      <div class="row" role="group" aria-label="Difficulty">
        <div class="chip" data-diff="easy"   data-active="true">Easy</div>
        <div class="chip" data-diff="normal">Normal</div>
        <div class="chip" data-diff="hard">Hard</div>
      </div>
      <button class="cta" id="startBtn">Start</button>
      <div class="hint">Pause: <span class="kbd">P</span> &nbsp; Restart: <span class="kbd">R</span> &nbsp; Start: <span class="kbd">Space/Enter or click Start</span></div>
    </div>
  </div>

  <div class="footer">
    <div class="kbd">Sprite bird: up/mid/down frames</div>
  </div>
</div>

<script>
(() => {
  // ======= Canvas sizing (fullscreen) =======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let W = window.innerWidth;
  let H = window.innerHeight;
  let GH = Math.max(60, Math.round(H * 0.12)); // ground height
  let PIPE_W = Math.max(28, Math.round(W * 0.035)); // narrower pipes
  let dpr = 1;

  function fit() {
    W = window.innerWidth; H = window.innerHeight;
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    GH = Math.max(60, Math.round(H * 0.12));
    PIPE_W = Math.max(28, Math.round(W * 0.035)); // keep narrow on resize
    rescaleConfig();
    bird.r = Math.max(10, Math.round(14 * (H / 640)));
    bird.x = Math.round(W * 0.25);
    setTargetY(targetY);
  }
  window.addEventListener('resize', fit, { passive:true });

  // ======= UI elements =======
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const startBtn = document.getElementById('startBtn');
  const menuPanel = document.getElementById('menuPanel');
  const chips = Array.from(document.querySelectorAll('.chip'));

  let difficulty = 'easy';
  chips.forEach(ch => ch.addEventListener('click', (e) => {
    // Toggle only; do NOT start the game
    chips.forEach(c => c.dataset.active = 'false');
    ch.dataset.active = 'true';
    difficulty = ch.dataset.diff;
    rescaleConfig();
    e.stopPropagation();
  }));

  // ======= Audio (generated) =======
  let AC, masterGain;
  function ensureAudio() {
    if (!AC) {
      AC = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = AC.createGain();
      masterGain.gain.value = 0.2;
      masterGain.connect(AC.destination);
    }
    if (AC.state === 'suspended') AC.resume();
  }
  function beep(freq=600, dur=0.08, type='sine', vol=0.6) {
    if (!AC) return;
    const t0 = AC.currentTime + 0.001;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(masterGain);
    o.start(t0); o.stop(t0 + dur + 0.02);
  }
  function scoreChime(){ beep(850, .07, 'square', .5); setTimeout(()=>beep(1100,.06,'square',.45), 30); }
  function hitSfx(){ beep(200, .18, 'sawtooth', .35); setTimeout(()=>beep(120,.22,'sawtooth',.3), 40); }

  // ======= Helpers =======
  const rand = (a,b)=>a + Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // ======= Game state =======
  const State = { READY:0, PLAYING:1, PAUSED:2, DEAD:3 };
  let state = State.READY;
  let score = 0, best = parseInt(localStorage.getItem('flappy-best')||'0',10);
  bestEl.textContent = best;

  // ======= Difficulty presets (fixed speeds per mode) =======
  const presetsBase = {
    easy:   { gap: 240, speed: 1.0 },  // slow & forgiving
    normal: { gap: 170, speed: 2.4 },  // moderate
    hard:   { gap: 140, speed: 3.6 }   // fast & tight
  };

  // Desired on-screen spacing between pipes (as a fraction of width)
  const SPACING_FACTOR = { easy: 0.42, normal: 0.33, hard: 0.27 };

  let cfg = { gap: 220, speed: 2.4, spawn: 1.5 }; // spawn computed from spacing

  function rescaleConfig() {
    const base = presetsBase[difficulty];
    cfg.gap   = Math.round(base.gap * (H / 640)); // responsive gap
    cfg.speed = base.speed;                       // fixed per mode
    // compute spawn seconds so density stays consistent for each mode
    const spacingPx = Math.max(200, Math.round(W * SPACING_FACTOR[difficulty]));
    const vx = cfg.speed * 60; // px/s
    cfg.spawn = spacingPx / vx; // seconds between pipe pairs
  }

  // Bird (mouse-follow control)
  const bird = { x: Math.round(W*0.25), y: Math.round(H*0.45), r: 14, angle: 0, wingPhase: 0 };
  let targetY = bird.y;
  function setTargetY(y){ targetY = clamp(y, bird.r+5, H - GH - bird.r - 5); }

  // ======= Sprite loading (your custom frames) =======
  const SPRITE_BASES = [
    "../../images/flappybird/birdup",
    "../../images/flappybird/birdmid",
    "../../images/flappybird/birddown"
  ];
  const SPRITE_EXTS = [".png", ".webp", ".jpg", ".jpeg"];
  let spriteFrames = [];
  let spriteReady = false;

  function loadWithFallback(base){
    return new Promise(resolve=>{
      let i = 0;
      function tryNext(){
        if (i >= SPRITE_EXTS.length){ resolve(null); return; }
        const src = base + SPRITE_EXTS[i++];
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = tryNext;
        img.src = src;
      }
      tryNext();
    });
  }
  async function preloadSprites(){
    const imgs = await Promise.all(SPRITE_BASES.map(loadWithFallback));
    spriteFrames = imgs.filter(Boolean);
    spriteReady = spriteFrames.length === SPRITE_BASES.length;
  }
  preloadSprites(); // fallback draws vector until ready

  // Pipes
  const pipes = [];
  let pipeTimer = 0;

  // Clouds
  const clouds = [];
  function makeCloud() {
    const y = rand(20, H*0.55);
    const s = rand(0.6, 1.4);
    const w = rand(100, 200)*s;
    const h = rand(24, 42)*s;
    clouds.push({ x: W + w, y, w, h, speed: rand(12, 22)*s });
  }
  for(let i=0;i<8;i++) makeCloud();

  // Ground motion accumulator (subtle)
  let groundOffset = 0;

  // ======= Fullscreen =======
  async function goFullscreen(){
    try{
      if (document.fullscreenElement) return;
      const el = document.documentElement; // full page
      if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen(); // Safari
      setTimeout(()=>window.scrollTo(0,1), 50);
    }catch(e){ /* ignore if blocked */ }
  }

  // ======= Reset & Start logic (resets on death) =======
  function resetGameState(){
    rescaleConfig();
    score = 0; scoreEl.textContent = '0';
    pipes.length = 0; pipeTimer = 0; groundOffset = 0;
    bird.x = Math.round(W*0.25);
    bird.y = Math.round(H*0.45);
    targetY = bird.y;
    bird.angle = 0; bird.wingPhase = 0;
  }

  function restart(){
    resetGameState();
    state = State.READY;
    showMenu('Flappy-ish');
  }

  async function startGame(){
    ensureAudio();
    await goFullscreen();
    if (state === State.DEAD) {
      // Full reset when starting from Game Over
      resetGameState();
    }
    state = State.PLAYING;
    hideMenu();
  }

  // UI helpers
  function showMenu(titleText){
    const t = menuPanel.querySelector('.title');
    if (titleText) t.textContent = titleText;
    menuPanel.parentElement.style.display = 'grid';
  }
  function hideMenu(){
    menuPanel.parentElement.style.display = 'none';
  }

  // Events
  window.addEventListener('keydown', e=>{
    if (e.key === 'p' || e.key === 'P'){ 
      if (state === State.PLAYING){ state = State.PAUSED; showMenu('Paused'); }
      else if (state === State.PAUSED){ state = State.PLAYING; hideMenu(); }
    } else if (e.key === 'r' || e.key === 'R'){
      restart();
    } else if (e.code === 'Space' || e.code === 'Enter'){
      // allow starting from READY, PAUSED, or DEAD
      if (state === State.READY || state === State.PAUSED || state === State.DEAD){
        e.preventDefault();
        startGame();
      }
    }
  });

  // Mouse/touch: only steer when playing
  window.addEventListener('mousedown', (e)=>{ if (state === State.PLAYING) setTargetY(e.clientY); });
  window.addEventListener('mousemove', (e)=>{ setTargetY(e.clientY); }, { passive:true });
  window.addEventListener('touchstart', (e)=>{ if (state === State.PLAYING && e.touches[0]) setTargetY(e.touches[0].clientY); }, { passive:true });
  window.addEventListener('touchmove', (e)=>{ if (e.touches[0]) setTargetY(e.touches[0].clientY); }, { passive:true });

  // Start button
  startBtn.addEventListener('click', () => { startGame(); });

  // ======= Drawing helpers (procedural assets) =======
  function drawSky() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#78c6ff');
    g.addColorStop(0.6, '#8ed0ff');
    g.addColorStop(1, '#b1e1ff');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }
  function drawSun() {
    ctx.save();
    ctx.globalAlpha = 0.35;
    const cx = W*0.12, cy = H*0.18, r = Math.max(40, Math.min(W,H)*0.05);
    const g = ctx.createRadialGradient(cx,cy,8, cx,cy,r*2.2);
    g.addColorStop(0, 'rgba(255,255,200,.95)');
    g.addColorStop(1, 'rgba(255,255,200,0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(cx,cy,r*2.2,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffe66d';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawCloud(c){
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    const {x,y,w,h} = c;
    roundedCloud(x,y,w,h);
    ctx.restore();
  }
  function roundedCloud(x,y,w,h){
    ctx.beginPath();
    const r = h/2;
    ctx.moveTo(x, y+h);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.quadraticCurveTo(x+w*0.35, y-h*.8, x+w*0.55, y);
    ctx.quadraticCurveTo(x+w-r, y, x+w, y+h);
    ctx.quadraticCurveTo(x+w, y+h*1.2, x+w-r, y+h*1.25);
    ctx.quadraticCurveTo(x+w*.55, y+h*1.6, x+w*.4, y+h*1.25);
    ctx.quadraticCurveTo(x+r, y+h*1.4, x, y+h);
    ctx.closePath(); ctx.fill();
  }

  // ======= Calmer ground (subtle pebbles, slow parallax) =======
  function drawGround() {
    const y0 = H - GH;

    // base grass
    const g = ctx.createLinearGradient(0,y0,0,H);
    g.addColorStop(0,'#3b7f3b'); g.addColorStop(1,'#2c5f2c');
    ctx.fillStyle = g; ctx.fillRect(0,y0, W, GH);

    // top rim for separation
    ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(0, y0, W, 2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0, y0+2, W, 2);

    // subtle moving pebbles (wide spacing, low contrast)
    const step = Math.max(60, Math.round(W * 0.06));
    const offset = groundOffset % step;

    function pebble(cx, cy, w, h, color){
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(cx, cy, w, h, 0, 0, Math.PI*2);
      ctx.fill();
    }

    for (let x = -offset; x < W + step; x += step) {
      pebble(x + 10, y0 + Math.round(GH*0.62), 14, 5, 'rgba(255,255,255,0.08)');
      pebble(x + 36, y0 + Math.round(GH*0.72), 10, 4, 'rgba(0,0,0,0.08)');
      pebble(x + 70, y0 + Math.round(GH*0.58), 8, 3,  'rgba(255,255,255,0.06)');
    }
  }

  // ======= Pipe drawing helpers & improved style =======
  function roundRectPath(x, y, w, h, r){
    const rr = Math.min(r, h/2, w/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  // Improved Mario-style pipe with beveled rim & side shading
  function drawPipe(x, topH, w=PIPE_W, gap=cfg.gap) {
    const bottomY = topH + gap;
    const capH = Math.max(10, Math.round(w * 0.36)); // rim height
    const over = Math.max(6,  Math.round(w * 0.22)); // cap overhang
    const bevelW = Math.max(3, Math.round(w * 0.10)); // left/right bevel width

    // Cylindrical body gradient (richer)
    const bodyGrad = ctx.createLinearGradient(x,0,x+w,0);
    bodyGrad.addColorStop(0.00, '#064f18');
    bodyGrad.addColorStop(0.16, '#0f8a2d');
    bodyGrad.addColorStop(0.50, '#39e15e'); // bright core
    bodyGrad.addColorStop(0.84, '#0f8a2d');
    bodyGrad.addColorStop(1.00, '#064f18');

    // TOP body
    ctx.fillStyle = bodyGrad;
    ctx.fillRect(x, 0, w, topH);

    // BOTTOM body
    ctx.fillStyle = bodyGrad;
    ctx.fillRect(x, bottomY, w, H - bottomY);

    // Body specular stripes (subtle)
    const stripeX1 = x + Math.round(w * 0.24);
    const stripeX2 = x + Math.round(w * 0.70);
    const stripeG1 = ctx.createLinearGradient(stripeX1-2,0,stripeX1+2,0);
    stripeG1.addColorStop(0,'rgba(255,255,255,0)');
    stripeG1.addColorStop(0.5,'rgba(255,255,255,0.22)');
    stripeG1.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = stripeG1;
    ctx.fillRect(stripeX1-2, 0, 4, topH);
    ctx.fillRect(stripeX1-2, bottomY, 4, H - bottomY);

    const stripeG2 = ctx.createLinearGradient(stripeX2-1,0,stripeX2+1,0);
    stripeG2.addColorStop(0,'rgba(255,255,255,0)');
    stripeG2.addColorStop(0.5,'rgba(255,255,255,0.12)');
    stripeG2.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = stripeG2;
    ctx.fillRect(stripeX2-1, 0, 2, topH);
    ctx.fillRect(stripeX2-1, bottomY, 2, H - bottomY);

    // Joint ambient occlusion where body meets the rims
    function jointAO(y){
      const g = ctx.createLinearGradient(0, y-8, 0, y+8);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(0.45, 'rgba(0,0,0,0.22)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(x- over, y-8, w + over*2, 16);
    }
    jointAO(topH);
    jointAO(bottomY);

    // RIM drawing (rounded rectangle with bevelled sides, gloss & inner shadow)
    function drawRim(cx, cy, cw, ch, facingDown){
      // Base rounded rim
      let base = ctx.createLinearGradient(cx, cy, cx, cy+ch);
      if (facingDown){
        // top is brighter (the underside catching light)
        base.addColorStop(0.00, '#6df279');
        base.addColorStop(0.45, '#2bd24f');
        base.addColorStop(1.00, '#18a83a');
      } else {
        base.addColorStop(0.00, '#18a83a');
        base.addColorStop(0.55, '#2bd24f');
        base.addColorStop(1.00, '#6df279');
      }
      ctx.fillStyle = base;
      roundRectPath(cx, cy, cw, ch, Math.round(ch*0.35));
      ctx.fill();

      // Side bevels (left/right)
      function sideBevel(bx){
        const sg = ctx.createLinearGradient(bx, cy, bx+bevelW, cy);
        sg.addColorStop(0, 'rgba(0,0,0,0.45)');
        sg.addColorStop(0.6, 'rgba(0,0,0,0.0)');
        ctx.fillStyle = sg;
        roundRectPath(bx, cy+1, bevelW, ch-2, Math.round((ch-2)*0.33));
        ctx.fill();
      }
      sideBevel(cx);                   // left bevel (dark -> clear)
      ctx.save();                      // right bevel (mirror)
      ctx.translate(cx+cw,0); ctx.scale(-1,1);
      sideBevel(0);
      ctx.restore();

      // Gloss band across rim face
      const gloss = ctx.createLinearGradient(cx, cy, cx, cy+ch);
      gloss.addColorStop(0.15,'rgba(255,255,255,0.30)');
      gloss.addColorStop(0.35,'rgba(255,255,255,0.10)');
      gloss.addColorStop(0.65,'rgba(255,255,255,0.05)');
      gloss.addColorStop(1.00,'rgba(255,255,255,0.00)');
      ctx.fillStyle = gloss;
      roundRectPath(cx+2, cy+1, cw-4, Math.max(2, ch-2), Math.max(1, Math.round((ch-2)*0.28)));
      ctx.fill();

      // Thin edge lines for crispness
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(cx, cy, cw, 1);                  // top edge
      ctx.fillRect(cx, cy+ch-1, cw, 1);             // bottom edge
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(cx+3, cy+Math.round(ch*0.28), cw-6, 1); // highlight line

      // Inner shadow at the meeting with body (gives depth)
      const inner = facingDown
        ? ctx.createLinearGradient(cx, cy+ch-4, cx, cy+ch+6)
        : ctx.createLinearGradient(cx, cy-6, cx, cy+4);
      inner.addColorStop(0, 'rgba(0,0,0,0.35)');
      inner.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = inner;
      ctx.fillRect(cx, facingDown ? (cy+ch-4) : (cy-6), cw, 10);
    }

    // Draw the two rims
    drawRim(x - over, topH - capH, w + over*2, capH, /*facingDown=*/true);
    drawRim(x - over, bottomY,      w + over*2, capH, /*facingDown=*/false);
  }

  // ======= Bird drawing (sprite first, vector fallback) =======
  function drawBirdSprite(b) {
    // frames: [up, mid, down] — cycle: mid, up, mid, down
    const cycle = [1, 0, 1, 2];
    const idx = cycle[Math.floor((b.wingPhase * 1) % 4)];
    const img = spriteFrames[idx] || spriteFrames[1] || spriteFrames[0];

    // scale so sprite height ~= 2 * r (intentionally big)
    const desiredH = b.r * 6;
    const scale = desiredH / img.naturalHeight;
    const dw = img.naturalWidth * scale;
    const dh = img.naturalHeight * scale;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);
    // (shadow removed)
    ctx.drawImage(img, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  }

  function drawBirdVector(b) {
    // fallback vector bird
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);

    const bodyR = b.r;
    const bodyGrad = ctx.createRadialGradient(0,0, bodyR*0.2, 0,0, bodyR*1.1);
    bodyGrad.addColorStop(0, '#ffd166'); bodyGrad.addColorStop(1, '#f4a261');
    ctx.fillStyle = bodyGrad; ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.beginPath(); ctx.ellipse(0, bodyR*0.2, bodyR*0.9, bodyR*0.7, 0, 0, Math.PI*2); ctx.fill();

    ctx.save();
    const wingA = Math.sin(b.wingPhase)*0.6 - 0.2;
    ctx.rotate(wingA); ctx.translate(-bodyR*0.1, 0);
    ctx.fillStyle = '#f77f00';
    ctx.beginPath(); ctx.ellipse(-bodyR*0.1, 0, bodyR*0.7, bodyR*0.45, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(bodyR*0.35, -bodyR*0.25, bodyR*0.28, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(bodyR*0.45, -bodyR*0.25, bodyR*0.12, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#ff7f00';
    ctx.beginPath(); ctx.moveTo(bodyR*0.9, 0);
    ctx.lineTo(bodyR*1.4, -bodyR*0.1);
    ctx.lineTo(bodyR*0.9, -bodyR*0.25);
    ctx.closePath(); ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawBird(b) {
    if (spriteReady) drawBirdSprite(b);
    else drawBirdVector(b);
  }

  // ======= Collision =======
  function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  // ======= Loop =======
  let last = performance.now();
  fit(); // initial sizing

  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt, now);
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function update(dt, now){
    // wing animation
    bird.wingPhase += (state === State.PLAYING ? 14 : 10)*dt;

    // Background motion (ground parallax slow to reduce dizziness)
    groundOffset += (cfg.speed * 60) * dt * 0.18;

    // Clouds
    for (const c of clouds){ c.x -= c.speed*dt; }
    while (clouds.length && clouds[0].x + clouds[0].w < -10) clouds.shift();
    if (clouds.length < 8 && Math.random() < 0.02) makeCloud();

    if (state === State.PAUSED || state === State.READY || state === State.DEAD){
      if (state === State.READY){
        // idle bob
        bird.y += Math.sin(now*0.004)*0.3;
        bird.angle = Math.sin(now*0.004)*0.05;
      }
      return;
    }

    // PLAYING — mouse/finger follow (smooth)
    const followSpeed = 8; // larger = snappier
    const t = clamp(followSpeed * dt, 0, 1);
    const dy = targetY - bird.y;
    bird.y += dy * t;
    bird.angle = clamp(dy * 0.0025, -0.6, 0.6);

    // keep inside bounds
    bird.y = clamp(bird.y, bird.r+5, H - GH - bird.r - 5);

    // Spawn pipes with spacing-derived timer
    pipeTimer -= dt;
    if (pipeTimer <= 0){
      const gap = cfg.gap;
      const margin = 30;
      const minY = margin + 30, maxY = H - margin - 30 - GH;
      const center = rand(minY + gap/2, Math.max(minY + gap/2, maxY - gap/2));
      pipes.push({ x: W + 8, topH: center - gap/2, w: PIPE_W, gap, scored:false });
      if (pipes.length > 12) pipes.shift();
      pipeTimer = cfg.spawn; // seconds computed from spacing and speed
    }

    // Move pipes and check scoring
    for (const p of pipes){
      p.x -= (cfg.speed * 60) * dt;
      if (!p.scored && p.x + p.w < bird.x - bird.r){
        p.scored = true;
        score++;
        scoreEl.textContent = score;
        scoreChime();
      }
    }
    while (pipes.length && pipes[0].x + pipes[0].w < -10) pipes.shift();

    // Collisions
    const hitTop = bird.y - bird.r < 0;
    const hitGround = bird.y + bird.r > H - GH;
    let hitPipe = false;
    for (const p of pipes){
      if (circleRectCollide(bird.x, bird.y, bird.r, p.x, 0, p.w, p.topH) ||
          circleRectCollide(bird.x, bird.y, bird.r, p.x, p.topH + p.gap, p.w, H - GH - (p.topH + p.gap))){
        hitPipe = true; break;
      }
    }
    if (hitTop || hitGround || hitPipe){
      if (state !== State.DEAD){
        state = State.DEAD;
        hitSfx();
        if (score > best){ best = score; localStorage.setItem('flappy-best', String(best)); bestEl.textContent = best; }
        setTimeout(()=>{ showMenu('Game Over'); }, 450);
      }
    }
  }

  function draw(){
    drawSky();
    drawSun();

    // Clouds
    for (const c of clouds) drawCloud(c);

    // Pipes
    for (const p of pipes) drawPipe(p.x, p.topH, p.w, p.gap);

    // Bird (sprite or vector)
    drawBird(bird);

    // Ground (now calmer)
    drawGround();

    // READY hint
    if (state === State.READY){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.font = '700 18px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Select a difficulty, then press Start (or Space/Enter).', W/2, H*0.62);
      ctx.restore();
    }

    if (state === State.DEAD){
      ctx.save();
      const g = ctx.createRadialGradient(W/2,H/2, 50, W/2,H/2, Math.max(W,H)*0.6);
      g.addColorStop(0, 'rgba(239,71,111,0)');
      g.addColorStop(1, 'rgba(239,71,111,0.25)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }
  }

  // Init
  restart();
})();
</script>
</body>
</html>
