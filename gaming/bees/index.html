<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title
    class="translate"
    data-fr="Construction de ruche - Compétitif"
    data-en="Hive Builder - Competitive"
    data-ja="ハチの巣づくり：対戦モード">
    Abeilles
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Common styles (same file as other switch games) -->
  <link rel="stylesheet" href="../../css/otherswitch.css">

  <style>
    :root {
      --c1: #fbbf24; --c2: #d97706; --c3: #FFCA3A; --c4: #8AC926;
      --c5: #1982C4; --c6: #6A4C93; --c7: #B5179E; --c8: #2EC4B6;
      --gap: 3rem;
      --side-pad: 3rem;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      touch-action: manipulation;
    }

    /* -------- LANG BUTTON -------- */
    #langToggle {
      position: fixed;
      top: 14px;
      right: 44px;
      z-index: 11;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      border: 2px solid #04c8bb;
      background: #0b0f12;
      color: #04c8bb;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 0 0 0 rgba(4, 200, 187, 0);
      transition: box-shadow 0.2s ease, transform 0.05s ease, background 0.2s ease;
    }

    #langToggle:hover {
      box-shadow: 0 0 0 3px rgba(4, 200, 187, 0.2);
    }

    #langToggle:active {
      transform: translateY(1px);
    }

    /* -------- LANDING OVERLAY -------- */
    #promptOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1rem;
      z-index: 10;
      overflow: hidden;
    }

    /* Bees canvas behind the menu card */
    #menuBeesCanvas {
      position: absolute;
      inset: 0;
      z-index: 0;
      pointer-events: none;
    }

    .menu-card {
      position: relative;
      z-index: 1;
      width: min(780px, 100%);
      padding: 1.5rem 1.75rem;
      border-radius: 16px;
      background: radial-gradient(circle at top, rgba(255,255,255,0.08), rgba(0,0,0,0.85));
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 18px 40px rgba(0,0,0,0.6);
    }

    #promptOverlay p {
      font-size: 1.2rem;
      max-width: none;
      margin-bottom: 1rem;
    }

    /* Mode select segmented control */
    #modeSelect {
      display: inline-flex;
      gap: 0;
      margin-bottom: 1rem;
      border-radius: 999px;
      padding: 0.18rem;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.18);
    }

    #modeSelect button {
      flex: 1;
      min-width: 140px;
      padding: 0.55rem 0.9rem;
      background: transparent;
      border: none;
      border-radius: 999px;
      color: #e5e7eb;
      font-size: 0.98rem;
      cursor: pointer;
      transition: background 0.18s ease, color 0.18s ease, transform 0.08s ease;
    }

    #modeSelect button:hover {
      background: rgba(255,255,255,0.06);
    }

    #modeSelect button.active {
      background: #fbbf24;
      color: #111827;
      font-weight: 700;
      transform: translateY(-1px);
    }

    .goal-setting {
      margin: 0.15rem 0;
      display: flex;
      gap: 0.45rem;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .goal-setting label {
      font-weight: 700;
      font-size: 0.98rem;
    }

    .goal-setting input[type="number"] {
      width: 68px;
      padding: 0.35rem 0.45rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: 1rem;
      text-align: center;
    }

    .goal-setting input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      accent-color: #00bfff;
      cursor: pointer;
    }

    .options-group {
      margin-top: 0.4rem;
      padding: 0.5rem 0.75rem;
      border-radius: 10px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
    }

    .option-row {
      margin: 0.15rem 0;
    }

    .option-row label {
      max-width: 32rem;
      text-align: left;
    }

    #editPlayers {
      display: none;
      padding: 0.55rem 1rem;
      background: rgba(0,0,0,0.15);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 999px;
      color: #fff;
      cursor: pointer;
      margin: 0.75rem auto 0.4rem;
      font-size: 0.9rem;
    }

    #promptOverlay button#startButton {
      display: block;
      margin: 0.6rem auto 0  auto;
      padding: 0.8rem 2.4rem;
      font-size: 1.1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #fbbf24, #f97316);
      color: #111827;
      font-weight: 800;
      letter-spacing: 0.03em;
      box-shadow: 0 12px 30px rgba(0,0,0,0.6);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
    }

    #promptOverlay button#startButton:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 36px rgba(0,0,0,0.75);
      filter: brightness(1.03);
    }

    #promptOverlay button#startButton:active {
      transform: translateY(1px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.55);
    }

    /* -------- Player Modal -------- */
    #playerConfigModal {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 12;
    }
    #playerConfigModal .modal-content {
      background: #0f172a;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 14px;
      padding: 1.5rem;
      width: min(720px, 90vw);
      box-shadow: 0 15px 40px rgba(0,0,0,0.5);
    }
    #playerConfigModal h3 {
      margin-bottom: 1rem;
      font-size: 1.25rem;
      text-align: center;
    }
    .player-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }
    .player-card {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 1rem;
    }
    .player-card label {
      display: block;
      margin-bottom: 0.35rem;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .player-card input[type="text"] {
      width: 100%;
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: #0b1220;
      color: #fff;
      font-size: 1rem;
    }
    .player-card input[type="color"] {
      width: 100%;
      height: 42px;
      border: none;
      border-radius: 8px;
      padding: 0;
      background: #0b1220;
      cursor: pointer;
    }
    .modal-actions {
      margin-top: 1rem;
      text-align: center;
      display: flex;
      gap: 0.75rem;
      justify-content: center;
    }
    .modal-actions button {
      padding: 0.75rem 1.6rem;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      font-weight: 700;
    }

    #goalDisplay {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.45rem 0.9rem;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px;
      font-weight: 700;
      letter-spacing: 0.02em;
      z-index: 9;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    }

    #endBanner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.92);
      padding: 1rem 1.5rem;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: 800;
      letter-spacing: 0.03em;
      color: #fefefe;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    #endBanner.visible {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .victory-text {
      margin-bottom: 0.3rem;
    }

    .restart-visual {
      margin-top: 0.35rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }

    .restart-arrow {
      width: 0;
      height: 0;
      border-left: 14px solid transparent;
      border-right: 14px solid transparent;
      border-top: 24px solid #fbbf24;
      filter: drop-shadow(0 0 8px rgba(251,191,36,0.9));
      animation: arrowBounce 0.9s ease-in-out infinite;
    }

.restart-switch-icon {
  width: 320px;
  max-width: 50vw;
  image-rendering: auto;
}

    @keyframes arrowBounce {
      0%   { transform: translateY(0); }
      40%  { transform: translateY(6px); }
      100% { transform: translateY(0); }
    }

    .controls-hint {
      margin-top: 0.4rem;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
      color: #d1d5db;
      line-height: 1.5;
      opacity: 0.8;
    }

    .key {
      display: inline-block;
      padding: 2px 7px;
      border: 1px solid #4b5563;
      border-radius: 4px;
      background: #111827;
      font-family: monospace;
      font-size: 0.8rem;
      color: #fbbf24;
    }

    /* -------- GAME CANVAS -------- */
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
  </style>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>

<body>
  <!-- Language toggle button -->
  <button id="langToggle">FR / EN / JA</button>

  <!-- Landing overlay -->
  <div id="promptOverlay">
    <canvas id="menuBeesCanvas"></canvas>

    <div class="menu-card">
      <p class="translate"
         data-fr="Choisissez un mode puis appuyez sur Commencer."
         data-en="Select a mode then press Start."
         data-ja="モードを選んで「開始」を押してください。">
        Choisissez un mode puis appuyez sur Commencer.
      </p>

      <div id="modeSelect">
        <button data-mode="1p" class="active">
          <span class="translate"
                data-fr="1 joueur"
                data-en="1 player"
                data-ja="1人プレイ">1 joueur</span>
        </button>
        <button data-mode="2p">
          <span class="translate"
                data-fr="2 joueurs"
                data-en="2 players"
                data-ja="2人プレイ">2 joueurs</span>
        </button>
      </div>

      <div class="goal-setting">
        <label for="tripGoalInput" class="translate"
               data-fr="Allers-retours requis :"
               data-en="Flower trips needed:"
               data-ja="花への往復回数：">
          Allers-retours requis :
        </label>
        <input id="tripGoalInput" type="number" min="1" max="15" value="5">
      </div>

      <div class="options-group">
        <!-- Timing mode checkbox -->
        <div class="goal-setting option-row">
          <label for="timingModeInput" class="translate"
                 data-fr="Mode timing (fleurs qui apparaissent/disparaissent)"
                 data-en="Timing mode (flowers appear/disappear)"
                 data-ja="タイミングモード（花が出たり消えたり）">
            Mode timing (fleurs qui apparaissent/disparaissent)
          </label>
          <input id="timingModeInput" type="checkbox">
        </div>

        <!-- Penalty mode checkbox -->
        <div class="goal-setting option-row">
          <label for="penaltyModeInput" class="translate"
                 data-fr="Pénalité si on appuie quand les abeilles ne sont pas prêtes"
                 data-en="Penalty if pressed when bees are not ready"
                 data-ja="ハチが準備できていない時に押すとペナルティ">
            Pénalité si on appuie quand les abeilles ne sont pas prêtes
          </label>
          <input id="penaltyModeInput" type="checkbox">
        </div>

        <!-- Switch image checkbox -->
        <div class="goal-setting option-row">
          <label for="showSwitchImageInput" class="translate"
                 data-fr="Afficher l'image de la switch (prompt)"
                 data-en="Show switch icon at the bottom"
                 data-ja="画面下部にスイッチ画像を表示">
            Afficher le pictogramme du contacteur en bas
          </label>
          <input id="showSwitchImageInput" type="checkbox">
        </div>
      </div>

      <div id="controlsText" class="controls-hint">
        <span id="p2hint" style="display:none;"></span>
      </div>

      <button id="editPlayers">Configurer les joueurs</button>

      <button id="startButton" class="translate"
              data-fr="Commencer"
              data-en="Start"
              data-ja="開始">
        Commencer
      </button>
    </div>
  </div>

  <div id="playerConfigModal">
    <div class="modal-content">
      <h3>Configurer les joueurs</h3>
      <div class="player-grid">
        <div class="player-card">
          <label for="p1Name">Nom du joueur 1</label>
          <input id="p1Name" type="text" value="Joueur 1" maxlength="20">
          <label for="p1Color" style="margin-top:0.75rem;">Couleur du miel</label>
          <input id="p1Color" type="color" value="#fbbf24">
        </div>
        <div class="player-card">
          <label for="p2Name">Nom du joueur 2</label>
          <input id="p2Name" type="text" value="Joueur 2" maxlength="20">
          <label for="p2Color" style="margin-top:0.75rem;">Couleur du miel</label>
          <input id="p2Color" type="color" value="#6a4c93">
        </div>
      </div>
      <div class="modal-actions">
        <button id="closeModal">Fermer</button>
        <button id="savePlayers">Enregistrer</button>
      </div>
    </div>
  </div>

  <canvas id="simCanvas"></canvas>
  <div id="goalDisplay"></div>
  <div id="endBanner" aria-live="polite"></div>
  <span id="restartHintTemplate" class="translate" aria-hidden="true" style="display:none;"
        data-fr="Maintenez votre contacteur pour recommencer"
        data-en="Hold your switch to restart"
        data-ja="スイッチを長押しして再スタート">Hold your switch to restart</span>

  <script>
    /**
     * CONFIGURATION & ASSETS
     */
    const COLORS = {
      bgLeft: '#120a02',
      bgRight: '#4a7c25',
      bgDark: '#120a02',
      hexBorderLight: '#ffd700',
      hexBorderDark: '#b45309',
      waxBase: '#fbbf24',
      waxDeep: '#78350f',
      beeYellowBright: '#ffdf00',
      beeYellowDark: '#c7a008',
      beeBlack: '#0a0a0a'
    };

    const playerConfigs = [
      { name: 'Joueur 1', color: COLORS.waxBase },
      { name: 'Joueur 2', color: '#6a4c93' }
    ];

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // ----- Color helpers -----
    function hexToRgb(hex) {
      const cleaned = hex.replace('#','');
      const bigint = parseInt(cleaned, 16);
      return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }

    function rgbToHex(r, g, b) {
      const toHex = (c) => c.toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function mixHex(base, target, amount) {
      const a = hexToRgb(base);
      const b = hexToRgb(target);
      const clamp = (v) => Math.max(0, Math.min(255, v));
      return rgbToHex(
        clamp(Math.round(a.r + (b.r - a.r) * amount)),
        clamp(Math.round(a.g + (b.g - a.g) * amount)),
        clamp(Math.round(a.b + (b.b - a.b) * amount))
      );
    }

    function createWaxTexture(baseColor) {
      const canvasPattern = document.createElement('canvas');
      canvasPattern.width = 128;
      canvasPattern.height = 128;
      const pCtx = canvasPattern.getContext('2d');

      const deep = mixHex(baseColor, '#000000', 0.45);
      const waxGrad = pCtx.createRadialGradient(64,64,0, 64,64,90);
      waxGrad.addColorStop(0, baseColor);
      waxGrad.addColorStop(1, deep);
      pCtx.fillStyle = waxGrad;
      pCtx.fillRect(0,0,128,128);

      for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 128;
        const y = Math.random() * 128;
        const alpha = Math.random() * 0.25;
        const light = mixHex(baseColor, '#ffffff', 0.4);
        const dark = mixHex(baseColor, '#000000', 0.6);
        const lightRgb = hexToRgb(light);
        const darkRgb = hexToRgb(dark);
        pCtx.fillStyle = Math.random() > 0.5
          ? `rgba(${lightRgb.r}, ${lightRgb.g}, ${lightRgb.b}, ${alpha})`
          : `rgba(${darkRgb.r}, ${darkRgb.g}, ${darkRgb.b}, ${alpha})`;
        pCtx.beginPath();
        pCtx.arc(x, y, Math.random()*1.5, 0, Math.PI*2);
        pCtx.fill();
      }
      return pCtx.createPattern(canvasPattern, 'repeat');
    }

    // ----- Canvas Setup ----- 
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    let width, height;

    // Track layout for switch placement
    let currentLayoutInfo = null;

    // Menu bees canvas + context
    const menuBeesCanvas = document.getElementById('menuBeesCanvas');
    const menuBeesCtx = menuBeesCanvas.getContext('2d');
    let menuBees = [];
    let overlayRect = null;
    let menuRect = null;

    // Create one decorative bee for a side (left/right)
    function makeMenuBee(side, playerIndex = 0) {
      const overlayEl = document.getElementById('promptOverlay');
      if (!overlayEl) return null;
      const rect = overlayEl.getBoundingClientRect();
      const w = rect.width || window.innerWidth;
      const h = rect.height || window.innerHeight;

      const centerX = side === 'left' ? w * 0.18 : w * 0.82;
      const centerY = h * 0.35;
      const radius = Math.min(w, h) * 0.08;

      const baseColor = playerConfigs[playerIndex]?.color || COLORS.beeYellowBright;
      const accentLight = baseColor;
      const accentDeep = mixHex(baseColor, '#000000', 0.45);

      return {
        side,
        playerIndex,
        centerX,
        centerY,
        radius,
        angle: Math.random() * Math.PI * 2,
        angularSpeed: (side === 'left' ? -1 : 1) * (0.4 + Math.random() * 0.2), // slower
        wobblePhase: Math.random() * Math.PI * 2,
        wingSpeed: 2.0,
        sizeScale: 1.6,                      // a bit bigger
        accentLight,
        accentDeep,
        x: centerX + radius,
        y: centerY
      };
    }

    // Update colors of decorative bees when player colors change
    function updateMenuBeeColors() {
      if (!menuBees || !menuBees.length) return;
      menuBees.forEach(bee => {
        const baseColor = playerConfigs[bee.playerIndex]?.color || COLORS.beeYellowBright;
        bee.accentLight = baseColor;
        bee.accentDeep = mixHex(baseColor, '#000000', 0.45);
      });
    }

    // ----- Game State ----- 
    let gameRunning = false;
    let gameMode = '1p'; // '1p' or '2p'
    let gameEnded = false;
    let tripGoal = 5;

    // Victory animation state
    let victoryPhase = false;
    let victoryTimer = 0;

    // Timing mode state
    let timingMode = false;
    let flowersActive = true;
    let timingState = 'static'; // 'static', 'waiting', 'visible'
    let timeUntilNextState = 0;
    let timingSpentThisCycle = false;
    let timingCapturedByPlayerIndex = null; // 0 or 1

    const PENALTY_DURATION = 2.0;

    // Hives and other entities
    let hives = [];
    const flowers = [];
    const particles = [];

    // GLOBAL HEX RADIUS (now scaled based on layout/mode)
    let hexRadius = 45;

    function computeHexRadius() {
      // use current width / mode / goal to adjust honeycomb size
      const w = width || window.innerWidth || 1200;
      const g = tripGoal || 5;

      const approxRings = Math.max(1, Math.min(4, Math.ceil(Math.sqrt(g)))); // simple approx

      if (gameMode === '1p') {
        const sideWidth = w * 0.4;
        const maxHorizontalSpace = sideWidth * 0.9; // keep some margin
        const maxRadiusFromSpace = maxHorizontalSpace / (1.5 * approxRings * 2);
        const raw = Math.min(60, maxRadiusFromSpace);
        hexRadius = Math.max(22, raw);
      } else {
        const sideWidth = w * 0.3;
        const maxHorizontalSpace = sideWidth * 0.85;
        const maxRadiusFromSpace = maxHorizontalSpace / (1.5 * approxRings * 2);
        const raw = Math.min(40, maxRadiusFromSpace);
        hexRadius = Math.max(20, raw);
      }
    }

    // ----- DOM Elements ----- 
    const modeButtons = document.querySelectorAll('#modeSelect button');
    const p2Hint = document.getElementById('p2hint');
    const startButton = document.getElementById('startButton');
    const overlay = document.getElementById('promptOverlay');
    const editPlayersBtn = document.getElementById('editPlayers');
    const playerModal = document.getElementById('playerConfigModal');
    const p1NameInput = document.getElementById('p1Name');
    const p2NameInput = document.getElementById('p2Name');
    const p1ColorInput = document.getElementById('p1Color');
    const p2ColorInput = document.getElementById('p2Color');
    const closeModalBtn = document.getElementById('closeModal');
    const savePlayersBtn = document.getElementById('savePlayers');
    const langToggle = document.getElementById('langToggle');
    const tripGoalInput = document.getElementById('tripGoalInput');
    const timingModeInput = document.getElementById('timingModeInput');
    const penaltyModeInput = document.getElementById('penaltyModeInput');
    const showSwitchImageInput = document.getElementById('showSwitchImageInput');
    const goalDisplay = document.getElementById('goalDisplay');
    const endBanner = document.getElementById('endBanner');
    const restartHintTemplate = document.getElementById('restartHintTemplate');

    // Switch image flag
    let showSwitchImage = false;

    // Audio: button, victory, honeycomb
    const pressSoundSrc = '../../sounds/startactivity.mp3';
    let buttonMusic;
    const finishSound = new Audio('../../sounds/victory.mp3');
    finishSound.volume = 0.5;

    // Honeycomb spawn sound
    const honeySpawnSound = new Audio('../../sounds/honeyspawn.mp3');
    honeySpawnSound.volume = 0.6;

    // Placeholder sounds when bees touch a plant (per-player)
    const flowerTouchSoundP1 = new Audio('../../sounds/bees/beeplayer1.mp3');
    const flowerTouchSoundP2 = new Audio('../../sounds/bees/beeplayer2.mp3');

    const FLOWER_SFX_BASE_VOLUME_P1 = 0.3;
    const FLOWER_SFX_BASE_VOLUME_P2 = 0.3;

    // Multiplier specifically for these SFX (0.0–2.0, etc.)
    let flowerSfxVolumeMultiplier = 1.0;

    function playFlowerTouchSoundForPlayer(playerIndex) {
      let sound, baseVol;

      if (playerIndex === 0) {
        sound = flowerTouchSoundP1;
        baseVol = FLOWER_SFX_BASE_VOLUME_P1;
      } else {
        sound = flowerTouchSoundP2;
        baseVol = FLOWER_SFX_BASE_VOLUME_P2;
      }

      if (!sound) return;

      // Apply multiplier and clamp to [0, 1]
      const vol = Math.max(0, Math.min(1, baseVol * flowerSfxVolumeMultiplier));
      sound.volume = vol;

      try {
        sound.currentTime = 0;
        sound.play().catch(() => {});
      } catch (e) {}
    }

    // Continuous ambient background sound (loop)
    const bgLoopSoundSrc = '../../sounds/bees_ambient_loop.mp3';
    let bgLoopSound = null;
    const BG_LOOP_IDLE_VOLUME = 0.15;  // volume when bees are NOT ready
    const BG_LOOP_READY_VOLUME = 0.35; // volume when at least one hive is ready

    function startBackgroundLoopSound() {
      if (!bgLoopSound) {
        bgLoopSound = new Audio(bgLoopSoundSrc);
        bgLoopSound.loop = true;
        bgLoopSound.volume = BG_LOOP_IDLE_VOLUME;
        bgLoopSound.play().catch(() => {});
      } else if (bgLoopSound.paused) {
        bgLoopSound.play().catch(() => {});
      }
    }

    function stopBackgroundLoopSound() {
      if (bgLoopSound) {
        bgLoopSound.pause();
      }
    }

    // Background music playlists (random)
    const playlist1P = [
      '../../songs/bees/beesmusic1.mp3',
      '../../songs/bees/beesmusic2.mp3',
      '../../songs/bees/beesmusic4.mp3',
      '../../songs/bees/beesmusic5.mp3',
      '../../songs/bees/beesmusic3.mp3'
    ];

    const playlist2P = [
      '../../songs/bees/beescompetition1.mp3',
      '../../songs/bees/beescompetition2.mp3',
      '../../songs/bees/beescompetition3.mp3',
      '../../songs/bees/beescompetition4.mp3',
      '../../songs/bees/beescompetition5.mp3'
    ];

    let bgMusic = null;
    let currentPlaylist = null;

    function getRandomTrack(list) {
      if (!list || !list.length) return null;
      const idx = Math.floor(Math.random() * list.length);
      return list[idx];
    }

    function stopBackgroundMusic() {
      if (bgMusic) {
        bgMusic.pause();
        bgMusic = null;
      }
      currentPlaylist = null;
    }

    function handleBgEnded() {
      if (!currentPlaylist || !currentPlaylist.length || !bgMusic) return;
      const nextSrc = getRandomTrack(currentPlaylist);
      if (!nextSrc) return;
      bgMusic.src = nextSrc;
      bgMusic.currentTime = 0;
      bgMusic.play().catch(()=>{});
    }

    function startBackgroundMusicForMode() {
      stopBackgroundMusic();
      currentPlaylist = (gameMode === '1p') ? playlist1P : playlist2P;
      if (!currentPlaylist || !currentPlaylist.length) return;

      const src = getRandomTrack(currentPlaylist);
      if (!src) return;

      bgMusic = new Audio(src);
      bgMusic.volume = 0.35;
      bgMusic.loop = false;
      bgMusic.addEventListener('ended', handleBgEnded);
      bgMusic.play().catch(()=>{});
    }

    // Switch image asset (used both in game and victory overlay)
    const switchImg = new Image();
    switchImg.src = '../../images/redswitch.png';

    // ----- UI Logic ----- 
    function applyPlayerConfig() {
      playerConfigs[0].name = (p1NameInput.value || 'Joueur 1').trim() || 'Joueur 1';
      playerConfigs[1].name = (p2NameInput.value || 'Joueur 2').trim() || 'Joueur 2';
      playerConfigs[0].color = p1ColorInput.value || playerConfigs[0].color;
      playerConfigs[1].color = p2ColorInput.value || playerConfigs[1].color;
      updateMenuBeeColors();
    }

    function openPlayerModal() {
      p1NameInput.value = playerConfigs[0].name;
      p2NameInput.value = playerConfigs[1].name;
      p1ColorInput.value = playerConfigs[0].color;
      p2ColorInput.value = playerConfigs[1].color;
      playerModal.style.display = 'flex';
    }

    function closePlayerModal() {
      playerModal.style.display = 'none';
    }

    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        if (p2Hint) {
          p2Hint.style.display = (gameMode === '2p') ? 'inline' : 'none';
        }
        editPlayersBtn.style.display = (gameMode === '2p') ? 'inline-block' : 'none';
        if (gameMode === '2p') openPlayerModal();
        else closePlayerModal();
      });
    });

    editPlayersBtn.addEventListener('click', openPlayerModal);
    closeModalBtn.addEventListener('click', closePlayerModal);
    savePlayersBtn.addEventListener('click', () => {
      applyPlayerConfig();
      closePlayerModal();
    });

    function readTripGoal() {
      const value = parseInt(tripGoalInput.value, 10);
      if (isNaN(value)) return 5;
      return Math.min(15, Math.max(1, value));
    }

    function updateGoalDisplay() {
      if (!gameRunning) return;
      const goalText = [];
      if (gameMode === '1p' && hives[0]) {
        goalText.push(`${playerConfigs[0].name}: ${Math.min(hives[0].voyagesCompleted, tripGoal)}/${tripGoal}`);
      }
      if (gameMode === '2p' && hives.length === 2) {
        goalText.push(`${playerConfigs[0].name}: ${Math.min(hives[0].voyagesCompleted, tripGoal)}/${tripGoal}`);
        goalText.push(`${playerConfigs[1].name}: ${Math.min(hives[1].voyagesCompleted, tripGoal)}/${tripGoal}`);
      }
      goalDisplay.textContent = goalText.join('  •  ');
    }

    function endGame(message) {
      gameEnded = true;
      victoryPhase = true;
      victoryTimer = 0;

      // Visual restart prompt: arrow + big switch image, no text
      endBanner.innerHTML = `
        <div class="restart-visual">
          <div class="restart-arrow"></div>
          <img class="restart-switch-icon" src="../../images/redswitch.png" alt="">
        </div>
      `;
      endBanner.className = 'visible';

      // Honey burst particles around each finished hive
      hives.forEach(h => {
        if (!h.finished) return;
        const baseX = h.centerX;
        const baseY = h.centerY;
        const bright = mixHex(h.waxColor, '#ffffff', 0.4);
        const mid = h.waxColor;
        spawnParticles(baseX, baseY, [bright, mid, '#ffffff']);
      });

      // Background music keeps playing by design
    }

    function checkGameEnd() {
      if (gameMode === '1p') {
        if (hives[0] && hives[0].finished) {
          endGame(`${playerConfigs[0].name} a terminé sa ruche !`);
        }
        return;
      }
      if (hives.length === 2 && hives[0].finished && hives[1].finished) {
        endGame('Les deux ruches sont complètes !');
      }
    }

    function playPressSound() {
      if (!buttonMusic) {
        buttonMusic = new Audio(pressSoundSrc);
        buttonMusic.volume = 0.35;
      } else {
        buttonMusic.currentTime = 0;
      }
      buttonMusic.play().catch(()=>{});
    }

    let restartHoldTimer = null;
    const RESTART_HOLD_MS = 3000;

    function cancelRestartHold() {
      if (restartHoldTimer) {
        clearTimeout(restartHoldTimer);
        restartHoldTimer = null;
      }
    }

    function beginGame() {
      overlay.style.display = 'none';
      gameRunning = true;
      gameEnded = false;
      victoryPhase = false;
      victoryTimer = 0;
      endBanner.className = '';
      endBanner.textContent = '';
      cancelRestartHold();
      langToggle?.remove();

      // recompute hex size just before building the hives,
      // so they are scaled to the current mode and viewport
      computeHexRadius();

      initGame();
      updateGoalDisplay();
      startBackgroundMusicForMode();
      startBackgroundLoopSound();
    }

    startButton.addEventListener('click', (e) => {
      e.preventDefault();
      applyPlayerConfig();
      tripGoal = readTripGoal();
      tripGoalInput.value = tripGoal;
      timingMode = !!timingModeInput.checked;
      showSwitchImage = !!showSwitchImageInput.checked;

      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(()=>{});
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
      }

      closePlayerModal();
      beginGame();
    });

    function resizeGameCanvas() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * window.devicePixelRatio;
      canvas.height = height * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
      // Important: do NOT re-init the game on resize,
      // otherwise leaving fullscreen (Escape) would reset the honeycomb.
    }

    function resizeMenuCanvas() {
      const overlayEl = document.getElementById('promptOverlay');
      if (!overlayEl) return;
      const w = overlayEl.clientWidth || window.innerWidth;
      const h = overlayEl.clientHeight || window.innerHeight;
      menuBeesCanvas.width = w * window.devicePixelRatio;
      menuBeesCanvas.height = h * window.devicePixelRatio;
      menuBeesCtx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
    }

    function resize() {
      resizeGameCanvas();
      resizeMenuCanvas();
      initMenuBees();
    }
    window.addEventListener('resize', resize);

    // ----- HIVE CLASS ----- 
    class Hive {
      constructor(centerX, isRightSide, options = {}) {
        this.centerX = centerX;
        this.centerY = height * 0.5;
        this.isRightSide = isRightSide;
        this.label = options.name || 'Joueur';
        this.waxColor = options.color || COLORS.waxBase;
        this.index = options.index ?? 0;
        this.waxPattern = createWaxTexture(this.waxColor);
        this.borderLight = mixHex(this.waxColor, '#ffffff', 0.35);
        this.borderDark = mixHex(this.waxColor, '#000000', 0.4);
        this.beeAccentLight = mixHex(this.waxColor, '#ffffff', 0.25);
        this.beeAccentDeep = mixHex(this.waxColor, '#000000', 0.35);
        this.cells = [];
        this.bees = [];
        this.occupiedMap = new Set();
        this.reservedMap = new Set();
        this.voyagesCompleted = 0;
        this.voyageLogged = false;
        this.finishing = false;
        this.finished = false;
        this.ready = false;

        // switch appear animation (0 → 1 when ready becomes true)
        this.switchAppear = 0;

        // penalty state
        this.penaltyTime = 0;
        this.penaltyBeesState = null;

        // initial cell (no sound)
        this.addCell(0, 0, false);

        for(let i=0; i<6; i++) this.bees.push(this.createBee());
      }

      hexToPixel(q, r) {
        const x = this.centerX + hexRadius * (3/2 * q);
        const y = this.centerY + hexRadius * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
        return { x, y };
      }

      // playSound = true for in-game builds, false for initial cell at setup
      addCell(q, r, playSound = true) {
        const pos = this.hexToPixel(q, r);
        this.cells.push({
          q, r, x: pos.x, y: pos.y,
          scale: 0,
          variation: Math.random(),
          wobble: Math.random() * Math.PI*2
        });
        const key = `${q},${r}`;
        this.occupiedMap.add(key);
        if(this.reservedMap.has(key)) this.reservedMap.delete(key);

        if (playSound && honeySpawnSound) {
          honeySpawnSound.currentTime = 0;
          honeySpawnSound.play().catch(()=>{});
        }
      }

      findNextBuildSpot() {
        const HEX_DIRECTIONS = [
          {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
          {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
        ];

        let queue = [{q:0, r:0}];
        let visited = new Set(['0,0']);
        let iterations = 0;

        while (queue.length > 0 && iterations < 3000) {
          iterations++;
          let current = queue.shift();
          for (let dir of HEX_DIRECTIONS) {
            let nq = current.q + dir.q;
            let nr = current.r + dir.r;
            let key = `${nq},${nr}`;

            if (!visited.has(key)) {
              visited.add(key);
              if (!this.occupiedMap.has(key) && !this.reservedMap.has(key)) {
                return { q: nq, r: nr };
              }
              if (this.occupiedMap.has(key)) {
                queue.push({q: nq, r: nr});
              }
            }
          }
        }
        return null;
      }

      createBee() {
        const home = this.hexToPixel(0, 0);
        return {
          x: home.x + (Math.random()-0.5)*50,
          y: home.y + (Math.random()-0.5)*50,
          vx: 0, vy: 0,
          state: 'idle',
          target: null,
          targetGrid: null,
          angle: this.isRightSide ? Math.PI : 0,
          wobblePhase: Math.random() * Math.PI * 2,
          wingSpeed: 1,
          sizeScale: 1.3 + Math.random() * 0.4,
          accentLight: this.beeAccentLight,
          accentDeep: this.beeAccentDeep,
          canScoreThisTrip: false,
          canBuildThisTrip: false,
          penaltyBase: null
        };
      }

      /**
       * Trigger a 2s penalty animation: bees freeze & shake, then resume.
       */
      triggerPenalty() {
        if (this.penaltyTime > 0) return;
        if (!this.bees.length) return;

        this.penaltyBeesState = this.bees.map(b => ({
          x: b.x,
          y: b.y,
          vx: b.vx,
          vy: b.vy,
          state: b.state,
          target: b.target ? { x: b.target.x, y: b.target.y } : null,
          targetGrid: b.targetGrid ? { q: b.targetGrid.q, r: b.targetGrid.r } : null,
          angle: b.angle,
          wobblePhase: b.wobblePhase,
          wingSpeed: b.wingSpeed,
          sizeScale: b.sizeScale,
          accentLight: b.accentLight,
          accentDeep: b.accentDeep,
          canScoreThisTrip: b.canScoreThisTrip,
          canBuildThisTrip: b.canBuildThisTrip
        }));

        this.bees.forEach(b => {
          b.penaltyBase = { x: b.x, y: b.y, angle: b.angle };
        });

        this.penaltyTime = PENALTY_DURATION;
      }

      /**
       * Returns true only if at least one bee is launched AND canScoreThisTrip is true.
       * Also enforces: can only launch when ALL bees are idle (all back home).
       */
      sendBees() {
        if (this.finished || this.finishing) return false;
        if (this.penaltyTime > 0) return false;

        // must wait until all bees are idle
        const allIdle = this.bees.every(b => b.state === 'idle');
        if (!allIdle) return false;

        if (timingMode && !flowersActive) return false;

        // Determine scoring/build permissions for this launch
        let canScoreTrip = true;
        let canBuildTrip = true;

        if (timingMode && gameMode === '2p') {
          if (!flowersActive || timingState !== 'visible') {
            canScoreTrip = false;
            canBuildTrip = false;
          } else if (
            timingCapturedByPlayerIndex !== null &&
            timingCapturedByPlayerIndex !== this.index
          ) {
            canScoreTrip = false;
            canBuildTrip = false;
          } else {
            canScoreTrip = true;
            canBuildTrip = true;
          }
        }

        let launched = false;
        let hasScoringBee = false;

        this.bees.forEach(b => {
          if (b.state === 'idle' && flowers.length > 0) {
            b.state = 'outbound';
            b.wingSpeed = 3.5;
            const flower = flowers[Math.floor(Math.random() * flowers.length)];
            const bloom = getFlowerBloom(flower);
            b.target = {
              x: bloom.x + (Math.random()-0.5)*10,
              y: bloom.y + (Math.random()-0.5)*10 - 15
            };
            b.canScoreThisTrip = canScoreTrip;
            b.canBuildThisTrip = canBuildTrip;
            launched = true;
            if (canScoreTrip) hasScoringBee = true;
          }
        });

        if (launched) {
          this.voyageLogged = false;

          // First player to send while visible captures this flower cycle
          if (timingMode && gameMode === '2p' &&
              flowersActive && timingState === 'visible' &&
              timingCapturedByPlayerIndex === this.index &&
              canScoreTrip) {
            timingCapturedByPlayerIndex = this.index;
          }
        }

        return hasScoringBee;
      }

      update(dt) {
        const prevReady = this.ready;

        // Victory orbit animation for finished hives
        if (this.finished && victoryPhase) {
          const orbitRadius = hexRadius * 2.2;
          const verticalFactor = 0.65;
          const orbitSpeed = 1.6;

          this.bees.forEach((b, index) => {
            const angle = orbitSpeed * victoryTimer + (index / this.bees.length) * Math.PI * 2;
            b.wobblePhase += dt * 6;
            b.x = this.centerX + Math.cos(angle) * orbitRadius;
            b.y = this.centerY + Math.sin(angle) * orbitRadius * verticalFactor;
            b.angle = angle + Math.PI / 2;
          });

          // During victory phase, no regular movement logic for this hive
          return;
        }

        const allIdle = this.bees.every(b => b.state === 'idle');
        this.ready =
          allIdle &&
          !this.finished &&
          !this.finishing &&
          this.penaltyTime <= 0 &&
          (!timingMode || flowersActive);

        // Switch appear animation logic
        if (!prevReady && this.ready) {
          this.switchAppear = 0; // restart animation when hive becomes ready
        }
        if (this.ready) {
          // Fast grow to 1 (about 0.25s)
          this.switchAppear = Math.min(1, this.switchAppear + dt * 4);
        } else {
          this.switchAppear = 0;
        }

        // Animate cell growth
        this.cells.forEach(c => {
          if (c.scale < 1) c.scale += (1 - c.scale) * 0.1;
        });

        // Penalty animation
        if (this.penaltyTime > 0) {
          this.penaltyTime -= dt;
          this.bees.forEach(b => {
            if (!b.penaltyBase) {
              b.penaltyBase = { x: b.x, y: b.y, angle: b.angle };
            }

            b.wobblePhase += dt * 6;

            const shakeAmp = 10;
            b.x = b.penaltyBase.x + Math.sin(b.wobblePhase * 6) * shakeAmp;
            b.y = b.penaltyBase.y + Math.cos(b.wobblePhase * 5) * (shakeAmp * 0.9);
            b.angle = b.penaltyBase.angle + Math.sin(b.wobblePhase * 4) * 0.45;
          });

          if (this.penaltyTime <= 0) {
            if (this.penaltyBeesState) {
              this.bees.forEach((b, i) => {
                const s = this.penaltyBeesState[i];
                Object.assign(b, s);
                b.penaltyBase = null;
              });
              this.penaltyBeesState = null;
            }
            this.penaltyTime = 0;
          }

          return;
        }

        const homeCenter = this.hexToPixel(0,0);

        this.bees.forEach(b => {
          b.wobblePhase += dt * 5 * b.wingSpeed;

          if (b.state === 'idle') {
            b.wingSpeed = 1;
            const hoverX = homeCenter.x + Math.cos(b.wobblePhase*0.2)*70;
            const hoverY = homeCenter.y + Math.sin(b.wobblePhase*0.3)*50;
            const dx = hoverX - b.x;
            const dy = hoverY - b.y;
            b.x += dx * 0.03;
            b.y += dy * 0.03;

            const desiredAngle = this.isRightSide ? Math.PI : 0;
            let angleDiff = desiredAngle - b.angle;
            if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
            if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
            b.angle += angleDiff * 0.05;
          }
          else {
            const dx = b.target.x - b.x;
            const dy = b.target.y - b.y;
            const dist = Math.hypot(dx, dy);
            const speed = 180 * dt;

            if (dist < 20) {
              if (b.state === 'outbound') {
                // Bee reaches flower: player-specific placeholder sound
                playFlowerTouchSoundForPlayer(this.index);

                if (!this.finished && !this.voyageLogged && b.canScoreThisTrip) {
                  this.voyagesCompleted = Math.min(tripGoal, this.voyagesCompleted + 1);
                  this.voyageLogged = true;
                  if (this.voyagesCompleted >= tripGoal) {
                    this.finishing = true;
                  }
                  updateGoalDisplay();
                }
                b.state = 'returning';
                const nextSpot = this.findNextBuildSpot();
                if (nextSpot) {
                  this.reservedMap.add(`${nextSpot.q},${nextSpot.r}`);
                  b.targetGrid = nextSpot;
                  b.target = this.hexToPixel(nextSpot.q, nextSpot.r);
                } else {
                  b.target = homeCenter;
                  b.targetGrid = null;
                }
                spawnParticles(b.x, b.y, ['#fff', this.borderLight]);

              } else if (b.state === 'returning') {
                b.state = 'idle';
                if (b.targetGrid && b.canBuildThisTrip) {
                  this.addCell(b.targetGrid.q, b.targetGrid.r, true);
                }
                b.targetGrid = null;
                spawnParticles(b.x, b.y, [this.borderLight, this.waxColor]);
              }
            } else {
              b.vx = (dx/dist) * speed;
              b.vy = (dy/dist) * speed;
              b.x += b.vx;
              b.y += b.vy;
              const targetAngle = Math.atan2(dy, dx);
              let angleDiff = targetAngle - b.angle;
              if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
              if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
              b.angle += angleDiff * 0.15;
            }
          }
        });

        // Timing competitive mode: hide flowers when the LAST outbound bee
        // of the capturing player has finished
        if (timingMode && gameMode === '2p' &&
            timingState === 'visible' &&
            !timingSpentThisCycle &&
            timingCapturedByPlayerIndex === this.index) {

          const anyOutbound = this.bees.some(b => b.state === 'outbound');
          if (!anyOutbound) {
            timingSpentThisCycle = true;
            flowersActive = false;
            timingState = 'waiting';
            timeUntilNextState = randRange(10, 20);
            timingCapturedByPlayerIndex = null;
          }
        }

        if (this.finishing && !this.finished) {
          const allHomeNow = this.bees.every(b => b.state === 'idle');
          if (allHomeNow) {
            this.finished = true;
            this.finishing = false;
            finishSound.currentTime = 0;
            finishSound.play().catch(()=>{});
            checkGameEnd();
          }
        }
      }

      draw(ctxDraw) {
        ctxDraw.save();
        ctxDraw.shadowColor = 'rgba(0,0,0,0.8)';
        ctxDraw.shadowBlur = 25;
        ctxDraw.shadowOffsetX = 5;
        ctxDraw.shadowOffsetY = 10;
        this.cells.forEach(c => drawOrganicHexBase(ctxDraw, c.x, c.y, hexRadius * c.scale, c.wobble));
        ctxDraw.restore();

        this.cells.forEach(c => drawOrganicHexDetail(
          ctxDraw,
          c.x,
          c.y,
          hexRadius * c.scale,
          c.variation,
          c.wobble,
          this.waxPattern,
          this.borderLight,
          this.borderDark
        ));

        this.bees.forEach(b => drawBee(ctxDraw, b, this.ready));
      }
    }

    // ----- Logic Initialization ----- 
    function initGame() {
      hives = [];
      flowers.length = 0;
      particles.length = 0;

      if (gameMode === '1p') {
        hives.push(new Hive(width * 0.2, false, { ...playerConfigs[0], index: 0 }));
        generateFlowers(width * 0.4, width * 0.95);
      } else {
        hives.push(new Hive(width * 0.15, false, { ...playerConfigs[0], index: 0 }));
        hives.push(new Hive(width * 0.85, true,  { ...playerConfigs[1], index: 1 }));
        generateFlowers(width * 0.35, width * 0.65);
      }

      if (timingMode) {
        flowersActive = false;
        timingState = 'waiting';
        timeUntilNextState = randRange(10, 20);
        timingSpentThisCycle = false;
        timingCapturedByPlayerIndex = null;
      } else {
        flowersActive = true;
        timingState = 'static';
        timeUntilNextState = 0;
        timingSpentThisCycle = false;
        timingCapturedByPlayerIndex = null;
      }
    }

    function getFieldZone() {
      if (gameMode === '1p') {
        const startX = width * 0.4;
        return { startX, zoneWidth: width - startX };
      }
      const startX = width * 0.3;
      return { startX, zoneWidth: width * 0.4 };
    }

    // ----- Flower Generation ----- 
    function generateFlowers(minX, maxX) {
      const count = 25;
      const daisyPalette = ['#ffb4e6', '#ffd6a5', '#c1fba4', '#b5dfff'];
      const tulipPalette = ['#ff7aa2', '#ff9f1c', '#ffcad4', '#c99bff'];

      for(let i=0; i<count; i++) {
        const type = Math.random() > 0.5 ? 'daisy' : 'tulip';
        const size = (12 + Math.random() * 10) * 1.5;     // 50% bigger
        const stemHeight = (90 + Math.random() * 70) * 1.5;
        flowers.push({
          x: minX + Math.random() * (maxX - minX),
          stemHeight,
          type: type,
          colorMain: type === 'daisy'
            ? daisyPalette[Math.floor(Math.random()*daisyPalette.length)]
            : tulipPalette[Math.floor(Math.random()*tulipPalette.length)],
          colorCenter: type === 'daisy' ? '#f6c453' : '#ffd166',
          size,
          stemCurve: (Math.random() - 0.5) * 80
        });
      }
    }

    // ----- Controls ----- 
    function restartGame() {
      if (!gameEnded) return;
      beginGame();
    }

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;

      // Restart logic when game has ended (Space OR Enter)
      if (gameEnded) {
        if (e.code === 'Space' || e.code === 'Enter') {
          e.preventDefault();
          if (!restartHoldTimer) {
            restartHoldTimer = setTimeout(() => restartGame(), RESTART_HOLD_MS);
          }
        }
        return;
      }

      if (!gameRunning) return;

      const penaltyOn = penaltyModeInput && penaltyModeInput.checked;

      // Player 1
      if (e.code === 'Space') {
        e.preventDefault();
        const hive = hives[0];
        if (!hive) return;

        if (penaltyOn && !hive.ready) {
          hive.triggerPenalty();
          // no sound on invalid press by request
          return;
        }

        const meaningful = hive.sendBees();
        if (meaningful) playPressSound();
      }

      // Player 2
      if (e.code === 'Enter' && gameMode === '2p') {
        e.preventDefault();
        const hive = hives[1];
        if (!hive) return;

        if (penaltyOn && !hive.ready) {
          hive.triggerPenalty();
          // no sound on invalid press by request
          return;
        }

        const meaningful = hive.sendBees();
        if (meaningful) playPressSound();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (gameEnded && (e.code === 'Space' || e.code === 'Enter')) {
        cancelRestartHold();
      }
    });

    function groundHeightAt(x) {
      const { startX, zoneWidth } = getFieldZone();
      const baseY = height * 0.86;
      const relX = Math.max(0, Math.min(zoneWidth, x - startX));
      const midX = zoneWidth * 0.5;

      if (relX <= midX) {
        const t = relX / midX;
        const p0 = baseY + 20;
        const p1 = baseY - 40;
        const p2 = baseY;
        return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
      }

      const t = (relX - midX) / (zoneWidth - midX);
      const p0 = baseY;
      const p1 = baseY + 40;
      const p2 = baseY - 10;
      return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
    }

    // ----- Particles ----- 
    function spawnParticles(x, y, colorPalette) {
      for(let i=0; i<15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 80;
        const size = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.0,
          decay: 0.8 + Math.random()*0.5,
          color: colorPalette[Math.floor(Math.random()*colorPalette.length)],
          size
        });
      }
    }

    function drawLeaf(ctxDraw, x, y, w, h, angle, color) {
      ctxDraw.save();
      ctxDraw.translate(x, y);
      ctxDraw.rotate(angle);
      ctxDraw.fillStyle = color;
      ctxDraw.beginPath();
      ctxDraw.moveTo(0, 0);
      ctxDraw.quadraticCurveTo(-w * 0.4, -h * 0.2, 0, -h);
      ctxDraw.quadraticCurveTo(w * 0.4, -h * 0.2, 0, 0);
      ctxDraw.fill();
      ctxDraw.restore();
    }

    function getFlowerBloom(f) {
      const groundY = groundHeightAt(f.x);
      return {
        x: f.x + f.stemCurve,
        y: groundY - f.stemHeight
      };
    }

    function drawFlowers(ctxDraw) {
      const leafColor = '#3b7a2a';

      flowers.forEach(f => {
        const groundY = groundHeightAt(f.x);
        const bloomY = groundY - f.stemHeight;
        const sway = f.stemCurve;

        // Stem (always visible)
        ctxDraw.beginPath();
        ctxDraw.moveTo(f.x, groundY);
        ctxDraw.quadraticCurveTo(f.x + sway * 0.35, groundY - f.stemHeight * 0.55, f.x + sway, bloomY);
        ctxDraw.strokeStyle = '#2d5e1c';
        ctxDraw.lineWidth = 6;
        ctxDraw.lineCap = 'round';
        ctxDraw.stroke();

        // Leaves (always visible)
        const leafY = groundY - f.stemHeight * 0.45;
        drawLeaf(ctxDraw, f.x + sway * 0.15, leafY, f.size * 2.2, f.size * 1.8, -0.9, leafColor);
        drawLeaf(ctxDraw, f.x + sway * 0.05, leafY - f.size * 3, f.size * 2.4, f.size * 1.6, 1.1, leafColor);

        // Blossoms appear/disappear with timing
        if (timingMode && !flowersActive) {
          return;
        }

        if (f.type === 'daisy') {
          const petalCount = 12;
          for(let i=0; i<petalCount; i++) {
            const angle = (Math.PI*2 / petalCount) * i;
            ctxDraw.fillStyle = f.colorMain;
            ctxDraw.beginPath();
            ctxDraw.ellipse(
              f.x + sway + Math.cos(angle)*f.size*1.2,
              bloomY + Math.sin(angle)*f.size*1.2,
              f.size*1.1,
              f.size*0.6,
              angle,
              0, Math.PI*2
            );
            ctxDraw.fill();
          }
          ctxDraw.fillStyle = f.colorCenter;
          ctxDraw.beginPath();
          ctxDraw.arc(f.x + sway, bloomY, f.size*0.9, 0, Math.PI*2);
          ctxDraw.fill();
          ctxDraw.fillStyle = 'rgba(255,255,255,0.35)';
          ctxDraw.beginPath();
          ctxDraw.arc(f.x + sway - f.size*0.2, bloomY - f.size*0.2, f.size*0.3, 0, Math.PI*2);
          ctxDraw.fill();
        }
        else if (f.type === 'tulip') {
          const baseX = f.x + sway;
          ctxDraw.fillStyle = f.colorMain;
          ctxDraw.beginPath();
          ctxDraw.moveTo(baseX, bloomY + f.size*1.4);
          ctxDraw.bezierCurveTo(
            baseX - f.size*2.2, bloomY,
            baseX - f.size*0.8, bloomY - f.size*2.2,
            baseX, bloomY - f.size
          );
          ctxDraw.bezierCurveTo(
            baseX + f.size*0.8, bloomY - f.size*2.2,
            baseX + f.size*2.2, bloomY,
            baseX, bloomY + f.size*1.4
          );
          ctxDraw.fill();

          ctxDraw.fillStyle = f.colorCenter;
          ctxDraw.beginPath();
          ctxDraw.ellipse(
            baseX, bloomY - f.size,
            f.size*0.6, f.size*0.35,
            0, 0, Math.PI*2
          );
          ctxDraw.fill();
        }
      });
    }

    function getHexPath(x, y, r, wobbleOffset) {
      const path = new Path2D();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i + Math.PI/6;
        const nextAngle = (Math.PI / 3) * (i+1) + Math.PI/6;
        const r1 = r + Math.sin(wobbleOffset + i)*r*0.05;
        const r2 = r + Math.sin(wobbleOffset + i+1)*r*0.05;
        const px1 = x + r1 * Math.cos(angle);
        const py1 = y + r1 * Math.sin(angle);
        const px2 = x + r2 * Math.cos(nextAngle);
        const py2 = y + r2 * Math.sin(nextAngle);

        if (i === 0) path.moveTo(px1, py1);
        const cpX = (px1 + px2) / 2 + Math.cos(angle+Math.PI/6)*r*0.1;
        const cpY = (py1 + py2) / 2 + Math.sin(angle+Math.PI/6)*r*0.1;
        path.quadraticCurveTo(cpX, cpY, px2, py2);
      }
      path.closePath();
      return path;
    }

    function drawOrganicHexBase(ctxDraw, x, y, r, wobble) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);
      ctxDraw.fillStyle = COLORS.bgDark;
      ctxDraw.fill(path);
    }

    function drawOrganicHexDetail(ctxDraw, x, y, r, variance, wobble, pattern, borderLight, borderDark) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);

      ctxDraw.save();
      ctxDraw.fillStyle = pattern;
      ctxDraw.fill(path);
      ctxDraw.fillStyle = `rgba(255, 220, 0, ${variance * 0.2})`;
      ctxDraw.fill(path);

      ctxDraw.clip(path);
      const grad = ctxDraw.createRadialGradient(x, y, 0, x, y, r*1.2);
      grad.addColorStop(0, 'rgba(255, 240, 150, 0.3)');
      grad.addColorStop(0.6, borderLight);
      grad.addColorStop(1, borderDark);
      ctxDraw.fillStyle = grad;
      ctxDraw.fillRect(x-r*2, y-r*2, r*4, r*4);

      ctxDraw.lineWidth = r * 0.1;
      ctxDraw.strokeStyle = 'rgba(50, 20, 0, 0.5)';
      ctxDraw.stroke(path);
      ctxDraw.restore();

      ctxDraw.lineCap = 'round';
      ctxDraw.lineWidth = r * 0.15;
      ctxDraw.strokeStyle = borderDark;
      ctxDraw.stroke(path);

      const pathHighlight = getHexPath(x-r*0.02, y-r*0.05, r*0.98, wobble);
      ctxDraw.lineWidth = r * 0.05;
      ctxDraw.strokeStyle = borderLight;
      ctxDraw.stroke(pathHighlight);
    }

    // isReady = hive.ready
    function drawBee(ctxDraw, b, isReady = false) {
      ctxDraw.save();
      ctxDraw.translate(b.x, b.y);
      ctxDraw.rotate(b.angle);

      const readyPulse = (isReady && b.state === 'idle')
        ? 1 + 0.15 * Math.sin(b.wobblePhase * 3)
        : 1;
      ctxDraw.scale(b.sizeScale * readyPulse, b.sizeScale * readyPulse);

      const accentLight = b.accentLight || COLORS.beeYellowBright;
      const accentDeep = b.accentDeep || mixHex(accentLight, '#000000', 0.45);
      const abdomenBright = mixHex(accentLight, COLORS.beeYellowBright, 0.5);
      const abdomenDark = mixHex(accentDeep, COLORS.beeYellowDark, 0.5);

      const wingCycle = Math.sin(b.wobblePhase*1.5);

      // Glowing halo when ready
      if (isReady && b.state === 'idle') {
        ctxDraw.save();
        const haloRadius = 24;
        const haloGrad = ctxDraw.createRadialGradient(0, 0, 0, 0, 0, haloRadius);
        haloGrad.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
        haloGrad.addColorStop(1, 'rgba(255, 255, 0, 0)');
        ctxDraw.fillStyle = haloGrad;
        ctxDraw.globalAlpha = 0.65;
        ctxDraw.beginPath();
        ctxDraw.arc(0, 0, haloRadius, 0, Math.PI * 2);
        ctxDraw.fill();
        ctxDraw.restore();
      }

      // Legs/Antennae (Behind)
      ctxDraw.strokeStyle = COLORS.beeBlack;
      ctxDraw.lineCap = 'round';
      ctxDraw.lineWidth = 3;
      ctxDraw.beginPath();
      ctxDraw.moveTo(10, -3); ctxDraw.lineTo(18, -6);
      ctxDraw.moveTo(10,  3); ctxDraw.lineTo(18,  6);
      ctxDraw.stroke();
      ctxDraw.fillStyle = COLORS.beeBlack;
      ctxDraw.beginPath(); ctxDraw.arc(18,-6, 2, 0, Math.PI*2); ctxDraw.fill();
      ctxDraw.beginPath(); ctxDraw.arc(18, 6, 2, 0, Math.PI*2); ctxDraw.fill();

      ctxDraw.lineWidth = 2.5;
      ctxDraw.beginPath();
      ctxDraw.moveTo(4, -6); ctxDraw.lineTo(6, -12);
      ctxDraw.moveTo(4,  6); ctxDraw.lineTo(6,  12);
      ctxDraw.stroke();

      // Thorax
      const thoraxGrad = ctxDraw.createRadialGradient(0, 0, 0, 0, 0, 10);
      thoraxGrad.addColorStop(0, accentLight);
      thoraxGrad.addColorStop(1, accentDeep);
      ctxDraw.fillStyle = thoraxGrad;
      ctxDraw.beginPath();
      ctxDraw.arc(0, 0, 10, 0, Math.PI*2);
      ctxDraw.fill();

      // Head
      ctxDraw.fillStyle = COLORS.beeBlack;
      ctxDraw.beginPath();
      ctxDraw.arc(12, 0, 6, 0, Math.PI*2);
      ctxDraw.fill();

      // Eyes
      ctxDraw.fillStyle = '#000';
      ctxDraw.beginPath();
      ctxDraw.ellipse(14, -3, 3, 4, 0, 0, Math.PI*2);
      ctxDraw.ellipse(14,  3, 3, 4, 0, 0, Math.PI*2);
      ctxDraw.fill();
      ctxDraw.fillStyle = '#fff';
      ctxDraw.beginPath();
      ctxDraw.arc(15, -4, 1.5, 0, Math.PI*2);
      ctxDraw.arc(15,  2, 1.5, 0, Math.PI*2);
      ctxDraw.fill();

      // Abdomen with stripes
      const abX = -12;
      const abY = 0;
      const abRX = 14;
      const abRY = 11;

      ctxDraw.save();
      ctxDraw.beginPath();
      ctxDraw.ellipse(abX, abY, abRX, abRY, 0, 0, Math.PI*2);
      ctxDraw.clip();

      const abdomenGrad = ctxDraw.createRadialGradient(abX, abY, 5, abX, abY, abRX);
      abdomenGrad.addColorStop(0, abdomenBright);
      abdomenGrad.addColorStop(1, abdomenDark);
      ctxDraw.fillStyle = abdomenGrad;
      ctxDraw.fill();

      ctxDraw.fillStyle = 'rgba(0,0,0,0.55)';
      const stripeWidth = 4;
      const stripeSpacing = 4;
      let currentStripeX = abX + abRX - stripeWidth/2 - stripeSpacing;

      for(let i = 0; i < 3; i++) {
        ctxDraw.fillRect(
          currentStripeX - stripeWidth,
          -abRY,
          stripeWidth,
          abRY * 2
        );
        currentStripeX -= (stripeWidth + stripeSpacing);
      }

      ctxDraw.fillStyle = 'rgba(0,0,0,0.55)';
      currentStripeX = abX + abRX - stripeWidth/2 - stripeSpacing;
      for(let i = 0; i < 3; i++) {
        ctxDraw.fillRect(
          currentStripeX - stripeWidth * 0.35,
          -abRY,
          stripeWidth * 0.7,
          abRY * 2
        );
        currentStripeX -= (stripeWidth + stripeSpacing);
      }
      ctxDraw.restore();

      // Wings
      const wingGrad = ctxDraw.createLinearGradient(-10, -10, 10, 10);
      wingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      wingGrad.addColorStop(0.5, 'rgba(200, 255, 255, 0.5)');
      wingGrad.addColorStop(1, 'rgba(255, 200, 255, 0.8)');
      ctxDraw.fillStyle = wingGrad;

      ctxDraw.beginPath();
      ctxDraw.ellipse(-4, -10, 16, 8, 0.3 + wingCycle * 0.4, 0, Math.PI*2);
      ctxDraw.fill();
      ctxDraw.beginPath();
      ctxDraw.ellipse(-4,  10, 16, 8, -0.3 - wingCycle * 0.4, 0, Math.PI*2);
      ctxDraw.fill();

      ctxDraw.globalAlpha = 0.65;
      ctxDraw.fillStyle = accentLight;
      ctxDraw.beginPath();
      ctxDraw.ellipse(-10, 0, 6, 3.5, 0, 0, Math.PI*2);
      ctxDraw.fill();
      ctxDraw.globalAlpha = 1;

      ctxDraw.restore();
    }

    function drawPlayerLabels(ctxDraw, layoutInfo) {
      if (!layoutInfo) return;
      ctxDraw.save();
      ctxDraw.textAlign = 'center';
      ctxDraw.textBaseline = 'top';
      ctxDraw.font = '700 18px sans-serif';

      if (layoutInfo.type === '2p') {
        const padY = 16;
        const leftX = layoutInfo.leftEdge * 0.5;
        const rightX = layoutInfo.rightEdge + (width - layoutInfo.rightEdge) * 0.5;

        [{x: leftX, config: playerConfigs[0]}, {x: rightX, config: playerConfigs[1]}].forEach(({x, config}) => {
          const badgeWidth = 210;
          const badgeHeight = 46;
          const radius = 12;
          const left = x - badgeWidth * 0.5;
          const top = padY;
          const labelY = top + badgeHeight * 0.5;
          const accentBright = mixHex(config.color, '#ffffff', 0.35);
          const accentDark = mixHex(config.color, '#000000', 0.45);

          ctxDraw.save();
          ctxDraw.textAlign = 'left';
          ctxDraw.textBaseline = 'middle';
          ctxDraw.font = '700 18px "Segoe UI", "Nunito", sans-serif';

          ctxDraw.beginPath();
          ctxDraw.moveTo(left + radius, top);
          ctxDraw.lineTo(left + badgeWidth - radius, top);
          ctxDraw.quadraticCurveTo(left + badgeWidth, top, left + badgeWidth, top + radius);
          ctxDraw.lineTo(left + badgeWidth, top + badgeHeight - radius);
          ctxDraw.quadraticCurveTo(left + badgeWidth, top + badgeHeight, left + badgeWidth - radius, top + badgeHeight);
          ctxDraw.lineTo(left + radius, top + badgeHeight);
          ctxDraw.quadraticCurveTo(left, top + badgeHeight, left, top + badgeHeight - radius);
          ctxDraw.lineTo(left, top + radius);
          ctxDraw.quadraticCurveTo(left, top, left + radius, top);
          ctxDraw.closePath();

          ctxDraw.shadowColor = 'rgba(0,0,0,0.35)';
          ctxDraw.shadowBlur = 12;
          ctxDraw.fillStyle = 'rgba(0,0,0,0.55)';
          ctxDraw.fill();

          const shine = ctxDraw.createLinearGradient(left, top, left + badgeWidth, top + badgeHeight);
          shine.addColorStop(0, mixHex(config.color, '#ffffff', 0.18));
          shine.addColorStop(1, mixHex(config.color, '#000000', 0.35));
          ctxDraw.shadowBlur = 0;
          ctxDraw.globalAlpha = 0.7;
          ctxDraw.fillStyle = shine;
          ctxDraw.fill();
          ctxDraw.globalAlpha = 1;

          ctxDraw.lineWidth = 2;
          ctxDraw.strokeStyle = accentBright;
          ctxDraw.stroke();

          ctxDraw.beginPath();
          ctxDraw.shadowColor = accentDark;
          ctxDraw.shadowBlur = 8;
          ctxDraw.fillStyle = config.color;
          ctxDraw.arc(left + 22, labelY, 11, 0, Math.PI * 2);
          ctxDraw.fill();
          ctxDraw.shadowBlur = 0;
          ctxDraw.lineWidth = 1.5;
          ctxDraw.strokeStyle = accentBright;
          ctxDraw.stroke();

          ctxDraw.fillStyle = '#fdfdfd';
          ctxDraw.shadowColor = 'rgba(0,0,0,0.45)';
          ctxDraw.shadowBlur = 4;
          ctxDraw.fillText(config.name, left + 44, labelY);
          ctxDraw.shadowBlur = 0;
          ctxDraw.restore();
        });
      }

      ctxDraw.restore();
    }

    function drawFieldBackdrop(ctxDraw, startX, zoneWidth) {
      const skyGrad = ctxDraw.createLinearGradient(0, 0, 0, height);
      skyGrad.addColorStop(0, '#cde9ff');
      skyGrad.addColorStop(0.6, '#93d2ff');
      skyGrad.addColorStop(1, '#7fc8ff');
      ctxDraw.fillStyle = skyGrad;
      ctxDraw.fillRect(startX, 0, zoneWidth, height);

      const sunX = startX + zoneWidth * 0.18;
      const sunY = height * 0.18;
      const sunRadius = Math.min(120, zoneWidth * 0.25);
      const sunGrad = ctxDraw.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);
      sunGrad.addColorStop(0, 'rgba(255, 240, 180, 0.95)');
      sunGrad.addColorStop(0.5, 'rgba(255, 220, 120, 0.75)');
      sunGrad.addColorStop(1, 'rgba(255, 200, 80, 0)');
      ctxDraw.fillStyle = sunGrad;
      ctxDraw.beginPath();
      ctxDraw.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctxDraw.fill();

      const groundY = height * 0.86;
      ctxDraw.save();
      ctxDraw.translate(startX, 0);
      ctxDraw.fillStyle = '#5fb34b';
      ctxDraw.beginPath();
      ctxDraw.moveTo(0, groundY + 20);
      ctxDraw.quadraticCurveTo(zoneWidth * 0.25, groundY - 40, zoneWidth * 0.5, groundY);
      ctxDraw.quadraticCurveTo(zoneWidth * 0.8, groundY + 40, zoneWidth, groundY - 10);
      ctxDraw.lineTo(zoneWidth, height);
      ctxDraw.lineTo(0, height);
      ctxDraw.closePath();
      ctxDraw.fill();

      ctxDraw.fillStyle = 'rgba(255,255,255,0.18)';
      for (let i = 0; i < zoneWidth; i += 80) {
        const ripple = Math.sin((i + startX) * 0.01) * 8;
        ctxDraw.beginPath();
        ctxDraw.ellipse(i + 30, groundY - 25 + ripple, 50, 14, 0, 0, Math.PI * 2);
        ctxDraw.fill();
      }
      ctxDraw.restore();
    }

    // Ambient + game update
    function updateGame(dt) {
      // Timing mode cycles
      if (timingMode) {
        if (timeUntilNextState > 0) {
          timeUntilNextState -= dt;
        }
        if (timeUntilNextState <= 0) {
          if (timingState === 'waiting') {
            flowersActive = true;
            timingState = 'visible';
            timeUntilNextState = 10; // time with flowers visible
            timingSpentThisCycle = false;
            timingCapturedByPlayerIndex = null;
          } else if (timingState === 'visible') {
            flowersActive = false;
            timingState = 'waiting';
            timeUntilNextState = randRange(10, 20); // 10–20 seconds with no flowers
            timingSpentThisCycle = false;
            timingCapturedByPlayerIndex = null;
          }
        }
      }

      // Victory timer for animation
      if (victoryPhase) {
        victoryTimer += dt;
      }

      hives.forEach(h => h.update(dt));

      // Ambient background sound volume based on readiness
      const anyHiveReady = hives.some(h => h.ready);
      const targetLoopVolume = anyHiveReady ? BG_LOOP_READY_VOLUME : BG_LOOP_IDLE_VOLUME;
      if (bgLoopSound) {
        bgLoopSound.volume += (targetLoopVolume - bgLoopSound.volume) * 0.05;
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 80 * dt;
        p.life -= dt * p.decay;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function drawParticles(ctxDraw) {
      particles.forEach(p => {
        ctxDraw.globalAlpha = p.life;
        ctxDraw.fillStyle = p.color;
        ctxDraw.beginPath();
        ctxDraw.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctxDraw.fill();
        ctxDraw.globalAlpha = 1.0;
      });
    }

    // Draw switch image under each hive that is ready, with appear animation
    function drawSwitchPrompt(ctxDraw) {
      if (!showSwitchImage) return;
      if (!switchImg.complete || !switchImg.width || !switchImg.height) return;
      if (!currentLayoutInfo) return;

      const margin = 10;

      hives.forEach(h => {
        if (!h.ready) return;

        let areaStart, areaEnd;
        if (gameMode === '1p') {
          const splitX = currentLayoutInfo.splitX || width * 0.4;
          areaStart = 0;
          areaEnd = splitX;
        } else {
          if (!h.isRightSide) {
            areaStart = 0;
            areaEnd = currentLayoutInfo.leftEdge;
          } else {
            areaStart = currentLayoutInfo.rightEdge;
            areaEnd = width;
          }
        }

        const areaWidth = areaEnd - areaStart;
        const maxWidth = areaWidth * 0.5; // scale relative to hive "div"

        const iw = switchImg.width;
        const ih = switchImg.height;
        const baseScale = maxWidth / iw;

        // Appear factor: 0 → 1, eased (pop)
        const rawT = (typeof h.switchAppear === 'number') ? h.switchAppear : (h.ready ? 1 : 0);
        const t = Math.max(0, Math.min(1, rawT));
        const ease = t * (2 - t); // ease-out quad

        const finalScale = baseScale * ease;
        if (finalScale <= 0.001) return;

        const drawW = iw * finalScale;
        const drawH = ih * finalScale;

        // Center on hive, clamped inside its area horizontally
        const centerX = Math.min(
          areaEnd - margin - drawW / 2,
          Math.max(areaStart + margin + drawW / 2, h.centerX)
        );
        const x = centerX - drawW / 2;

        // Place under honeycomb, but not off screen
        const desiredY = h.centerY + hexRadius * 2.2;
        const y = Math.min(height - drawH - margin, desiredY);

        ctxDraw.save();
        ctxDraw.globalAlpha = 0.95;
        ctxDraw.drawImage(switchImg, x, y, drawW, drawH);
        ctxDraw.restore();
      });
    }

    function drawGame() {
      let layoutInfo;
      if (gameMode === '1p') {
        const splitX = width * 0.4;
        layoutInfo = { type: '1p', splitX };
        ctx.fillStyle = COLORS.bgLeft;
        ctx.fillRect(0, 0, splitX, height);
        drawFieldBackdrop(ctx, splitX, width - splitX);
      } else {
        const leftEdge = width * 0.3;
        const rightEdge = width * 0.7;
        layoutInfo = { type: '2p', leftEdge, rightEdge };

        ctx.fillStyle = COLORS.bgDark;
        ctx.fillRect(0, 0, leftEdge, height);

        ctx.fillStyle = COLORS.bgDark;
        ctx.fillRect(rightEdge, 0, width - rightEdge, height);

        drawFieldBackdrop(ctx, leftEdge, rightEdge - leftEdge);
      }

      currentLayoutInfo = layoutInfo;

      drawPlayerLabels(ctx, layoutInfo);
      drawFlowers(ctx);
      hives.forEach(h => h.draw(ctx));

      // Victory glow behind finished hives
      if (victoryPhase) {
        const t = Math.min(1, victoryTimer / 3);
        const pulse = 0.5 + 0.5 * Math.sin(victoryTimer * 4);
        hives.forEach(h => {
          if (!h.finished) return;
          const radius = hexRadius * (4 + t * 2);
          const col = mixHex(h.waxColor, '#ffffff', 0.4);
          const rgb = hexToRgb(col);
          const grad = ctx.createRadialGradient(h.centerX, h.centerY, 0, h.centerX, h.centerY, radius);
          grad.addColorStop(0, `rgba(255,255,255,${0.25 + 0.25 * pulse})`);
          grad.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.25 * pulse})`);
          grad.addColorStop(1, 'rgba(0,0,0,0)');

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(h.centerX, h.centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      drawParticles(ctx);
      drawSwitchPrompt(ctx);
    }

    // ----- MENU BEES AROUND SCREEN (LEFT/RIGHT) ----- 
    function initMenuBees() {
      const overlayEl = document.getElementById('promptOverlay');
      const menuCardEl = document.querySelector('.menu-card');
      if (!overlayEl || !menuCardEl) return;

      overlayRect = overlayEl.getBoundingClientRect();
      menuRect = menuCardEl.getBoundingClientRect();

      // More bees around the menu, matching in-game count style (e.g., 6 per side)
      menuBees = [];
      const leftCount = 6;
      const rightCount = 6;
      for (let i = 0; i < leftCount; i++) {
        const b = makeMenuBee('left', 0);
        if (b) menuBees.push(b);
      }
      for (let i = 0; i < rightCount; i++) {
        const b = makeMenuBee('right', 1);
        if (b) menuBees.push(b);
      }
    }

    function updateMenuBees(dt) {
      const overlayStyle = window.getComputedStyle(overlay);
      if (overlayStyle.display === 'none') return;

      const overlayEl = document.getElementById('promptOverlay');
      const menuCardEl = document.querySelector('.menu-card');
      if (!overlayEl || !menuCardEl) return;

      overlayRect = overlayEl.getBoundingClientRect();
      menuRect = menuCardEl.getBoundingClientRect();

      if (!menuBees || !menuBees.length) {
        initMenuBees();
      }

      const w = overlayRect.width || window.innerWidth;
      const h = overlayRect.height || window.innerHeight;

      menuBees.forEach(b => {
        // Center & radius adapt to resize
        b.centerX = b.side === 'left' ? w * 0.18 : w * 0.82;
        b.centerY = h * 0.35;
        b.radius = Math.min(w, h) * 0.08;

        b.angle += b.angularSpeed * dt;                 // slower, smooth movement
        b.wobblePhase += dt * 3 * b.wingSpeed;

        const bob = Math.sin(b.wobblePhase * 0.9) * (b.radius * 0.15);

        b.x = b.centerX + Math.cos(b.angle) * b.radius;
        b.y = b.centerY + Math.sin(b.angle) * b.radius + bob;
      });
    }

    function drawMenuBees() {
      const overlayStyle = window.getComputedStyle(overlay);
      const w = menuBeesCanvas.width / window.devicePixelRatio;
      const h = menuBeesCanvas.height / window.devicePixelRatio;
      menuBeesCtx.clearRect(0, 0, w, h);

      if (overlayStyle.display === 'none') {
        return;
      }

      if (!menuBees || !menuBees.length) return;

      menuBees.forEach(b => {
        // Decorative bees are never "ready"
        drawBee(menuBeesCtx, b, false);
      });
    }

    // ----- Main loop ----- 
    let lastTime = 0;
    function loop(timestamp) {
      requestAnimationFrame(loop);
      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;

      // Menu bees always update when overlay is visible
      updateMenuBees(dt);
      drawMenuBees();

      if (!gameRunning) return;

      updateGame(dt);
      drawGame();
    }

    // Kickoff
    resize();
    loop(0);
  </script>

  <!-- Translation system -->
  <script src="../../js/translationmain.js"></script>
  <script>
    document.getElementById('langToggle')?.addEventListener('pointerup', () => {
      toggleLanguage();
    });
    document.addEventListener('DOMContentLoaded', () => {
      updateLanguage();
    });
  </script>
  <script src="../../js/translationonly.js"></script>
</body>
</html>
