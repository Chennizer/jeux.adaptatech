<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Samurai Focus — Ki Gathering (Eye-gaze)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #game { display:block; width:100vw; height:100vh; cursor: crosshair; background:#000; }
    #startOverlay { position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,0.75); z-index:10; }
    #startBtn{ padding:14px 22px; border:2px solid #6ad1c9; color:#6ad1c9; background:#000; border-radius:12px; font-size:18px; font-weight:700; box-shadow:0 6px 24px rgba(0,0,0,.25); cursor:pointer; }
    #startBtn:active{ transform:translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay"><button id="startBtn">Start • Fullscreen</button></div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       TUNABLES
    ======================= */
    const BG_SRC         = "../../images/samurai/meditationbg.png";      // calm temple/night garden
    const PETAL_SRC      = "../../images/samurai/cherryblossom.png";     // reuse petal
    const GONG_SOUND     = "../../sounds/gong.mp3";
    const BREATH_IN_SND  = "../../sounds/breath_in.mp3";
    const BREATH_OUT_SND = "../../sounds/breath_out.mp3";

    // Focus ring + dwell logic
    const FOCUS_RADIUS_PCT     = 0.14;  // radius of target circle as fraction of min(W,H)
    const MAX_JITTER_PX        = 26;    // allowed movement per sample while charging
    const REQUIRED_DWELL_MS    = 3800;  // continuous stable time to reach 100%
    const DECAY_PER_SEC        = 0.35;  // charge decay fraction when outside or too jittery
    const ENTRY_GRACE_MS       = 250;   // brief grace when entering focus zone

    // Breathing guide ring
    const BREATH_IN_SEC  = 3.0;
    const BREATH_OUT_SEC = 3.0;
    const BREATH_PAUSE   = 0.6;

    // Ambient petals
    const AMBIENT_PETALS = 28;
    const PETAL_SIZE_MIN = 34, PETAL_SIZE_MAX = 88;
    const PETAL_VX_MIN = -15, PETAL_VX_MAX = 15;
    const PETAL_VY_MIN = 10,  PETAL_VY_MAX = 24;
    const PETAL_ROT_MIN = -0.6, PETAL_ROT_MAX = 0.6;

    // Burst at completion
    const BURST_PETALS = 140;
    const BURST_SPEED  = 360;
    const BURST_LIFE   = 1.6;  // seconds

    // HUD
    const METER_WIDTH = 320, METER_HEIGHT = 14;

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    function resize(){
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      focusCx = W/2; focusCy = H*0.54;
      focusR  = Math.min(W,H) * FOCUS_RADIUS_PCT;
    }
    window.addEventListener('resize', resize);

    const bgImg = new Image();    bgImg.src = BG_SRC;
    const petalImg = new Image(); petalImg.src = PETAL_SRC;

    // Audio
    const gong      = new Audio(GONG_SOUND);      gong.volume = 0.7;
    const breathIn  = new Audio(BREATH_IN_SND);   breathIn.volume = 0.35;
    const breathOut = new Audio(BREATH_OUT_SND);  breathOut.volume = 0.35;

    function playOnce(aud){ try {aud.currentTime = 0; aud.play();} catch(_){} }
    function clonePlay(src, vol=1){
      const a = new Audio(src); a.volume = vol; a.play().catch(()=>{});
    }

    // Pointer / gaze
    const pointer = { x:-9999, y:-9999, px:-9999, py:-9999, inside:false, moved:0 };
    canvas.addEventListener('pointermove', e=>{
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top)  * (canvas.height / r.height);
      if (pointer.px !== -9999) pointer.moved = Math.hypot(x-pointer.px, y-pointer.py);
      pointer.x=x; pointer.y=y; pointer.px=x; pointer.py=y; pointer.inside=true;
    });
    canvas.addEventListener('pointerleave', ()=>{ pointer.inside=false; });

    /* =======================
       STATE
    ======================= */
    let started = false;
    let lastT   = performance.now();
    let focusCx = W/2, focusCy = H*0.54;
    let focusR  = Math.min(W,H)*FOCUS_RADIUS_PCT;

    let charge01 = 0;                   // 0..1
    let enterTimeMs = 0;                // time when pointer entered zone
    let inZone = false;
    let completed = false;

    // Ambient petals
    const petals = [];
    const rand = (a,b)=>a+Math.random()*(b-a);
    function spawnAmbientPetal(initial=false){
      const size = rand(PETAL_SIZE_MIN, PETAL_SIZE_MAX);
      const x = Math.random()*W;
      const y = initial ? rand(-H, H) : -size - 20;
      petals.push({
        x,y, w:size, h:size, ang:rand(-Math.PI,Math.PI),
        vx: rand(PETAL_VX_MIN, PETAL_VX_MAX),
        vy: rand(PETAL_VY_MIN, PETAL_VY_MAX),
        rot: rand(PETAL_ROT_MIN, PETAL_ROT_MAX)
      });
    }
    for (let i=0;i<AMBIENT_PETALS;i++) spawnAmbientPetal(true);

    // Burst shards
    const shards = []; // {x,y,w,h,ang,vx,vy,rot,born,life}
    function spawnBurst(){
      const tBorn = performance.now()/1000;
      for (let i=0;i<BURST_PETALS;i++){
        const a = Math.random()*Math.PI*2;
        const sp = BURST_SPEED*(0.4+0.6*Math.random());
        const size = rand(26,72);
        shards.push({
          x: focusCx, y: focusCy,
          w:size, h:size,
          ang: rand(-Math.PI, Math.PI),
          vx: Math.cos(a)*sp,
          vy: Math.sin(a)*sp - rand(60,120),
          rot: rand(-1.6,1.6),
          born: tBorn, life: BURST_LIFE
        });
      }
      playOnce(gong);
    }

    /* =======================
       BREATHING GUIDE
    ======================= */
    let breathTimer = 0;  // cycles IN → PAUSE → OUT → PAUSE
    function breathPhase(dt){
      breathTimer += dt;
      const total = BREATH_IN_SEC + BREATH_PAUSE + BREATH_OUT_SEC + BREATH_PAUSE;
      breathTimer %= total;

      if (breathTimer < BREATH_IN_SEC) return {phase:'in',   t:breathTimer/BREATH_IN_SEC};
      const t1 = breathTimer - BREATH_IN_SEC;
      if (t1 < BREATH_PAUSE) return {phase:'hold1',t:t1/BREATH_PAUSE};

      const t2 = t1 - BREATH_PAUSE;
      if (t2 < BREATH_OUT_SEC) return {phase:'out',  t:t2/BREATH_OUT_SEC};

      const t3 = t2 - BREATH_OUT_SEC;
      return {phase:'hold2', t:t3/BREATH_PAUSE};
    }

    let lastPhase = '';
    function maybePlayBreathSound(ph){
      if (ph.phase !== lastPhase){
        lastPhase = ph.phase;
        if (ph.phase==='in')  playOnce(breathIn);
        if (ph.phase==='out') playOnce(breathOut);
      }
    }

    /* =======================
       UPDATE / RENDER
    ======================= */
    function inFocusZone(x,y){
      return Math.hypot(x-focusCx, y-focusCy) <= focusR;
    }

    function update(dt){
      // ambient petals
      for (let i=petals.length-1;i>=0;i--){
        const p = petals[i];
        p.x += p.vx*dt; p.y += p.vy*dt; p.ang += p.rot*dt;
        if (p.y - p.h/2 > H+40) { petals.splice(i,1); spawnAmbientPetal(false); }
      }

      // shards
      const now = performance.now()/1000;
      for (let i=shards.length-1;i>=0;i--){
        const s = shards[i];
        s.x += s.vx*dt; s.y += s.vy*dt; s.vy += 360*dt; s.ang += s.rot*dt;
        if (now - s.born > s.life) shards.splice(i,1);
      }

      // breathing guide
      const ph = breathPhase(dt);
      maybePlayBreathSound(ph);

      // focus logic
      const currentlyIn = pointer.inside && inFocusZone(pointer.x, pointer.y);
      const stable = pointer.moved <= MAX_JITTER_PX;

      if (currentlyIn){
        if (!inZone){ inZone = true; enterTimeMs = performance.now(); }
        const graceOk = (performance.now() - enterTimeMs) >= ENTRY_GRACE_MS;

        if (graceOk && stable && !completed){
          // grow towards 1.0 based on REQUIRED_DWELL_MS
          const grow = dt * (1000 / REQUIRED_DWELL_MS);
          charge01 = Math.min(1, charge01 + grow);
          if (charge01 >= 1 && !completed){
            completed = true;
            spawnBurst();
          }
        }
      } else {
        inZone = false;
      }

      // decay when not steady / outside (unless already completed)
      if (!completed && (!currentlyIn || !stable)){
        charge01 = Math.max(0, charge01 - DECAY_PER_SEC * dt);
      }
    }

    function drawBackgroundImage(){
      if (bgImg.complete && bgImg.naturalWidth > 0){
        const iw = bgImg.width, ih = bgImg.height;
        const scale = Math.max(W/iw, H/ih);
        const dw = iw*scale, dh = ih*scale;
        const dx = (W-dw)/2, dy = (H-dh)/2;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(bgImg, dx, dy, dw, dh);
      } else {
        ctx.fillStyle = "#041017"; ctx.fillRect(0,0,W,H);
      }
    }

    function drawAmbient(){
      // subtle star fog/glow behind petals
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(W*0.5, H*0.35, 0, W*0.5, H*0.35, Math.max(W,H)*0.6);
      g.addColorStop(0, 'rgba(140,200,255,0.06)');
      g.addColorStop(1, 'rgba(140,200,255,0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(W*0.5, H*0.35, Math.max(W,H)*0.6, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // ambient petals
      for (const p of petals){
        ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.ang);
        ctx.drawImage(petalImg, -p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
    }

    function drawFocus(ph){
      // outer breathing halo
      const breathe01 = (ph.phase==='in')  ? ph.t
                        : (ph.phase==='out') ? 1-ph.t
                        : (ph.phase==='hold1' ? 1 : 0); // hold2 minimal
      const haloR = focusR * (1.15 + 0.25 * breathe01);

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      let grad = ctx.createRadialGradient(focusCx, focusCy, 0, focusCx, focusCy, haloR);
      grad.addColorStop(0, `rgba(120,220,210,0.25)`);
      grad.addColorStop(1, `rgba(120,220,210,0)`);
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(focusCx, focusCy, haloR, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // base circle
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(180,240,235,0.9)';
      ctx.beginPath(); ctx.arc(focusCx, focusCy, focusR, 0, Math.PI*2); ctx.stroke();

      // progress arc
      const arcR = focusR * 0.92;
      ctx.lineWidth = 8;
      ctx.strokeStyle = 'rgba(80,200,190,0.9)';
      ctx.beginPath();
      ctx.arc(focusCx, focusCy, arcR, -Math.PI/2, -Math.PI/2 + charge01 * Math.PI*2);
      ctx.stroke();

      // inner orb grows with charge
      const orbR = focusR * (0.25 + 0.6 * charge01);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const og = ctx.createRadialGradient(focusCx, focusCy, 0, focusCx, focusCy, orbR);
      og.addColorStop(0, `rgba(120,220,210,${0.45+0.45*charge01})`);
      og.addColorStop(1, `rgba(120,220,210,0)`);
      ctx.fillStyle = og;
      ctx.beginPath(); ctx.arc(focusCx, focusCy, orbR, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // tiny sparkle
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.45 * charge01;
      ctx.fillStyle = '#dffff8';
      ctx.beginPath(); ctx.arc(focusCx, focusCy, 2, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawMeter(){
      const x = (W - METER_WIDTH)/2;
      const y = H * 0.82;
      ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(x, y, METER_WIDTH, METER_HEIGHT);
      ctx.fillStyle = 'rgba(110,220,210,0.9)';  ctx.fillRect(x, y, METER_WIDTH * charge01, METER_HEIGHT);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 2; ctx.strokeRect(x, y, METER_WIDTH, METER_HEIGHT);
      // label
      ctx.fillStyle = 'rgba(255,255,255,0.75)'; ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center'; ctx.fillText('Focus / Ki', W/2, y - 10);
    }

    function drawShards(){
      const t = performance.now()/1000;
      for (const s of shards){
        const alpha = Math.max(0, 1 - (t - s.born)/s.life);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.translate(s.x, s.y); ctx.rotate(s.ang);
        ctx.drawImage(petalImg, -s.w/2, -s.h/2, s.w, s.h);
        ctx.restore();
      }
    }

    function render(){
      drawBackgroundImage();
      drawAmbient();

      const ph = breathPhase(0); // query only (no advance)
      drawFocus(ph);
      drawMeter();
      drawShards();

      if (completed){
        // subtle “Mastery” text pulse
        ctx.save();
        ctx.textAlign='center'; ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.font = '700 clamp(24px, 5vmin, 48px) system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText('Mastery achieved', W/2, H*0.18);
        ctx.restore();
      }
    }

    function tick(tMs){
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT)/1000);
      lastT = tMs;

      update(dt);
      render();

      requestAnimationFrame(tick);
    }

    /* ===== FULLSCREEN START ===== */
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    async function enterFullscreen(){
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    }

    startBtn.addEventListener('click', async ()=>{
      try { await enterFullscreen(); } catch(e){}
      startOverlay.style.display = 'none';
      started = true;

      resize();
      // ensure images
      let pending = 0;
      const tryStart = ()=>{ if (--pending<=0) requestAnimationFrame(tick); };
      [bgImg, petalImg].forEach(im=>{ if (!im.complete){ pending++; im.onload = tryStart; }});
      if (pending===0) requestAnimationFrame(tick);
    });
  })();
  </script>
</body>
</html>
