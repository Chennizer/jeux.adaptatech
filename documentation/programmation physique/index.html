<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title data-fr="Initiation à la programmation physique" data-en="English placeholder for Initiation to Physical Programming">Initiation à la programmation physique</title>

  <!-- CSS Files -->
  <link rel="stylesheet" href="../../css/menu.css" />
  <link rel="stylesheet" href="../../css/global.css" />
  <link rel="stylesheet" href="../../css/layout.css" />
  <link rel="stylesheet" href="../../css/components.css" />
  <link rel="stylesheet" href="../../css/instructions.css" />

  <!-- Custom Styles for the new layout structure -->
  <style>
    /* Clearfix for the main container */
    .instruction-container::after {
      content: "";
      display: table;
      clear: both;
    }
    /* Two-column flex layout for sections if needed */
    .two-col {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 20px;
      margin-bottom: 40px;
    }
    .two-col .text {
      flex: 1;
      min-width: 250px;
    }
    .two-col .image {
      flex: 0 0 30vw;
      max-width: 30vw;
    }
    .two-col .image img {
      width: 100%;
      height: auto;
      display: block;
    }
    @media (max-width: 800px) {
      .two-col {
        flex-direction: column;
      }
      .two-col .image {
        flex: none;
        width: 100%;
        max-width: 100%;
      }
    }
    /* Styling for inline floated images */
    .img-float-right {
      float: right;
      width: 30vw;
      max-width: 100%;
      margin-right: 50px;
      margin-bottom: 20px;
      padding-top: 20px;
      padding-left: 20px;
    }
    /* Styling for side-by-side images */
    .images-row {
      display: flex;
      margin-top: 10px;
      margin-bottom: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 5px;
    }
    .images-row img {
      width: 20vw;
      margin: 0;
    }
  </style>
</head>
<body class="menu">
  <!-- Top Navigation -->
  <nav class="top-menu">
    <div class="top-menu-title" data-fr="Portail de jeux adaptés" data-en="Adapted Games Portal">Portail de jeux adaptés</div>
    <ul>
      <li>
        <strong><a href="../index.html" data-fr="Accueil" data-en="Home">Accueil</a></strong>
      </li>
      <li>
        <strong><a href="#" id="language-toggle" onclick="toggleLanguage(); return false;" data-fr="" data-en=""></a></strong>
      </li>
    </ul>
  </nav>

  <!-- Hero Section -->
  <div class="hero-minimalist">
    <h1 data-fr="Initiation à la programmation physique" data-en="English placeholder for Initiation to Physical Programming">Initiation à la programmation physique</h1>
  </div>

  <!-- Main Content Container -->
  <main class="instruction-container">
  
    <!-- Section: Programmation physique -->
    <section>
      <h3 data-fr="Programmation physique" data-en="English placeholder for Physical Programming">Programmation physique</h3>
      <p data-fr="
La programmation physique consiste à développer le logiciel qui contrôle un microcontrôleur. Cet outil est essentiel pour concevoir du matériel adapté. Par exemple, il permet de créer des switchs numériques (<strong><a href='https://adaptatech.org/base-de-connaissances/principe-de-fonctionnement-des-switchs-adaptées/' download>définition ici</a></strong>) applicables dans de nombreux contextes.
      
Grâce à cette approche, les possibilités créatives sont vastes. Les technologies adaptées deviennent accessibles à un public large, y compris aux personnes à force manuelle limitée. Par exemple, des capteurs de proximité (infrarouge, ultrasons) requièrent moins d'effort qu'un bouton classique, tandis que des switchs de type <em>Sip and Puff</em> (souffle et aspiration) – associées à un capteur barométrique – offrent une alternative pour ceux dont la mobilité est réduite.
      
De plus, la programmation physique permet de développer des projets technologiques au-delà des switchs adaptées. On peut l'utiliser pour créer des projets interactifs, que ce soit avec des moteurs, des lumières des haut-parleurs, etc. Par exemple, on peut l'utiliser pour des projets de jouets adaptés personnalisés.
      
Cet article présente une vue d'ensemble des principes de base de la programmation physique et son potentiel. L'objectif n'est pas d'offrir un tutoriel complet, mais de montrer comment démarrer. Des ressources supplémentaires (en anglais) seront indiquées en conclusion.
      " data-en="English placeholder for Physical Programming">
      </p>
    </section>
  
    <!-- Section: Choix de langage de programmation -->
    <section>
      <h3 data-fr="Choix de langage de programmation" data-en="English placeholder for Programming Language Choice">Choix de langage de programmation</h3>
      <p data-fr="
      Pour concevoir un dispositif numérique performant, il est essentiel de choisir les technologies de base : le capteur, le microcontrôleur et le langage de programmation. Le microcontrôleur, c’est-à-dire la puce qui exécute le code et commande les composants électroniques du système, constitue le cœur de l’appareil. Dans ce projet, nous utilisons le Raspberry Pico, reconnu pour sa polyvalence et son prix abordable (6 à 7 dollars). De plus, nous intégrons un capteur de proximité (e.g. KY-032), sélectionné pour sa fiabilité et sa simplicité d’utilisation, qui permet de détecter la présence ou le mouvement et ainsi d’interagir efficacement avec le dispositif.      " data-en="English placeholder for Programming Language Choice">
      </p>
      <img class="grid-w33" src="CPU_programmation.webp" alt="Description" style="float: right; margin-right: 50px; padding-top: 20px; padding-left: 20px;"/>
      <p data-fr="
En ce qui concerne le langage de programmation, plusieurs options s'offrent au développeur selon son expérience. Les langages comme le C/C++ ou l'Assembly offrent de hautes performances, mais présentent une courbe d'apprentissage plus raide. Dans le contexte des switchs numériques, trois langages se démarquent :
<ul class=&quot;list-disc&quot;>
  <li><strong>Micropython :</strong> Une implémentation complète de Python 3 optimisée pour les microcontrôleurs, idéale pour ceux ayant déjà une expérience de Python ou d’autres langages orientés objet.</li>
  <li><strong>Arduino :</strong> Basé sur le C/C++, cette plateforme est largement utilisée pour ses performances, même si elle demande plus de temps d'apprentissage et offre moins d'outils de débogage.</li>
  <li><strong>Circuitpython :</strong> Une version de Micropython développée par Adafruit pour rendre la programmation plus accessible, notamment aux amateurs, avec des outils comme le REPL via l’IDE Mu.</li>
</ul>
      " data-en="English placeholder for Programming Language Options">
      </p>
    </section>
  
    <!-- Section: Exemple : switch qui détecte le mouvement -->
    <section>
      <img class="grid-w100" src="python.webp" alt="Description" style="float: right; margin-right: 50px; padding-top: 20px; padding-bottom: 20px;"/>
      <h3 data-fr="Exemple : switch qui détecte le mouvement" data-en="English placeholder for Example: Motion-Detecting Switch">Exemple : switch qui détecte le mouvement</h3>
      <p data-fr="
Pour cet exemple, le code sera pour un détecteur de mouvement qui active un relai. Concrètement, cela permet de faire un appareil qui a le même prince qu'une switch détectrice de mouvement comme la HoneyBee. Avant de programmer, il faut choisir un éditeur de code. Bien qu'il soit possible d'écrire du code dans un éditeur de texte simple, des outils spécialisés facilitent grandement le processus. Pour Circuitpython, l'éditeur Mu est recommandé, car il permet de sauvegarder le code directement sur le microcontrôleur et de le tester facilement. Pour télécharger Mu, cliquez <strong><a href='https://codewith.mu/en/download' download>ici</a></strong>.
      " data-en="English placeholder for Code Editor Choice">
      </p>

      <img  src="../../images/hugo/circuit_digital.png" alt="Description" style="float: right; width:60vh; margin-right: 50px; padding-top: 20px; padding-left: 20px;"/>
    </section>
  
    <!-- Section: Bibliothèques -->
    <section>
      <h4 data-fr="Bibliothèques" data-en="English placeholder for Libraries">Bibliothèques</h4>
      <p data-fr="
Les bibliothèques regroupent des fonctions préprogrammées indispensables pour que le code fonctionne correctement. Par exemple, la bibliothèque <em>time</em> permet d'introduire des délais, essentiels pour retarder l'activation d'une switch numérique. Sans ces bibliothèques, le code génèrerait des erreurs. Certaines bibliothèques sont intégrées à Circuitpython, tandis que d'autres spécifiques doivent être téléchargées dans le dossier <em>lib</em> du microcontrôleur. Les premières lignes de notre code importent les bibliothèques nécessaires : <em>board</em>, <em>digitalio</em> et <em>time</em>.
      " data-en="English placeholder for Libraries">
      </p>
      <pre><code class="language-python">import board
import time
from digitalio import DigitalInOut, Direction, Pull
      </code></pre>
    </section>
  
    <!-- Section: Initialisation du matériel -->
    <section>
      <h4 data-fr="Initialisation du matériel" data-en="English placeholder for Hardware Initialization">Initialisation du matériel</h4>
      <p data-fr="
Pour que le microcontrôleur communique avec les capteurs, relais et autres composants, il est nécessaire de définir leur configuration dans le code. Cette étape attribue à chaque composant son rôle (entrée ou sortie) et prépare le système à recevoir ou à transmettre des signaux.
      " data-en="English placeholder for Hardware Initialization">
      </p>
      <pre><code class="language-python">sensor = DigitalInOut(board.GP22)
sensor.direction = Direction.INPUT

relay = DigitalInOut(board.GP0)
relay.direction = Direction.OUTPUT
      </code></pre>
    </section>
  
    <!-- Section: Définir les fonctions et les variables -->
    <section>
      <h4 data-fr="Définir les fonctions et les variables" data-en="English placeholder for Defining Variables and Functions">Définir les fonctions et les variables</h4>
      <p data-fr="
Structurer le code à l'aide de variables et de fonctions le rend plus lisible et plus facile à maintenir. Dans cet exemple, nous définissons une variable <em>activation_time</em> qui détermine la durée pendant laquelle le relais reste activé. La fonction <em>relay_activation</em> vérifie l'état du capteur et, en cas de détection, active le relais pendant ce laps de temps.
      " data-en="English placeholder for Variables and Functions">
      </p>
      <pre><code class="language-python">activation_time = 5

def relay_activation():
    if sensor.value:
        relay.value = True
        time.sleep(activation_time)
        relay.value = False
      </code></pre>
    </section>
  
    <!-- Section: Boucle principale -->
    <section>
      <h4 data-fr="Boucle principale" data-en="English placeholder for Main Loop">Boucle principale</h4>
      <p data-fr="
La boucle principale exécute en continu le code qui contrôle le dispositif. Tant que l'appareil reste alimenté, le microcontrôleur vérifie constamment l'état du capteur et active le relais en conséquence.
      " data-en="English placeholder for Main Loop">
      </p>
      <pre><code class="language-python">while True:
    relay_activation()
      </code></pre>
    </section>
  
    <!-- Section: Code final -->
    <section>
      <h4 data-fr="Code final" data-en="English placeholder for Final Code">Code final</h4>
      <p data-fr="
Voici le code complet qui réunit toutes les étapes présentées ci-dessus :
      " data-en="English placeholder for Final Code">
      </p>
      <pre><code class="language-python">import board
from digitalio import DigitalInOut, Direction, Pull
import time

sensor = DigitalInOut(board.GP22)
sensor.direction = Direction.INPUT

relay = DigitalInOut(board.GP0)
relay.direction = Direction.OUTPUT

activation_time = 5

def relay_activation():
    if sensor.value:
        relay.value = True
        time.sleep(activation_time)
        relay.value = False

while True:
    relay_activation()
      </code></pre>
      <p data-fr="
Ce code, d'une vingtaine de lignes, illustre la simplicité avec laquelle on peut créer une switch numérique. Il sert de point de départ pour explorer davantage les possibilités offertes par la programmation physique.
      " data-en="English placeholder for Final Code Summary">
      </p>
    </section>
  
    <!-- Section: Ressources -->
    <section>
      <h3 data-fr="Ressources" data-en="English placeholder for Resources">Ressources</h3>
      <p data-fr="
John Gallagher, enseignant au Boston College, propose plusieurs tutoriels sur sa <strong><a href='https://www.youtube.com/watch?v=eU1e6xPvZEU&amp;list=PL9VJ9OpT-IPSsQUWqQcNrVJqy4LhBjPX2&amp;ab_channel=JohnGallaugher' download>chaîne YouTube</a></strong> destinée aux débutants.
      " data-en="English placeholder for Resources">
      </p>
      <p data-fr="
Adafruit offre <strong><a href='https://learn.adafruit.com/welcome-to-circuitpython/what-is-circuitpython' download>des instructions détaillées</a></strong> pour utiliser CircuitPython, accompagnées d'une documentation complète pour les bibliothèques.
      " data-en="English placeholder for Resources">
      </p>
      <p data-fr="
Pour aller plus loin, consultez <strong><a href='https://github.com/adafruit/circuitpython' download>la page GitHub</a></strong> de CircuitPython, qui recense une multitude de ressources d'apprentissage.
      " data-en="English placeholder for Resources">
      </p>
    </section>
  
  </main>
  
  <!-- Footer inclusion (if available) -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      fetch('../../footer.html')
        .then(response => response.text())
        .then(data => {
          document.body.insertAdjacentHTML('beforeend', data);
        });
    });
  </script>
  <script src="../../js/translationmain.js"></script>
</body>
</html>
