<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="apple-touch-icon" href="../images/binou.png" />
  <link rel="stylesheet" href="../css/ipadteachh.css" />
  <link rel="stylesheet" href="css/sensorial-base.css" />
  <title>Comparer les tailles</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body { margin: 0; font-family: 'Poppins', 'Segoe UI', sans-serif; }
    #activityNumberOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.85);
      color: #fff;
      font-size: clamp(4rem, 12vw, 9rem);
      z-index: 1000;
    }
    #activityNumberOverlay .number-text { font-weight: 700; }

    .game-container {
      display: none;
      width: 100%;
      height: 100%;
      padding: clamp(18px, 3.5vh, 36px);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.96), rgba(236, 244, 255, 0.92));
      border-radius: clamp(18px, 2.6vw, 28px);
      box-shadow: inset 0 0 0 1px rgba(15, 30, 60, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: clamp(20px, 4vh, 32px);
      position: relative;
      overflow: hidden;
    }

    .size-game {
      width: min(100%, 1280px);
      margin: 0 auto;
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: clamp(18px, 3vh, 32px);
      align-items: center;
      justify-items: center;
      text-align: center;
    }

    .size-progress {
      font-size: clamp(1.05rem, 2vw, 1.35rem);
      font-weight: 600;
      color: #0f172a;
    }

    .size-instruction {
      font-size: clamp(1rem, 1.8vw, 1.3rem);
      color: #475569;
      margin: 0;
    }

    .size-feedback {
      min-height: clamp(32px, 4vh, 40px);
      font-size: clamp(1.05rem, 2vw, 1.35rem);
      font-weight: 600;
      color: #0f172a;
    }

    .size-workspace {
      width: 100%;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: clamp(22px, 4vw, 48px);
      align-items: stretch;
    }

    .size-targets {
      background: rgba(255, 255, 255, 0.92);
      border-radius: clamp(18px, 3vw, 28px);
      padding: clamp(18px, 3vh, 28px);
      box-shadow: inset 0 0 0 1px rgba(15, 30, 60, 0.08);
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: clamp(18px, 3vw, 28px);
    }

    .size-target {
      background: rgba(226, 232, 240, 0.3);
      border-radius: clamp(16px, 3vw, 24px);
      border: 2px dashed rgba(28, 140, 214, 0.45);
      padding: clamp(16px, 2.4vh, 24px);
      display: grid;
      gap: clamp(12px, 2vh, 18px);
      justify-items: center;
      align-content: start;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    .size-target.is-highlighted {
      border-color: rgba(28, 140, 214, 0.85);
      transform: translateY(-4px);
    }

    .size-target.is-correct {
      border-style: solid;
      border-color: #16a34a;
      background: rgba(34, 197, 94, 0.14);
    }

    .size-target.is-incorrect {
      border-color: #dc2626;
      animation: shake 0.4s ease;
    }

    .size-target-title {
      font-size: clamp(1.1rem, 2vw, 1.4rem);
      font-weight: 600;
      color: #0b5e8d;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .size-dropzone {
      width: min(100%, clamp(180px, 24vw, 260px));
      aspect-ratio: 1 / 1;
      border-radius: clamp(16px, 3vw, 24px);
      background: rgba(148, 163, 184, 0.15);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .size-dropzone .size-placed-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      transform-origin: center;
      transform: scale(var(--token-scale, 1));
      pointer-events: none;
    }

    .size-source {
      background: rgba(255, 255, 255, 0.92);
      border-radius: clamp(18px, 3vw, 28px);
      padding: clamp(18px, 3vh, 28px);
      box-shadow: inset 0 0 0 1px rgba(15, 30, 60, 0.08);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(clamp(160px, 22vw, 220px), 1fr));
      gap: clamp(18px, 3vw, 28px);
      align-content: start;
      justify-items: center;
    }

    .size-token,
    .size-token-placeholder {
      width: min(100%, clamp(160px, 20vw, 220px));
      aspect-ratio: 1 / 1;
      border-radius: clamp(16px, 3vw, 24px);
    }

    .size-token {
      border: 3px solid transparent;
      background: #fff;
      box-shadow: 0 20px 34px rgba(15, 30, 60, 0.18);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(12px, 2.4vh, 20px);
      cursor: grab;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      touch-action: none;
      user-select: none;
      position: relative;
      overflow: visible;
    }

    .size-token img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      transform: scale(var(--token-scale, 1));
      transform-origin: center;
      pointer-events: none;
    }

    .size-token:focus,
    .size-token:hover {
      outline: none;
      border-color: rgba(28, 140, 214, 0.7);
      transform: translateY(-4px);
    }

    .size-token.is-dragging {
      cursor: grabbing;
      box-shadow: 0 26px 42px rgba(15, 30, 60, 0.25);
      transform: none !important;
    }

    .size-token.is-placed {
      opacity: 0.85;
      cursor: default;
      box-shadow: none;
    }

    .size-token-placeholder {
      border: 2px dashed transparent;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    @media (max-width: 1080px) {
      .size-workspace {
        grid-template-columns: 1fr;
      }
      .size-targets {
        grid-template-columns: repeat(auto-fit, minmax(clamp(180px, 44vw, 240px), 1fr));
      }
      .size-source {
        grid-template-columns: repeat(auto-fit, minmax(clamp(160px, 44vw, 220px), 1fr));
      }
    }

    @media (max-width: 720px) {
      .size-dropzone {
        width: min(100%, clamp(160px, 58vw, 220px));
      }
      .size-token,
      .size-token-placeholder {
        width: min(100%, clamp(150px, 58vw, 200px));
      }
    }
  </style>
</head>
<body class="sensorial-game">
  <div id="activityNumberOverlay" role="presentation">
    <div class="number-text"></div>
  </div>
  <div class="sensorial-shell">
    <header class="sensorial-header">
      <div class="sensorial-header-main">
        <h1 class="sensorial-title">Comparer les tailles</h1>
        <div class="sensorial-activity-marker" role="group" aria-label="Activité en cours">
          <img src="../images/plasticbasket.png" alt="" />
          <span class="sensorial-activity-number">–</span>
        </div>
      </div>
      <p class="sensorial-subtitle">Glisse chaque image vers la case Petit, Moyen ou Grand.</p>
    </header>
    <main class="sensorial-content">
      <div class="game-container" id="sizeGameContainer" aria-live="polite">
        <section class="size-game" aria-describedby="sizeInstruction sizeFeedback">
          <p class="size-progress" id="sizeProgress"></p>
          <p class="size-instruction" id="sizeInstruction">Glisse chaque image vers la case de la bonne taille.</p>
          <div class="size-workspace">
            <section class="size-targets" id="sizeTargets" aria-label="Emplacements des tailles"></section>
            <section class="size-source" id="sizeSource" aria-label="Images à classer"></section>
          </div>
          <p class="size-feedback" id="sizeFeedback" aria-live="assertive"></p>
        </section>
      </div>
    </main>
  </div>
  <audio id="error-sound" src="" preload="auto"></audio>
  <audio id="word-reward-sound" src="" preload="auto"></audio>
  <audio id="final-reward-sound" src="" preload="auto"></audio>
  <script src="../js/themes.js"></script>
  <script src="js/games-config.js"></script>
  <script src="js/session-helpers.js"></script>
  <script src="js/reinforcer-overlay.js"></script>
  <script src="js/fullscreen.js"></script>
  <script>
    (function () {
      'use strict';

      const SIZE_CONFIG = [
        { key: 'petit', label: 'Petit', scale: 0.55 },
        { key: 'moyen', label: 'Moyen', scale: 0.85 },
        { key: 'grand', label: 'Grand', scale: 1.25 }
      ];

      let session = null;
      let themeData = {};
      let reinforcerController = null;
      let reinforcerType = 'shortvideo';
      let totalRounds = 3;
      let currentRound = 0;
      let remainingPlacements = 0;
      let dragState = null;

      const progressEl = document.getElementById('sizeProgress');
      const targetsEl = document.getElementById('sizeTargets');
      const sourceEl = document.getElementById('sizeSource');
      const feedbackEl = document.getElementById('sizeFeedback');
      const gameContainer = document.getElementById('sizeGameContainer');

      document.addEventListener('DOMContentLoaded', () => {
        session = sessionHelpers.ensureCurrentGame('taille');
        if (!session) {
          return;
        }

        sessionHelpers.updateActivityMarker(session);

        themeData = session.themeData || {};
        reinforcerType = (session.selections && session.selections.reinforcerType) || 'shortvideo';

        document.getElementById('error-sound').src = themeData.errorSound || '../sounds/error.mp3';
        document.getElementById('word-reward-sound').src = themeData.reinforcerSound || '../sounds/success3.mp3';
        document.getElementById('final-reward-sound').src = themeData.finalRewardSound || '../sounds/victory.mp3';

        const options = sessionHelpers.getCurrentGameOptions(session);
        const parsedRounds = parseInt(options.roundCount, 10);
        if (Number.isFinite(parsedRounds)) {
          totalRounds = Math.min(Math.max(parsedRounds, 1), 10);
        }

        reinforcerController = sessionHelpers.setupSharedReinforcer(session, {
          reinforcerType,
          onAdvance: sessionHelpers.advanceToNextGame
        });

        sessionHelpers.showActivityOverlay(() => {
          gameContainer.style.display = 'flex';
          startGame();
        }, session);
      });

      function getImagePool() {
        const pool = Array.isArray(themeData.transparentPNGs) && themeData.transparentPNGs.length > 0
          ? themeData.transparentPNGs.slice()
          : [];
        if (pool.length === 0 && themeData.images && themeData.images.length > 0) {
          return themeData.images.slice();
        }
        if (pool.length === 0) {
          pool.push('../images/binou.png');
        }
        return pool;
      }

      function playSound(id) {
        const el = document.getElementById(id);
        if (!el) { return; }
        el.currentTime = 0;
        el.play().catch(() => {});
      }

      function startGame() {
        currentRound = 0;
        nextRound();
      }

      function nextRound() {
        if (currentRound >= totalRounds) {
          finishGame();
          return;
        }
        currentRound += 1;
        buildRound();
      }

      function buildRound() {
        feedbackEl.textContent = '';
        progressEl.textContent = `Épreuve ${currentRound} / ${totalRounds}`;

        const imageSrc = pickImageForRound();
        renderTargets();
        renderTokens(imageSrc);
        remainingPlacements = SIZE_CONFIG.length;
      }

      function pickImageForRound() {
        const pool = getImagePool();
        return pool[Math.floor(Math.random() * pool.length)];
      }

      function renderTargets() {
        targetsEl.innerHTML = '';
        SIZE_CONFIG.forEach((item) => {
          const target = document.createElement('div');
          target.className = 'size-target';
          target.dataset.size = item.key;

          const title = document.createElement('div');
          title.className = 'size-target-title';
          title.textContent = item.label;

          const dropzone = document.createElement('div');
          dropzone.className = 'size-dropzone';
          dropzone.dataset.size = item.key;
          dropzone.setAttribute('aria-label', `Case ${item.label}`);

          target.appendChild(title);
          target.appendChild(dropzone);
          targetsEl.appendChild(target);
        });
      }

      function renderTokens(imageSrc) {
        sourceEl.innerHTML = '';
        const shuffled = shuffleArray(SIZE_CONFIG.slice());
        shuffled.forEach((item, index) => {
          const token = document.createElement('button');
          token.type = 'button';
          token.className = 'size-token';
          token.dataset.size = item.key;
          token.dataset.scale = item.scale;
          token.setAttribute('aria-label', `Image taille ${item.label}`);
          token.style.setProperty('--token-scale', item.scale);

          const img = document.createElement('img');
          img.src = imageSrc;
          img.alt = `Image taille ${item.label}`;
          img.style.setProperty('--token-scale', item.scale);
          token.appendChild(img);

          token.addEventListener('pointerdown', (event) => beginDrag(event, token));

          sourceEl.appendChild(token);
        });
      }

      function beginDrag(event, token) {
        if (!token || token.dataset.locked === 'true') {
          return;
        }
        event.preventDefault();

        const rect = token.getBoundingClientRect();
        const placeholder = document.createElement('div');
        placeholder.className = 'size-token-placeholder';
        placeholder.style.width = `${rect.width}px`;
        placeholder.style.height = `${rect.height}px`;
        token.parentElement.insertBefore(placeholder, token);

        dragState = {
          token,
          placeholder,
          pointerId: event.pointerId,
          offsetX: event.clientX - rect.left,
          offsetY: event.clientY - rect.top,
          currentTarget: null
        };

        token.classList.add('is-dragging');
        token.style.width = `${rect.width}px`;
        token.style.height = `${rect.height}px`;
        token.style.position = 'fixed';
        token.style.left = `${rect.left}px`;
        token.style.top = `${rect.top}px`;
        token.style.margin = '0';
        token.style.zIndex = '2000';

        token.setPointerCapture(event.pointerId);
        document.body.appendChild(token);

        moveToken(event.clientX, event.clientY);
        token.addEventListener('pointermove', handleDragMove);
        token.addEventListener('pointerup', endDrag);
        token.addEventListener('pointercancel', cancelDrag);
        feedbackEl.textContent = 'Dépose l’image dans la bonne case.';
      }

      function handleDragMove(event) {
        if (!dragState || event.pointerId !== dragState.pointerId) {
          return;
        }
        moveToken(event.clientX, event.clientY);
        highlightTarget(event.clientX, event.clientY);
      }

      function moveToken(clientX, clientY) {
        if (!dragState) { return; }
        const { token, offsetX, offsetY } = dragState;
        token.style.left = `${clientX - offsetX}px`;
        token.style.top = `${clientY - offsetY}px`;
      }

      function highlightTarget(clientX, clientY) {
        const previous = dragState.currentTarget;
        const target = findTargetAtPoint(clientX, clientY);
        if (previous && previous !== target) {
          previous.classList.remove('is-highlighted');
        }
        dragState.currentTarget = target;
        if (target) {
          const dropzone = target.querySelector('.size-dropzone');
          if (dropzone && dropzone.dataset.filled !== 'true') {
            target.classList.add('is-highlighted');
          }
        }
      }

      function endDrag(event) {
        if (!dragState || event.pointerId !== dragState.pointerId) {
          return;
        }

        const { token } = dragState;
        token.releasePointerCapture(event.pointerId);

        const target = findTargetAtPoint(event.clientX, event.clientY);
        if (target) {
          const dropzone = target.querySelector('.size-dropzone');
          if (dropzone.dataset.filled === 'true') {
            target.classList.remove('is-highlighted');
            feedbackEl.textContent = 'Cette case est déjà remplie.';
            resetToken();
            return;
          }
          completeAttempt(target, dropzone);
        } else {
          resetToken();
          feedbackEl.textContent = 'Essaie encore.';
        }
      }

      function cancelDrag(event) {
        if (!dragState || event.pointerId !== dragState.pointerId) {
          return;
        }
        resetToken();
      }

      function findTargetAtPoint(x, y) {
        const { token } = dragState || {};
        if (!token) { return null; }
        token.style.visibility = 'hidden';
        const element = document.elementFromPoint(x, y);
        token.style.visibility = '';
        return element ? element.closest('.size-target') : null;
      }

      function completeAttempt(target, dropzone) {
        if (!dragState) { return; }
        const { token, placeholder } = dragState;
        const expected = dropzone.dataset.size;
        const candidate = token.dataset.size;

        target.classList.remove('is-highlighted');

        if (expected === candidate) {
          dropzone.dataset.filled = 'true';
          dropzone.style.setProperty('--token-scale', token.dataset.scale);
          const clone = token.querySelector('img').cloneNode(true);
          clone.classList.add('size-placed-image');
          clone.style.setProperty('--token-scale', token.dataset.scale);
          dropzone.innerHTML = '';
          dropzone.appendChild(clone);

          target.classList.add('is-correct');
          token.dataset.locked = 'true';
          token.classList.add('is-placed');
          playSound('word-reward-sound');
          remainingPlacements -= 1;
          feedbackEl.textContent = remainingPlacements === 0
            ? 'Bravo ! Toutes les tailles sont en place.'
            : 'Super ! Continue avec les autres tailles.';

          cleanupToken(token, placeholder, true);

          if (remainingPlacements === 0) {
            setTimeout(nextRound, 900);
          }
        } else {
          target.classList.add('is-incorrect');
          token.classList.add('is-incorrect');
          playSound('error-sound');
          feedbackEl.textContent = 'Ce n’est pas la bonne taille.';
          setTimeout(() => {
            target.classList.remove('is-incorrect');
            token.classList.remove('is-incorrect');
          }, 650);
          cleanupToken(token, placeholder, false);
        }
      }

      function resetToken() {
        if (!dragState) { return; }
        const { token, placeholder, currentTarget } = dragState;
        if (currentTarget) {
          currentTarget.classList.remove('is-highlighted');
        }
        cleanupToken(token, placeholder, false);
      }

      function cleanupToken(token, placeholder, lockInPlace) {
        token.classList.remove('is-dragging');
        token.style.position = '';
        token.style.left = '';
        token.style.top = '';
        token.style.margin = '';
        token.style.zIndex = '';
        token.style.width = '';
        token.style.height = '';

        token.removeEventListener('pointermove', handleDragMove);
        token.removeEventListener('pointerup', endDrag);
        token.removeEventListener('pointercancel', cancelDrag);

        if (lockInPlace) {
          token.remove();
        } else {
          placeholder.parentElement.insertBefore(token, placeholder);
        }
        placeholder.remove();
        dragState = null;
      }

      function finishGame() {
        const finalSound = document.getElementById('final-reward-sound');
        finalSound.currentTime = 0;
        finalSound.play().catch(() => {});
        setTimeout(() => {
          if (reinforcerController && typeof reinforcerController.show === 'function') {
            reinforcerController.show({ reinforcerType });
          } else {
            sessionHelpers.advanceToNextGame();
          }
        }, 400);
      }

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
    })();
  </script>
</body>
</html>
