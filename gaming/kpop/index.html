<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title 
    class="translate"
    data-fr="K-pop Demon Hunter"
    data-en="K-pop Demon Hunter"
    data-ja="K-pop デーモンハンター">
    K-pop Demon Hunter
  </title>

  <!-- Shared site styles -->
  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Quicksand", "Segoe UI", system-ui, sans-serif;
      min-height: 100vh;
      background: #03000a;
      color: #fef6ff;
      overflow: hidden;
    }

    /* ====== stage visuals ====== */
    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at center 120%, rgba(180,120,255,0.16), rgba(5,0,15,0.95)),
                  radial-gradient(circle at 50% 20%, rgba(255,245,200,0.12), rgba(0,0,0,0.95));
      overflow: hidden;
    }
    .stage::before,
    .stage::after {
      content: "";
      position: absolute;
      inset: -30%;
      background: conic-gradient(from 120deg, rgba(255,79,172,0.1), rgba(111,72,255,0.25), rgba(255,79,172,0.1));
      opacity: 0.6;
      filter: blur(60px);
      transform-origin: center;
      animation: aurora 14s linear infinite;
      pointer-events: none;
    }
    .stage::after { animation-direction: reverse; opacity: 0.45; }

    @keyframes aurora {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.08); }
      100% { transform: rotate(360deg) scale(1); }
    }

    .stage-entry {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 50%, rgba(15,3,30,0.9) 0%, rgba(3,0,10,0.95) 55%, rgba(0,0,0,1) 100%);
      transform: scale(1.35);
      opacity: 1;
      animation: stageReveal 2.0s cubic-bezier(.23,1,.32,1) forwards;
      pointer-events: none;
      z-index: 0;
    }
    @keyframes stageReveal {
      0% { opacity: 0; transform: scale(1.6); }
      20% { opacity: 1; transform: scale(1.6); }
      55% { opacity: 1; transform: scale(1.15); }
      100% { opacity: 0; transform: scale(1); }
    }

    /* ====== idols bottom-left in an L ====== */
    .silhouette-grid {
      position: absolute;
      bottom: clamp(16px, 4vh, 28px);
      left: clamp(16px, 3vw, 32px);
      display: grid;
      grid-template-columns: auto auto;
      grid-template-rows: auto auto;
      gap: clamp(16px, 3vw, 24px);
      align-items: end;
      z-index: 1;
      pointer-events: none;
    }
    .silhouette[data-hero="mira"] { grid-column: 1; grid-row: 1; }
    .silhouette[data-hero="zoey"] { grid-column: 1; grid-row: 2; }
    .silhouette[data-hero="rumi"] { grid-column: 2; grid-row: 2; }

    .silhouette {
      width: clamp(150px, 18vw, 260px);
      aspect-ratio: 3 / 4;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center bottom;
      filter: brightness(0) saturate(0);
      opacity: 0.95;
      transform-origin: bottom center;
      animation: idleBreathe 6s ease-in-out infinite;
      transition: transform 360ms cubic-bezier(.25, .9, .35, 1.4), opacity 360ms ease, filter 360ms ease;
    }
    .silhouette.active { opacity: 1; filter: brightness(0.22) saturate(0); animation: spotlightPulse 1.2s ease-in-out infinite; }
    .silhouette.popping { opacity: 0; transform: translateY(-18px) scale(1.16); animation: none; }
    @keyframes idleBreathe { 0%,100%{transform:translateY(0) scale(1)} 50%{transform:translateY(-6px) scale(1.02)} }
    @keyframes spotlightPulse { 0%,100%{transform:translateY(-10px) scale(1.05)} 50%{transform:translateY(-4px) scale(1.03)} }

    /* ====== monsters on right ====== */
    .monster-area { position:absolute; inset:0; pointer-events:none; z-index:2; }
    .monster {
      position: absolute;
      width: clamp(210px, 30vw, 330px);
      aspect-ratio: 1;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.2) rotate(-12deg);
      animation: monsterRise 600ms ease-out forwards;
      will-change: transform, opacity;
    }
    @keyframes monsterRise {
      0% { opacity: 0; transform: translate(-50%, calc(-50% + 80px)) scale(0.35) rotate(-8deg); }
      60% { opacity: 1; transform: translate(-50%, calc(-50% - 6px))   scale(1.05) rotate(3deg); }
      100%{ opacity: 1; transform: translate(-50%, -50%)               scale(1)    rotate(0deg); }
    }

    /* Richer banish animation */
    .monster.banish { animation: monsterBanish 700ms ease-in forwards; }
    @keyframes monsterBanish {
      0%   { opacity: 1; filter: brightness(1) blur(0px);   transform: translate(-50%, -50%) scale(1); }
      60%  { opacity: .9; filter: brightness(1.2) blur(1px); transform: translate(-50%, -54%) scale(0.92); }
      100% { opacity: 0; filter: brightness(1.6) blur(6px); transform: translate(-50%, -60%) scale(0.75); }
    }

    /* ===== Idol (in/out via JS tweens) ===== */
    .hero-action{
      position:absolute;
      background-size:contain;
      background-repeat:no-repeat;
      background-position:center bottom;
      transform-origin: bottom left;
      opacity:0;
      pointer-events:none;
      z-index:4;
    }

    /* ===== EFFECTS ===== */
    .slash {
      position:absolute; left:50%; top:50%;
      width: 220%; height: 16px;
      transform: translate(-50%, -50%) rotate(var(--rot, 45deg)) scaleX(0.05);
      transform-origin: center center;
      background: linear-gradient(90deg,
        rgba(255,255,255,0),
        rgba(255,225,245,1),
        rgba(255,120,210,1),
        rgba(255,255,255,0));
      opacity: 0;
      pointer-events:none; z-index:3;
      mix-blend-mode: screen;
      filter: saturate(1.2) contrast(1.1);
      box-shadow: 0 0 26px rgba(255,120,210,0.95), 0 0 64px rgba(255,120,210,0.45);
      animation: slashGrow 1100ms cubic-bezier(.2,.9,.2,1) forwards;
      will-change: transform, opacity;
    }
    @keyframes slashGrow{
      0%   { opacity:0.85; transform:translate(-50%,-50%) rotate(var(--rot,45deg)) scaleX(0.25); }
      25%  { opacity:1;    transform:translate(-50%,-50%) rotate(var(--rot,45deg)) scaleX(0.8); }
      75%  { opacity:1;    transform:translate(-50%,-50%) rotate(var(--rot,45deg)) scaleX(1.35); }
      100% { opacity:0;    transform:translate(-50%,-50%) rotate(var(--rot,45deg)) scaleX(1.6); }
    }

    .knife {
      position:absolute; left:50%; top:50%;
      width: 30px; height: 6px; border-radius:2px;
      background: linear-gradient(90deg, rgba(190,230,255,0.3), rgba(160,210,255,1), rgba(90,180,255,1));
      opacity:0; pointer-events:none; z-index:3;
      transform: translate(-50%,-50%) rotate(var(--rot,0deg));
      box-shadow: 0 0 18px rgba(90,180,255,0.95), 0 0 42px rgba(90,180,255,0.35);
      mix-blend-mode: screen;
      animation: knifeFly 1100ms cubic-bezier(.18,.85,.25,1) forwards;
      will-change: transform, opacity;
    }
    .knife::after{
      content:""; position:absolute; inset:-2px -60px -2px -60px;
      background: linear-gradient(90deg, rgba(140,200,255,0), rgba(140,200,255,0.4), rgba(140,200,255,0));
      pointer-events:none; filter: blur(2px); opacity:.85;
    }
    @keyframes knifeFly {
      0%   { opacity:0.85; transform:translate(calc(-50% + var(--x0,-420px)), calc(-50% + var(--y0,-20px))) rotate(var(--rot,0deg)); }
      20%  { opacity:1; }
      100% { opacity:0;   transform:translate(calc(-50% + var(--x1, 220px)),  calc(-50% + var(--y1, 24px)))  rotate(var(--rot,0deg)); }
    }

    .sweep {
      position:absolute; left:50%; top:50%;
      width: 230%; height: 18px; border-radius: 12px;
      transform: translate(-50%,-50%) rotate(var(--start,-36deg)) scaleX(0.08);
      transform-origin:center center;
      background: linear-gradient(90deg, rgba(255,255,255,0),
        rgba(255,240,190,1), rgba(255,210,100,1), rgba(255,255,255,0));
      opacity:0; pointer-events:none; z-index:3;
      mix-blend-mode: screen;
      box-shadow: 0 0 26px rgba(255,215,120,1), 0 0 60px rgba(255,210,120,0.5);
      animation: sweepGo 650ms cubic-bezier(.2,.9,.15,1) forwards;
      will-change: transform, opacity;
    }
    @keyframes sweepGo {
      0%   { opacity:.9; transform:translate(-50%,-50%) rotate(var(--start,-36deg)) scaleX(0.28); }
      20%  { opacity:1;  }
      100% { opacity:0;  transform:translate(-50%,-50%) rotate(var(--end,36deg))  scaleX(1.2); }
    }

    .hit-flare {
      position:absolute; left:50%; top:50%;
      width:220px; height:220px; transform:translate(-50%,-50%) scale(0.4);
      background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,230,160,0.6) 40%, rgba(255,0,165,0) 75%);
      opacity:0; pointer-events:none; z-index:2;
      mix-blend-mode: screen;
      animation: flare 420ms ease-out forwards;
      filter: blur(0.4px);
      will-change: transform, opacity;
    }
    @keyframes flare {
      0%   { opacity:0.9; transform:translate(-50%,-50%) scale(0.6); }
      60%  { opacity:1;   transform:translate(-50%,-50%) scale(1.05); }
      100% { opacity:0;   transform:translate(-50%,-50%) scale(1.45); }
    }

    .shockwave{
      position:absolute; left:50%; top:50%; pointer-events:none; z-index:2;
      width:18px; height:18px; border-radius:50%;
      transform:translate(-50%,-50%) scale(0.2);
      border:2px solid rgba(255,255,255,.7);
      box-shadow: 0 0 22px rgba(255,255,255,.4);
      opacity:0; animation: shock 560ms ease-out forwards;
      filter: blur(.25px);
      mix-blend-mode: screen;
      will-change: transform, opacity;
    }
    @keyframes shock {
      0%   { opacity:0.95; transform:translate(-50%,-50%) scale(0.2); }
      100% { opacity:0;    transform:translate(-50%,-50%) scale(7.5); }
    }

    .afterglow{
      position:absolute; left:50%; top:50%; pointer-events:none; z-index:1;
      width:300px; height:300px; transform:translate(-50%,-50%);
      background: radial-gradient(circle, rgba(255,255,255,0.22) 0%, rgba(255,40,180,0.1) 55%, rgba(255,40,180,0) 80%);
      animation: afterGlow 700ms ease-out forwards;
      filter: blur(1.6px);
      mix-blend-mode: screen;
      will-change: opacity, transform;
    }
    @keyframes afterGlow{
      0%   { opacity:.55; transform:translate(-50%,-50%) scale(1); }
      100% { opacity:0;   transform:translate(-50%,-50%) scale(1.22); }
    }

    .spark{
      position:absolute; left:50%; top:50%;
      width: var(--sz,6px); height: var(--sz,6px);
      border-radius: 50%;
      transform: translate(-50%,-50%) translate(var(--dx,0), var(--dy,0)) rotate(var(--rot,0deg));
      opacity: 0;
      animation: sparkFly var(--dur,700ms) ease-out forwards;
      will-change: transform, opacity, filter;
      filter: blur(.25px);
      mix-blend-mode: screen;
    }
    .spark.pink{ background: radial-gradient(circle, #ffe2f6 0%, #ff79c8 70%); box-shadow: 0 0 14px rgba(255,120,210,.9); }
    .spark.blue{ background: radial-gradient(circle, #e0f2ff 0%, #6ec0ff 70%); box-shadow: 0 0 14px rgba(90,180,255,.9); }
    .spark.gold{ background: radial-gradient(circle, #fff3cd 0%, #ffc34a 70%); box-shadow: 0 0 14px rgba(255,205,120,.9); }
    @keyframes sparkFly{
      0%   { opacity:.9; transform:translate(-50%,-50%) translate(0,0) scale(.7); }
      75%  { opacity:1; }
      100% { opacity:0; transform:translate(-50%,-50%) translate(var(--dx,60px), var(--dy,-10px)) scale(1); }
    }

    /* ===== Bottom-right Kill HUD ===== */
    .kill-hud{
      position:absolute;
      right: clamp(10px, 3vw, 24px);
      bottom: clamp(10px, 3vh, 24px);
      display:flex; gap:12px;
      z-index:5; pointer-events:none;
    }
    .kill-hud.hidden{ display:none; }

    .kill-card{
      --accent: #c9a7ff;
      --accent-soft: rgba(200,160,255,0.35);
      display:flex; align-items:center; gap:10px;
      padding:8px 12px;
      min-width: 92px;
      border-radius: 14px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)) padding-box,
        linear-gradient(180deg, var(--accent), transparent) border-box;
      border: 1px solid var(--accent-soft);
      backdrop-filter: blur(8px);
      box-shadow:
        0 0 24px rgba(160,120,255,0.25),
        0 0 8px color-mix(in oklab, var(--accent) 35%, transparent);
    }
    .kill-card[data-hero="rumi"]{ --accent:#ff79c8; --accent-soft: rgba(255,121,200,0.35); }
    .kill-card[data-hero="zoey"]{ --accent:#6ec0ff; --accent-soft: rgba(110,192,255,0.35); }
    .kill-card[data-hero="mira"]{ --accent:#ffc34a; --accent-soft: rgba(255,195,74,0.35); }

    .kill-card .avatar{
      width: 40px; height: 40px;
      border-radius: 10px;
      overflow: hidden;
      background: radial-gradient(circle at 40% 60%, rgba(255,255,255,0.07), rgba(255,255,255,0.02));
      box-shadow: inset 0 0 8px rgba(0,0,0,0.35);
      flex: 0 0 40px;
    }
    .kill-card .avatar img{
      width: 100%; height: 100%;
      object-fit: contain;
      object-position: center bottom;
      filter: grayscale(20%) brightness(.9) contrast(1.05);
      transform: translateY(1px);
    }
    .kill-card .count{
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      font-size: clamp(18px, 2.4vw, 28px);
      letter-spacing:.25px;
      min-width: 30px; text-align: right;
      color: #fff;
      text-shadow:
        0 0 10px color-mix(in oklab, var(--accent) 70%, transparent),
        0 0 20px color-mix(in oklab, var(--accent) 50%, transparent);
    }
    .kill-card .count.bump{ animation: bump 300ms ease; }
    @keyframes bump{ 0%{transform:scale(1)} 50%{transform:scale(1.18)} 100%{transform:scale(1)} }

    /* ===== Game Over overlay (Hard) ===== */
    .game-over {
      position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.6); z-index: 6;
    }
    .game-over .panel {
      padding: 24px 32px; border: 1px solid rgba(255,120,220,0.35); border-radius: 16px;
      background: rgba(20, 4, 32, 0.8); box-shadow: 0 0 35px rgba(255, 80, 200, 0.35);
      text-align: center; max-width: 80vw;
    }
    .game-over h2 { margin: 0 0 8px; font-size: clamp(24px, 4vw, 40px); }
    .game-over p { margin: 0; opacity: 0.9; }

    /* ===== Options hints (black text) ===== */
    /* Make modal text black so it's readable on the light panel */
    #game-options, #game-options *:not(button) {
      color: #000 !important;
    }

    .option-hint{
      margin-top: 8px;
      font-size: 0.95rem;
      line-height: 1.25rem;
      padding: 10px 12px;
      border-radius: 10px;
      background: #ffffff;
      border: 1px solid rgba(0,0,0,0.12);
      color: #000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .option-hint.hidden{ display:none; }

    #langToggle{
      position: fixed; top:10px; right:10px; z-index:99999;
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:10px; border:2px solid #009688;
      background:#fff; color:#009688; font-weight:700; cursor:pointer;
      user-select:none;
    }
    body.dark #langToggle { background:#111; color:#00b3a4; border-color:#00b3a4; }
    #options-inline-container{ align-items: start; }

    @media (max-width: 768px) {
      .silhouette { width: clamp(130px, 28vw, 200px); }
      .kill-card { padding:7px 10px; min-width: 82px; }
      .kill-card .avatar{ width:34px; height:34px; flex-basis:34px; }
      .kill-card .count{ font-size: clamp(16px, 3.5vw, 24px); min-width:26px; }
    }
  </style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>
<body class="dark">
  <button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

  <!-- ===== Options modal ===== -->
  <div id="game-options" class="modal" style="display:flex;">
    <div id="options-title-bar">
      <h2 id="options-main-title" class="translate"
          data-fr="K-pop Demon Hunter"
          data-en="K-pop Demon Hunter"
          data-ja="K-pop デーモンハンター">K-pop Demon Hunter</h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <!-- LEFT COLUMN: Sound -->
        <div class="options-column">
          <div class="option-item">
            <label for="sfxVol" class="teal-label">
              <span class="translate" data-fr="Volume des sons:" data-en="Sound volume:" data-ja="効果音の音量：">Volume des sons:</span>
              <span id="sfxVolVal">100</span>
            </label>
            <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="100">
          </div>
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="muteSFX">
              <span class="translate" data-fr="Désactiver les sons" data-en="Disable sounds" data-ja="効果音をオフにする">Désactiver les sons</span>
            </label>
          </div>
        </div>

        <!-- MIDDLE COLUMN: Theme + Difficulty -->
        <div class="options-column">
          <div class="option-item">
            <label for="themeSelect" class="teal-label label-block translate"
                   data-fr="Mode" data-en="Theme" data-ja="テーマ">Mode</label>
            <select id="themeSelect" class="styled-select">
              <option value="dark" selected class="translate" data-fr="Sombre" data-en="Dark" data-ja="ダーク">Sombre</option>
              <option value="light" class="translate" data-fr="Clair" data-en="Light" data-ja="ライト">Clair</option>
            </select>
          </div>

          <div class="option-item">
            <label for="difficultySelect" class="teal-label label-block translate"
                   data-fr="Difficulté" data-en="Difficulty" data-ja="難易度">Difficulté</label>
            <select id="difficultySelect" class="styled-select">
              <option value="normal" selected class="translate" data-fr="Normal" data-en="Normal" data-ja="ノーマル">Normal</option>
              <option value="hard" class="translate" data-fr="Difficile" data-en="Hard" data-ja="ハード">Difficile</option>
            </select>

            <!-- Hard mode hint (auto i18n) -->
            <div id="hardHint" class="option-hint hidden translate"
                 data-fr="Mode difficile : les démons apparaissent en continu. Plus il y en a à l’écran, plus la musique baisse. Si 4 démons sont présents en même temps, c’est perdu."
                 data-en="Hard mode: demons keep spawning. The more on screen, the lower the music volume. If 4 demons are alive at once, you lose."
                 data-ja="ハードモード：悪魔が途切れず出現します。画面に多くいるほど音楽の音量が下がります。同時に4体出たらゲームオーバーです。">
              Mode difficile : les démons apparaissent en continu. Plus il y en a à l’écran, plus la musique baisse. Si 4 démons sont présents en même temps, c’est perdu.
            </div>
          </div>
        </div>

        <!-- RIGHT COLUMN: Player Mode -->
        <div class="options-column">
          <div class="option-item">
            <label for="playerModeSelect" class="teal-label label-block translate"
                   data-fr="Mode joueurs" data-en="Player mode" data-ja="プレイヤーモード">Mode joueurs</label>
            <select id="playerModeSelect" class="styled-select">
              <option value="1p" selected class="translate" data-fr="1 joueur" data-en="1 player" data-ja="1人プレイ">1 joueur</option>
              <option value="2p" class="translate" data-fr="2 joueurs" data-en="2 players" data-ja="2人プレイ">2 joueurs</option>
              <option value="3p" class="translate" data-fr="3 joueurs" data-en="3 players" data-ja="3人プレイ">3 joueurs</option>
            </select>
          </div>

          <!-- Mode hints for 2P / 3P -->
          <div id="modeHint2p" class="option-hint hidden translate"
               data-fr="Mode 2 joueurs : Rumi (ESPACE) et Zoey (ENTRÉE). Un compteur par héro s’affiche en bas à droite."
               data-en="2-player mode: Rumi (SPACE) and Zoey (ENTER). Each hero’s kill counter shows at the bottom-right."
               data-ja="2人プレイ：ルミ（スペース）とゾーイ（エンター）。各キャラの撃退数が右下に表示されます。">
            Mode 2 joueurs : Rumi (ESPACE) et Zoey (ENTRÉE). Un compteur par héro s’affiche en bas à droite.
          </div>
          <div id="modeHint3p" class="option-hint hidden translate"
               data-fr="Mode 3 joueurs : Rumi (ESPACE), Zoey (ENTRÉE) et Mira (CLIC GAUCHE). Les trois compteurs de démons apparaissent en bas à droite."
               data-en="3-player mode: Rumi (SPACE), Zoey (ENTER), and Mira (LEFT CLICK). All three demon counters appear at the bottom-right."
               data-ja="3人プレイ：ルミ（スペース）、ゾーイ（エンター）、ミラ（左クリック）。3つの撃退カウンターが右下に表示されます。">
            Mode 3 joueurs : Rumi (ESPACE), Zoey (ENTRÉE) et Mira (CLIC GAUCHE). Les trois compteurs de démons apparaissent en bas à droite.
          </div>

          <div class="option-item" style="opacity:.85%;">
            <div class="translate" data-fr="Contrôles:" data-en="Controls:" data-ja="操作方法：">Contrôles:</div>
            <div id="hint1p" class="translate" data-fr="Solo: ESPACE" data-en="Solo: SPACE" data-ja="ソロ：スペース">Solo: ESPACE</div>
            <div id="hint2p" class="translate" data-fr="Rumi: ESPACE • Zoey: ENTRÉE" data-en="Rumi: SPACE • Zoey: ENTER" data-ja="ルミ：スペース・ゾーイ：エンター" style="display:none;">
              Rumi: ESPACE • Zoey: ENTRÉE
            </div>
            <div id="hint3p" class="translate" data-fr="Rumi: ESPACE • Zoey: ENTRÉE • Mira: CLIC GAUCHE" data-en="Rumi: SPACE • Zoey: ENTER • Mira: LEFT CLICK" data-ja="ルミ：スペース・ゾーイ：エンター・ミラ：左クリック" style="display:none;">
              Rumi: ESPACE • Zoey: ENTRÉE • Mira: CLIC GAUCHE
            </div>
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
    </div>
  </div>

  <!-- ===== Game stage ===== -->
  <div class="stage" id="stage" aria-hidden="true">
    <div class="stage-entry" aria-hidden="true"></div>

    <div class="silhouette-grid" aria-hidden="true">
      <div class="silhouette" data-hero="mira" style="background-image:url('../../images/kpop/mira.png')"></div>
      <div class="silhouette" data-hero="zoey" style="background-image:url('../../images/kpop/zoey.png')"></div>
      <div class="silhouette" data-hero="rumi" style="background-image:url('../../images/kpop/rumi.png')"></div>
    </div>

    <div class="monster-area" id="monsterArea"></div>

    <!-- Kill HUD (bottom-right) -->
    <div class="kill-hud hidden" id="killHud" aria-hidden="true">
      <div class="kill-card" data-hero="rumi">
        <div class="avatar">
          <img src="../../images/kpop/rumi.png" alt="Rumi">
        </div>
        <div class="count" id="count-rumi">0</div>
      </div>
      <div class="kill-card" data-hero="zoey">
        <div class="avatar">
          <img src="../../images/kpop/zoey.png" alt="Zoey">
        </div>
        <div class="count" id="count-zoey">0</div>
      </div>
      <div class="kill-card" data-hero="mira">
        <div class="avatar">
          <img src="../../images/kpop/mira.png" alt="Mira">
        </div>
        <div class="count" id="count-mira">0</div>
      </div>
    </div>

    <!-- Game Over overlay -->
    <div class="game-over" id="gameOver">
      <div class="panel">
        <h2 class="translate" data-fr="Partie terminée!" data-en="Game Over!" data-ja="ゲームオーバー！">Partie terminée!</h2>
        <p class="translate" data-fr="Appuie sur ESPACE pour recommencer." data-en="Press SPACE to restart." data-ja="スペースキーで再スタート。">
          Appuie sur ESPACE pour recommencer.
        </p>
      </div>
    </div>
  </div>

  <script src="../../js/translationmain.js"></script>
  <script>
    document.getElementById('langToggle')?.addEventListener('pointerup', toggleLanguage);

    /* ===================== Menu bindings ===================== */
    const startBtn         = document.getElementById('startButton');
    const muteSFX          = document.getElementById('muteSFX');
    const sfxVol           = document.getElementById('sfxVol');
    const sfxVolVal        = document.getElementById('sfxVolVal');
    const themeSelect      = document.getElementById('themeSelect');
    const difficultySelect = document.getElementById('difficultySelect');
    const playerModeSelect = document.getElementById('playerModeSelect');

    const hint1p = document.getElementById('hint1p');
    const hint2p = document.getElementById('hint2p');
    const hint3p = document.getElementById('hint3p');
    const hardHint = document.getElementById('hardHint');
    const modeHint2p = document.getElementById('modeHint2p');
    const modeHint3p = document.getElementById('modeHint3p');

    function updateHardHintVisibility(){
      const isHard = (difficultySelect.value === 'hard');
      hardHint.classList.toggle('hidden', !isHard);
    }

    function updateModeHintsVisibility(){
      const mode = playerModeSelect.value;
      modeHint2p.classList.toggle('hidden', mode !== '2p');
      modeHint3p.classList.toggle('hidden', mode !== '3p');
    }

    sfxVol.addEventListener('input', ()=> { sfxVolVal.textContent = sfxVol.value; applyMusicVolume(state.musicVolumeMultiplier); });
    playerModeSelect.addEventListener('change', ()=>{
      updateControlsHints();
      updateSilhouetteVisibility(playerModeSelect.value);
      updateKillHudVisibility(playerModeSelect.value);
      updateModeHintsVisibility();
    });
    difficultySelect.addEventListener('change', updateHardHintVisibility);

    function updateControlsHints(){
      const mode = playerModeSelect.value;
      hint1p.style.display = (mode==='1p') ? 'block' : 'none';
      hint2p.style.display = (mode==='2p') ? 'block' : 'none';
      hint3p.style.display = (mode==='3p') ? 'block' : 'none';
    }

    function applyTheme(theme){
      const isDark = theme === 'dark';
      document.body.style.backgroundColor = isDark ? '#03000a' : '#ffffff';
      document.body.style.color = isDark ? '#fef6ff' : '#000000';
      document.body.classList.toggle('dark', isDark);
    }

    let started=false, difficulty='normal', playerMode='1p';
    let spawnTimerId = null;
    let gameOver = false;

    // Normal mode delay (after full hero sequence)
    const EASY_DELAY_MS  = 6000;
    // Hard mode periodic spawn delay
    const HARD_DELAY_MS  = 10000;

    // Peak scale (clamped by computeSafePeakScale)
    const HERO_PEAK_SCALE = 2.2;

    startBtn.addEventListener('click', () => {
      applyTheme(themeSelect.value);
      document.getElementById('langToggle').style.display = 'none';
      document.getElementById('game-options').style.display = 'none';

      const rootEl = document.documentElement;
      if (rootEl.requestFullscreen) rootEl.requestFullscreen().catch(()=>{});
      else if (rootEl.webkitRequestFullscreen) rootEl.webkitRequestFullscreen();

      difficulty = difficultySelect.value || 'normal';
      playerMode = playerModeSelect.value || '1p';
      started = true;
      gameOver = false;

      resetKillCounts();
      updateKillHudVisibility(playerMode);

      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('stage')?.setAttribute('aria-hidden','false');

      updateSilhouetteVisibility(playerMode);
      updateControlsHints();

      primeSfx();
      ensureMusic(true); // start playlist

      setTimeout(spawnMonster, 600);

      if (difficulty === 'normal') {
        // volume already set
      } else {
        scheduleHardSpawn();
        applyHardVolumeByCount(); // ensure correct level immediately in hard
      }
    });

    /* ===================== Game data ===================== */
    const heroes = [
      { id: 'mira', sprite: "../../images/kpop/mira.png" },
      { id: 'zoey', sprite: "../../images/kpop/zoey.png" },
      { id: 'rumi', sprite: "../../images/kpop/rumi.png" }
    ];
    const monsters = [
      "../../images/kpop/monster1.png",
      "../../images/kpop/monster2.png",
      "../../images/kpop/monster3.png",
      "../../images/kpop/monster4.png"
    ];

    const monsterArea = document.getElementById('monsterArea');
    const stage = document.getElementById('stage');

    const state = {
      monsters: [],
      heroElement: null,
      heroTweenCancel: null,
      attackInProgress: false,
      // ==== Music / SFX ====
      musicList: [],       // array<Audio>
      musicIndex: 0,
      musicStarted: false,
      musicVolumeMultiplier: 1.0,
      sfxCache: {},
      // UI state
      activeSilhouette: null,
      kills: { rumi:0, zoey:0, mira:0 }
    };

    /* ===================== Kill HUD helpers ===================== */
    const killHud = document.getElementById('killHud');
    const countEls = {
      rumi: document.getElementById('count-rumi'),
      zoey: document.getElementById('count-zoey'),
      mira: document.getElementById('count-mira')
    };

    function resetKillCounts(){
      state.kills = { rumi:0, zoey:0, mira:0 };
      Object.keys(countEls).forEach(k => countEls[k].textContent = '0');
    }

    function addKill(heroId){
      if (!(heroId in state.kills)) return;
      state.kills[heroId] += 1;
      const el = countEls[heroId];
      if (el){
        el.textContent = String(state.kills[heroId]);
        el.classList.remove('bump');
        void el.offsetWidth; // restart animation
        el.classList.add('bump');
      }
    }

    function updateKillHudVisibility(mode){
      const show = (mode === '2p' || mode === '3p');
      killHud.classList.toggle('hidden', !show);
      killHud.setAttribute('aria-hidden', show ? 'false' : 'true');

      const cardRumi = killHud.querySelector('.kill-card[data-hero="rumi"]');
      const cardZoey = killHud.querySelector('.kill-card[data-hero="zoey"]');
      const cardMira = killHud.querySelector('.kill-card[data-hero="mira"]');
      if (mode === '2p') {
        cardRumi.style.display = 'flex';
        cardZoey.style.display = 'flex';
        cardMira.style.display = 'none';
      } else if (mode === '3p') {
        cardRumi.style.display = 'flex';
        cardZoey.style.display = 'flex';
        cardMira.style.display = 'flex';
      } else {
        cardRumi.style.display = 'none';
        cardZoey.style.display = 'none';
        cardMira.style.display = 'none';
      }
    }

    /* ===================== SFX helpers ===================== */
    const introSfxByHero = {
      rumi: "../../sounds/kpop/kpopsound1.mp3",
      zoey: "../../sounds/kpop/kpopsound2.mp3",
      mira: "../../sounds/kpop/kpopsound3.mp3"
    };
    const attackSfxByHero = {
      rumi: "../../sounds/kpop/kpopsword.mp3",
      zoey: "../../sounds/kpop/kpopdagger.mp3",
      mira: "../../sounds/kpop/kpopspear.mp3"
    };

    function baseVolume() {
      return Math.max(0, Math.min(1, (parseInt(sfxVol.value,10)||100)/100));
    }

    function getAudio(path){
      if (!state.sfxCache[path]) {
        const a = new Audio(path);
        a.preload = 'auto';
        state.sfxCache[path] = a;
      }
      return state.sfxCache[path].cloneNode(true);
    }

    function playSfx(path, volMult=1, rate=1){
      if (muteSFX.checked) return;
      try{
        const a = getAudio(path);
        a.volume = Math.max(0, Math.min(1, baseVolume() * volMult));
        a.playbackRate = rate;
        a.play().catch(()=>{});
      }catch(e){}
    }

    function primeSfx(){
      Object.values(introSfxByHero).forEach(p=>getAudio(p));
      Object.values(attackSfxByHero).forEach(p=>getAudio(p));
    }

    function playIntroSfxFor(heroId){
      const p = introSfxByHero[heroId];
      if (p) playSfx(p, 0.85, 1);
    }

    function playAttackSfxFor(heroId){
      const path = attackSfxByHero[heroId] || attackSfxByHero.rumi;
      playSfx(path, 1.0, 1);
    }

    /* ===================== Music (playlist rotation) ===================== */
    const MUSIC_TRACKS = [
      "../../songs/kpop/golden.mp3",
      "../../songs/kpop/whatitslike.mp3"
    ];

    function currentTrack(){
      return state.musicList[state.musicIndex] || null;
    }

    function initPlaylist(){
      if (state.musicList.length) return;
      state.musicList = MUSIC_TRACKS.map(src => {
        const a = new Audio(src);
        a.preload = 'auto';
        a.loop = false; // we will loop across the list manually
        a.volume = baseVolume() * state.musicVolumeMultiplier;
        a.addEventListener('ended', onTrackEnded);
        return a;
      });
      // randomize starting song for variety
      state.musicIndex = Math.random() < 0.5 ? 0 : 1;
    }

    function onTrackEnded(){
      if (muteSFX.checked || !started || gameOver) return;
      nextTrack(true);
    }

    function nextTrack(play=true){
      if (!state.musicList.length) return;
      const t = currentTrack();
      if (t){ t.pause(); t.currentTime = 0; }
      state.musicIndex = (state.musicIndex + 1) % state.musicList.length;
      const n = currentTrack();
      if (n){
        n.volume = baseVolume() * state.musicVolumeMultiplier;
        if (play){
          n.play().catch(()=>{ state.musicStarted = false; });
        }
      }
    }

    function ensureMusic(forcePlay=false) {
      initPlaylist();
      const track = currentTrack();
      if (!track) return;
      track.volume = baseVolume() * state.musicVolumeMultiplier;

      if (muteSFX.checked) { track.pause(); state.musicStarted=false; return; }
      if (forcePlay || !state.musicStarted) {
        state.musicStarted = true;
        track.play().catch(() => { state.musicStarted = false; });
      }
    }

    function pauseMusic(){
      const t = currentTrack();
      if (t){ t.pause(); state.musicStarted=false; }
    }

    function applyMusicVolume(multiplier=1) {
      state.musicVolumeMultiplier = multiplier;
      const t = currentTrack();
      if (!t) return;
      const vol = baseVolume() * multiplier;
      t.volume = Math.max(0, Math.min(1, vol));
    }

    function applyHardVolumeByCount() {
      const n = state.monsters.length;
      let m = 1.0;
      if (n <= 0) m = 1.00;
      else if (n === 1) m = 0.75;
      else if (n === 2) m = 0.50;
      else if (n === 3) m = 0.25;
      else m = 0.00;
      applyMusicVolume(m);
    }

    const easeInOutQuad = (t)=> t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
    function tween({duration=600, from=0, to=1, easing=easeInOutQuad, update, onComplete}) {
      let raf=0, stopped=false;
      const start = performance.now();
      function step(now){
        if (stopped) return;
        const t = Math.min(1, (now - start)/duration);
        const v = from + (to - from)*easing(t);
        update(v, t);
        if (t < 1) { raf = requestAnimationFrame(step); }
        else { onComplete && onComplete(); }
      }
      raf = requestAnimationFrame(step);
      return ()=>{ stopped=true; cancelAnimationFrame(raf); };
    }

    /* ===================== Spawning ===================== */
    function clearSpawnTimer(){ if (spawnTimerId) { clearTimeout(spawnTimerId); spawnTimerId = null; } }

    function scheduleNormalSpawn() {
      clearSpawnTimer();
      spawnTimerId = setTimeout(() => {
        if (!started || gameOver || state.attackInProgress) { scheduleNormalSpawn(); return; }
        if (state.monsters.length === 0) spawnMonster();
      }, EASY_DELAY_MS);
    }

    function scheduleHardSpawn() {
      clearSpawnTimer();
      spawnTimerId = setTimeout(() => {
        if (!started || gameOver) return;
        if (state.attackInProgress) { scheduleHardSpawn(); return; }
        spawnMonster();
        scheduleHardSpawn();
      }, HARD_DELAY_MS);
    }

    function updateSilhouetteVisibility(mode){
      const mira = document.querySelector('.silhouette[data-hero="mira"]');
      if (mira) mira.style.display = (mode === '2p') ? 'none' : 'block';
    }

    function highlightSilhouette(id) {
      let target = null;
      document.querySelectorAll('.silhouette').forEach(el => {
        if (el.style.display === 'none') return;
        const isMatch = el.dataset.hero === id;
        el.classList.toggle('active', isMatch);
        if (isMatch) target = el; else el.classList.remove('popping');
      });
      state.activeSilhouette = target;
      return target;
    }
    function clearHighlight(){
      document.querySelectorAll('.silhouette').forEach(el=>el.classList.remove('active','popping'));
      state.activeSilhouette = null;
    }

    function randRange(a,b){ return a + Math.random()*(b-a); }

    function spawnMonster() {
      if (!started || !monsterArea || gameOver) return;

      if (difficulty === 'normal' && state.monsters.length >= 1) return;
      if (difficulty === 'hard' && state.monsters.length >= 4) {
        triggerGameOver();
        return;
      }

      const monster = document.createElement('div');
      monster.className = 'monster';
      monster.style.backgroundImage = `url('${monsters[Math.floor(Math.random() * monsters.length)]}')`;

      const stageRect = stage.getBoundingClientRect();
      const x = randRange(stageRect.width * 0.60, stageRect.width * 0.92);
      const y = randRange(stageRect.height * 0.18, stageRect.height * 0.82);

      monster.style.left = `${x}px`;
      monster.style.top  = `${y}px`;

      monsterArea.appendChild(monster);
      state.monsters.push(monster);

      if (difficulty === 'hard') applyHardVolumeByCount();
    }

    /* ===== Monster banish FX ===== */
    function spawnMonsterBanishFx(mon){
      const flare = document.createElement('div');
      flare.className = 'vanish-flare';
      mon.appendChild(flare);
      flare.addEventListener('animationend', ()=> flare.remove(), { once:true });

      const ring = document.createElement('div');
      ring.className = 'vanish-ring';
      mon.appendChild(ring);
      ring.addEventListener('animationend', ()=> ring.remove(), { once:true });

      const smoke = document.createElement('div');
      smoke.className = 'vanish-smoke';
      mon.appendChild(smoke);
      smoke.addEventListener('animationend', ()=> smoke.remove(), { once:true });

      const count = 16 + (Math.random()*10|0);
      for(let i=0;i<count;i++){
        const b = document.createElement('div');
        b.className = 'vanish-bit';
        const angle = Math.random()*Math.PI*2;
        const dist  = 60 + Math.random()*120;
        const dx = Math.cos(angle) * dist;
        const dy = Math.sin(angle) * dist * (0.8 + Math.random()*0.6);
        const rot = (Math.random()*180)|0;
        const w = (3 + Math.random()*4).toFixed(0) + 'px';
        const h = (3 + Math.random()*4).toFixed(0) + 'px';
        const dur = (520 + Math.random()*260)|0;
        b.style.setProperty('--dx', dx+'px');
        b.style.setProperty('--dy', dy+'px');
        b.style.setProperty('--rot', rot+'deg');
        b.style.setProperty('--w', w);
        b.style.setProperty('--h', h);
        b.style.setProperty('--dur', dur+'ms');
        mon.appendChild(b);
        b.addEventListener('animationend', ()=> b.remove(), { once:true });
      }
    }

    function removeMonster(mon) {
      if (!mon) return;
      state.monsters = state.monsters.filter(m => m !== mon);
      spawnMonsterBanishFx(mon);
      mon.classList.add('banish');
      mon.addEventListener('animationend', () => mon.remove(), { once: true });
      if (difficulty === 'hard') applyHardVolumeByCount();
    }

    /* ===== Hero sizing/alignment ===== */
    function makeHeroElement(hero, silhouetteEl){
      const sRect  = silhouetteEl.getBoundingClientRect();
      const stRect = stage.getBoundingClientRect();

      const targetW = sRect.width;
      const targetH = sRect.height;

      const left = sRect.left - stRect.left;
      const top  = (sRect.bottom - stRect.top) - targetH;

      const el = document.createElement('div');
      el.className = 'hero-action';
      el.style.backgroundImage = `url('${hero.sprite}')`;
      el.style.left   = `${left}px`;
      el.style.top    = `${top}px`;
      el.style.width  = `${targetW}px`;
      el.style.height = `${targetH}px`;
      return el;
    }

    /* ===== Safe peak scale (no overflow) ===== */
    function computeSafePeakScale(el, margin = 12){
      const st = stage.getBoundingClientRect();
      const r  = el.getBoundingClientRect();
      const width  = r.width;
      const height = r.height;
      const leftPx   = parseFloat(el.style.left) || 0;
      const topPx    = parseFloat(el.style.top)  || 0;
      const bottomPx = topPx + height;
      const maxScaleRight = (st.width  - margin - leftPx) / width;
      const maxScaleTop   = (bottomPx  - margin) / height;
      const HARD_CAP = 3.0;
      const safe = Math.max(1.0, Math.min(HARD_CAP, maxScaleRight, maxScaleTop));
      return (isFinite(safe) && safe >= 1) ? safe : 1.0;
    }

    /* ===== Hero appear/disappear (mirrored smooth) ===== */
    function heroIn(el, {duration=1800}={}, heroId){
      playIntroSfxFor(heroId);
      el.style.opacity = '0';
      el.style.transform = 'translate(0, 0) scale(1)';
      el.style.willChange = 'transform,opacity';

      const safeCap = computeSafePeakScale(el);
      const peak = Math.min(HERO_PEAK_SCALE, safeCap);

      const st = stage.getBoundingClientRect();
      const r  = el.getBoundingClientRect();
      const miraDown = Math.min(r.height * 0.18, st.height * 0.12);
      const deltaY = (heroId === 'mira') ? miraDown : -6;

      el.dataset.peakScale = String(peak);
      el.dataset.deltaY = String(deltaY);
      el.dataset.heroId = heroId;

      return new Promise(res=>{
        state.heroTweenCancel = tween({
          duration,
          from: 0, to: 1,
          easing: easeInOutQuad,
          update: (p)=> {
            const scale = 1 + (peak - 1) * p;
            const y = deltaY * p;
            el.style.opacity = String(p);
            el.style.transform = `translate(0, ${y}px) scale(${scale})`;
          },
          onComplete: ()=>{
            el.style.willChange = 'auto';
            state.heroTweenCancel = null;
            res();
          }
        });
      });
    }

    function heroOut(el, {duration=1800}={}){
      el.style.willChange = 'transform,opacity';
      const peak   = parseFloat(el.dataset.peakScale || '1') || 1;
      const deltaY = parseFloat(el.dataset.deltaY || '0') || 0;
      return new Promise(res=>{
        state.heroTweenCancel = tween({
          duration,
          from: 0, to: 1,
          easing: easeInOutQuad,
          update: (p)=> {
            const scale = peak - (peak - 1) * p;
            const y = deltaY * (1 - p);
            const opacity = 1 - p;
            el.style.opacity = String(Math.max(0, Math.min(1, opacity)));
            el.style.transform = `translate(0, ${y}px) scale(${scale})`;
          },
          onComplete: ()=>{
            el.style.willChange = 'auto';
            state.heroTweenCancel = null;
            res();
          }
        });
      });
    }

    /* ===== Particles helpers (for hero hits) ===== */
    function spawnShock(mon){
      const sw = document.createElement('div');
      sw.className = 'shockwave';
      mon.appendChild(sw);
      sw.addEventListener('animationend', ()=> sw.remove(), { once:true });
    }
    function spawnAfterglow(mon){
      const ag = document.createElement('div');
      ag.className = 'afterglow';
      mon.appendChild(ag);
      ag.addEventListener('animationend', ()=> ag.remove(), { once:true });
    }
    function spawnSparks(mon, count, colorClass, spread=140, minDur=450, maxDur=720){
      for (let i=0;i<count;i++){
        const sp = document.createElement('div');
        sp.className = 'spark ' + colorClass;
        const angle = Math.random()*Math.PI*2;
        const dist  = (0.35 + Math.random()*0.65) * spread;
        const dx = Math.cos(angle) * dist;
        const dy = Math.sin(angle) * dist * (0.75 + Math.random()*0.6);
        const rot = (Math.random()*360)|0;
        const size = (Math.random()*5 + 4).toFixed(1) + 'px';
        const dur = (Math.random()*(maxDur-minDur) + minDur)|0;
        sp.style.setProperty('--dx', dx+'px');
        sp.style.setProperty('--dy', dy+'px');
        sp.style.setProperty('--rot', rot+'deg');
        sp.style.setProperty('--sz', size);
        sp.style.setProperty('--dur', dur+'ms');
        mon.appendChild(sp);
        sp.addEventListener('animationend', ()=> sp.remove(), { once:true });
      }
    }

    /* ===== Visual effect builders (hero hits) ===== */
    function effectRumiVisuals(mon){
      const s1 = document.createElement('div');
      const s2 = document.createElement('div');
      s1.className = 'slash'; s2.className = 'slash';
      s1.style.setProperty('--rot', '45deg');
      s2.style.setProperty('--rot', '-45deg');
      mon.appendChild(s1); mon.appendChild(s2);
      s1.addEventListener('animationend', ()=> s1.remove(), {once:true});
      s2.addEventListener('animationend', ()=> s2.remove(), {once:true});
      const flare = document.createElement('div'); flare.className='hit-flare'; mon.appendChild(flare);
      flare.addEventListener('animationend', ()=> flare.remove(), {once:true});
      spawnShock(mon);
      spawnAfterglow(mon);
      spawnSparks(mon, 22, 'pink', 160, 500, 720);
    }

    function effectZoeyVisuals(mon){
      const count = 5;
      for (let i=0;i<count;i++){
        const k = document.createElement('div');
        k.className = 'knife';
        const baseY = (-28 + i*14);
        const rot   = (-6 + i*3);
        k.style.setProperty('--x0', (-480 + Math.random()*-120) + 'px');
        k.style.setProperty('--y0', (baseY - 10) + 'px');
        k.style.setProperty('--x1', (220 + Math.random()*80) + 'px');
        k.style.setProperty('--y1', (baseY + 18) + 'px');
        k.style.setProperty('--rot', rot + 'deg');
        mon.appendChild(k);
        k.addEventListener('animationend', ()=> k.remove(), {once:true});
      }
      const flare = document.createElement('div'); flare.className='hit-flare'; mon.appendChild(flare);
      flare.addEventListener('animationend', ()=> flare.remove(), {once:true});
      spawnShock(mon);
      spawnAfterglow(mon);
      spawnSparks(mon, 20, 'blue', 150, 480, 720);
    }

    function effectMiraVisuals(mon){
      const sw = document.createElement('div');
      sw.className = 'sweep';
      sw.style.setProperty('--start', '-36deg');
      sw.style.setProperty('--end', '36deg');
      mon.appendChild(sw);
      sw.addEventListener('animationend', ()=> sw.remove(), {once:true});
      const flare = document.createElement('div'); flare.className='hit-flare'; mon.appendChild(flare);
      flare.addEventListener('animationend', ()=> flare.remove(), {once:true});
      spawnShock(mon);
      spawnAfterglow(mon);
      spawnSparks(mon, 22, 'gold', 170, 480, 720);
    }

    function performHeroEffectVisuals(mon, heroId){
      if (heroId === 'rumi') effectRumiVisuals(mon);
      else if (heroId === 'zoey') effectZoeyVisuals(mon);
      else effectMiraVisuals(mon);
    }

    /* ===== Game Over (Hard) ===== */
    function triggerGameOver() {
      gameOver = true;
      clearSpawnTimer();
      pauseMusic();
      document.getElementById('gameOver').style.display = 'flex';
    }

    function resetHardRun() {
      state.monsters.forEach(m => m.remove());
      state.monsters = [];
      gameOver = false;
      document.getElementById('gameOver').style.display = 'none';
      ensureMusic(true);
      applyHardVolumeByCount();
      resetKillCounts();
      updateKillHudVisibility(playerMode);
      setTimeout(spawnMonster, 600);
      scheduleHardSpawn();
    }

    /* ===== Attack sequence ===== */
    async function runAttack(heroId) {
      if (!started || state.attackInProgress || gameOver) return;
      if (!state.monsters.length) return;

      // Select hero based on playerMode
      let chosenId = heroId;
      if (playerMode === '1p') {
        const pool = ['rumi','zoey','mira'];
        chosenId = pool[Math.floor(Math.random()*pool.length)];
      } else if (playerMode === '2p') {
        if (chosenId !== 'rumi' && chosenId !== 'zoey') return;
      } else if (playerMode === '3p') {
        if (!['rumi','zoey','mira'].includes(chosenId)) return;
      }

      clearSpawnTimer();
      state.attackInProgress = true;
      ensureMusic(true);
      if (difficulty === 'hard') applyHardVolumeByCount();

      const target = state.monsters[0];
      const hero = heroes.find(h => h.id === chosenId) || heroes[0];
      const silhouetteEl = highlightSilhouette(hero.id);
      silhouetteEl?.classList.add('popping');

      if (state.heroTweenCancel) { state.heroTweenCancel(); state.heroTweenCancel=null; }
      if (state.heroElement) { state.heroElement.remove(); state.heroElement=null; }

      const heroEl = makeHeroElement(hero, silhouetteEl || document.querySelector('.silhouette'));
      stage.appendChild(heroEl);
      state.heroElement = heroEl;

      // Hero in
      await heroIn(heroEl, {duration: 1800}, hero.id);

      if (target && state.monsters.includes(target)) {
        if (hero.id === 'zoey') {
          playAttackSfxFor(hero.id);
          await new Promise(r => setTimeout(r, 220));
          performHeroEffectVisuals(target, hero.id);
        } else {
          playAttackSfxFor(hero.id);
          await new Promise(r => requestAnimationFrame(r));
          performHeroEffectVisuals(target, hero.id);
        }

        await new Promise(r => setTimeout(r, 650));
        addKill(hero.id);
        removeMonster(target);
      }

      await new Promise(r => setTimeout(r, 360));

      await heroOut(heroEl, {duration: 1800});
      heroEl.remove();
      if (state.heroElement === heroEl) state.heroElement = null;
      clearHighlight();

      state.attackInProgress = false;

      if (difficulty === 'normal') {
        scheduleNormalSpawn();
      } else if (!gameOver) {
        scheduleHardSpawn();
      }
    }

    /* ===== Input ===== */
    function handleKey(event) {
      if (!started) return;

      if (gameOver && event.code === 'Space') {
        event.preventDefault();
        resetHardRun();
        return;
      }

      if (event.code === 'Space') { // 1P or Rumi
        event.preventDefault();
        runAttack(playerMode === '1p' ? undefined : 'rumi');
      } else if (event.code === 'Enter') { // Zoey (2P/3P)
        if (playerMode !== '1p') {
          event.preventDefault();
          runAttack('zoey');
        }
      }
    }
    window.addEventListener('keydown', handleKey);

    // Click-to-attack only in 3P (Mira)
    window.addEventListener('pointerdown', (e) => {
      if (!started || gameOver) return;
      if (playerMode !== '3p') return;
      if (e.button === 0) runAttack('mira');
    });

    window.addEventListener('blur',  () => {
      const t = currentTrack();
      if (t && !document.hasFocus()) { t.pause(); state.musicStarted=false; }
    });
    window.addEventListener('focus', () => {
      if (!started || muteSFX.checked || gameOver) return;
      ensureMusic(); // resume current track
      if (difficulty==='hard') applyHardVolumeByCount();
    });

    muteSFX.addEventListener('change', () => {
      if (muteSFX.checked) pauseMusic();
      else { ensureMusic(true); if (difficulty==='hard') applyHardVolumeByCount(); }
    });

    // Init UI state
    (function initPlayerModeUI(){
      updateControlsHints();
      updateSilhouetteVisibility(playerModeSelect.value);
      updateKillHudVisibility(playerModeSelect.value);
      updateHardHintVisibility();
      updateModeHintsVisibility();
    })();
  </script>

  <script src="../../js/lang-info-standard.js"></script>
</body>
</html>
