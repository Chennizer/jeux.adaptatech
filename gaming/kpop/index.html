<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>K-pop Demon Hunter</title>
  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%23ff4fac'/%3E%3C/svg%3E" />
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Quicksand', 'Segoe UI', sans-serif;
      background: #000; /* full black */
      overflow: hidden;
      color: #fff;
    }

    /* Landing menu */
    #landingMenu {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; padding: 2rem;
      background: transparent;
      z-index: 10; transition: opacity .3s ease, visibility .3s ease;
    }
    #landingMenu.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
    .menu-card {
      width: min(780px, 92vw); background: rgba(12,6,18,.85); border: 1px solid rgba(255,79,172,.18);
      border-radius: 20px; padding: 2rem; box-shadow: 0 30px 90px rgba(0,0,0,.45), 0 0 40px rgba(255,79,172,.25);
      backdrop-filter: blur(8px); text-align: center;
    }
    .menu-title { font-size: clamp(1.6rem, 2.8vw, 2.4rem); font-weight: 700; margin: 0 0 .25rem; }
    .menu-sub { opacity: .85; font-size: .95rem; margin-bottom: 1.5rem; }
    .menu-grid { display: grid; grid-template-columns: 1fr; gap: 1rem; margin: 1rem 0 1.5rem; }
    .option-item { text-align: left; }
    .option-item label { display: flex; align-items: baseline; gap: .5rem; font-size: .95rem; color: #ffd6f5; margin-bottom: .4rem; }
    .styled-slider { width: 100%; }
    .btn-row { display: flex; gap: .75rem; justify-content: center; flex-wrap: wrap; }
    .btn {
      appearance: none; border: none; border-radius: 14px; padding: .85rem 1.4rem; font-weight: 700; letter-spacing: .02em; cursor: pointer;
      box-shadow: 0 6px 18px rgba(255,79,172,.25), inset 0 0 0 1px rgba(255,255,255,.06);
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms ease;
    }
    .btn:active { transform: translateY(1px); }
    .btn-primary { background: linear-gradient(135deg, #ff4fac, #a86bff); color: #0e0316; }
    .btn-ghost { background: rgba(255,255,255,.06); color: #fff; }

    /* Game stage */
    .game-stage {
      position: relative; width: 100vw; height: 100vh; background: #000;
      display: none; align-items: center; justify-content: center; z-index: 0;
    }
    .game-stage.active { display: flex; }

    /* UI (hidden during play) */
    .game-overlay {
      position: absolute; left: 50%; transform: translateX(-50%); top: 2rem;
      padding: .75rem 1.5rem; font-size: 1.1rem; letter-spacing: .04em;
      background: rgba(15,4,22,.7); color: #fff4fb; border-radius: 1.5rem;
      box-shadow: 0 0 20px rgba(255,79,172,.4); backdrop-filter: blur(6px); z-index: 2;
    }
    .game-stage.active .game-overlay { display: none !important; }

    .monster-field { position: relative; width: 100%; height: 100%; overflow: hidden; z-index: 1; }

    .monster {
      position: absolute; width: 160px; height: 160px; background-size: contain; background-repeat: no-repeat; background-position: center;
      animation: pulse 1.2s ease-in-out infinite; filter: drop-shadow(0 0 20px rgba(255,0,128,.6)); will-change: transform, filter, opacity;
    }
    .monster.vanish { opacity: 0; transform: scale(.6); transition: opacity 250ms ease, transform 250ms ease; }
    @keyframes pulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.08);} }
    @media (prefers-reduced-motion: reduce) { .monster { animation: none; } }

    .monster.hit { animation: monsterHit 420ms ease-out; }
    @keyframes monsterHit {
      0%   { transform: translateY(0) scale(1);      filter: brightness(1) drop-shadow(0 0 20px rgba(255,0,128,.6)); }
      20%  { transform: translateY(-6px) scale(1.06); filter: brightness(1.35) drop-shadow(0 0 28px rgba(255,120,200,.9)); }
      50%  { transform: translateY(2px) scale(.98);  filter: brightness(.95) drop-shadow(0 0 16px rgba(255,0,128,.55)); }
      100% { transform: translateY(0) scale(1.02);    filter: brightness(1.05) drop-shadow(0 0 20px rgba(255,0,128,.6)); }
    }
    .monster.banish { animation: monsterBanish 360ms ease-in forwards; }
    @keyframes monsterBanish {
      0%   { opacity: 1;   transform: scale(1.02) rotate(0deg);   filter: brightness(1.1); }
      70%  { opacity: .25; transform: scale(.72) rotate(-6deg);   filter: brightness(1.6); }
      100% { opacity: 0;   transform: scale(.6)  rotate(-10deg);  filter: brightness(2); }
    }

    /* Hero */
    .hero {
      position: absolute; bottom: 1.25rem; left: 1.25rem;
      transform: translateX(-160%) translateY(0) scale(1);
      width: min(28vw, 360px); aspect-ratio: 3/4; background-size: contain; background-position: bottom left; background-repeat: no-repeat;
      opacity: 0; filter: drop-shadow(0 0 20px rgba(255,79,172,.5));
      transition: opacity 300ms ease, transform 700ms cubic-bezier(.2,.8,.2,1); z-index: 3; pointer-events: none;
    }
    .hero.show { opacity: 1; transform: translateX(0) translateY(0) scale(1); }
    .hero.hide { opacity: .2 !important; transform: translateX(-160%) translateY(0) scale(1) !important; transition: opacity 300ms ease, transform 700ms cubic-bezier(.2,.8,.2,1); }

    /* Slash effect (warm/white) */
    .slash {
      position: absolute; width: 260px; height: 80px; pointer-events: none; z-index: 4;
      background:
        radial-gradient(60% 120% at 50% 50%, rgba(255,255,255,.95) 0%, rgba(255,248,220,.9) 25%, rgba(255,220,64,.6) 50%, rgba(255,220,64,0) 70%),
        linear-gradient(90deg, rgba(255,255,255,.9), rgba(255,220,64,.75));
      border-radius: 999px; filter: drop-shadow(0 0 18px rgba(255,220,64,.65)) drop-shadow(0 0 42px rgba(255,220,64,.35));
      transform-origin: center left; opacity: 0; animation: slashStrike 320ms ease-out forwards; mix-blend-mode: screen;
    }
    @keyframes slashStrike {
      0%   { opacity: 0; transform: scaleX(.2) scaleY(.9) rotate(-14deg) translateX(-20px); }
      40%  { opacity: 1; transform: scaleX(1.05) scaleY(1.0) rotate(-14deg) translateX(0); }
      70%  { opacity: .9; transform: scaleX(1.2)  scaleY(1.02) rotate(-14deg) translateX(10px); }
      100% { opacity: 0; transform: scaleX(1.35) scaleY(1.05) rotate(-14deg) translateX(22px); }
    }

    @media (max-width: 768px) {
      .monster { width: 120px; height: 120px; }
      .menu-card { padding: 1.5rem; }
      .game-overlay { font-size: 1rem; padding: .6rem 1.1rem; }
      .hero { width: min(46vw, 320px); }
    }
  </style>
</head>
<body>
  <!-- Landing menu -->
  <div id="landingMenu" role="dialog" aria-modal="true">
    <div class="menu-card">
      <h1 class="menu-title">K-pop Demon Hunter</h1>
      <p class="menu-sub">Press 'Play' to start. A demon spawns every 10 seconds.</p>

      <div class="menu-grid">
        <div class="option-item">
          <label for="spawnDelay">Interval (s): <strong id="spawnDelayVal">10</strong></label>
          <input type="range" id="spawnDelay" class="styled-slider" min="3" max="20" value="10" />
        </div>
      </div>

      <div class="btn-row">
        <button id="startButton" class="btn btn-primary">Play</button>
        <button id="muteSFX" class="btn btn-ghost" aria-pressed="false">Sound: On</button>
      </div>
    </div>
  </div>

  <!-- Game stage -->
  <div class="game-stage" id="gameStage">
    <!-- p5 full-screen background (behind monsters & hero) -->
    <div id="p5-bg" aria-hidden="true" style="position:absolute; inset:0; z-index:0; pointer-events:none;"></div>

    <div class="monster-field" id="monsterField"></div>

    <!-- Text UI (hidden when playing) -->
    <div class="game-overlay">Press SPACE to banish demons</div>
  </div>

  <!-- p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>

  <!-- p5 show lights: TWO origins (top-left & top-right), white/yellow, black bg -->
  <script>
  (function () {
    const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    function fillLinearGradient(p, x0, y0, x1, y1, stops) {
      const g = p.drawingContext.createLinearGradient(x0, y0, x1, y1);
      for (const [offset, color] of stops) g.addColorStop(offset, color);
      p.drawingContext.fillStyle = g;
    }

    const confetti = [];
    const pendingConfetti = [];
    function spawnConfetti(x, y) {
      for (let i = 0; i < 22; i++) {
        confetti.push({
          x, y,
          vx: (Math.random() * 2 - 1) * 6,
          vy: (-Math.random() * 6) - 4,
          life: 0,
          ttl: 60 + Math.random() * 24,
          size: 3 + Math.random() * 3,
          hue: 50 + Math.random() * 20
        });
      }
    }
    window.addEventListener('kpop-confetti', (e) => {
      if (reduceMotion) return;
      const { x, y } = (e && e.detail) ? e.detail : { x: 0, y: 0 };
      pendingConfetti.push({ x, y });
    });

    new p5((p) => {
      let W = 0, H = 0, beams = [];

      const clusterBeams = 3;     // beams per side
      const topOffset = 10;       // distance from very top
      const fanSpread = 0.28;     // each cluster's spread around its center angle
      const centerTilt = 0.38;    // magnitude from straight-down to aim inward
      const lenFactor = 0.7;

      function resize() {
        const bg = document.getElementById('p5-bg');
        if (!bg) return;
        const rect = bg.getBoundingClientRect();
        W = Math.max(1, rect.width | 0);
        H = Math.max(1, rect.height | 0);
        p.resizeCanvas(W, H, true);
      }

      p.setup = function () {
        const parent = document.getElementById('p5-bg');
        p.createCanvas(10, 10).parent(parent);
        p.pixelDensity(1);
        p.noStroke();
        p.rectMode(p.CORNER);
        p.frameRate(60);
        p.clear();
        p.canvas.style.zIndex = 0;
        p.canvas.style.position = 'absolute';
        p.canvas.style.inset = '0';

        resize();
        window.addEventListener('resize', resize);

        // Build two clusters: LEFT origin & RIGHT origin
        beams = [];
        // Left cluster: origin near top-left, aiming down-right (negative angles)
        for (let i = 0; i < clusterBeams; i++) {
          const t = clusterBeams === 1 ? 0 : i / (clusterBeams - 1);
          const baseAngle = -(centerTilt) + (t - 0.5) * (2 * fanSpread); // around -centerTilt
          beams.push({
            origin: () => ({ x: W * 0.12, y: topOffset }),
            baseAngle,
            speed: (0.35 + Math.random() * 0.35) * (reduceMotion ? 0.6 : 1),
            width: p.random(110, 170),
            colors: { start: 'rgba(255,255,240,0.85)', mid: 'rgba(255,235,120,0.55)', end: 'rgba(255,220,64,0.00)' }
          });
        }
        // Right cluster: origin near top-right, aiming down-left (positive angles)
        for (let i = 0; i < clusterBeams; i++) {
          const t = clusterBeams === 1 ? 0 : i / (clusterBeams - 1);
          const baseAngle = +(centerTilt) + (t - 0.5) * (2 * fanSpread); // around +centerTilt
          beams.push({
            origin: () => ({ x: W * 0.88, y: topOffset }),
            baseAngle,
            speed: (0.35 + Math.random() * 0.35) * (reduceMotion ? 0.6 : 1),
            width: p.random(110, 170),
            colors: { start: 'rgba(255,255,240,0.85)', mid: 'rgba(255,235,120,0.55)', end: 'rgba(255,220,64,0.00)' }
          });
        }
      };

      p.draw = function () {
        if (!W || !H) return;

        // Full black background
        p.clear();
        p.fill(0, 0, 0, 255);
        p.rect(0, 0, W, H);

        // Draw beams
        p.push();
        p.noStroke();
        for (const b of beams) {
          const { x: originX, y: originY } = b.origin();
          const t = p.millis() / 1000;
          const sway = Math.sin(b.baseAngle * 2 + t * b.speed) * (reduceMotion ? 0.08 : 0.16);
          const angle = b.baseAngle + sway; // 0 = straight down

          const len = H * lenFactor;
          const w   = b.width;

          p.push();
          p.translate(originX, originY);
          p.rotate(angle);

          const g = p.drawingContext.createLinearGradient(0, 0, 0, len);
          g.addColorStop(0,   b.colors.start);
          g.addColorStop(0.4, b.colors.mid);
          g.addColorStop(1,   b.colors.end);
          p.drawingContext.fillStyle = g;

          p.beginShape();
          p.vertex(0, 0);
          p.vertex(-w * 0.5, len);
          p.vertex(w * 0.5, len);
          p.endShape();
          p.pop();
        }
        p.pop();

        // Confetti
        if (pendingConfetti.length) {
          while (pendingConfetti.length) {
            const it = pendingConfetti.pop();
            spawnConfetti(it.x, it.y);
          }
        }
        for (let i = confetti.length - 1; i >= 0; i--) {
          const c = confetti[i];
          c.life++;
          c.x += c.vx;
          c.y += c.vy;
          c.vy += 0.25;
          const alpha = Math.max(0, 1 - c.life / c.ttl);
          p.push();
          p.translate(c.x, c.y);
          p.rotate((c.life * 0.2) % (Math.PI * 2));
          p.fill(`hsla(${c.hue}, 100%, 60%, ${alpha})`);
          p.rect(0, 0, c.size + 1, c.size * 2, 2);
          p.pop();
          if (c.life > c.ttl) confetti.splice(i, 1);
        }
      };
    });
  })();
  </script>

  <!-- Main game script -->
  <script>
    // Assets
    const monsterImages = [
      "../../images/kpop/monster1.png",
      "../../images/kpop/monster2.png"
    ];
    const heroImages = [
      "../../images/kpop/mira.png",
      "../../images/kpop/zoey.png",
      "../../images/kpop/rumi.png"
    ];

    const TIMING = {
      slideIn: 700,
      pauseBeforeAttack: 1000,
      hitToBanishDelay: 430,
      banishAnim: 360,
      slideOut: 700
    };

    const state = {
      started: false,
      attackInProgress: false,
      monsters: [],
      spawnDelaySeconds: 10,
      spawnTimeout: null,
      music: null,
      sfxMuted: false,
      sfxVolume: 100,
      heroEl: null,
      heroTimer: null
    };
    window.kpopState = state;

    function preloadSprites() {
      [...monsterImages, ...heroImages].forEach(src => { const im = new Image(); im.src = src; });
    }

    // Spawn position: RIGHT half only (avoid hero on left)
    function getRightSidePosition(container, size = 160) {
      const padding = 40;
      const bounds = container.getBoundingClientRect();
      const half = Math.floor(bounds.width * 0.55);
      const minX = Math.min(bounds.width - size - padding, Math.max(half, padding));
      const maxX = Math.max(minX, bounds.width - size - padding);
      const x = Math.floor(Math.random() * (maxX - minX + 1) + minX);

      const minY = padding;
      const maxY = Math.max(minY, bounds.height - size - padding);
      const y = Math.floor(Math.random() * (maxY - minY + 1) + minY);
      return { x, y };
    }

    function updateMusicVolume() {
      if (!state.music) return;
      if (state.sfxMuted) { state.music.volume = 0; return; }
      const base = (state.sfxVolume || 0) / 100;
      const penalty = Math.max(0, 1 - state.monsters.length * 0.1);
      state.music.volume = Math.max(0, Math.min(1, base * penalty));
    }

    function spawnMonster() {
      const field = document.getElementById('monsterField');
      if (!field) return;

      const monster = document.createElement('div');
      monster.className = 'monster';
      const sprite = monsterImages[Math.floor(Math.random() * monsterImages.length)];
      monster.style.backgroundImage = `url('${sprite}')`;

      const baseSize = Math.floor(130 + Math.random() * 70);
      monster.style.width = `${baseSize}px`;
      monster.style.height = `${baseSize}px`;

      const { x, y } = getRightSidePosition(field, baseSize);
      monster.style.left = `${x}px`;
      monster.style.top = `${y}px`;

      field.appendChild(monster);
      state.monsters.push(monster);
      updateMusicVolume();
    }

    function clearMonsters() {
      state.monsters.forEach(m => m.remove());
      state.monsters.length = 0;
      updateMusicVolume();
    }

    // Slash effect at monster
    function createSlashAtMonster(monster) {
      const field = document.getElementById('monsterField');
      if (!field || !monster) return;

      const mRect = monster.getBoundingClientRect();
      const fRect = field.getBoundingClientRect();

      const slash = document.createElement('div');
      slash.className = 'slash';

      const angle = -10 + Math.random() * 20;
      const left = mRect.left - fRect.left + mRect.width * 0.15;
      const top  = mRect.top  - fRect.top  + mRect.height * 0.45;

      const hitX = mRect.left - fRect.left + mRect.width * 0.5;
      const hitY = mRect.top  - fRect.top  + mRect.height * 0.5;

      slash.style.left = `${left}px`;
      slash.style.top = `${top}px`;
      slash.style.transform = `rotate(${angle}deg)`;

      window.dispatchEvent(new CustomEvent('kpop-confetti', { detail: { x: hitX, y: hitY } }));

      field.appendChild(slash);
      slash.addEventListener('animationend', () => slash.remove(), { once: true });
    }

    function animateHitThenBanishAsync() {
      return new Promise(resolve => {
        if (!state.started || state.monsters.length === 0) return resolve();

        const m = state.monsters[0];
        m.classList.remove('banish', 'hit');
        void m.offsetWidth;

        createSlashAtMonster(m);
        m.classList.add('hit');

        setTimeout(() => {
          const removed = state.monsters.shift();
          if (!removed) return resolve();

          removed.classList.remove('hit');
          removed.classList.add('banish');
          updateMusicVolume();

          removed.addEventListener('animationend', () => {
            removed.remove();
            resolve();
          }, { once: true });
        }, TIMING.hitToBanishDelay);
      });
    }

    function scheduleNextSpawn() {
      clearTimeout(state.spawnTimeout);
      state.spawnTimeout = setTimeout(() => {
        spawnMonster();
        scheduleNextSpawn();
      }, state.spawnDelaySeconds * 1000);
    }

    function showHero() {
      const sprite = heroImages[Math.floor(Math.random() * heroImages.length)];
      const stage = document.getElementById('gameStage');

      let el = state.heroEl;
      if (!el) {
        el = document.createElement('div');
        el.className = 'hero';
        stage.appendChild(el);
        state.heroEl = el;
      }

      el.classList.remove('hide');
      el.style.backgroundImage = `url('${sprite}')`;
      void el.offsetWidth;
      el.classList.add('show');
      return el;
    }

    function hideHero() {
      return new Promise(resolve => {
        const el = state.heroEl;
        if (!el) return resolve();
        el.classList.remove('show');
        el.classList.add('hide');

        const onDone = () => {
          if (el && el.parentNode) el.parentNode.removeChild(el);
          state.heroEl = null;
          resolve();
        };

        el.addEventListener('transitionend', onDone, { once: true });
        setTimeout(onDone, TIMING.slideOut + 80);
      });
    }

    const wait = (ms) => new Promise(r => setTimeout(r, ms));

    async function runAttackSequence() {
      if (!state.started || state.attackInProgress) return;
      state.attackInProgress = true;

      showHero();
      await wait(TIMING.slideIn + 50);
      await wait(TIMING.pauseBeforeAttack);

      await animateHitThenBanishAsync();

      await hideHero();
      state.attackInProgress = false;
    }

    function handleKeyDown(event) {
      if (event.code === 'Space') {
        event.preventDefault();
        runAttackSequence();
      }
    }

    function startGame() {
      if (state.started) return;
      state.started = true;

      document.getElementById('landingMenu')?.classList.add('hidden');
      const stage = document.getElementById('gameStage');
      stage?.classList.add('active');
      stage?.requestFullscreen?.();

      state.music = new Audio("../../songs/kpop/golden.mp3");
      state.music.loop = true;
      state.music.addEventListener('canplaythrough', updateMusicVolume, { once: true });
      state.music.play().catch(() => updateMusicVolume());
      updateMusicVolume();

      spawnMonster();
      scheduleNextSpawn();

      window.addEventListener('keydown', handleKeyDown);
    }

    function stopGame() {
      clearTimeout(state.spawnTimeout);
      window.removeEventListener('keydown', handleKeyDown);

      if (state.music) {
        state.music.pause();
        state.music.currentTime = 0;
      }
      clearMonsters();

      if (state.heroTimer) clearTimeout(state.heroTimer);
      if (state.heroEl && state.heroEl.parentNode) state.heroEl.parentNode.removeChild(state.heroEl);
      state.heroEl = null;

      state.started = false;
      document.getElementById('gameStage')?.classList.remove('active');
      document.getElementById('landingMenu')?.classList.remove('hidden');
      state.attackInProgress = false;
    }

    (function initMenu() {
      const spawnSlider = document.getElementById('spawnDelay');
      const spawnLabel = document.getElementById('spawnDelayVal');
      const startButton = document.getElementById('startButton');
      const muteBtn = document.getElementById('muteSFX');

      if (spawnSlider && spawnLabel) {
        const syncSpawn = v => { state.spawnDelaySeconds = v; spawnLabel.textContent = String(v); };
        syncSpawn(Number(spawnSlider.value || 10));
        spawnSlider.addEventListener('input', e => {
          syncSpawn(Number(e.target.value));
          if (state.started) scheduleNextSpawn();
        });
      }

      if (muteBtn) {
        muteBtn.addEventListener('click', () => {
          state.sfxMuted = !state.sfxMuted;
          muteBtn.setAttribute('aria-pressed', state.sfxMuted ? 'true' : 'false');
          muteBtn.textContent = state.sfxMuted ? 'Sound: Off' : 'Sound: On';
          updateMusicVolume();
        });
      }

      if (startButton) startButton.addEventListener('click', startGame);
    })();

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        state.music?.pause();
      } else if (state.music && state.started && !state.sfxMuted) {
        state.music.play().catch(() => {});
      }
    });

    window.addEventListener('beforeunload', () => { clearTimeout(state.spawnTimeout); });

    preloadSprites();
  </script>

    <script src="../../js/home-button.js" defer></script>
</body>
</html>
