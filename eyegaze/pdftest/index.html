<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title class="translate" data-fr="PDF — Lecteur oculométrique" data-en="PDF — Eye Gaze Reader">PDF — Lecteur oculométrique</title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <!-- pdf.js (stable UMD v3) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    window.pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    window.__PDFJS__ = window.pdfjsLib;
  </script>

  <!-- tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    :root { --teal:#009688; --bg:#000; --fg:#fff; }
    html, body {
      margin:0;
      padding:0;
      background:var(--bg);
      color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      height:100%;
      overflow:hidden;
    }

    body {
      display:block;
    }

    #langToggle {
      position:fixed;
      top:10px;
      right:10px;
      z-index:1100;
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:10px;
      border:2px solid var(--teal);
      background:#fff;
      color:var(--teal);
      font-weight:700;
      cursor:pointer;
      user-select:none;
    }

    body.playing #langToggle { display:none !important; }

    #stage {
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      background:#000;
      cursor:pointer;
      z-index:1;
    }
    body.playing #stage { display:grid; }

    canvas { display:block; max-width:100vw; max-height:100vh; }

    #hud {
      position:fixed;
      left:12px;
      bottom:12px;
      padding:6px 10px;
      background:rgba(0,0,0,.5);
      border:1px solid rgba(255,255,255,.2);
      border-radius:10px;
      font-size:14px;
      user-select:none;
      z-index:5;
    }

    #ocrHud {
      position:fixed;
      right:12px;
      bottom:12px;
      z-index:6;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.2);
      border-radius:10px;
      padding:8px 10px;
      font-size:13px;
      min-width:220px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    #ocrHud .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    #ocrHud select, #ocrHud label { font-size:13px; }
    #ocrProg { height:6px; background:#111; border-radius:999px; overflow:hidden; }
    #ocrProg > div { height:100%; width:0%; background:linear-gradient(90deg,#60a5fa,#34d399); }
    #ocrStatus { opacity:.85; }
    #ocrHud label.disabled { opacity:0.55; }

    #textOut {
      display:none;
      width:min(520px, 90vw);
      max-height:30vh;
      overflow:auto;
      background:#0b0b0b;
      color:#ddd;
      border:1px solid #333;
      border-radius:10px;
      padding:8px;
      margin:0;
      position:fixed;
      right:12px;
      bottom:82px;
      z-index:6;
      white-space:pre-wrap;
    }

    body:not(.playing) #hud,
    body:not(.playing) #ocrHud,
    body:not(.playing) #textOut {
      display:none !important;
    }

    body.playing #ocrHud { display:none !important; }

    body.playing #game-options { display:none !important; }

    /* ===== Menu enhancements ===== */
    .select-block {
      width:100%;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    select {
      border:2px solid var(--teal);
      border-radius:12px;
      padding:10px 12px;
      font-size:16px;
      font-weight:600;
      color:#004d40;
      background:#fff;
      width:100%;
      box-sizing:border-box;
      appearance:none;
    }

    .select-wrapper {
      position:relative;
      width:100%;
    }

    .select-wrapper::after {
      content:'';
      position:absolute;
      right:14px;
      top:50%;
      width:0;
      height:0;
      border-left:6px solid transparent;
      border-right:6px solid transparent;
      border-top:8px solid var(--teal);
      transform:translateY(-50%);
      pointer-events:none;
    }

    .button[disabled] {
      opacity:0.5;
      cursor:not-allowed;
      box-shadow:none;
    }

    .file-status {
      margin-top:10px;
      font-size:16px;
      font-weight:600;
      color:#004d40;
      text-align:center;
    }

    .library-container {
      width:100%;
      box-sizing:border-box;
      border:2px dashed var(--teal);
      border-radius:12px;
      padding:12px;
      background:rgba(0,150,136,0.08);
      color:#004d40;
      display:flex;
      flex-direction:column;
      gap:10px;
      max-width:100%;
    }

    .library-header {
      font-weight:700;
      font-size:16px;
      text-align:center;
    }

    .library-list {
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:200px;
      overflow-y:auto;
      padding-right:4px;
    }

    .library-item {
      border:2px solid rgba(0,150,136,0.3);
      background:#fff;
      border-radius:10px;
      padding:8px 10px;
      font-weight:600;
      color:#00695c;
      cursor:pointer;
      transition:transform 0.15s ease, box-shadow 0.15s ease;
      text-align:left;
      word-break:break-word;
    }

    .library-item:hover,
    .library-item:focus-visible {
      outline:none;
      transform:translateY(-1px);
      box-shadow:0 6px 16px rgba(0,0,0,0.18);
    }

    .library-item[aria-pressed="true"] {
      border-color:var(--teal);
      background:rgba(0,150,136,0.15);
      color:#004d40;
    }

    .mode-option {
      display:grid;
      grid-template-columns:20px 1fr;
      align-items:flex-start;
      column-gap:10px;
      row-gap:6px;
      margin-bottom:10px;
      font-weight:600;
      color:#004d40;
    }
    .mode-option input[type="radio"] {
      margin:3px 0 0;
      accent-color:var(--teal);
      transform:scale(1.1);
    }
    .mode-option span { font-size:16px; }

    .instructions {
      font-size:16px;
      color:#004d40;
      text-align:left;
    }

    .tip-text {
      font-size:16px;
      color:#004d40;
      margin:0;
      line-height:1.3;
    }

    .menu-hint {
      margin-top:12px;
      color:#00695c;
      font-weight:600;
    }

    #options-inline-container > .options-column { align-items:flex-start; }
    #options-inline-container > .options-column:nth-child(2) { align-items:center; }
    #options-inline-container > .options-column:nth-child(2) .option-item { align-items:center; text-align:center; }
    #options-inline-container > .options-column:nth-child(2) .teal-label { justify-content:center; }

    #options-inline-container > .options-column:nth-child(3) { align-items:flex-start; }
  </style>
</head>
<body>
  <button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title" class="translate" data-fr="PDF — Lecteur oculométrique" data-en="PDF — Eye Gaze Reader">PDF — Lecteur oculométrique</h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <!-- LEFT COLUMN -->
        <div class="options-column">
          <div class="option-item">
            <p class="teal-label label-block translate" data-fr="Voix de lecture" data-en="Reading voice">Voix de lecture</p>
            <div class="select-block">
              <div class="select-wrapper">
                <select id="ttsLang">
                  <option value="auto" class="translate" data-fr="Automatique (interface)" data-en="Automatic (interface)">Automatique (interface)</option>
                  <option value="fr-CA">Français (Canada)</option>
                  <option value="fr-FR">Français (France)</option>
                  <option value="en-US">English (United States)</option>
                  <option value="en-GB">English (United Kingdom)</option>
                  <option value="es-ES">Español (España)</option>
                  <option value="de-DE">Deutsch (Deutschland)</option>
                </select>
              </div>
              <p class="tip-text translate" data-fr="Par défaut, la langue suit celle de l’interface. Changez-la ici pour la remplacer." data-en="By default the voice follows the interface language. Change it here to override.">Par défaut, la langue suit celle de l’interface. Changez-la ici pour la remplacer.</p>
            </div>
          </div>
          <div class="option-item instructions translate" data-fr="Utilisez la colonne centrale pour choisir le fichier PDF et la colonne de droite pour définir le mode de lecture." data-en="Use the middle column to choose the PDF file and the right column to set the reading mode.">Utilisez la colonne centrale pour choisir le fichier PDF et la colonne de droite pour définir le mode de lecture.</div>
        </div>

        <!-- MIDDLE COLUMN -->
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label label-block translate" data-fr="Choisir un PDF" data-en="Choose a PDF">Choisir un PDF</label>
            <button id="chooseBtn" type="button" class="button translate" data-fr="Depuis l’ordinateur…" data-en="From computer…">Depuis l’ordinateur…</button>
            <input id="fileInput" type="file" accept="application/pdf" hidden />
            <p id="fileStatus" class="file-status translate" data-fr="Aucun fichier sélectionné" data-en="No file selected">Aucun fichier sélectionné</p>
          </div>
          <div class="option-item">
            <label class="teal-label label-block translate" data-fr="Bibliothèque PDF" data-en="PDF library">Bibliothèque PDF</label>
            <div id="libraryContainer" class="library-container">
              <div id="libraryHeader" class="library-header">Chargement…</div>
              <div id="libraryList" class="library-list" role="list"></div>
            </div>
          </div>
        </div>

        <!-- RIGHT COLUMN -->
        <div class="options-column">
          <div class="option-item">
            <p class="teal-label label-block translate" data-fr="Options de lecture" data-en="Reading options">Options de lecture</p>
            <label class="teal-label mode-option">
              <input type="radio" name="advanceMode" value="direct" checked />
              <span class="translate" data-fr="Lecture automatique : espace ou clic avance immédiatement." data-en="Auto reading: space or click advances right away.">Lecture automatique : espace ou clic avance immédiatement.</span>
            </label>
            <label class="teal-label mode-option">
              <input type="radio" name="advanceMode" value="tts-confirm" />
              <span class="translate" data-fr="Lecture guidée : premier appui lit la page, deuxième appui passe à la suivante." data-en="Guided reading: first press speaks the page, second press goes to the next.">Lecture guidée : premier appui lit la page, deuxième appui passe à la suivante.</span>
            </label>
          </div>
          <div class="option-item">
            <p class="teal-label label-block translate" data-fr="Astuce" data-en="Tip">Astuce</p>
            <p class="tip-text translate" data-fr="Vous pouvez aussi déposer un PDF directement dans la fenêtre." data-en="You can also drop a PDF directly into the window.">Vous pouvez aussi déposer un PDF directement dans la fenêtre.</p>
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" disabled>Commencer</button>
      <p id="menuHint" class="menu-hint translate" data-fr="Le plein écran démarre après avoir choisi un PDF." data-en="Full screen starts after choosing a PDF.">Le plein écran démarre après avoir choisi un PDF.</p>
    </div>
  </div>

  <div id="stage" aria-label="Zone d’affichage PDF">
    <canvas id="pageCanvas" aria-hidden="true"></canvas>
  </div>

  <div id="hud"><span id="pageLabel">—</span></div>

  <pre id="textOut"></pre>
  <div id="ocrHud">
    <div class="row">
      <label for="ocrLang">OCR:</label>
      <select id="ocrLang">
        <option value="eng" selected>English (eng)</option>
        <option value="fra">Français (fra)</option>
        <option value="eng+fra">English + Français</option>
        <option value="spa">Español (spa)</option>
        <option value="deu">Deutsch (deu)</option>
      </select>
      <label class="teal-label auto-read-label">
        <input type="checkbox" id="autoRead" checked />
        <span class="translate" data-fr="Lecture auto" data-en="Auto-read">Lecture auto</span>
      </label>
    </div>
    <div id="ocrProg" aria-hidden="true"><div id="ocrBar"></div></div>
    <div id="ocrStatus">—</div>
  </div>

  <script src="../../js/eyegaze-menu.js"></script>
  <script>
    if (typeof initEyegazeMenu === 'function') {
      initEyegazeMenu();
    }

    const LS_LANG_KEY = 'siteLanguage';
    const LS_TTS_KEY = 'pdfTtsVoice';
    const langToggle = document.getElementById('langToggle');
    const ttsSelect = document.getElementById('ttsLang');

    const chooseBtn = document.getElementById('chooseBtn');
    const fileInput = document.getElementById('fileInput');
    const fileStatus = document.getElementById('fileStatus');
    const libraryHeader = document.getElementById('libraryHeader');
    const libraryList = document.getElementById('libraryList');
    const startButton = document.getElementById('startButton');
    const stage = document.getElementById('stage');
    const canvas = document.getElementById('pageCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const hudLabel = document.getElementById('pageLabel');
    const ocrLangSel = document.getElementById('ocrLang');
    const autoRead = document.getElementById('autoRead');
    const ocrBar = document.getElementById('ocrBar');
    const ocrStatus = document.getElementById('ocrStatus');
    const textOut = document.getElementById('textOut');
    const advanceRadios = Array.from(document.querySelectorAll('input[name="advanceMode"]'));

    const CONFIRM_STATES = { LOADING:'loading', NEED_READ:'need-read', READY:'ready' };
    const DEFAULT_TTS_BY_LANG = { fr: 'fr-CA', en: 'en-US' };
    const LIBRARY_HEADER_TEXT = {
      loading: { fr:'Chargement…', en:'Loading…' },
      ready: { fr:'Choisissez un PDF', en:'Choose a PDF' },
      empty: { fr:'Aucun PDF trouvé', en:'No PDFs found' },
      error: { fr:'Impossible de charger les PDF', en:'Unable to load PDFs' }
    };

    let pdfDoc = null, currentPageNum = 1, totalPages = 0, started = false, loading = false, pdfData = null;
    let speakingAllowed = false;
    let currentRenderToken = 0;
    let advanceMode = 'direct';
    let confirmState = CONFIRM_STATES.READY;
    let currentLang = 'fr';
    let lastFileName = '';
    let fileStatusOverride = null;
    let libraryHeaderState = 'loading';
    let libraryEntries = [];
    let currentLibraryButton = null;

    function applyTranslationsForLang(lang) {
      document.querySelectorAll('.translate').forEach(el => {
        const text = el.dataset?.[lang];
        if (text != null) {
          el.innerHTML = text;
        }
      });
      updateFileStatusText();
      refreshLibraryHeader();
    }

    function refreshLibraryHeader() {
      if (!libraryHeader) return;
      const pack = LIBRARY_HEADER_TEXT[libraryHeaderState] || LIBRARY_HEADER_TEXT.loading;
      libraryHeader.textContent = pack[currentLang] || pack.fr || '';
    }

    function setLibraryHeaderState(state) {
      libraryHeaderState = state;
      refreshLibraryHeader();
    }

    function updateFileStatusText() {
      if (fileStatusOverride) {
        if (fileStatusOverride.type === 'loading') {
          fileStatus.textContent = (currentLang === 'fr') ? 'Chargement du PDF…' : 'Loading PDF…';
          return;
        }
        if (fileStatusOverride.type === 'error') {
          const fr = fileStatusOverride.fr || fileStatusOverride.en;
          const en = fileStatusOverride.en || fileStatusOverride.fr;
          fileStatus.textContent = (currentLang === 'fr') ? (fr || en || '') : (en || fr || '');
          return;
        }
        if (fileStatusOverride.html) {
          fileStatus.innerHTML = fileStatusOverride.html;
          return;
        }
        if (fileStatusOverride.text) {
          fileStatus.textContent = fileStatusOverride.text;
          return;
        }
      }

      if (lastFileName) {
        const label = (currentLang === 'fr') ? 'Fichier sélectionné : ' : 'Selected file: ';
        fileStatus.innerHTML = `${label}<strong>${escapeHtml(lastFileName)}</strong>`;
      } else {
        const fallback = fileStatus.dataset?.[currentLang];
        if (fallback != null) fileStatus.textContent = fallback;
      }
    }

    function setFileStatusOverride(override) {
      fileStatusOverride = override;
      updateFileStatusText();
    }

    function getEffectiveTtsLang() {
      if (!ttsSelect) {
        return DEFAULT_TTS_BY_LANG[currentLang] || DEFAULT_TTS_BY_LANG.en;
      }
      const value = ttsSelect.value || 'auto';
      if (value === 'auto') {
        return DEFAULT_TTS_BY_LANG[currentLang] || DEFAULT_TTS_BY_LANG.en;
      }
      return value;
    }

    function applyVoicePreference(utterance) {
      const langCode = getEffectiveTtsLang();
      if (!langCode || !utterance) return;
      utterance.lang = langCode;
      if (!('speechSynthesis' in window)) return;
      const voices = window.speechSynthesis.getVoices?.() || [];
      const match = voices.find(v => v.lang && v.lang.toLowerCase().startsWith(langCode.toLowerCase()));
      if (match) {
        utterance.voice = match;
      }
    }

    function saveTtsPreference(value) {
      try { localStorage.setItem(LS_TTS_KEY, value); } catch(e) {}
    }

    function syncTtsWithInterface() {
      if (!ttsSelect) return;
      if (!ttsSelect.value) {
        ttsSelect.value = 'auto';
      }
      if (ttsSelect.value === 'auto') {
        saveTtsPreference('auto');
      }
    }

    function initializeTtsSelection() {
      if (!ttsSelect) return;
      let initial = 'auto';
      try {
        const saved = localStorage.getItem(LS_TTS_KEY);
        if (saved && (saved === 'auto' || Array.from(ttsSelect.options).some(opt => opt.value === saved))) {
          initial = saved;
        }
      } catch(e) {}
      ttsSelect.value = initial;
      if (!ttsSelect.value) {
        ttsSelect.value = 'auto';
      }
      ttsSelect.addEventListener('change', () => {
        const val = ttsSelect.value || 'auto';
        saveTtsPreference(val);
      });
    }

    function getLang() {
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr') return saved;
      } catch(e) {}
      return (document.documentElement.lang === 'en') ? 'en' : 'fr';
    }

    function setLang(lang) {
      const safe = (lang === 'en') ? 'en' : 'fr';
      currentLang = safe;
      document.documentElement.lang = safe;
      try { localStorage.setItem(LS_LANG_KEY, safe); } catch(e) {}
      applyTranslationsForLang(safe);
      syncTtsWithInterface();
    }

    (function initializeLanguage(){
      let initial = 'fr';
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr') {
          initial = saved;
        } else {
          initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
          localStorage.setItem(LS_LANG_KEY, initial);
        }
      } catch(e) {
        initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
      }
      setLang(initial);
    })();

    initializeTtsSelection();

    langToggle.addEventListener('click', () => {
      setLang(getLang() === 'fr' ? 'en' : 'fr');
    });

    const PDF_LIBRARY_BASE = '../../pdf/';

    function decodeFileName(name) {
      if (!name) return '';
      let clean = name.split('?')[0].split('#')[0];
      clean = clean.replace(/\/+/g, '/');
      clean = clean.substring(clean.lastIndexOf('/') + 1);
      try { clean = decodeURIComponent(clean); } catch(e) {}
      return clean || 'PDF';
    }

    function normaliseLibraryEntry(entry) {
      if (!entry) return null;
      if (typeof entry === 'string') {
        let url;
        try { url = new URL(entry, PDF_LIBRARY_BASE).href; }
        catch(e) { return null; }
        if (!/\.pdf(?:$|[?#])/i.test(url)) return null;
        return { url, name: decodeFileName(entry) };
      }
      if (typeof entry === 'object') {
        const ref = entry.url || entry.href || entry.path || entry.file;
        if (!ref) return null;
        let url;
        try { url = new URL(ref, PDF_LIBRARY_BASE).href; }
        catch(e) { return null; }
        if (!/\.pdf(?:$|[?#])/i.test(url)) return null;
        const name = entry.name || entry.title || decodeFileName(ref);
        return { url, name };
      }
      return null;
    }

    async function fetchLibraryEntries() {
      const entries = [];
      try {
        const jsonRes = await fetch(PDF_LIBRARY_BASE + 'list.json', { cache: 'no-store' });
        if (jsonRes.ok) {
          const data = await jsonRes.json();
          if (Array.isArray(data)) {
            data.map(normaliseLibraryEntry).forEach(item => { if (item) entries.push(item); });
          }
        }
      } catch(e) {
        console.info('No list.json for PDFs, falling back to directory scan.');
      }

      if (entries.length) {
        return dedupeEntries(entries);
      }

      try {
        const res = await fetch(PDF_LIBRARY_BASE, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Directory request failed: ${res.status}`);
        const text = await res.text();
        const doc = new DOMParser().parseFromString(text, 'text/html');
        doc.querySelectorAll('a[href]').forEach(a => {
          const href = a.getAttribute('href');
          if (!href || !/\.pdf(?:$|[?#])/i.test(href)) return;
          try {
            const url = new URL(href, res.url).href;
            entries.push({ url, name: decodeFileName(url) });
          } catch(err) {
            console.warn('Skipping invalid PDF entry', href, err);
          }
        });
      } catch(err) {
        console.error('PDF library load error:', err);
      }

      return dedupeEntries(entries);
    }

    function dedupeEntries(entries) {
      const seen = new Set();
      return entries.filter(item => {
        if (!item || !item.url) return false;
        const key = item.url;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    function clearLibrarySelection() {
      if (currentLibraryButton) {
        currentLibraryButton.setAttribute('aria-pressed', 'false');
      }
      currentLibraryButton = null;
    }

    function setCurrentLibraryButton(button) {
      if (currentLibraryButton && currentLibraryButton !== button) {
        currentLibraryButton.setAttribute('aria-pressed', 'false');
      }
      currentLibraryButton = button;
      if (currentLibraryButton) {
        currentLibraryButton.setAttribute('aria-pressed', 'true');
      }
    }

    function showLibraryMessage(fr, en) {
      if (!libraryList) return;
      libraryList.innerHTML = '';
      const msg = document.createElement('div');
      msg.className = 'tip-text translate';
      msg.dataset.fr = fr;
      msg.dataset.en = en;
      msg.textContent = (currentLang === 'fr') ? fr : en;
      libraryList.appendChild(msg);
    }

    function buildLibraryList(entries) {
      if (!libraryList) return;
      libraryList.innerHTML = '';
      clearLibrarySelection();
      if (!entries.length) {
        setLibraryHeaderState('empty');
        showLibraryMessage(
          'Aucun PDF disponible pour le moment.',
          'No PDFs available yet.'
        );
        return;
      }
      setLibraryHeaderState('ready');
      entries.forEach(entry => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'library-item';
        button.setAttribute('role', 'listitem');
        button.setAttribute('aria-pressed', 'false');
        button.textContent = entry.name;
        button.addEventListener('click', async () => {
          setCurrentLibraryButton(button);
          await loadPdfFromUrl(entry.url, entry.name);
        });
        libraryList.appendChild(button);
      });
    }

    async function populateLibraryList() {
      if (!libraryList || !libraryHeader) return;
      setLibraryHeaderState('loading');
      libraryList.innerHTML = '';
      clearLibrarySelection();
      try {
        libraryEntries = await fetchLibraryEntries();
        buildLibraryList(libraryEntries);
      } catch(err) {
        console.error('Unable to populate PDF library:', err);
        libraryEntries = [];
        setLibraryHeaderState('error');
        clearLibrarySelection();
        showLibraryMessage(
          'Impossible de charger la bibliothèque PDF.',
          'Unable to load the PDF library.'
        );
      }
    }

    async function loadPdfFromUrl(url, displayName) {
      if (!url) return;
      setFileStatusOverride({ type: 'loading' });
      try {
        const response = await fetch(url, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const buffer = await response.arrayBuffer();
        pdfData = new Uint8Array(buffer);
        lastFileName = displayName || decodeFileName(url);
        setFileStatusOverride(null);
        updateFileStatusText();
        updateStartButtonState();
        if (!document.body.classList.contains('playing')) {
          try { startButton.focus({ preventScroll:true }); }
          catch(_) { startButton.focus(); }
        }
      } catch(err) {
        console.error('Remote PDF load error:', err);
        setFileStatusOverride({ type: 'error', fr: 'Erreur de chargement du PDF', en: 'Failed to load PDF' });
      }
    }

    function escapeHtml(str) {
      const map = {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"};
      return str.replace(/[&<>"']/g, ch => map[ch]);
    }

    function setHUD() {
      hudLabel.textContent = (pdfDoc && started) ? `${currentPageNum} / ${totalPages}` : '—';
    }

    async function goFullscreen() {
      if (!document.fullscreenElement) {
        try { await document.documentElement.requestFullscreen(); } catch(_) {}
      }
    }

    function enterPlayingUI() {
      document.body.classList.add('playing');
    }

    function exitPlayingUI() {
      document.body.classList.remove('playing');
      started = false;
      speakingAllowed = false;
      stopSpeak();
      document.body.style.cursor = 'default';
      setHUD();
      updateStartButtonState();
    }

    function setOcrProgress(p) {
      ocrBar.style.width = Math.max(0, Math.min(100, Math.round(p * 100))) + '%';
    }

    function updateStartButtonState() {
      startButton.disabled = !pdfData;
    }

    function syncAutoReadWithMode() {
      if (advanceMode === 'tts-confirm') {
        autoRead.checked = false;
        autoRead.disabled = true;
        autoRead.parentElement.classList.add('disabled');
      } else {
        autoRead.disabled = false;
        if (!autoRead.checked) autoRead.checked = true;
        autoRead.parentElement.classList.remove('disabled');
      }
    }

    advanceRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        if (!radio.checked) return;
        advanceMode = (radio.value === 'tts-confirm') ? 'tts-confirm' : 'direct';
        syncAutoReadWithMode();
        const hasText = textOut.textContent.trim().length > 0;
        prepareConfirmForCurrentPage(hasText);
      });
    });

    function prepareConfirmForCurrentPage(hasText) {
      if (advanceMode === 'tts-confirm') {
        confirmState = hasText ? CONFIRM_STATES.NEED_READ : CONFIRM_STATES.READY;
      } else {
        confirmState = CONFIRM_STATES.READY;
      }
    }

    function speak(text) {
      if (!speakingAllowed || !text || !('speechSynthesis' in window)) return;
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      applyVoicePreference(utterance);
      window.speechSynthesis.speak(utterance);
    }

    function stopSpeak() {
      window.speechSynthesis?.cancel();
    }

    chooseBtn.addEventListener('click', () => fileInput.click());

    ;['dragenter','dragover'].forEach(ev => {
      window.addEventListener(ev, e => { e.preventDefault(); }, { passive:false });
    });

    window.addEventListener('drop', async e => {
      e.preventDefault();
      const file = [...(e.dataTransfer?.files || [])].find(f => f.type === 'application/pdf' || f.name?.toLowerCase().endsWith('.pdf'));
      if (file) {
        await loadPDFFile(file);
      }
    });

    fileInput.addEventListener('change', async e => {
      const file = e.target.files?.[0];
      if (!file) return;
      await loadPDFFile(file);
    });

    async function loadPDFFile(file) {
      if (!file) return;
      clearLibrarySelection();
      setFileStatusOverride({ type: 'loading' });
      try {
        const arrBuf = await file.arrayBuffer();
        pdfData = new Uint8Array(arrBuf);
        lastFileName = file.name || '';
        setFileStatusOverride(null);
        updateFileStatusText();
        updateStartButtonState();
        if (!document.body.classList.contains('playing')) {
          try { startButton.focus({ preventScroll:true }); }
          catch(_) { startButton.focus(); }
        }
      } catch(err) {
        console.error('Local PDF load error:', err);
        setFileStatusOverride({ type: 'error', fr: 'Erreur de chargement du PDF', en: 'Failed to load PDF' });
      }
    }

    startButton.addEventListener('click', async () => {
      if (!pdfData) return;
      await goFullscreen();
      started = true;
      speakingAllowed = true;
      enterPlayingUI();
      scheduleCursorHide();
      await openAndRender();
    });

    window.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        exitPlayingUI();
        if (document.fullscreenElement) {
          try { document.exitFullscreen(); } catch(_) {}
        }
      }
    });

    async function openAndRender() {
      try {
        const pdfjs = window.__PDFJS__ || window.pdfjsLib;
        if (!pdfjs) throw new Error('pdf.js library not available on window.');
        const loadingTask = pdfjs.getDocument({ data: pdfData });
        pdfDoc = await loadingTask.promise;
        totalPages = pdfDoc.numPages;
        currentPageNum = 1;
        textOut.textContent = '';
        await renderPage(currentPageNum);
        setHUD();
      } catch(err) {
        console.error('PDF load error:', err);
        const msg = (currentLang === 'fr' ? 'Erreur de chargement du PDF: ' : 'PDF load error: ')
                    + (err?.message || err?.toString() || '');
        alert(msg);
      }
    }

    function getZoneRectPixels() {
      const W = canvas.width, H = canvas.height;
      const ZONE_W_PCT = 30;
      const ZONE_H_PCT = 40;
      const ZONE_CENTER_X_PCT = 75;
      const ZONE_CENTER_Y_PCT = 50;
      const w = Math.round((ZONE_W_PCT/100) * W);
      const h = Math.round((ZONE_H_PCT/100) * H);
      const cx = Math.round((ZONE_CENTER_X_PCT/100) * W);
      const cy = Math.round((ZONE_CENTER_Y_PCT/100) * H);
      const x = Math.max(0, Math.min(W-1, cx - Math.floor(w/2)));
      const y = Math.max(0, Math.min(H-1, cy - Math.floor(h/2)));
      return { x, y, w: Math.max(1, Math.min(W - x, w)), h: Math.max(1, Math.min(H - y, h)) };
    }

    function cropCanvas(srcCanvas, rect) {
      const c = document.createElement('canvas');
      c.width = rect.w; c.height = rect.h;
      const cx = c.getContext('2d');
      cx.drawImage(srcCanvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
      return c;
    }

    async function renderPage(pageNum) {
      if (!pdfDoc || loading) return;
      loading = true;
      confirmState = CONFIRM_STATES.LOADING;
      const myToken = ++currentRenderToken;

      try {
        const page = await pdfDoc.getPage(pageNum);
        const viewportUnscaled = page.getViewport({ scale: 1 });
        const availW = window.innerWidth;
        const availH = window.innerHeight;
        const scale = Math.min(availW / viewportUnscaled.width, availH / viewportUnscaled.height);
        const viewport = page.getViewport({ scale: scale * (window.devicePixelRatio || 1) });

        canvas.width  = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width  = Math.floor(viewport.width  / (window.devicePixelRatio || 1)) + 'px';
        canvas.style.height = Math.floor(viewport.height / (window.devicePixelRatio || 1)) + 'px';

        await page.render({ canvasContext: ctx, viewport }).promise;

        const rect = getZoneRectPixels();
        const region = cropCanvas(canvas, rect);

        setOcrProgress(0);
        ocrStatus.textContent = (currentLang === 'fr' ? 'OCR…' : 'OCR…');

        const lang = ocrLangSel.value || 'eng';
        const { data: { text } } = await Tesseract.recognize(
          region,
          lang,
          { logger: m => { if (m && typeof m.progress === 'number') { setOcrProgress(m.progress); } } }
        );

        if (myToken !== currentRenderToken) return;

        const cleaned = reflowOcrText(text || '');
        textOut.textContent = cleaned;
        setOcrProgress(1);

        const trimmed = cleaned.trim();
        if (autoRead.checked && trimmed) {
          stopSpeak();
          speak(trimmed);
        } else {
          stopSpeak();
        }

        prepareConfirmForCurrentPage(trimmed.length > 0);
      } catch(err) {
        console.error('Render/OCR error:', err);
      } finally {
        loading = false;
      }
    }

    function reflowOcrText(raw) {
      if (!raw) return '';
      let s = raw;
      s = s.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
      s = s.replace(/\u00AD/g, '');
      s = s.replace(/\r\n/g, '\n');
      s = s.replace(/([A-Za-zÀ-ÖØ-öø-ÿ])-\s*\n\s*([A-Za-zÀ-ÖØ-öø-ÿ])/g, '$1$2');
      s = s.replace(/\n{2,}/g, '¶¶');
      s = s.replace(/([^\n])\n(?!\n)/g, (m, prev) => {
        return /[.!?;:)"'»\]]\s*$/.test(prev) ? prev + '\n' : prev + ' ';
      });
      s = s.replace(/¶¶/g, '\n\n');
      s = s.replace(/[ \t]+/g, ' ').replace(/ +\n/g, '\n').trim();
      return s;
    }

    async function goToNextPage() {
      if (!pdfDoc) return;
      currentPageNum = (currentPageNum % totalPages) + 1;
      await renderPage(currentPageNum);
      setHUD();
    }

    async function goToPreviousPage() {
      if (!pdfDoc) return;
      currentPageNum = (currentPageNum - 2 + totalPages) % totalPages + 1;
      await renderPage(currentPageNum);
      setHUD();
    }

    async function handleAdvanceRequest(direction = 1) {
      if (!started || !pdfDoc || loading) return;
      if (direction < 0) {
        stopSpeak();
        await goToPreviousPage();
        return;
      }

      if (advanceMode === 'tts-confirm') {
        if (confirmState === CONFIRM_STATES.NEED_READ) {
          const text = textOut.textContent.trim();
          if (text) {
            confirmState = CONFIRM_STATES.READY;
            stopSpeak();
            speak(text);
            return;
          }
          confirmState = CONFIRM_STATES.READY;
        }
      }

      stopSpeak();
      await goToNextPage();
    }

    stage.addEventListener('click', async () => {
      await handleAdvanceRequest(1);
    });

    window.addEventListener('keydown', async e => {
      if (!started || !pdfDoc || loading) return;
      if (e.code === 'Space' && e.shiftKey) {
        e.preventDefault();
        await handleAdvanceRequest(-1);
      } else if (e.code === 'Space' || e.code === 'ArrowRight') {
        e.preventDefault();
        await handleAdvanceRequest(1);
      } else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        await handleAdvanceRequest(-1);
      }
    });

    window.addEventListener('resize', () => {
      if (!started || !pdfDoc) return;
      clearTimeout(window.__resizeT);
      window.__resizeT = setTimeout(() => renderPage(currentPageNum), 100);
    });

    let hideTimer = null;
    function scheduleCursorHide() {
      document.body.style.cursor = 'default';
      clearTimeout(hideTimer);
      if (!document.body.classList.contains('playing')) return;
      hideTimer = setTimeout(() => {
        if (document.body.classList.contains('playing')) {
          document.body.style.cursor = 'none';
        }
      }, 1500);
    }
    ['mousemove','mousedown','touchstart','keydown'].forEach(ev => {
      window.addEventListener(ev, scheduleCursorHide, { passive:true });
    });
    scheduleCursorHide();

    ocrLangSel.addEventListener('change', () => {
      if (!started || !pdfDoc) return;
      renderPage(currentPageNum);
    });

    populateLibraryList();
    syncAutoReadWithMode();
    updateStartButtonState();
    setHUD();
  </script>
</body>
</html>
