<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Samurai Focus — One Orb → Moon (Respawn)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #game { display:block; width:100vw; height:100vh; cursor: crosshair; background:#000; }
    #startOverlay { position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(0,0,0,0.75); z-index:10; }
    #startBtn { padding:14px 22px; border:2px solid #6ad1c9; color:#6ad1c9; background:#000;
      border-radius:12px; font-size:18px; font-weight:700; box-shadow:0 6px 24px rgba(0,0,0,.25); cursor:pointer; }
    #startBtn:active{ transform:translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay"><button id="startBtn">Start • Fullscreen</button></div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       PLACEHOLDER ASSETS (reuse your files)
    ======================= */
    const BG_SRC     = "../../images/samurai/lampbg.png";
    const PETAL_SRC  = "../../images/samurai/cherryblossom.png";
    const SFX_RELEASE= "../../sounds/blade.mp3";
    const SFX_IMPACT = "../../sounds/gong.mp3";

    /* =======================
       TUNABLES
    ======================= */
    // Dwell → ball size: 100 → 200 px over 2s
    const MIN_DIAMETER = 100;
    const MAX_DIAMETER = 200;
    const DWELL_MS     = 2000;
    const MAX_JITTER_PX= 26;
    const DECAY_PER_SEC= 0.5;
    const ENTRY_GRACE_MS = 200;

    // Spawn area (bottom third)
    const SPAWN_X_MIN_FRAC = 0.20;
    const SPAWN_X_MAX_FRAC = 0.80;
    const SPAWN_Y_MIN_FRAC = 0.68;
    const SPAWN_Y_MAX_FRAC = 0.90;

    // Launch path → to the moon (perspective shrink)
    const LAUNCH_MS      = 6000;   // flight duration
    const END_RADIUS     = 10;     // size at the moon
    const BEZIER_PEAK    = 0.34;   // arc height (fraction of screen)
    const RESPAWN_DELAY_MS = 2500; // wait before next orb

    // Ball look (opaque + small halo)
    const BALL_RGB       = "120,220,210";
    const RIM_ALPHA      = 0.15;
    const HALO_INNER_MULT = 1.00;
    const HALO_OUTER_MULT = 1.12;  // ~6% of diameter beyond edge
    const HALO_ALPHA      = 0.25;
    const HALO_TRAIL_ALPHA= 0.16;

    // Local jitter only
    const ORB_SHAKE_MAX  = 8;
    const ORB_SHAKE_FX   = 23, ORB_SHAKE_FY = 17;

    // Audio (crescendo while charging)
    const HUM_GAIN_MAX   = 0.6;

    // Moon
    const MOON_R         = 70;
    const MOON_GLOW_R    = 240;
    const MOON_X_FRAC    = 0.78;
    const MOON_Y_FRAC    = 0.24;

    // Impact FX
    const IMPACT_PETALS  = 180;
    const IMPACT_SPEED   = 460;
    const IMPACT_LIFE    = 1.9;
    const SHOCKWAVE_MAX_R= 340;
    const FLASH_MAX_ALPHA= 0.7;

    // Craters
    const MAX_CRATERS      = 24;
    const CRATER_FADE_MS   = 250; // pop-in duration
    const CRATER_R_MIN_FR  = 0.06; // 6% of moon radius
    const CRATER_R_MAX_FR  = 0.14; // 14% of moon radius
    const CRATER_MARGIN_FR = 0.04; // keep inside disk

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    const bgImg     = new Image(); bgImg.src = BG_SRC;
    const petalImg  = new Image(); petalImg.src = PETAL_SRC;

    const sfxRelease= new Audio(SFX_RELEASE); sfxRelease.volume = 0.7;
    const sfxImpact = new Audio(SFX_IMPACT);  sfxImpact.volume  = 0.75;
    const play = a => { try { a.currentTime = 0; a.play(); } catch(_){} };

    const rand  = (a,b)=>a+Math.random()*(b-a);
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const nowS  = ()=> performance.now()/1000;

    // Pointer / eye-gaze
    const pointer = { x:-9999, y:-9999, px:-9999, py:-9999, moved:0, inside:false };
    canvas.addEventListener('pointermove', e=>{
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top ) * (canvas.height / r.height);
      if (pointer.px !== -9999) pointer.moved = Math.hypot(x-pointer.px, y-pointer.py);
      pointer.x=x; pointer.y=y; pointer.px=x; pointer.py=y; pointer.inside=true;
    });
    canvas.addEventListener('pointerleave', ()=> pointer.inside=false);

    // Moon position (responsive)
    let moon = { x: W*MOON_X_FRAC, y: H*MOON_Y_FRAC };
    function resize(){
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      moon.x = W*MOON_X_FRAC; moon.y = H*MOON_Y_FRAC;
      if (orb && !launching){
        // keep orb within spawn band on resize
        orb.cx = clamp(orb.cx, W*SPAWN_X_MIN_FRAC, W*SPAWN_X_MAX_FRAC);
        orb.cy = clamp(orb.cy, H*SPAWN_Y_MIN_FRAC, H*SPAWN_Y_MAX_FRAC);
      }
    }
    window.addEventListener('resize', resize);

    /* =======================
       AUDIO — charging hum
    ======================= */
    let audioCtx=null, masterGain=null;
    let chargeGain=null, filter=null, osc1=null, osc2=null, o1g=null, o2g=null;

    function setupAudio(){
      audioCtx   = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(audioCtx.destination);

      osc1 = audioCtx.createOscillator(); osc1.type = 'sawtooth'; osc1.frequency.value = 90;
      osc2 = audioCtx.createOscillator(); osc2.type = 'triangle';  osc2.frequency.value = 180;

      o1g = audioCtx.createGain(); o1g.gain.value = 0.35;
      o2g = audioCtx.createGain(); o2g.gain.value = 0.25;

      filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 700; filter.Q.value = 0.7;

      chargeGain = audioCtx.createGain(); chargeGain.gain.value = 0.0;

      osc1.connect(o1g); osc2.connect(o2g);
      o1g.connect(filter); o2g.connect(filter);
      filter.connect(chargeGain); chargeGain.connect(masterGain);

      osc1.start(); osc2.start();
    }
    function updateHum(level){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const gTarget = clamp(HUM_GAIN_MAX * Math.pow(level,1.15), 0, HUM_GAIN_MAX);
      chargeGain.gain.setTargetAtTime(gTarget, t, 0.06);

      const f1 = 90  + (240-90)  * level;
      const f2 = 180 + (520-180) * level;
      const ff = 700 + (4200-700)* level;
      osc1.frequency.setTargetAtTime(f1, t, 0.05);
      osc2.frequency.setTargetAtTime(f2, t, 0.05);
      filter.frequency.setTargetAtTime(ff, t, 0.08);
    }
    function cutHumPunch(){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const cur = chargeGain.gain.value || 0.0001;
      chargeGain.gain.setValueAtTime(cur, t);
      chargeGain.gain.exponentialRampToValueAtTime(Math.max(0.001, cur*1.6), t+0.05);
      chargeGain.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      filter.frequency.setTargetAtTime(6000, t, 0.03);
    }

    /* =======================
       ORB (single)
    ======================= */
    let orb = null;            // {cx,cy,charge,inZone,enterMs,launching,launchT0,startR,trail,renderR}
    let launching = false;
    let respawnAtMs = 0;

    function spawnOrb(){
      orb = {
        cx: W*rand(SPAWN_X_MIN_FRAC, SPAWN_X_MAX_FRAC),
        cy: H*SPAWN_Y_MIN_FRAC + rand(0, (H*SPAWN_Y_MAX_FRAC - H*SPAWN_Y_MIN_FRAC)),
        charge: 0, inZone:false, enterMs:0,
        launching:false, launchT0:0, startR:MIN_DIAMETER*0.5,
        trail: [], renderR: MIN_DIAMETER*0.5
      };
    }
    function radiusFromCharge(o){ return (MIN_DIAMETER + (MAX_DIAMETER - MIN_DIAMETER)*o.charge) * 0.5; }
    function inOrb(o, x, y){ return Math.hypot(x - o.cx, y - o.cy) <= radiusFromCharge(o); }

    /* =======================
       IMPACT FX
    ======================= */
    const shards=[];
    function burstAt(x,y){
      const tBorn = nowS();
      for (let i=0;i<IMPACT_PETALS;i++){
        const a = Math.random()*Math.PI*2;
        const sp= IMPACT_SPEED*(0.4+0.6*Math.random());
        const size=rand(24,72);
        shards.push({
          x, y, w:size, h:size, ang:rand(-Math.PI,Math.PI),
          vx:Math.cos(a)*sp, vy:Math.sin(a)*sp - rand(60,120),
          rot:rand(-1.6,1.6), born:tBorn, life:IMPACT_LIFE
        });
      }
    }
    let flashLife=0, flashT=0, shockLife=0, shockT=0, shockX=0, shockY=0;
    function flash(a=FLASH_MAX_ALPHA, life=0.16){ flashLife=life; flashT=0; }
    function shock(cx,cy,life=0.9){ shockLife=life; shockT=0; shockX=cx; shockY=cy; }

    /* =======================
       CRATERS
    ======================= */
    // Stored relative to the moon so they scale on resize
    // { ang: radians, dist: 0..1 of moon radius, rFrac: radius as fraction of moon radius, bornMs: timestamp }
    const craters = [];
    function addCraterFromImpact() {
      // Approach angle from last trail segment if available
      let ang = -Math.PI/2; // default: from below
      if (orb && orb.trail && orb.trail.length >= 2) {
        const a = orb.trail[orb.trail.length - 1];
        const b = orb.trail[orb.trail.length - 2];
        ang = Math.atan2(a.y - b.y, a.x - b.x);
      }
      const rFrac = rand(CRATER_R_MIN_FR, CRATER_R_MAX_FR);
      const distMax = Math.max(0, 1 - rFrac - CRATER_MARGIN_FR);
      const dist = rand(0.10, distMax);
      craters.push({ ang, dist, rFrac, bornMs: performance.now() });
      if (craters.length > MAX_CRATERS) craters.shift();
    }

    function drawCraters() {
      if (!craters.length) return;
      // light from top-left
      const LVX = -0.5, LVY = -0.9;
      const lvLen = Math.hypot(LVX, LVY) || 1;
      const lx = LVX / lvLen, ly = LVY / lvLen;
      const nowMs = performance.now();

      for (const c of craters) {
        // pop-in animation
        const age = nowMs - c.bornMs;
        const k = Math.min(1, age / CRATER_FADE_MS); // 0..1
        const scale = 0.7 + 0.3 * k;                 // start slightly smaller
        const alpha = k;                              // fade in

        const cx = moon.x + Math.cos(c.ang) * c.dist * MOON_R;
        const cy = moon.y + Math.sin(c.ang) * c.dist * MOON_R;
        const r  = c.rFrac * MOON_R * scale;

        // base depression (radial gradient, darker center)
        const g = ctx.createRadialGradient(
          cx - lx * r * 0.25, cy - ly * r * 0.25, r * 0.15,
          cx, cy, r
        );
        g.addColorStop(0, `rgba(185,190,205,${0.45*alpha})`);
        g.addColorStop(1, `rgba(160,165,185,0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

        // soft shadow rim on far (down-right) side
        const shadowAng = Math.atan2(-ly, -lx);
        ctx.strokeStyle = `rgba(90,100,130,${0.20*alpha})`;
        ctx.lineWidth = Math.max(1, r * 0.12);
        ctx.beginPath();
        ctx.arc(cx, cy, r, shadowAng - 0.9, shadowAng + 0.9);
        ctx.stroke();

        // subtle highlight on light (top-left) side
        const lightAng = Math.atan2(ly, lx);
        ctx.strokeStyle = `rgba(255,255,255,${0.12*alpha})`;
        ctx.lineWidth = Math.max(1, r * 0.08);
        ctx.beginPath();
        ctx.arc(cx, cy, r, lightAng - 0.9, lightAng + 0.9);
        ctx.stroke();
      }
    }

    /* =======================
       DRAW HELPERS
    ======================= */
    function drawSmallHalo(cx, cy, r, alpha=HALO_ALPHA){
      const inner = r*HALO_INNER_MULT, outer = r*HALO_OUTER_MULT;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(cx, cy, inner, cx, cy, outer);
      g.addColorStop(0, `rgba(${BALL_RGB},${alpha})`);
      g.addColorStop(1, `rgba(${BALL_RGB},0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, outer, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
    function drawSolidBall(cx, cy, r, withRim=true){
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = `rgb(${BALL_RGB})`;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      if (withRim){
        ctx.strokeStyle = `rgba(255,255,255,${RIM_ALPHA})`;
        ctx.lineWidth = Math.max(1, r*0.02);
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    }
    function orbJitter(charge01){
      const t = performance.now()/1000;
      const amp = ORB_SHAKE_MAX * Math.pow(charge01,1.2);
      const ox = Math.sin(t*ORB_SHAKE_FX*2*Math.PI + 0.31) * amp;
      const oy = Math.cos(t*ORB_SHAKE_FY*2*Math.PI + 1.13) * amp * 0.8;
      return [ox, oy];
    }

    function drawMoon(){
      // glow
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g = ctx.createRadialGradient(moon.x, moon.y, 0, moon.x, moon.y, MOON_GLOW_R);
      g.addColorStop(0,  'rgba(255,245,220,0.18)');
      g.addColorStop(1,  'rgba(255,245,220,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_GLOW_R, 0, Math.PI*2); ctx.fill();
      ctx.restore();
      // disk
      ctx.save();
      ctx.fillStyle = 'rgb(245,245,250)';
      ctx.beginPath(); ctx.arc(moon.x, moon.y, MOON_R, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // craters over the disk
      drawCraters();
    }

    function drawBackground(){
      if (bgImg.complete && bgImg.naturalWidth>0){
        const iw=bgImg.width, ih=bgImg.height;
        const sc=Math.max(W/iw, H/ih);
        ctx.drawImage(bgImg, (W-iw*sc)/2, (H-ih*sc)/2, iw*sc, ih*sc);
      } else {
        ctx.fillStyle="#041017"; ctx.fillRect(0,0,W,H);
      }
    }

    function drawShards(){
      const t=nowS();
      for (let i=shards.length-1; i>=0; i--){
        const s = shards[i];
        const a = Math.max(0, 1 - (t - s.born)/s.life);
        ctx.save(); ctx.globalAlpha = a;
        ctx.translate(s.x, s.y); ctx.rotate(s.ang);
        ctx.drawImage(petalImg, -s.w/2, -s.h/2, s.w, s.h);
        ctx.restore();
        if (a<=0) shards.splice(i,1);
      }
    }
    function drawFlash(){
      if (flashLife<=0) return;
      const p = Math.min(1, flashT/flashLife);
      const a = FLASH_MAX_ALPHA*(1-p);
      if (a<=0.01) return;
      ctx.save(); ctx.fillStyle=`rgba(255,255,255,${a})`; ctx.fillRect(0,0,W,H); ctx.restore();
    }
    function drawShockwave(){
      if (shockLife<=0) return;
      const p = Math.min(1, shockT/shockLife);
      const r = SHOCKWAVE_MAX_R*p;
      const a = 0.35*(1-p);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,255,255,${a})`;
      ctx.lineWidth = 6*(1-p);
      ctx.beginPath(); ctx.arc(shockX, shockY, r, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    /* =======================
       EASING (slower early ascent)
    ======================= */
    const easeInCubic = t => t*t*t;

    /* =======================
       UPDATE
    ======================= */
    let started=false, lastT=performance.now();

    function maybeCharge(dt){
      if (!orb || launching) return;
      const r = radiusFromCharge(orb);
      const inside = pointer.inside && inOrb(orb, pointer.x, pointer.y);
      const stable = pointer.moved <= MAX_JITTER_PX;

      if (inside){
        if (!orb.inZone){ orb.inZone = true; orb.enterMs = performance.now(); }
        const ok = (performance.now() - orb.enterMs) >= ENTRY_GRACE_MS;
        if (ok){
          orb.charge = Math.min(1, orb.charge + dt*(1000/DWELL_MS));
          if (orb.charge >= 1 && !launching){
            // launch!
            launching = true;
            cutHumPunch();
            play(sfxRelease);
            orb.launching = true;
            orb.launchT0 = performance.now();
            orb.startR  = radiusFromCharge(orb);
            orb.trail.length = 0;
          }
        }
      } else {
        orb.inZone = false;
        if (!launching) orb.charge = Math.max(0, orb.charge - DECAY_PER_SEC*dt);
      }
    }

    function update(dt){
      // Spawn if needed
      if (!orb && !launching && respawnAtMs && performance.now() >= respawnAtMs){
        respawnAtMs = 0;
        spawnOrb();
      } else if (!orb && !launching && !respawnAtMs){
        // first time
        spawnOrb();
      }

      // Charging
      maybeCharge(dt);

      // Update hum
      updateHum(orb && !launching ? orb.charge : 0);

      // Launch curve (eased to slow early ascent)
      if (launching && orb){
        const tNow = performance.now();
        const pLinear = clamp((tNow - orb.launchT0)/LAUNCH_MS, 0, 1);
        const t = easeInCubic(pLinear);

        const p0   = { x:orb.cx, y:orb.cy };
        const ctrl = { x:orb.cx + (moon.x - orb.cx)*0.35, y: Math.min(orb.cy, moon.y) - H*BEZIER_PEAK };
        const p1   = { x:moon.x, y:moon.y };

        const x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*ctrl.x + t*t*p1.x;
        const y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*ctrl.y + t*t*p1.y;
        const r = orb.startR + (END_RADIUS - orb.startR) * t;

        // trail
        orb.trail.push({ x, y, r, a:1 });
        if (orb.trail.length>18) orb.trail.shift();
        for (const tr of orb.trail) tr.a *= 0.9;

        orb.cx = x; orb.cy = y; orb.renderR = r;

        if (t>=1){
          // Impact & clean up
          addCraterFromImpact();     // <<< add a crater
          burstAt(moon.x, moon.y);
          flash(); shock(moon.x, moon.y);
          play(sfxImpact);
          launching = false;
          orb = null;
          respawnAtMs = performance.now() + RESPAWN_DELAY_MS; // schedule next orb
        }
      }

      // FX timers
      if (flashLife>0){ flashT += dt; if (flashT>=flashLife) flashLife=0; }
      if (shockLife>0){ shockT += dt; if (shockT>=shockLife) shockLife=0; }

      // Petal physics
      const t = nowS();
      for (let i=shards.length-1;i>=0;i--){
        const s=shards[i];
        s.x += s.vx*dt; s.y += s.vy*dt; s.vy += 360*dt; s.ang += s.rot*dt;
        if (t - s.born > s.life) shards.splice(i,1);
      }
    }

    /* =======================
       RENDER
    ======================= */
    function drawOrb(){
      if (!orb) return;
      if (!launching){
        const r = radiusFromCharge(orb);
        const [ox, oy] = orbJitter(orb.charge);
        const cx = orb.cx + ox, cy = orb.cy + oy;
        drawSolidBall(cx, cy, r, true);
        drawSmallHalo(cx, cy, r, HALO_ALPHA);
      } else {
        // trail echoes
        ctx.save(); ctx.globalCompositeOperation='source-over';
        for (const tr of orb.trail){
          if (tr.a<=0.02) continue;
          ctx.globalAlpha = 0.10 * tr.a;
          drawSolidBall(tr.x, tr.y, tr.r*0.9, false);
          drawSmallHalo(tr.x, tr.y, tr.r*0.9, HALO_TRAIL_ALPHA*tr.a);
        }
        ctx.restore(); ctx.globalAlpha=1;

        // current position
        drawSolidBall(orb.cx, orb.cy, orb.renderR||END_RADIUS, true);
        drawSmallHalo(orb.cx, orb.cy, orb.renderR||END_RADIUS, HALO_ALPHA);
      }
    }

    function render(){
      // bg + moon + craters
      if (bgImg.complete && bgImg.naturalWidth>0){
        const iw=bgImg.width, ih=bgImg.height;
        const sc=Math.max(W/iw, H/ih);
        ctx.drawImage(bgImg, (W-iw*sc)/2, (H-ih*sc)/2, iw*sc, ih*sc);
      } else {
        ctx.fillStyle="#041017"; ctx.fillRect(0,0,W,H);
      }
      drawMoon();

      drawOrb();

      drawShards();
      drawShockwave();
      drawFlash();
    }

    function tick(tMs){
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT)/1000);
      lastT = tMs;
      update(dt);
      render();
      requestAnimationFrame(tick);
    }

    /* =======================
       START
    ======================= */
    const startOverlay=document.getElementById('startOverlay');
    const startBtn=document.getElementById('startBtn');

    async function enterFullscreen(){
      const el=document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    }

    startBtn.addEventListener('click', async ()=>{
      try{ await enterFullscreen(); }catch(e){}
      startOverlay.style.display='none';
      started = true;

      // ensure images then start
      let pending = 0;
      const tryStart = ()=>{ if (--pending<=0) requestAnimationFrame(tick); };
      [bgImg, petalImg].forEach(im=>{ if (!im.complete){ pending++; im.onload=tryStart; }});
      if (pending===0) requestAnimationFrame(tick);

      // audio on gesture
      try { setupAudio(); await audioCtx.resume(); } catch(e){}
      resize();
    });
  })();
  </script>
</body>
</html>
