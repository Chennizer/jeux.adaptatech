<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MediaPipe Gaze â€“ dynamic ES-module imports</title>
  <style>
    html,body{margin:0;height:100%;background:#1a1a1a;overflow:hidden}
    #video{
      position:absolute;top:16px;left:16px;
      object-fit:cover;border:2px solid #fff;border-radius:14px;
      box-shadow:0 0 18px #000a;z-index:2;
    }
    #overlay{
      position:absolute;top:16px;left:16px;pointer-events:none;z-index:3;
    }
  </style>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <canvas id="overlay"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection/dist/face-landmarks-detection.min.js"></script>
  <script>
    (async () => {
      /* ---------------------------------------------------------------
         2.  DOM setup
      ----------------------------------------------------------------*/
      const video  = document.getElementById('video');
      const canvas = /** @type {HTMLCanvasElement} */ (document.getElementById('overlay'));
      const ctx    = canvas.getContext('2d');

      /* ---------------------------------------------------------------
         3.  Webcam
      ----------------------------------------------------------------*/
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      await new Promise(r => video.onloadedmetadata = r);
      const {videoWidth:vw, videoHeight:vh} = video;
      video.width = canvas.width = vw;
      video.height = canvas.height = vh;
      video.style.width = canvas.style.width = vw + 'px';
      video.style.height = canvas.style.height = vh + 'px';

      /* ---------------------------------------------------------------
         4.  TFJS backend + model
      ----------------------------------------------------------------*/
      await tf.setBackend('webgl');
      await tf.ready();

      const model = await faceLandmarksDetection.createDetector(
        faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh,
        { runtime: 'tfjs', maxFaces: 1, refineLandmarks: true }
      );

      /* ---------------------------------------------------------------
         5.  Helpers
      ----------------------------------------------------------------*/
      const L=[33,133,159,145,468,469,470,471],               // left eye landmarks
            R=[362,263,386,374,473,474,475,476];              // right eye landmarks
      const irisCenter = pts => pts.slice(4).reduce((s,p)=>[s[0]+p[0],s[1]+p[1]],[0,0]).map(v=>v/4);

      /* ---------------------------------------------------------------
         6.  Render loop
      ----------------------------------------------------------------*/
      async function draw(){
        const faces = await model.estimateFaces(video, { flipHorizontal: true });
        ctx.clearRect(0,0,canvas.width,canvas.height);

        if (faces.length){
          const mesh = faces[0].keypoints;
          for (const {x,y} of mesh) {
            ctx.beginPath();
            ctx.arc(x,y,1.5,0,Math.PI*2);
            ctx.fillStyle = '#0ff';
            ctx.fill();
          }

          const lPts = L.map(i=>[mesh[i].x, mesh[i].y]),
                rPts = R.map(i=>[mesh[i].x, mesh[i].y]);

          const [lOuter,lInner,lUpper,lLower] = lPts.slice(0,4),
                [rOuter,rInner,rUpper,rLower] = rPts.slice(0,4);

          const lIris = irisCenter(lPts),
                rIris = irisCenter(rPts);

          const lx = (lIris[0]-lOuter[0])/(lInner[0]-lOuter[0]),
                ly = (lIris[1]-lUpper[1])/(lLower[1]-lUpper[1]);
          const rx = (rIris[0]-rOuter[0])/(rInner[0]-rOuter[0]),
                ry = (rIris[1]-rUpper[1])/(rLower[1]-rUpper[1]);

          const normX = Math.min(Math.max((lx+rx)/2,0),1);
          const normY = Math.min(Math.max((ly+ry)/2,0),1);
          const screenX = normX*vw, screenY = normY*vh;

          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(screenX-20, screenY);
          ctx.lineTo(screenX+20, screenY);
          ctx.moveTo(screenX, screenY-20);
          ctx.lineTo(screenX, screenY+20);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(screenX, screenY, 4, 0, Math.PI*2);
          ctx.fillStyle = '#ffd700';
          ctx.fill();
        }
        requestAnimationFrame(draw);
      }
      draw();
    })();
  </script>
</body>
</html>
