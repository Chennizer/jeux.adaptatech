<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title
    class="translate"
    data-fr="Construction de ruche - Compétitif"
    data-en="Hive Builder - Competitive"
    data-ja="ハチの巣づくり：対戦モード">
    Construction de ruche - Compétitif
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Common styles (same file as other switch games) -->
  <link rel="stylesheet" href="../../css/otherswitch.css">

  <style>
    :root {
      --c1: #fbbf24; --c2: #d97706; --c3: #FFCA3A; --c4: #8AC926;
      --c5: #1982C4; --c6: #6A4C93; --c7: #B5179E; --c8: #2EC4B6;
      --gap: 3rem;
      --side-pad: 3rem;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      touch-action: manipulation;
    }

    /* -------- LANG BUTTON (copied from Window example) -------- */
    #langToggle {
      position: fixed;
      top: 14px;
      right: 44px;
      z-index: 11;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      border: 2px solid #04c8bb;
      background: #0b0f12;
      color: #04c8bb;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 0 0 0 rgba(4, 200, 187, 0);
      transition: box-shadow 0.2s ease, transform 0.05s ease, background 0.2s ease;
    }

    #langToggle:hover {
      box-shadow: 0 0 0 3px rgba(4, 200, 187, 0.2);
    }

    #langToggle:active {
      transform: translateY(1px);
    }

    /* -------- LANDING OVERLAY (same design as xylophone) -------- */
    #promptOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1rem;
      z-index: 10;
    }
    #promptOverlay p {
      font-size: 1.25rem;
      max-width: 80%;
      margin-bottom: 1.5rem;
    }
    #modeSelect {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
    }
    #modeSelect button {
      flex: 1;
      min-width: 120px;
      padding: 0.75rem 1rem;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 8px;
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    #modeSelect button:hover {
      background: rgba(255,255,255,0.2);
    }
    #modeSelect button.active {
      background: #00bfff;
      color: #000;
      font-weight: bold;
    }
    #promptOverlay button#startButton {
      padding: 1rem 2rem;
      font-size: 1.25rem;
      margin-top: 1rem;
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }

    /* -------- GAME CANVAS -------- */
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .controls-hint {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
      line-height: 1.6;
    }
    .key {
      display: inline-block;
      padding: 2px 6px;
      border: 1px solid #666;
      border-radius: 4px;
      background: #222;
      font-family: monospace;
      color: #fbbf24;
    }
  </style>
</head>

<body>
  <!-- Language toggle button -->
  <button id="langToggle" title="Changer de langue / Change language">FR / EN / JA</button>

  <!-- Landing overlay -->
  <div id="promptOverlay">
    <p class="translate"
       data-fr="Choisissez un mode puis appuyez sur Commencer."
       data-en="Select a mode then press Start."
       data-ja="モードを選んで「開始」を押してください。">
      Choisissez un mode puis appuyez sur Commencer.
    </p>

    <div id="modeSelect">
      <button data-mode="1p" class="active">
        <span class="translate"
              data-fr="1 joueur"
              data-en="1 player"
              data-ja="1人プレイ">1 joueur</span>
      </button>
      <button data-mode="2p">
        <span class="translate"
              data-fr="2 joueurs"
              data-en="2 players"
              data-ja="2人プレイ">2 joueurs</span>
      </button>
    </div>

    <div id="controlsText" class="controls-hint">
      <span class="translate"
            data-fr="Construisez la plus grande ruche !"
            data-en="Build the biggest hive!"
            data-ja="いちばん大きなハチの巣を作ろう！">
        Construisez la plus grande ruche !
      </span>
      <br>
      <span class="translate"
            data-fr="Joueur 1 : appuyez sur"
            data-en="Player 1: Press"
            data-ja="プレイヤー1：押すキー">
        Joueur 1 : appuyez sur
      </span>
      <span class="key">SPACE</span>
      <br>
      <span id="p2hint" style="display:none;">
        <span class="translate"
              data-fr="Joueur 2 : appuyez sur"
              data-en="Player 2: Press"
              data-ja="プレイヤー2：押すキー">
          Joueur 2 : appuyez sur
        </span>
        <span class="key">ENTER</span>
      </span>
    </div>

    <button id="startButton" class="translate"
            data-fr="Commencer"
            data-en="Start"
            data-ja="開始">
      Commencer
    </button>
  </div>

  <canvas id="simCanvas"></canvas>

  <script>
    /**
     * CONFIGURATION & ASSETS (original game logic)
     */
    const COLORS = {
      bgLeft: '#120a02',
      bgRight: '#4a7c25',
      bgDark: '#120a02',
      hexBorderLight: '#ffd700',
      hexBorderDark: '#b45309',
      waxBase: '#fbbf24',
      waxDeep: '#78350f',
      beeYellowBright: '#ffdf00',
      beeYellowDark: '#c7a008',
      beeBlack: '#0a0a0a',
      fieldSkyTop: '#b8e7ff',
      fieldSkyBottom: '#7ac6f2',
      fieldGrass: '#63c042',
      fieldGrassShadow: '#4e9d35'
    };

    // ----- Procedural Wax Texture -----
    const waxTextureCanvas = document.createElement('canvas');
    waxTextureCanvas.width = 128;
    waxTextureCanvas.height = 128;
    const wCtx = waxTextureCanvas.getContext('2d');

    const waxGrad = wCtx.createRadialGradient(64,64,0, 64,64,90);
    waxGrad.addColorStop(0, COLORS.waxBase);
    waxGrad.addColorStop(1, COLORS.waxDeep);
    wCtx.fillStyle = waxGrad;
    wCtx.fillRect(0,0,128,128);

    for (let i = 0; i < 3000; i++) {
      const x = Math.random() * 128;
      const y = Math.random() * 128;
      const alpha = Math.random() * 0.2;
      wCtx.fillStyle = Math.random() > 0.5
        ? `rgba(255, 255, 200, ${alpha})`
        : `rgba(100, 50, 0, ${alpha})`;
      wCtx.beginPath();
      wCtx.arc(x, y, Math.random()*1.5, 0, Math.PI*2);
      wCtx.fill();
    }

    // ----- Canvas Setup -----
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    let width, height, waxPattern;

    // ----- Game State -----
    let gameRunning = false;
    let gameMode = '1p'; // '1p' or '2p'

    // Hives and other entities
    let hives = [];
    const flowers = [];
    const particles = [];

    let hexRadius = 45;

    // ----- DOM Elements for Menu -----
    const modeButtons = document.querySelectorAll('#modeSelect button');
    const p2Hint = document.getElementById('p2hint');
    const startButton = document.getElementById('startButton');
    const overlay = document.getElementById('promptOverlay');

    // ----- UI Logic -----
    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        p2Hint.style.display = (gameMode === '2p') ? 'inline' : 'none';
      });
    });

    startButton.addEventListener('click', (e) => {
      e.preventDefault();

      // Fullscreen request (like your other games)
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(()=>{});
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
      }

      overlay.style.display = 'none';
      gameRunning = true;
      initGame();
    });

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * window.devicePixelRatio;
      canvas.height = height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      waxPattern = ctx.createPattern(waxTextureCanvas, 'repeat');

      // If game is running, re-init to adjust positions
      if (gameRunning) initGame();
    }
    window.addEventListener('resize', resize);

    // ----- HIVE CLASS -----
    class Hive {
      constructor(centerX, isRightSide) {
        this.centerX = centerX;
        this.centerY = height * 0.5;
        this.isRightSide = isRightSide;
        this.cells = [];
        this.bees = [];
        this.occupiedMap = new Set();
        this.reservedMap = new Set();

        // Initial Cell
        this.addCell(0,0);

        // Initial Bees
        for(let i=0; i<6; i++) this.bees.push(this.createBee());
      }

      hexToPixel(q, r) {
        // Pointy topped hex math
        const x = this.centerX + hexRadius * (3/2 * q);
        const y = this.centerY + hexRadius * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
        return { x, y };
      }

      addCell(q, r) {
        const pos = this.hexToPixel(q, r);
        this.cells.push({
          q, r, x: pos.x, y: pos.y,
          scale: 0,
          variation: Math.random(),
          wobble: Math.random() * Math.PI*2
        });
        const key = `${q},${r}`;
        this.occupiedMap.add(key);
        if(this.reservedMap.has(key)) this.reservedMap.delete(key);
      }

      findNextBuildSpot() {
        const HEX_DIRECTIONS = [
          {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
          {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
        ];

        // Spiral search
        let queue = [{q:0, r:0}];
        let visited = new Set(['0,0']);
        let iterations = 0;

        while (queue.length > 0 && iterations < 3000) {
          iterations++;
          let current = queue.shift();
          for (let dir of HEX_DIRECTIONS) {
            let nq = current.q + dir.q;
            let nr = current.r + dir.r;
            let key = `${nq},${nr}`;

            if (!visited.has(key)) {
              visited.add(key);
              if (!this.occupiedMap.has(key) && !this.reservedMap.has(key)) {
                return { q: nq, r: nr };
              }
              if (this.occupiedMap.has(key)) {
                queue.push({q: nq, r: nr});
              }
            }
          }
        }
        return null;
      }

      createBee() {
        const home = this.hexToPixel(0, 0);
        return {
          x: home.x + (Math.random()-0.5)*50,
          y: home.y + (Math.random()-0.5)*50,
          vx: 0, vy: 0,
          state: 'idle',
          target: null,
          targetGrid: null,
          angle: this.isRightSide ? Math.PI : 0, // Face center initially
          wobblePhase: Math.random() * Math.PI * 2,
          wingSpeed: 1,
          sizeScale: 1.3 + Math.random() * 0.4
        };
      }

      sendBees() {
        this.bees.forEach(b => {
          if (b.state === 'idle' && flowers.length > 0) {
            b.state = 'outbound';
            b.wingSpeed = 3.5;
            const flower = flowers[Math.floor(Math.random() * flowers.length)];
            b.target = {
              x: flower.x + (Math.random()-0.5)*10,
              y: flower.y + (Math.random()-0.5)*10 - 15
            };
          }
        });
      }

      update(dt) {
        // Animate Cells
        this.cells.forEach(c => {
          if (c.scale < 1) c.scale += (1 - c.scale) * 0.1;
        });

        // Update Bees
        const homeCenter = this.hexToPixel(0,0);

        this.bees.forEach(b => {
          b.wobblePhase += dt * 5 * b.wingSpeed;

          if (b.state === 'idle') {
            b.wingSpeed = 1;
            // Hover near center of hive
            const hoverX = homeCenter.x + Math.cos(b.wobblePhase*0.2)*70;
            const hoverY = homeCenter.y + Math.sin(b.wobblePhase*0.3)*50;
            const dx = hoverX - b.x;
            const dy = hoverY - b.y;
            b.x += dx * 0.03;
            b.y += dy * 0.03;

            // Face towards center (flowers)
            const desiredAngle = this.isRightSide ? Math.PI : 0;
            let angleDiff = desiredAngle - b.angle;
            if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
            if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
            b.angle += angleDiff * 0.05;
          }
          else {
            const dx = b.target.x - b.x;
            const dy = b.target.y - b.y;
            const dist = Math.hypot(dx, dy);
            const speed = 180 * dt;

            if (dist < 20) {
              if (b.state === 'outbound') {
                b.state = 'returning';
                const nextSpot = this.findNextBuildSpot();
                if (nextSpot) {
                  this.reservedMap.add(`${nextSpot.q},${nextSpot.r}`);
                  b.targetGrid = nextSpot;
                  b.target = this.hexToPixel(nextSpot.q, nextSpot.r);
                } else {
                  b.target = homeCenter;
                  b.targetGrid = null;
                }
                spawnParticles(b.x, b.y, ['#fff', COLORS.beeYellowBright]);
              } else if (b.state === 'returning') {
                b.state = 'idle';
                if (b.targetGrid) {
                  this.addCell(b.targetGrid.q, b.targetGrid.r);
                  b.targetGrid = null;
                }
                spawnParticles(b.x, b.y, [COLORS.hexBorderLight, COLORS.waxBase]);
              }
            } else {
              b.vx = (dx/dist) * speed;
              b.vy = (dy/dist) * speed;
              b.x += b.vx;
              b.y += b.vy;
              const targetAngle = Math.atan2(dy, dx);
              let angleDiff = targetAngle - b.angle;
              if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
              if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
              b.angle += angleDiff * 0.15;
            }
          }
        });
      }

      draw(ctx) {
        // Draw Shadows/Base
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 25;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 10;
        this.cells.forEach(c => drawOrganicHexBase(c.x, c.y, hexRadius * c.scale, c.wobble));
        ctx.restore();

        // Draw Cells
        this.cells.forEach(c => drawOrganicHexDetail(c.x, c.y, hexRadius * c.scale, c.variation, c.wobble));

        // Draw Bees
        this.bees.forEach(b => drawBee(b));
      }
    }

    // ----- Logic Initialization -----
    function initGame() {
      hives = [];
      flowers.length = 0;
      particles.length = 0;

      if (gameMode === '1p') {
        // 1 Player: Hive Left (20%), Flowers Right
        hives.push(new Hive(width * 0.2, false));
        generateFlowers(width * 0.4, width * 0.95);
      } else {
        // 2 Player: Hive Left (15%), Hive Right (85%), Flowers Middle
        hives.push(new Hive(width * 0.15, false)); // P1
        hives.push(new Hive(width * 0.85, true));  // P2
        generateFlowers(width * 0.35, width * 0.65);
      }
    }

    // ----- Flower Generation -----
    function generateFlowers(minX, maxX) {
      const count = 25;
      const petalsPalette = ['#ff69b4', '#ff8c42', '#ffb703', '#a855f7', '#6ee7b7', '#60a5fa'];
      const centersPalette = ['#fcd34d', '#fde68a', '#fff7ae'];
      for(let i=0; i<count; i++) {
        const type = ['daisy','burst','tulip','ring'][Math.floor(Math.random()*4)];
        const size = 10 + Math.random() * 10;
        const sway = 3 + Math.random() * 4;
        flowers.push({
          x: minX + Math.random() * (maxX - minX),
          y: height * 0.55 + Math.random() * (height * 0.18),
          type,
          colorMain: petalsPalette[Math.floor(Math.random()*petalsPalette.length)],
          colorSecondary: petalsPalette[Math.floor(Math.random()*petalsPalette.length)],
          colorCenter: centersPalette[Math.floor(Math.random()*centersPalette.length)],
          size,
          stemCurve: (Math.random() - 0.5) * 50,
          sway,
          phase: Math.random() * Math.PI * 2
        });
      }
    }

    // ----- Controls -----
    window.addEventListener('keydown', (e) => {
      if (!gameRunning) return;

      // Player 1 (Space)
      if (e.code === 'Space') {
        e.preventDefault();
        hives[0].sendBees();
      }

      // Player 2 (Enter) - Only in 2p mode
      if (e.code === 'Enter' && gameMode === '2p') {
        e.preventDefault();
        hives[1].sendBees();
      }
    });

    // Touch/Mouse fallback (Triggers both or P1)
    window.addEventListener('mousedown', () => {
      if(!gameRunning) return;
      hives[0].sendBees();
      if(gameMode === '2p') hives[1].sendBees();
    });

    // ----- Particles -----
    function spawnParticles(x, y, colorPalette) {
      for(let i=0; i<15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 80;
        const size = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.0,
          decay: 0.8 + Math.random()*0.5,
          color: colorPalette[Math.floor(Math.random()*colorPalette.length)],
          size
        });
      }
    }

    // ----- Main Update -----
    function update(dt) {
      hives.forEach(h => h.update(dt));

      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 80 * dt;
        p.life -= dt * p.decay;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // ----- Drawing -----
    function drawFieldRegion(startX, endX) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(startX, 0, endX - startX, height);
      ctx.clip();

      const skyGrad = ctx.createLinearGradient(0, 0, 0, height * 0.8);
      skyGrad.addColorStop(0, COLORS.fieldSkyTop);
      skyGrad.addColorStop(1, COLORS.fieldSkyBottom);
      ctx.fillStyle = skyGrad;
      ctx.fillRect(startX, 0, endX - startX, height);

      const sunX = startX + (endX - startX) * 0.18;
      const sunY = height * 0.18;
      const sunR = 90;
      const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
      sunGrad.addColorStop(0, 'rgba(255,223,0,0.9)');
      sunGrad.addColorStop(1, 'rgba(255,223,0,0)');
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();

      const hillBase = height * 0.78;
      ctx.fillStyle = COLORS.fieldGrass;
      ctx.beginPath();
      ctx.moveTo(startX, height);
      ctx.lineTo(startX, hillBase);
      ctx.quadraticCurveTo(
        startX + (endX - startX) * 0.25,
        hillBase - 40,
        startX + (endX - startX) * 0.5,
        hillBase - 10
      );
      ctx.quadraticCurveTo(
        startX + (endX - startX) * 0.75,
        hillBase + 20,
        endX,
        hillBase - 5
      );
      ctx.lineTo(endX, height);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = COLORS.fieldGrassShadow;
      ctx.beginPath();
      ctx.moveTo(startX - 10, height);
      ctx.lineTo(startX - 10, hillBase + 15);
      ctx.quadraticCurveTo(
        startX + (endX - startX) * 0.3,
        hillBase - 10,
        startX + (endX - startX) * 0.55,
        hillBase + 25
      );
      ctx.quadraticCurveTo(
        startX + (endX - startX) * 0.8,
        hillBase + 50,
        endX + 10,
        hillBase + 10
      );
      ctx.lineTo(endX + 10, height);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i = 0; i < 8; i++) {
        const rayAngle = (Math.PI * 2 / 8) * i - 0.2;
        const innerR = 35;
        const outerR = 130;
        ctx.moveTo(
          sunX + Math.cos(rayAngle) * innerR,
          sunY + Math.sin(rayAngle) * innerR
        );
        ctx.lineTo(
          sunX + Math.cos(rayAngle) * outerR,
          sunY + Math.sin(rayAngle) * outerR
        );
      }
      ctx.stroke();

      ctx.restore();
    }

    function draw() {
      // 1. Draw Background Zones
      if (gameMode === '1p') {
        const splitX = width * 0.4;
        ctx.fillStyle = COLORS.bgLeft;
        ctx.fillRect(0, 0, splitX, height);
        drawFieldRegion(splitX, width);
      } else {
        // 2 Player Background: Dark | Field | Dark
        const leftEdge = width * 0.3;
        const rightEdge = width * 0.7;

        ctx.fillStyle = COLORS.bgDark;
        ctx.fillRect(0, 0, leftEdge, height);
        ctx.fillRect(rightEdge, 0, width - rightEdge, height);
        drawFieldRegion(leftEdge, rightEdge);
      }

      drawFlowers();
      hives.forEach(h => h.draw(ctx));
      drawParticles();
    }

    // --- Rendering Helpers ---
    function drawFlowers() {
      const groundY = height * 0.82;
      const t = timeSeconds || 0;

      flowers.forEach(f => {
        const sway = Math.sin(t * 0.8 + f.phase) * f.sway;
        const xTop = f.x + sway;
        const stemTopY = f.y;

        const stemGrad = ctx.createLinearGradient(f.x, groundY, xTop, stemTopY);
        stemGrad.addColorStop(0, '#1f5d16');
        stemGrad.addColorStop(1, '#4caf50');
        ctx.strokeStyle = stemGrad;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(f.x, groundY);
        ctx.bezierCurveTo(
          f.x + f.stemCurve * 0.4,
          groundY - 40,
          f.x - f.stemCurve,
          groundY - 120,
          xTop,
          stemTopY
        );
        ctx.stroke();

        ctx.fillStyle = '#2f6b1f';
        ctx.beginPath();
        ctx.ellipse(
          f.x + f.stemCurve * 0.15,
          groundY - 30,
          f.size * 1.3,
          f.size * 0.8,
          -0.7,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.save();
        ctx.translate(xTop, stemTopY);
        if (f.type === 'daisy') {
          const petalCount = 9;
          for(let i=0; i<petalCount; i++) {
            const angle = (Math.PI*2 / petalCount) * i;
            ctx.fillStyle = f.colorMain;
            ctx.beginPath();
            ctx.ellipse(
              Math.cos(angle)*f.size*1.2,
              Math.sin(angle)*f.size*0.9,
              f.size,
              f.size*0.55,
              angle,
              0, Math.PI*2
            );
            ctx.fill();
          }
          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.arc(0, 0, f.size*0.8, 0, Math.PI*2);
          ctx.fill();
        } else if (f.type === 'burst') {
          const petals = 6;
          ctx.fillStyle = f.colorMain;
          for(let i=0; i<petals; i++) {
            const angle = (Math.PI*2/petals)*i + 0.3;
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.quadraticCurveTo(
              Math.cos(angle) * f.size * 0.8,
              Math.sin(angle) * f.size * 0.8,
              Math.cos(angle) * f.size * 1.6,
              Math.sin(angle) * f.size * 1.6
            );
            ctx.quadraticCurveTo(
              Math.cos(angle) * f.size * 0.8,
              Math.sin(angle) * f.size * 0.8,
              0,0
            );
            ctx.fill();
          }
          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.arc(0, 0, f.size*0.6, 0, Math.PI*2);
          ctx.fill();
        } else if (f.type === 'ring') {
          const petals = 12;
          ctx.fillStyle = f.colorSecondary;
          for(let i=0; i<petals; i++) {
            const angle = (Math.PI*2/petals)*i;
            ctx.beginPath();
            ctx.ellipse(
              Math.cos(angle) * f.size * 1.6,
              Math.sin(angle) * f.size * 1.6,
              f.size * 0.9,
              f.size * 0.45,
              angle,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
          ctx.fillStyle = f.colorMain;
          ctx.beginPath();
          ctx.arc(0, 0, f.size * 1.1, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.arc(0, 0, f.size*0.65, 0, Math.PI*2);
          ctx.fill();
        } else if (f.type === 'tulip') {
          ctx.fillStyle = f.colorMain;
          ctx.beginPath();
          ctx.moveTo(0, f.size * 1.3);
          ctx.bezierCurveTo(
            -f.size * 2, 0,
            -f.size * 1.2, -f.size * 1.6,
            0, -f.size * 0.6
          );
          ctx.bezierCurveTo(
            f.size * 1.2, -f.size * 1.6,
            f.size * 2, 0,
            0, f.size * 1.3
          );
          ctx.fill();
          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.arc(0, -f.size * 0.5, f.size * 0.45, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      });
    }

    function getHexPath(x, y, r, wobbleOffset) {
      const path = new Path2D();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i + Math.PI/6;
        const nextAngle = (Math.PI / 3) * (i+1) + Math.PI/6;
        const r1 = r + Math.sin(wobbleOffset + i)*r*0.05;
        const r2 = r + Math.sin(wobbleOffset + i+1)*r*0.05;
        const px1 = x + r1 * Math.cos(angle);
        const py1 = y + r1 * Math.sin(angle);
        const px2 = x + r2 * Math.cos(nextAngle);
        const py2 = y + r2 * Math.sin(nextAngle);

        if (i === 0) path.moveTo(px1, py1);
        const cpX = (px1 + px2) / 2 + Math.cos(angle+Math.PI/6)*r*0.1;
        const cpY = (py1 + py2) / 2 + Math.sin(angle+Math.PI/6)*r*0.1;
        path.quadraticCurveTo(cpX, cpY, px2, py2);
      }
      path.closePath();
      return path;
    }

    function drawOrganicHexBase(x, y, r, wobble) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);
      ctx.fillStyle = COLORS.bgDark; // Use dark background for base
      ctx.fill(path);
    }

    function drawOrganicHexDetail(x, y, r, variance, wobble) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);

      ctx.save();
      ctx.fillStyle = waxPattern;
      ctx.fill(path);
      ctx.fillStyle = `rgba(255, 220, 0, ${variance * 0.2})`;
      ctx.fill(path);

      ctx.clip(path);
      const grad = ctx.createRadialGradient(x, y, 0, x, y, r*1.2);
      grad.addColorStop(0, 'rgba(255, 240, 150, 0.3)');
      grad.addColorStop(0.6, COLORS.waxBase);
      grad.addColorStop(1, COLORS.waxDeep);
      ctx.fillStyle = grad;
      ctx.fillRect(x-r*2, y-r*2, r*4, r*4);

      ctx.lineWidth = r * 0.1;
      ctx.strokeStyle = 'rgba(50, 20, 0, 0.5)';
      ctx.stroke(path);
      ctx.restore();

      ctx.lineCap = 'round';
      ctx.lineWidth = r * 0.15;
      ctx.strokeStyle = COLORS.hexBorderDark;
      ctx.stroke(path);

      const pathHighlight = getHexPath(x-r*0.02, y-r*0.05, r*0.98, wobble);
      ctx.lineWidth = r * 0.05;
      ctx.strokeStyle = COLORS.hexBorderLight;
      ctx.stroke(pathHighlight);
    }

    function drawBee(b) {
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);
      ctx.scale(b.sizeScale, b.sizeScale);

      const wingCycle = Math.sin(b.wobblePhase*1.5);

      // Legs/Antennae (Behind)
      ctx.strokeStyle = COLORS.beeBlack;
      ctx.lineCap = 'round';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, -3); ctx.lineTo(18, -6);
      ctx.moveTo(10,  3); ctx.lineTo(18,  6);
      ctx.stroke();
      ctx.fillStyle = COLORS.beeBlack;
      ctx.beginPath(); ctx.arc(18,-6, 2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(18, 6, 2, 0, Math.PI*2); ctx.fill();

      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(4, -6); ctx.lineTo(6, -12);
      ctx.moveTo(4,  6); ctx.lineTo(6,  12);
      ctx.stroke();

      // Thorax
      const thoraxGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
      thoraxGrad.addColorStop(0, COLORS.beeYellowBright);
      thoraxGrad.addColorStop(1, COLORS.beeYellowDark);
      ctx.fillStyle = thoraxGrad;
      ctx.beginPath();
      ctx.arc(0, 0, 10, 0, Math.PI*2);
      ctx.fill();

      // Head
      ctx.fillStyle = COLORS.beeBlack;
      ctx.beginPath();
      ctx.arc(12, 0, 6, 0, Math.PI*2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(14, -3, 3, 4, 0, 0, Math.PI*2);
      ctx.ellipse(14,  3, 3, 4, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(15, -4, 1.5, 0, Math.PI*2);
      ctx.arc(15,  2, 1.5, 0, Math.PI*2);
      ctx.fill();

      // Abdomen with stripes
      const abX = -12;
      const abY = 0;
      const abRX = 14;
      const abRY = 11;

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(abX, abY, abRX, abRY, 0, 0, Math.PI*2);
      ctx.clip();

      const abdomenGrad = ctx.createRadialGradient(abX, abY, 5, abX, abY, abRX);
      abdomenGrad.addColorStop(0, COLORS.beeYellowBright);
      abdomenGrad.addColorStop(1, COLORS.beeYellowDark);
      ctx.fillStyle = abdomenGrad;
      ctx.fill();

      ctx.fillStyle = COLORS.beeBlack;
      const stripeWidth = 4;
      const stripeSpacing = 4;
      let currentStripeX = abX + abRX - stripeWidth/2 - stripeSpacing;

      for(let i = 0; i < 3; i++) {
        ctx.fillRect(
          currentStripeX - stripeWidth,
          -abRY,
          stripeWidth,
          abRY * 2
        );
        currentStripeX -= (stripeWidth + stripeSpacing);
      }
      ctx.restore();

      // Wings
      const wingGrad = ctx.createLinearGradient(-10, -10, 10, 10);
      wingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      wingGrad.addColorStop(0.5, 'rgba(200, 255, 255, 0.5)');
      wingGrad.addColorStop(1, 'rgba(255, 200, 255, 0.8)');
      ctx.fillStyle = wingGrad;

      ctx.beginPath();
      ctx.ellipse(-4, -10, 16, 8, 0.3 + wingCycle * 0.4, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-4,  10, 16, 8, -0.3 - wingCycle * 0.4, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      });
    }

    let lastTime = 0;
    let timeSeconds = 0;
    function loop(timestamp) {
      requestAnimationFrame(loop);
      if (!gameRunning) return;

      timeSeconds = timestamp / 1000;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;
      update(dt);
      draw();
    }

    // Kickoff
    resize();
    loop(0);
  </script>

  <!-- Translation system wired exactly like the Window example -->
  <script src="../../js/translationmain.js"></script>
  <script>
    document.getElementById('langToggle')?.addEventListener('pointerup', toggleLanguage);
    document.addEventListener('DOMContentLoaded', updateLanguage);
  </script>
  <script src="../../js/translationonly.js"></script>
</body>
</html>
