<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title class="translate"
          data-fr="Trouve l’image — Pictos"
          data-en="Find the image — Icons">Trouve l’image — Pictos</title>

  <!-- Shared styles -->
  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    /* Lang toggle button */
    #langToggle {
      position: fixed;
      top: 10px; right: 10px;
      z-index: 99999;
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 10px; border: 2px solid #009688;
      background: #fff; color: #009688; font-weight: 700; cursor: pointer;
      user-select: none;
    }
    body.dark #langToggle { background:#111; color:#14b8a6; border-color:#14b8a6; }

    /* Themes */
    body.light { background-color: #fff; color: #000; }
    body.dark  { background-color: #000; color: #fff; }

    /* Game container */
    .game-container {
      width: 100%;
      max-width: 100vw;
      height: 100%;
      display: none;             /* shown after Start */
      padding: 12px;
      box-sizing: border-box;
    }

    .game-stage {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: row;
      align-items: stretch;
      justify-content: center;
      gap: clamp(16px, 3vw, 32px);
    }

    .reference-panel {
      flex: 0 0 clamp(260px, 32vw, 420px);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 16px;
    }

    .grid-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    /* Top strip card */
    .top-strip{
      width: 100%;
      padding: 14px 16px;
      border-radius: 14px;
      border: 2px solid rgba(0,0,0,0.12);
      box-shadow: 0 6px 20px rgba(0,0,0,0.06);
      transition: opacity 500ms ease;
      opacity: 1;

      display: none;
      flex: 0 0 auto;
      overflow: hidden;
      --top-cap: clamp(140px, 26vh, 320px);
      max-height: var(--top-cap);

      background: #ffffff;
    }
    .top-strip.fade-out { opacity: 0; }
    .top-strip.hidden{ display: none !important; }
    body.dark .top-strip{
      border-color: rgba(255,255,255,0.18);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      background: #ffffff;
    }

    .top-center{
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin: 0 auto;
    }

    #prompt{ margin:0; display:none; opacity:1; transition: opacity 500ms ease; }
    #prompt .prompt-text{
      font-size: clamp(1.25rem, 2.2vw, 1.6rem);
      font-weight: 800;
      color: #0f172a;
      line-height: 1.25;
      letter-spacing: .2px;
      text-wrap: balance;
    }

    .target-image{
      flex: 0 0 auto;
      width: min(30vmin, 260px);
      max-width: 260px;
      max-height: calc(var(--top-cap) - 24px);
      object-fit: contain;
      background: transparent;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.12));
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    .grid-outer{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 100%;
    }

    .phase-card {
      flex: 0 0 auto;
      padding: 18px;
      border-radius: 14px;
      border: 2px solid rgba(0,0,0,0.12);
      box-shadow: 0 6px 20px rgba(0,0,0,0.06);
      background: rgba(255,255,255,0.95);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    body.dark .phase-card {
      border-color: rgba(255,255,255,0.18);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      background: rgba(30,30,30,0.96);
    }
    .phase-label {
      font-weight: 800;
      font-size: clamp(1.1rem, 2.4vw, 1.6rem);
      margin: 0;
    }
    .phase-instruction {
      margin: 0;
      font-size: clamp(1rem, 1.9vw, 1.3rem);
      line-height: 1.4;
    }

    @media (max-width: 900px) {
      .game-stage {
        flex-direction: column;
        align-items: center;
      }
      .reference-panel {
        width: 100%;
        flex: 0 0 auto;
      }
      .grid-panel {
        width: 100%;
      }
      .top-center {
        flex-direction: row;
      }
    }

    .letter-grid {
      display: none;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      place-content: center;
      justify-items: stretch;
      align-items: stretch;
      margin: 0;
    }
    .letter-grid.no-input { pointer-events: none; }

    .letter-cell {
      position: relative;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;
      transform: translateZ(0);
      background-clip: padding-box;
      background-color: #fff;
      color: #000;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      opacity: 1;
      transition: opacity 500ms ease, transform 500ms ease, filter 500ms ease, background-color 300ms ease, box-shadow 250ms ease;
    }
    body.dark .letter-cell { background-color: #222; color: #fff; }

    .letter-cell.word-card {
      background: linear-gradient(135deg, rgba(20,184,166,0.16), rgba(13,148,136,0.28));
      border: 2px solid rgba(13,148,136,0.35);
      color: #0f172a;
      text-transform: uppercase;
    }
    body.dark .letter-cell.word-card {
      background: linear-gradient(135deg, rgba(14,116,144,0.35), rgba(13,148,136,0.35));
      border-color: rgba(94,234,212,0.35);
      color: #ecfeff;
    }
    .letter-cell.word-card .word-text {
      padding: 8px 14px;
      font-weight: 800;
      font-size: clamp(1.2rem, 3.8vw, 2.3rem);
      text-align: center;
      line-height: 1.2;
      text-wrap: balance;
    }
    .letter-cell.word-card.matched {
      background: linear-gradient(135deg, rgba(14,116,144,0.9), rgba(13,148,136,0.9));
      color: #ffffff;
      border-color: rgba(14,116,144,0.9);
    }

    .cell-img{
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    .letter-cell.dim {
      opacity: 0;
      transform: scale(0.92);
      filter: blur(1px);
    }

    .dwell-fill {
      position: absolute;
      background-color: rgba(255, 0, 0, 0.5);
      top: 50%; left: 50%;
      width: 0; height: 0;
      transform: translate(-50%, -50%);
      pointer-events: none;
      border-radius: 8px;
    }

    .flying-tile {
      position: fixed;
      left: 0; top: 0;
      transform: translate3d(0, 0, 0) scale(1);
      transform-origin: center center;

      z-index: 9999;
      pointer-events: none;
      border-radius: 12px;
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;
      background-color: inherit;
      color: inherit;
      backface-visibility: hidden;
      will-change: transform;
      contain: layout paint style;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

      display: flex;
      align-items: center;
      justify-content: center;
    }

    .letter-grid.grid-locked { pointer-events: none; }

    .naming-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.6);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(16px, 4vw, 40px);
      z-index: 120000;
    }
    body.dark .naming-overlay { background: rgba(15,23,42,0.75); }

    .naming-card {
      width: min(560px, 90vw);
      background: #ffffff;
      border-radius: 20px;
      padding: clamp(18px, 3vw, 32px);
      box-shadow: 0 24px 48px rgba(15,23,42,0.35);
      display: flex;
      flex-direction: column;
      gap: clamp(12px, 2.5vw, 24px);
      position: relative;
    }
    body.dark .naming-card {
      background: #0f172a;
      color: #f8fafc;
      box-shadow: 0 24px 48px rgba(0,0,0,0.55);
    }

    .naming-word {
      margin: 0;
      font-size: clamp(1.8rem, 4.2vw, 2.6rem);
      font-weight: 900;
      letter-spacing: 0.08em;
      text-align: center;
    }

    .naming-image {
      width: min(220px, 60%);
      margin: 0 auto;
      display: block;
      filter: drop-shadow(0 6px 16px rgba(15,23,42,0.2));
    }

    .syllable-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    .syllable-chip {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(13,148,136,0.15);
      color: #0f172a;
      font-weight: 600;
      font-size: clamp(1rem, 2.4vw, 1.2rem);
      letter-spacing: 0.04em;
    }
    body.dark .syllable-chip {
      background: rgba(94,234,212,0.18);
      color: #ecfeff;
    }

    .tracing-wrapper {
      display: flex;
      justify-content: center;
    }
    .tracing-svg {
      width: min(420px, 90%);
      height: clamp(120px, 18vw, 160px);
    }
    .tracing-svg text {
      fill: none;
      stroke: rgba(13,148,136,0.75);
      stroke-width: 3;
      font-size: clamp(72px, 10vw, 110px);
      font-family: 'Montserrat', 'Nunito', sans-serif;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    body.dark .tracing-svg text {
      stroke: rgba(94,234,212,0.8);
    }

    .naming-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }
    .naming-button {
      border: none;
      border-radius: 999px;
      padding: 10px 22px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 150ms ease, box-shadow 200ms ease;
    }
    .naming-button.primary {
      background: linear-gradient(135deg, #0f766e, #0d9488);
      color: #fff;
      box-shadow: 0 10px 20px rgba(13,148,136,0.35);
    }
    .naming-button.secondary {
      background: rgba(15,118,110,0.12);
      color: #0f172a;
    }
    body.dark .naming-button.secondary {
      background: rgba(94,234,212,0.15);
      color: #ecfeff;
    }
    .naming-button:active { transform: scale(0.97); }

    .naming-clone {
      z-index: 119000;
    }
    .letter-grid.grid-locked .letter-cell {
      opacity: .35;
      filter: grayscale(70%);
      transition: opacity 250ms ease, filter 250ms ease;
    }
    @keyframes readyPop {
      0% { transform: scale(.98); }
      100% { transform: scale(1); }
    }
    .letter-grid.ready-pop .letter-cell { animation: readyPop 220ms ease; }

    /* Reduced-motion wrong feedback */
    @media (prefers-reduced-motion: reduce) {
      .letter-cell.wrong-flash { box-shadow: inset 0 0 0 3px rgba(198,40,40,.5); }
    }
  </style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>
<body>

<button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

<!-- Options -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title" class="translate"
        data-fr="Trouve l’image — Pictos"
        data-en="Find the image — Icons">Trouve l’image — Pictos</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Col 1: Audio + TTS -->
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span class="translate" data-fr="Désactiver les sons" data-en="Disable sounds">Désactiver les sons</span>
          </label>
        </div>

        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="ttsEnabled">
            <span class="translate" data-fr="Lecture vocale" data-en="Voice reading (TTS)">Lecture vocale</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span class="translate" data-fr="Volume des sons:" data-en="Sound volume:">Volume des sons:</span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Col 2: Category + choices -->
      <div class="options-column">
        <div class="option-item">
          <label for="categorySelect" class="teal-label label-block translate"
                 data-fr="Catégorie" data-en="Category">Catégorie</label>
          <select id="categorySelect" class="styled-select"></select>
        </div>

        <div class="option-item">
          <label for="choicesCount" class="teal-label">
            <span class="translate" data-fr="Nombre de choix:" data-en="Number of choices:">Nombre de choix:</span>
            <span id="choicesCountVal">2</span>
          </label>
          <input type="range" id="choicesCount" class="styled-slider" min="1" max="9" step="1" value="2">
        </div>
      </div>

      <!-- Col 3: Dwell + layout scale + theme -->
      <div class="options-column">
        <div class="option-item">
          <label for="dwellTimeSlider" class="teal-label">
            <span class="translate" data-fr="Temps de fixation:" data-en="Dwell time:">Temps de fixation:</span>
            <span id="dwellTimeVal">1500</span> ms
          </label>
          <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="5000" step="100" value="1500">
        </div>
        <div class="option-item">
          <label for="layoutScale" class="teal-label">
            <span class="translate" data-fr="Mise en page (taille):" data-en="Layout scale:">Mise en page (taille):</span>
            <span id="layoutScaleVal"> 1.00</span>x
          </label>
          <input type="range" id="layoutScale" class="styled-slider" min="0.8" max="1.4" step="0.05" value="1.0">
        </div>
        <div class="option-item">
          <label for="themeSelect" class="teal-label label-block translate"
                 data-fr="Mode" data-en="Theme">Mode</label>
          <select id="themeSelect" class="styled-select">
            <option value="light" selected class="translate" data-fr="Clair" data-en="Light">Clair</option>
            <option value="dark" class="translate" data-fr="Sombre" data-en="Dark">Sombre</option>
          </select>
        </div>

        <div class="option-item gp-compact">
          <label class="teal-label">
            <input type="checkbox" id="showGazePointer" checked>
            <span class="translate" data-fr="Afficher le pointeur (cache la souris)" data-en="Show gaze pointer (hide mouse)">
              Afficher le pointeur (cache la souris)
            </span>
          </label>

          <details id="gpDetails">
            <summary class="gp-summary">
              <span class="translate" data-fr="Options avancées du pointeur" data-en="Pointer advanced options">
                Options avancées du pointeur
              </span>
            </summary>

            <div class="gp-advanced">
              <div class="gp-row">
                <label for="gazeSize" class="teal-label gp-label">
                  <span class="translate" data-fr="Taille" data-en="Size">Taille</span>:
                  <span id="gazeSizeVal">36</span> px
                </label>
                <input type="range" id="gazeSize" class="styled-slider gp-range" min="16" max="100" step="2" value="36">
              </div>

              <div class="gp-row">
                <label for="gazeOpacity" class="teal-label gp-label">
                  <span class="translate" data-fr="Opacité" data-en="Opacity">Opacité</span>:
                  <span id="gazeOpacityVal">100</span>%
                </label>
                <input type="range" id="gazeOpacity" class="styled-slider gp-range" min="20" max="100" step="5" value="100">
              </div>
            </div>
          </details>
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
  </div>
</div>

<!-- Game area -->
<div class="game-container">
  <div class="game-stage">
    <div class="reference-panel">
      <div id="topStrip" class="top-strip">
        <div class="top-center">
          <h2 id="prompt">
            <span class="prompt-text">
              <span id="promptLead" class="translate" data-fr="Trouve" data-en="Find">Trouve</span>
              &nbsp;<span id="promptWord">…</span>
            </span>
          </h2>
          <img id="targetImage" class="target-image" alt="">
        </div>
      </div>
      <div class="phase-card" id="phaseCard">
        <p class="phase-label" id="phaseLabel"></p>
        <p class="phase-instruction" id="phaseInstruction"></p>
      </div>
    </div>
    <div class="grid-panel">
      <div class="grid-outer">
        <div class="letter-grid" id="imageGrid"></div>
      </div>
    </div>
  </div>
</div>

<div id="gazePointer" aria-hidden="true"></div>

<!-- Audio -->
<audio id="correctSound" src="../../sounds/victory.mp3"></audio>
<audio id="wrongSound"   src="../../sounds/error.mp3"></audio>

<!-- Helpers -->
<script src="../../js/eyegaze-menu.js"></script>
<script src="../../js/translationmain.js"></script>

<script>
/* =========================================================
   EARLY GLOBALS (avoid TDZ for pictosData)
   ========================================================= */
var pictosData = null; // declare first so setLang() can safely read/guard it

/* =========================
   Language — storage as source of truth
   ========================= */
const LS_LANG_KEY = 'siteLanguage';
const langToggle  = document.getElementById('langToggle');

function getLang(){
  try {
    const saved = localStorage.getItem(LS_LANG_KEY);
    if (saved === 'en' || saved === 'fr') return saved;
  } catch(e){}
  return (document.documentElement.lang === 'en') ? 'en' : 'fr';
}

function setLang(lang){
  const safe = (lang === 'en') ? 'en' : 'fr';
  document.documentElement.lang = safe;
  try { localStorage.setItem(LS_LANG_KEY, safe); } catch(e){}
  document.querySelectorAll('.translate').forEach(el=>{
    const fr = el.getAttribute('data-fr');
    const en = el.getAttribute('data-en');
    if (safe === 'fr' && fr != null) el.textContent = fr;
    if (safe === 'en' && en != null) el.textContent = en;
  });
  // Only repopulate categories if data is loaded
  if (window.pictosData) {
    populateCategoriesSelect(document.getElementById('categorySelect').value);
  }
  updatePhaseCard();
  if (isGameActive()) {
    nextRound(false);
  }
}

/* Normalize once on load */
(function normalizeLangOnLoad(){
  let initial = 'fr';
  try {
    const saved = localStorage.getItem(LS_LANG_KEY);
    if (saved === 'en' || saved === 'fr') {
      initial = saved;
    } else {
      initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
      localStorage.setItem(LS_LANG_KEY, initial);
    }
  } catch(e){
    initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
  }
  setLang(initial);
})();

langToggle.addEventListener('click', ()=>{
  setLang(getLang()==='fr' ? 'en' : 'fr');
  choosePreferredVoice();
});

/* =========================
   Load pictos (new JSON with {label, items})
   ========================= */
const PICTOS_JSON_PATH = '../../images/pictos/oelwein.json';

function populateCategoriesSelect(preserveKey){
  const select = document.getElementById('categorySelect');
  if (!select || !pictosData) return;
  const lang = getLang();
  const prev = preserveKey || select.value;
  select.innerHTML = '';
  Object.entries(pictosData.categories).forEach(([key, obj])=>{
    const opt = document.createElement('option');
    opt.value = key;
    const lbl = obj.label?.[lang] || obj.label?.fr || obj.label?.en || key;
    opt.textContent = lbl;
    select.appendChild(opt);
  });
  if (prev && pictosData.categories[prev]) select.value = prev;
}

fetch(PICTOS_JSON_PATH)
  .then(r => r.json())
  .then(data => {
    pictosData = data;
    populateCategoriesSelect();
  })
  .catch(err => console.error('Erreur JSON pictos:', err));

/* =========================
   UI bindings
   ========================= */
const muteSFX      = document.getElementById('muteSFX');
const sfxVol       = document.getElementById('sfxVol');
const sfxVolVal    = document.getElementById('sfxVolVal');
const dwellSlider  = document.getElementById('dwellTimeSlider');
const dwellTimeVal = document.getElementById('dwellTimeVal');
const themeSelect  = document.getElementById('themeSelect');
const startButton  = document.getElementById('startButton');
const ttsEnabled   = document.getElementById('ttsEnabled');
const choicesCountEl = document.getElementById('choicesCount');
const choicesCountVal= document.getElementById('choicesCountVal');

const layoutScaleEl = document.getElementById('layoutScale');
const layoutScaleVal= document.getElementById('layoutScaleVal');

const showGazePointer = document.getElementById('showGazePointer');
const gazeSize        = document.getElementById('gazeSize');
const gazeSizeVal     = document.getElementById('gazeSizeVal');
const gazeOpacity     = document.getElementById('gazeOpacity');
const gazeOpacityVal  = document.getElementById('gazeOpacityVal');
const gpDetails       = document.getElementById('gpDetails');
const gazePointer     = document.getElementById('gazePointer');

function ensurePointerOverlay() {
  if (!gazePointer) return null;
  let overlay = document.getElementById('gazePointerOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'gazePointerOverlay';
    overlay.setAttribute('aria-hidden', 'true');
    overlay.style.position = 'fixed';
    overlay.style.inset = '0';
    overlay.style.pointerEvents = 'none';
    overlay.style.zIndex = '2147483647';
    overlay.style.overflow = 'visible';
    document.body.appendChild(overlay);
  }
  if (gazePointer.parentElement !== overlay) {
    overlay.appendChild(gazePointer);
  }
  return overlay;
}

ensurePointerOverlay();

sfxVol.addEventListener('input', () => sfxVolVal.textContent = sfxVol.value);
dwellSlider.addEventListener('input', () => dwellTimeVal.textContent = dwellSlider.value);
choicesCountEl.addEventListener('input', () => choicesCountVal.textContent = choicesCountEl.value);
layoutScaleEl.addEventListener('input', () => {
  layoutScaleVal.textContent = parseFloat(layoutScaleEl.value).toFixed(2);
  if (document.querySelector('.game-container').style.display === 'flex') {
    layoutScale = parseFloat(layoutScaleEl.value);
    adjustGridSizes();
  }
});

(function initPointerControls(){
  if (!gazePointer) return;

  try {
    const settings = window.eyegazeSettings;
    if (settings) {
      if (showGazePointer && typeof settings.showGazePointer === 'boolean') {
        showGazePointer.checked = settings.showGazePointer;
      }
      if (gazeSize && typeof settings.gazePointerSize === 'number') {
        const min = parseInt(gazeSize.min || '16', 10);
        const max = parseInt(gazeSize.max || '100', 10);
        const stored = Math.round(settings.gazePointerSize);
        if (!Number.isNaN(stored)) {
          gazeSize.value = Math.max(min, Math.min(max, stored));
        }
      }
      if (gazeOpacity && typeof settings.gazePointerAlpha === 'number') {
        const min = parseInt(gazeOpacity.min || '0', 10);
        const max = parseInt(gazeOpacity.max || '100', 10);
        const stored = Math.round(Math.max(0, Math.min(1, settings.gazePointerAlpha)) * 100);
        gazeOpacity.value = Math.max(min || 0, Math.min(max || 100, stored));
      }
    }
  } catch(e) {}

  applyPointerToggle();
  syncEyegazeSettingsFromUI();

  if (showGazePointer) {
    showGazePointer.addEventListener('change', () => {
      applyPointerToggle();
      syncEyegazeSettingsFromUI();
    });
  }

  [gazeSize, gazeOpacity].forEach(ctrl => {
    if (!ctrl) return;
    ctrl.addEventListener('input', () => {
      applyPointerToggle();
      syncEyegazeSettingsFromUI();
    });
  });
})();

/* =========================
   Persist TTS
   ========================= */
const LS_KEYS = { ttsEnabled: 'trouveimage:ttsEnabled' };
(function initPersistedControls(){
  try {
    const en = localStorage.getItem(LS_KEYS.ttsEnabled);
    if (en !== null) ttsEnabled.checked = (en === 'true');
  } catch(e){}
})();
ttsEnabled.addEventListener('change', () => {
  try { localStorage.setItem(LS_KEYS.ttsEnabled, String(ttsEnabled.checked)); } catch(e){}
});

/* =========================
   Game state
   ========================= */
let currentCategory = null;
let pool = [];
let targetItem = null;
let isReady = false;
let layoutScale = 1.0;
let phase = 'matching';
let matchedTargetCount = 0;
let namingOverlayEl = null;
let namingClone = null;
let customAudioPlayer = null;

const PHASE_COPY = {
  matching: {
    fr: {
      label: 'Étape 1 · Associer',
      instruction: 'Regarde et sélectionne les deux cartes identiques.',
      promptLead: 'Associe'
    },
    en: {
      label: 'Step 1 · Match',
      instruction: 'Look and select the two matching cards.',
      promptLead: 'Match'
    }
  },
  selecting: {
    fr: {
      label: 'Étape 2 · Choisir',
      instruction: 'Trouve l’image qui correspond au mot.',
      promptLead: 'Choisis'
    },
    en: {
      label: 'Step 2 · Select',
      instruction: 'Find the picture that matches the word.',
      promptLead: 'Select'
    }
  },
  naming: {
    fr: {
      label: 'Étape 3 · Nommer',
      instruction: 'Dis le mot avec l’enfant puis appuie sur Terminé.',
      promptLead: 'Nommer'
    },
    en: {
      label: 'Step 3 · Name',
      instruction: 'Say the word together, then press Done.',
      promptLead: 'Name'
    }
  }
};

function phaseCopy(phaseKey, lang){
  const safePhase = PHASE_COPY[phaseKey] ? phaseKey : 'matching';
  const safeLang = (lang === 'en') ? 'en' : 'fr';
  return PHASE_COPY[safePhase][safeLang] || PHASE_COPY[safePhase].fr;
}

function updatePhaseCard(){
  const lang = getLang();
  const copy = phaseCopy(phase, lang);
  const labelEl = document.getElementById('phaseLabel');
  const instructionEl = document.getElementById('phaseInstruction');
  if (labelEl) labelEl.textContent = copy.label;
  if (instructionEl) instructionEl.textContent = copy.instruction;
  const leadEl = document.getElementById('promptLead');
  if (leadEl) leadEl.textContent = copy.promptLead;
}

/* pointer-in-tile unlock */
let hoveredTile = null;
let lastPointer = { x: null, y: null };

function pointerSizeFromControls() {
  return parseInt(gazeSize?.value, 10) || 36;
}

function pointerOpacityFromControls() {
  const raw = parseInt(gazeOpacity?.value, 10);
  return Math.max(0, Math.min(1, (isNaN(raw) ? 100 : raw) / 100));
}

function setPointerPos(x, y) {
  if (!gazePointer) return;
  gazePointer.style.left = `${x}px`;
  gazePointer.style.top = `${y}px`;
}

function setPointerDwell(active) {
  if (!gazePointer) return;
  gazePointer.classList.toggle('gp-dwell', !!active);
}

function isGameActive() {
  return document.querySelector('.game-container')?.style.display === 'flex';
}

function applyPointerToggle() {
  if (!gazePointer) return;
  const size = pointerSizeFromControls();
  const opct = pointerOpacityFromControls();
  if (gazeSizeVal) gazeSizeVal.textContent = size;
  if (gazeOpacityVal) gazeOpacityVal.textContent = Math.round(opct * 100);
  gazePointer.style.setProperty('--gp-size', `${size}px`);
  const enable = !!showGazePointer?.checked && isGameActive();
  document.documentElement.classList.toggle('hide-native-cursor', enable);
  if (!enable) {
    setPointerDwell(false);
    if (gpDetails) gpDetails.open = false;
  }
  gazePointer.style.opacity = enable ? opct : 0;
  if (enable && lastPointer.x !== null && lastPointer.y !== null) {
    setPointerPos(lastPointer.x, lastPointer.y);
  }
}

if (gazePointer) {
  const rawHandler = (event) => {
    lastPointer.x = event.clientX;
    lastPointer.y = event.clientY;
    setPointerPos(event.clientX, event.clientY);
  };

  if ('onpointerrawupdate' in window) {
    window.addEventListener('pointerrawupdate', rawHandler, { passive: true });
  }
  window.addEventListener('pointermove', rawHandler, { passive: true });

  window.addEventListener('pointerleave', () => {
    gazePointer._savedOpacity = gazePointer.style.opacity;
    gazePointer.style.opacity = 0;
  });

  window.addEventListener('pointerenter', () => {
    applyPointerToggle();
    if (lastPointer.x !== null && lastPointer.y !== null) {
      setPointerPos(lastPointer.x, lastPointer.y);
    }
  });
}
const cellItemMap = new WeakMap();
let matchedTileSet = new WeakSet();

const EDGE_PAD = 10;
const MIN_TILE = 96;
const GAP_MIN  = 80;
const GAP_MAX  = 120;

const correctAudio = document.getElementById('correctSound');
const wrongAudio   = document.getElementById('wrongSound');

/* Theme */
function applyTheme(theme) {
  document.body.classList.remove('light','dark');
  document.body.classList.add(theme);
}

/* =========================
   Label helpers (FR elision + EN join)
   ========================= */
function joinFr(article, word){
  const a = (article || '').trim();
  const w = (word || '').trim();
  if (!a) return w;
  if (!w) return a;
  const endsWithApo = /[’'ʼ]$/.test(a);
  return endsWithApo ? (a + w) : (a + ' ' + w);
}
function joinEn(article, word){
  const a = (article || '').trim();
  const w = (word || '').trim();
  return [a, w].filter(Boolean).join(' ');
}
function labelFor(item, lang){
  const lab = (lang === 'en') ? item.label?.en : item.label?.fr;
  if (!lab) return '';
  return (lang === 'en')
    ? joinEn(lab.article, lab.word)
    : joinFr(lab.article, lab.word);
}

function wordUpperFor(item, lang){
  if (!item) return '';
  const langKey = (lang === 'en') ? 'en' : 'fr';
  const upper = item.wordUpper?.[langKey] || item.wordUpper?.fr || item.wordUpper?.en;
  if (upper) return upper;
  const base = labelFor(item, lang);
  return base ? base.toUpperCase() : '';
}

function syllablesFor(item, lang){
  if (!item) return [];
  const langKey = (lang === 'en') ? 'en' : 'fr';
  const raw = item.syllables?.[langKey] || item.syllables?.fr || item.syllables?.en;
  if (Array.isArray(raw) && raw.length) return raw;
  const base = labelFor(item, lang);
  return base ? [base] : [];
}

/* =========================
   TTS
   ========================= */
let TTS_TROUVE_GAP_MS = 0; // 0ms => say as one utterance

let preferredVoice = null;
function choosePreferredVoice() {
  const ss = window.speechSynthesis;
  if (!ss || !ss.getVoices) return;
  const voices = ss.getVoices() || [];
  if (!voices.length) return;

  const lang = getLang();
  const by = (fn) => voices.find(fn);
  if (lang === 'fr') {
    preferredVoice =
      by(v => /sylvie/i.test(v.name || '') && /^fr[-_]?CA/i.test(v.lang || '')) ||
      by(v => /^fr[-_]?CA/i.test(v.lang || '')) ||
      by(v => /^fr[-_]?FR/i.test(v.lang || '')) ||
      by(v => (v.lang || '').toLowerCase().startsWith('fr')) ||
      voices[0];
  } else {
    preferredVoice =
      by(v => /^en[-_]?CA/i.test(v.lang || '')) ||
      by(v => /^en[-_]?US/i.test(v.lang || '')) ||
      by(v => /^en[-_]?GB/i.test(v.lang || '')) ||
      by(v => (v.lang || '').toLowerCase().startsWith('en')) ||
      voices[0];
  }
}
function makeUtterance(text) {
  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;
  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number') ? sfxSetting : (isNaN(uiVol) ? 50 : uiVol);
  const volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));

  const u = new SpeechSynthesisUtterance(text);
  if (preferredVoice) { u.voice = preferredVoice; u.lang = preferredVoice.lang || (getLang()==='fr'?'fr-CA':'en-US'); }
  else { u.lang = (getLang()==='fr'?'fr-CA':'en-US'); }
  u.rate = 1.0;
  u.volume = volume;
  return u;
}
function voicesReady() {
  return new Promise((resolve) => {
    const ss = window.speechSynthesis;
    if (!ss) return resolve();
    const v = ss.getVoices();
    if (v && v.length) return resolve();
    const onChange = () => { ss.removeEventListener('voiceschanged', onChange); resolve(); };
    ss.addEventListener('voiceschanged', onChange);
  });
}
async function speakSequence(texts, gapMs = 0) {
  if (!('speechSynthesis' in window)) return;
  try { speechSynthesis.cancel(); } catch(e) {}
  await voicesReady();
  choosePreferredVoice();

  if (gapMs <= 0 && texts.length === 2) {
    const u = makeUtterance(`${texts[0]} ${texts[1]}`);
    speechSynthesis.speak(u);
    return;
  }
  texts.forEach((t) => {
    const u = makeUtterance(t);
    speechSynthesis.speak(u);
  });
}
if ('speechSynthesis' in window) {
  speechSynthesis.addEventListener('voiceschanged', choosePreferredVoice);
  choosePreferredVoice();
}

const TIMING = {
  glide: 3800,
  grow: 2600
};

function speakPromptForItem(item){
  const enabled = !!ttsEnabled.checked || !!(window.eyegazeSettings?.ttsEnabled);
  if (!enabled || !item) return;

  const lang = getLang();
  const copy = phaseCopy(phase, lang);
  const noun = (phase === 'selecting') ? labelFor(item, lang) : wordUpperFor(item, lang);
  speakSequence([copy.promptLead, noun], TTS_TROUVE_GAP_MS);
}

/* =========================
   Lock / unlock
   ========================= */
function lockGrid() {
  const grid = document.getElementById('imageGrid');
  isReady = false;
  stopHover();
  if (grid) grid.classList.add('grid-locked');
}
function unlockGrid() {
  const grid = document.getElementById('imageGrid');
  isReady = true;
  if (grid) {
    grid.classList.remove('grid-locked');
    grid.classList.add('ready-pop');
    setTimeout(() => grid.classList.remove('ready-pop'), 260);
  }
  if (lastPointer.x !== null && lastPointer.y !== null) {
    const el = document.elementFromPoint(lastPointer.x, lastPointer.y);
    const tile = el && (el.closest ? el.closest('.letter-cell') : null);
    if (tile) {
      hoveredTile = tile;
      const item = cellItemMap.get(tile);
      if (item) startHover(tile, item);
    }
  }
}

/* =========================
   Start
   ========================= */
function startGame() {
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.webkitRequestFullscreen) {
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) {
    document.documentElement.msRequestFullscreen();
  }

  langToggle.style.display = 'none';

  syncEyegazeSettingsFromUI();

  applyTheme(themeSelect.value);
  layoutScale = parseFloat(layoutScaleEl.value) || 1.0;

  currentCategory = document.getElementById('categorySelect').value;

  if (!pictosData || !pictosData.categories[currentCategory]) {
    alert(getLang()==='fr' ? 'Catégorie non disponible.' : 'Category not available.');
    return;
  }
  const base = pictosData.base || '';
  const items = pictosData.categories[currentCategory].items || [];
  pool = items.map(entry => ({
    file: entry.file,
    label: entry.label,
    wordUpper: entry.wordUpper || null,
    syllables: entry.syllables || null,
    audio: entry.audio || null,
    tracingSvg: entry.tracingSvg || null,
    srcAbs: base + entry.file
  }));

  phase = 'matching';
  matchedTargetCount = 0;
  namingOverlayEl?.remove?.();
  namingOverlayEl = null;
  namingClone = null;
  targetItem = null;

  document.querySelector('.game-container').style.display = 'flex';
  document.getElementById('topStrip').style.display = 'block';
  document.getElementById('prompt').style.display = 'block';

  const grid = document.getElementById('imageGrid');
  grid.style.display = 'grid';

  buildGridSkeleton();
  nextRound(true);

  try { if (window.eyegazeSettings?.hideOverlay) eyegazeSettings.hideOverlay(); } catch(e) {}
  choosePreferredVoice();
  applyPointerToggle();
}
startButton.addEventListener('click', startGame);

/* =========================
   Eyegaze sync
   ========================= */
function syncEyegazeSettingsFromUI() {
  try {
    if (window.eyegazeSettings) {
      eyegazeSettings.sfxMuted  = !!muteSFX.checked;
      eyegazeSettings.sfxVolume = parseInt(sfxVol.value, 10) || 50;
      eyegazeSettings.dwellTime = parseInt(dwellSlider.value, 10) || 1500;
      eyegazeSettings.ttsEnabled= !!ttsEnabled.checked;
      eyegazeSettings.showGazePointer  = !!showGazePointer?.checked;
      eyegazeSettings.gazePointerSize  = pointerSizeFromControls();
      eyegazeSettings.gazePointerAlpha = pointerOpacityFromControls();
    }
  } catch(e) {}
}

/* =========================
   Grid build / sizing
   ========================= */
function buildGridSkeleton(){
  const grid = document.getElementById('imageGrid');
  grid.innerHTML = '';
  const total = getDesiredChoicesCount();
  const columns = Math.min(3, Math.ceil(Math.sqrt(total))); // up to 3x3
  grid.dataset.columns = String(columns);
  grid.style.padding = EDGE_PAD + 'px';

  for (let i=0;i<total;i++){
    const cell = document.createElement('div');
    cell.className = 'letter-cell';
    grid.appendChild(cell);
  }
  adjustGridSizes();
}

window.addEventListener('resize', adjustGridSizes);
document.getElementById('targetImage').addEventListener('load', adjustGridSizes);
window.addEventListener('orientationchange', adjustGridSizes);

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape' && namingOverlayEl) {
    event.preventDefault();
    handleNamingDone();
  }
});

function adjustGridSizes() {
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  const grid = document.getElementById('imageGrid');
  const outer = grid.parentElement;
  const cells = grid.querySelectorAll('.letter-cell');
  if (!cells.length || !outer) return;

  const columns = parseInt(grid.dataset.columns || '3', 10);
  const rows    = Math.ceil(cells.length / columns);

  const containerW = grid.clientWidth;

  // Height available below the strip, stable
  const outerRect = outer.getBoundingClientRect();
  const containerH = Math.max(0, window.innerHeight - outerRect.top - 8);

  const contentW = Math.max(0, containerW - 2 * EDGE_PAD);
  const contentH = Math.max(0, containerH - 2 * EDGE_PAD);
  const contentMin = Math.min(contentW, contentH);

  let GAP = Math.round((contentMin * 0.02) / Math.max(0.8, layoutScale));
  GAP = clamp(GAP, GAP_MIN, GAP_MAX);
  grid.style.gap = GAP + 'px';

  const sizeByW = (contentW - (columns - 1) * GAP) / columns;
  const SAFETY = 8;
  const sizeByH = ((contentH - (rows - 1) * GAP) / rows) - SAFETY;

  const candidate = Math.floor(Math.min(sizeByW, sizeByH));
  const size = Math.max(MIN_TILE, Math.min(candidate, Math.floor(candidate * layoutScale)));

  const track = size + 'px';
  grid.style.gridTemplateColumns = `repeat(${columns}, ${track})`;
  grid.style.gridAutoRows        = track;
}

/* =========================
   Round
   ========================= */
function nextRound(forceNewWord = false){
  if (!pool.length) return;

  const strip = document.getElementById('topStrip');
  strip?.classList.remove('hidden','fade-out');

  if (!targetItem || forceNewWord) {
    targetItem = pickRandom(pool);
    matchedTargetCount = 0;
  }

  const lang = getLang();
  const promptWordEl = document.getElementById('promptWord');
  if (promptWordEl) {
    const showUpper = (phase !== 'selecting');
    promptWordEl.textContent = showUpper ? wordUpperFor(targetItem, lang) : labelFor(targetItem, lang);
  }

  const targetImage = document.getElementById('targetImage');
  if (targetImage) {
    targetImage.src = targetItem.srcAbs;
    targetImage.alt = labelFor(targetItem, lang);
  }

  updatePhaseCard();

  if (phase !== 'naming') {
    if (namingOverlayEl) { namingOverlayEl.remove(); namingOverlayEl = null; }
    if (namingClone) { namingClone.remove(); namingClone = null; }
    if (customAudioPlayer) { try { customAudioPlayer.pause(); } catch(e){} customAudioPlayer = null; }
  }

  const grid = document.getElementById('imageGrid');
  if (!grid) return;
  grid.classList.remove('no-input', 'grid-locked');
  grid.innerHTML = '';

  if (phase === 'matching') {
    renderMatchingPhase();
  } else if (phase === 'selecting') {
    renderSelectingPhase();
  } else {
    renderNamingPhase();
  }
}

function renderMatchingPhase() {
  const grid = document.getElementById('imageGrid');
  if (!grid || !targetItem) return;

  matchedTileSet = new WeakSet();
  matchedTargetCount = 0;

  stopHover();
  isReady = false;

  grid.classList.remove('no-input');
  grid.style.display = 'grid';
  grid.style.padding = EDGE_PAD + 'px';

  const lang = getLang();
  const distractorPool = pool.filter(entry => entry.file !== targetItem.file);
  const tiles = [
    { item: targetItem, role: 'target' },
    { item: targetItem, role: 'target' }
  ];
  if (distractorPool.length) {
    tiles.push({ item: pickRandom(distractorPool), role: 'distractor' });
  }

  const columns = Math.min(tiles.length, 3);
  grid.dataset.columns = String(Math.max(columns, 1));

  shuffle(tiles).forEach(meta => {
    const cell = document.createElement('div');
    cell.className = 'letter-cell word-card';
    cell.dataset.matchRole = meta.role;

    const label = document.createElement('span');
    label.className = 'word-text';
    label.textContent = wordUpperFor(meta.item, lang);
    cell.appendChild(label);

    cellItemMap.set(cell, meta.item);

    cell.addEventListener('pointerenter', () => {
      hoveredTile = cell;
      if (isReady) startHover(cell, meta.item);
    });
    cell.addEventListener('pointerleave', () => {
      if (hoveredTile === cell) hoveredTile = null;
      stopHover();
    });

    grid.appendChild(cell);
  });

  adjustGridSizes();
  isReady = true;
  speakPromptForItem(targetItem);
}

function renderSelectingPhase() {
  const grid = document.getElementById('imageGrid');
  if (!grid || !targetItem) return;

  stopHover();
  grid.classList.remove('no-input');
  grid.style.display = 'grid';
  grid.style.padding = EDGE_PAD + 'px';

  const lang = getLang();
  const total = Math.max(3, getDesiredChoicesCount());
  const distractorPool = pool.filter(entry => entry.file !== targetItem.file);
  const distractors = pickNDistinct(distractorPool, Math.min(total - 1, distractorPool.length));
  const tiles = shuffle([targetItem, ...distractors]);

  const columns = Math.min(3, Math.ceil(Math.sqrt(tiles.length)));
  grid.dataset.columns = String(Math.max(columns, 1));

  tiles.forEach(item => {
    const cell = document.createElement('div');
    cell.className = 'letter-cell';

    const img = document.createElement('img');
    img.src = item.srcAbs;
    img.alt = labelFor(item, lang);
    img.className = 'cell-img';
    cell.appendChild(img);

    cellItemMap.set(cell, item);

    cell.addEventListener('pointerenter', () => {
      hoveredTile = cell;
      if (isReady) startHover(cell, item);
    });
    cell.addEventListener('pointerleave', () => {
      if (hoveredTile === cell) hoveredTile = null;
      stopHover();
    });

    grid.appendChild(cell);
  });

  lockGrid();
  speakPromptForItem(targetItem);
  adjustGridSizes();

  setTimeout(unlockGrid, 2000);
}

function renderNamingPhase() {
  stopHover();
  isReady = false;
  const grid = document.getElementById('imageGrid');
  if (grid) {
    grid.classList.add('no-input');
    grid.innerHTML = '';
  }
  if (namingClone) namingClone.classList.add('naming-clone');
  showNamingOverlay(targetItem);
}

function advancePhase() {
  if (phase === 'matching') {
    phase = 'selecting';
    nextRound();
  } else if (phase === 'selecting') {
    phase = 'naming';
    nextRound();
  } else {
    phase = 'matching';
    matchedTileSet = new WeakSet();
    nextRound(true);
  }
}

function playWordAudio(item) {
  if (!item) return;
  if (customAudioPlayer) {
    try { customAudioPlayer.pause(); } catch(e){}
    customAudioPlayer = null;
  }
  const lang = getLang();
  const audioPath = item.audio?.[lang] || item.audio?.fr || item.audio?.en;
  if (audioPath) {
    try {
      const audio = new Audio(audioPath);
      audio.play().catch(()=>{});
      customAudioPlayer = audio;
      return;
    } catch(e) {}
  }
  const enabled = !!ttsEnabled.checked || !!(window.eyegazeSettings?.ttsEnabled);
  if (enabled) {
    speakSequence([wordUpperFor(item, lang)], 0);
  }
}

function showNamingOverlay(item) {
  if (!item) return;
  if (namingOverlayEl) namingOverlayEl.remove();

  const lang = getLang();
  const overlay = document.createElement('div');
  overlay.className = 'naming-overlay';

  const card = document.createElement('div');
  card.className = 'naming-card';

  const wordEl = document.createElement('p');
  wordEl.className = 'naming-word';
  wordEl.textContent = wordUpperFor(item, lang);
  card.appendChild(wordEl);

  const img = document.createElement('img');
  img.className = 'naming-image';
  img.src = item.srcAbs;
  img.alt = labelFor(item, lang);
  card.appendChild(img);

  const syllableRow = document.createElement('div');
  syllableRow.className = 'syllable-row';
  syllablesFor(item, lang).forEach(segment => {
    const chip = document.createElement('span');
    chip.className = 'syllable-chip';
    chip.textContent = segment;
    syllableRow.appendChild(chip);
  });
  card.appendChild(syllableRow);

  const tracingWrapper = document.createElement('div');
  tracingWrapper.className = 'tracing-wrapper';
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.classList.add('tracing-svg');
  svg.setAttribute('viewBox', '0 0 600 200');
  const text = document.createElementNS(svgNS, 'text');
  text.setAttribute('x', '50%');
  text.setAttribute('y', '50%');
  text.textContent = wordUpperFor(item, lang);
  svg.appendChild(text);
  tracingWrapper.appendChild(svg);
  card.appendChild(tracingWrapper);

  const actions = document.createElement('div');
  actions.className = 'naming-actions';

  const playBtn = document.createElement('button');
  playBtn.className = 'naming-button secondary';
  playBtn.type = 'button';
  playBtn.textContent = (lang === 'fr') ? 'Écouter encore' : 'Play again';
  playBtn.addEventListener('click', () => playWordAudio(item));
  actions.appendChild(playBtn);

  const doneBtn = document.createElement('button');
  doneBtn.className = 'naming-button primary';
  doneBtn.type = 'button';
  doneBtn.textContent = (lang === 'fr') ? 'Terminé' : 'Done';
  doneBtn.addEventListener('click', handleNamingDone);
  actions.appendChild(doneBtn);

  card.appendChild(actions);
  overlay.appendChild(card);

  namingOverlayEl = overlay;
  document.body.appendChild(overlay);

  requestAnimationFrame(() => {
    try { doneBtn.focus(); } catch(e){}
  });

  playWordAudio(item);
}

function handleNamingDone() {
  if (customAudioPlayer) {
    try { customAudioPlayer.pause(); } catch(e){}
    customAudioPlayer = null;
  }
  if (namingOverlayEl) { namingOverlayEl.remove(); namingOverlayEl = null; }
  if (namingClone) { namingClone.remove(); namingClone = null; }
  advancePhase();
}

/* =========================
   Dwell
   ========================= */
let currentOverlay;
let hoverTimeout;

function startHover(tile, item) {
  if (!isReady) return;

  const hoverTime = (window.eyegazeSettings?.dwellTime) || parseInt(dwellSlider.value, 10) || 1500;

  stopHover();
  setPointerDwell(true);
  currentOverlay = document.createElement('div');
  currentOverlay.className = 'dwell-fill';
  tile.appendChild(currentOverlay);

  requestAnimationFrame(() => {
    currentOverlay.style.transition = `width ${hoverTime}ms linear, height ${hoverTime}ms linear`;
    currentOverlay.style.width = '0';
    currentOverlay.style.height = '0';
    requestAnimationFrame(() => {
      currentOverlay.style.width = '100%';
      currentOverlay.style.height = '100%';
    });
  });

  hoverTimeout = setTimeout(() => {
    handleSelection(tile, item);
    stopHover();
  }, hoverTime);
}

function stopHover() {
  clearTimeout(hoverTimeout);
  setPointerDwell(false);
  if (currentOverlay && currentOverlay.parentElement) currentOverlay.parentElement.removeChild(currentOverlay);
  currentOverlay = null;
}

/* =========================
   WRONG feedback (shake / flash / vibrate)
   ========================= */
function wrongFeedback(el){
  const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  if (prefersReduce) {
    el.classList.add('wrong-flash');
    setTimeout(() => el.classList.remove('wrong-flash'), 250);
  } else if (el.animate) {
    el.animate(
      [
        { transform: 'translateX(0)' },
        { transform: 'translateX(-10px)' },
        { transform: 'translateX(10px)' },
        { transform: 'translateX(-7px)' },
        { transform: 'translateX(7px)' },
        { transform: 'translateX(-4px)' },
        { transform: 'translateX(4px)' },
        { transform: 'translateX(0)' }
      ],
      { duration: 420, easing: 'ease' }
    );
    const prevShadow = el.style.boxShadow;
    el.style.boxShadow = 'inset 0 0 0 3px rgba(198,40,40,.45)';
    setTimeout(() => { el.style.boxShadow = prevShadow || ''; }, 420);
  } else {
    const prev = el.style.transform;
    el.style.transition = 'none';
    let i = 0;
    const seq = [0,-10,10,-7,7,-4,4,0];
    const tick = () => {
      el.style.transform = `translateX(${seq[i]}px)`;
      if (++i < seq.length) setTimeout(tick, 52);
      else { el.style.transform = prev || ''; el.style.transition = ''; }
    };
    tick();
  }
  try { if (navigator.vibrate) navigator.vibrate(60); } catch(e){}
}

/* =========================
   Selection
   ========================= */
function handleSelection(tile, item){
  if (phase === 'matching') {
    handleMatchingSelection(tile, item);
  } else if (phase === 'selecting') {
    handleSelectingSelection(tile, item);
  }
}

function handleMatchingSelection(tile, item) {
  if (!tile || !targetItem) return;
  const role = tile.dataset.matchRole;
  const isCorrect = role === 'target' && item && item.file === targetItem.file;
  if (!isCorrect) {
    playSound(wrongAudio);
    wrongFeedback(tile);
    return;
  }

  if (matchedTileSet.has(tile)) return;

  matchedTileSet.add(tile);
  matchedTargetCount += 1;
  playSound(correctAudio);
  tile.classList.add('matched');
  tile.style.pointerEvents = 'none';

  if (matchedTargetCount >= 2) {
    setTimeout(() => { if (phase === 'matching') advancePhase(); }, 500);
  }
}

function handleSelectingSelection(tile, item) {
  if (!tile || !item || !targetItem) return;
  const isCorrect = (item.file === targetItem.file);
  if (!isCorrect) {
    playSound(wrongAudio);
    wrongFeedback(tile);
    return;
  }

  stopHover();
  playSound(correctAudio);

  const grid  = document.getElementById('imageGrid');
  grid.classList.add('no-input');
  grid.querySelectorAll('.letter-cell').forEach(cell => { if (cell !== tile) cell.classList.add('dim'); });

  const startRect = tile.getBoundingClientRect();
  const dark = getComputedStyle(document.body).backgroundColor === 'rgb(0, 0, 0)';
  const bgColor = dark ? '#222' : '#fff';
  const textColor = dark ? '#fff' : '#000';
  tile.style.backgroundColor = bgColor;
  tile.style.color = textColor;

  requestAnimationFrame(() => {
    glideTileToCenter(tile, TIMING.glide, TIMING.grow, {bgColor, textColor}, startRect).then((clone) => {
      namingClone = clone;
      phase = 'naming';
      nextRound();
    });
  });
}

/* =========================
   Glide & grow — clamped to viewport
   ========================= */
function glideTileToCenter(tile, glideMs = 1200, growMs = 700, forcedColors, startRect) {
  return new Promise(resolve => {
    const r  = startRect || tile.getBoundingClientRect();
    const cs = getComputedStyle(tile);

    const clone = tile.cloneNode(true);
    clone.className = 'flying-tile';

    clone.style.width  = r.width + 'px';
    clone.style.height = r.height + 'px';
    clone.style.left   = r.left + 'px';
    clone.style.top    = r.top  + 'px';
    clone.style.transform = 'translate3d(0,0,0) scale(1)';
    clone.style.transformOrigin = 'center center';

    const bg = forcedColors?.bgColor || cs.backgroundColor;
    const fg = forcedColors?.textColor || cs.color;
    clone.style.backgroundColor = bg;
    clone.style.color           = fg;
    clone.style.borderRadius    = cs.borderRadius;
    clone.style.border          = cs.border;
    clone.style.boxShadow       = cs.boxShadow;

    const img = clone.querySelector('img');
    if (img) { img.style.width = '100%'; img.style.height = '100%'; img.style.objectFit = 'contain'; }

    document.body.appendChild(clone);

    tile.style.opacity = '0';
    tile.style.pointerEvents = 'none';

    const centerX = window.innerWidth  / 2;
    const centerY = window.innerHeight / 2;
    const dx = centerX - (r.left + r.width  / 2);
    const dy = centerY - (r.top  + r.height / 2);

    const margin = Math.max(16, Math.min(48, Math.round(Math.min(window.innerWidth, window.innerHeight) * 0.04)));
    const maxScaleW = (window.innerWidth  - margin * 2) / r.width;
    const maxScaleH = (window.innerHeight - margin * 2) / r.height;
    let targetScale = Math.min(2, maxScaleW, maxScaleH);
    targetScale = Math.max(1, targetScale);

    const growthFactor = Math.max(0, targetScale - 1);
    const adjustedGrowMs = Math.round(growMs * (0.45 + 0.55 * Math.min(1, growthFactor)));

    void clone.getBoundingClientRect();

    const a1 = clone.animate(
      [
        { transform: 'translate3d(0px, 0px, 0) scale(1)' },
        { transform: `translate3d(${dx}px, ${dy}px, 0) scale(1)` }
      ],
      { duration: glideMs, easing: 'cubic-bezier(.25,.8,.25,1)', fill: 'forwards' }
    );

    a1.onfinish = () => {
      const a2 = clone.animate(
        [
          { transform: `translate3d(${dx}px, ${dy}px, 0) scale(1)` },
          { transform: `translate3d(${dx}px, ${dy}px, 0) scale(${targetScale})` }
        ],
        { duration: adjustedGrowMs, easing: 'cubic-bezier(.2,.7,.2,1)', fill: 'forwards' }
      );
      a2.onfinish = () => resolve(clone);
    };
  });
}

/* Sounds */
function playSound(audioEl) {
  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;
  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number') ? sfxSetting : (isNaN(uiVol) ? 50 : uiVol);

  audioEl.volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));
  try { audioEl.currentTime = 0; audioEl.play(); } catch(e) {}

  setTimeout(() => { try { audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }, 2000);
}

/* Utils */
function pickRandom(arr){ return arr[Math.floor(Math.random() * arr.length)]; }
function shuffle(a){
  const arr = a.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function pickNDistinct(arr, n){
  const pool = arr.slice();
  const out = [];
  while (pool.length && out.length < n){
    const idx = Math.floor(Math.random() * pool.length);
    out.push(pool.splice(idx,1)[0]);
  }
  return out;
}
function getDesiredChoicesCount(){
  const wanted = parseInt(choicesCountEl.value, 10) || 6;
  if (!pictosData || !pictosData.categories || !currentCategory) return Math.max(1, Math.min(9, wanted));
  const available = (pictosData.categories[currentCategory]?.items || []).length || wanted;
  return Math.max(1, Math.min(9, Math.min(wanted, available)));
}

/* Init voices on load */
window.addEventListener('load', choosePreferredVoice);
</script>
</body>
</html>
