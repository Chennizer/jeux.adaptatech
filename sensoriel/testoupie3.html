<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Dispersed Puzzle with Moana Background</title>
  <style>
    /* Ensure the page fills the entire viewport without scrollbars */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* No scrollbars */
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }

    /* Main container: side-by-side layout */
    .puzzle-container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      gap: 40px; /* Space between left and right areas */
      padding: 20px;
    }

    /* Left side: fixed area for scrambled pieces using grid for dispersion */
    #piecesArea {
      position: relative;
      width: 600px;   /* Adjusted for larger play zone */
      height: 600px;  /* Adjusted for larger play zone */
      background: #ddd;
      border: 2px solid #999;
      border-radius: 8px;
      overflow: hidden; /* Hide overflow */
      display: grid;
      grid-template-columns: repeat(3, 1fr); /* 3 columns */
      grid-template-rows: repeat(3, 1fr);    /* 3 rows */
      gap: 20px; /* Space between grid cells */
    }

    /* Right side: puzzle board = exactly 3Ã—3 slots of 130Ã—130 */
    #puzzleArea {
      width: 390px;   /* 3 columns Ã— 130px each */
      height: 390px;  /* 3 rows Ã— 130px each */
      background: #fff;
      border: 4px solid #000; /* Bold black border */
      border-radius: 8px;
      display: grid;
      grid-template-columns: repeat(3, 130px);
      grid-template-rows: repeat(3, 130px);
      gap: 0; /* Tight puzzle */
      box-sizing: content-box; /* Changed from border-box to content-box */
      position: relative;
    }

    /* Each puzzle slot = 130Ã—130 exactly */
    .slot {
      width: 130px;
      height: 130px;
      background: #e2e2e2;
      border: 1px solid #ccc;
      position: relative;
      overflow: hidden; 
      box-sizing: border-box;
    }

    /* All puzzle pieces = 130Ã—130 no matter where they are */
    .draggable-piece {
      width: 130px;
      height: 130px;
      cursor: grab;
      border: 2px solid transparent;
      border-radius: 4px;
      object-fit: cover;  
      position: absolute; /* Initial absolute positioning */
      touch-action: none; /* Prevent default touch actions */
      user-select: none; /* Prevent text selection */
    }

    .draggable-piece.active {
      opacity: 0.8;
      cursor: grabbing;
      z-index: 1000; /* Bring to front when dragging */
    }

    /* Hidden canvas for slicing the puzzle image */
    #hiddenCanvas {
      display: none;
    }

    /* Optional Title */
    h1 {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 1.5rem;
      color: #333;
    }

    /* Highlight indicator: add/remove this class on dragenter/dragleave */
    .highlight {
      outline: 3px dashed #00aaff; 
      outline-offset: -5px;
      background-color: rgba(0, 170, 255, 0.1); /* Subtle highlight */
    }
  </style>
</head>
<body>

  <h1>Enhanced Dispersed Puzzle with Moana Background</h1>

  <div class="puzzle-container">
    <!-- LEFT: area for scrambled pieces, using grid for dispersion -->
    <div id="piecesArea">
      <!-- Puzzle pieces will be inserted here -->
    </div>
    <!-- RIGHT: puzzle board (3Ã—3 slots of 130Ã—130) -->
    <div id="puzzleArea"></div>
  </div>

  <!-- Hidden canvas for slicing -->
  <canvas id="hiddenCanvas"></canvas>

  <script>
    /* 
       1) Use the specified image path.
          Ensure that "../../images/moana-background.jpg" is correct relative to this HTML file's location.
    */
    const puzzleImagePath = "../../images/moana-background.jpg";

    /* 
       2) Puzzle rows & columns (3x3). Each piece = 130Ã—130 in the final layout.
    */
    const ROWS = 3;
    const COLS = 3;
    const PIECE_SIZE = 130; // px

    let puzzlePieces = [];

    /* Grab DOM references */
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const piecesArea   = document.getElementById('piecesArea');
    const puzzleArea   = document.getElementById('puzzleArea');
    const ctx          = hiddenCanvas.getContext('2d');

    /* On page load, create the puzzle from the given image path */
    window.addEventListener('load', () => {
      const puzzleImage = new Image();
      puzzleImage.src = puzzleImagePath;
      puzzleImage.onload = () => createPuzzleFromImage(puzzleImage);
      puzzleImage.onerror = err => console.error("Image failed to load:", err);
    });

    /* Create puzzle by slicing the image into 3Ã—3 => 9 pieces */
    function createPuzzleFromImage(image) {
      // Clear old puzzle if any
      puzzleArea.innerHTML = "";
      piecesArea.innerHTML = "";
      puzzlePieces = [];

      // Slice the image via the hidden canvas
      hiddenCanvas.width = image.width;
      hiddenCanvas.height = image.height;
      ctx.drawImage(image, 0, 0);

      // Calculate piece dimensions from the source image
      const sourcePieceWidth  = image.width  / COLS;
      const sourcePieceHeight = image.height / ROWS;

      let pieceIndex = 0;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const pieceCanvas = document.createElement('canvas');
          pieceCanvas.width = sourcePieceWidth;
          pieceCanvas.height = sourcePieceHeight;
          const pieceCtx = pieceCanvas.getContext('2d');

          // Copy that slice from the main image
          pieceCtx.drawImage(
            image,
            col * sourcePieceWidth,
            row * sourcePieceHeight,
            sourcePieceWidth,
            sourcePieceHeight,
            0,
            0,
            sourcePieceWidth,
            sourcePieceHeight
          );

          // Convert to base64
          const pieceDataURL = pieceCanvas.toDataURL();

          puzzlePieces.push({
            index: pieceIndex,
            row,
            col,
            img: pieceDataURL
          });
          pieceIndex++;
        }
      }

      // Build the puzzle board's 9 slots
      for (let i = 0; i < puzzlePieces.length; i++) {
        const slot = document.createElement('div');
        slot.classList.add('slot');
        slot.dataset.index = i; // so we can check correctness if needed

        // Make it droppable
        slot.addEventListener('dragover', allowDrop);
        slot.addEventListener('drop', onDrop); // Ensure onDrop is defined

        // Also highlight on dragenter/dragleave
        slot.addEventListener('dragenter', onDragEnter);
        slot.addEventListener('dragleave', onDragLeave);

        puzzleArea.appendChild(slot);
      }

      // Also allow dropping back into the left #piecesArea
      piecesArea.addEventListener('dragover', allowDrop);
      piecesArea.addEventListener('drop', onDropLeft); // Ensure onDropLeft is defined
      piecesArea.addEventListener('dragenter', onDragEnter);
      piecesArea.addEventListener('dragleave', onDragLeave);

      // Shuffle the pieces, then place them randomly in the left area grid
      shuffleArray(puzzlePieces);
      puzzlePieces.forEach(piece => {
        const imgEl = document.createElement('img');
        imgEl.src = piece.img;
        imgEl.classList.add('draggable-piece');
        imgEl.draggable = true;
        imgEl.dataset.index = piece.index;

        // All pieces are 130Ã—130 always
        imgEl.style.width  = PIECE_SIZE + "px";
        imgEl.style.height = PIECE_SIZE + "px";

        // Drag events
        imgEl.addEventListener('dragstart', onDragStart);
        imgEl.addEventListener('dragend',   onDragEnd);

        // Place randomly within their assigned grid cell for better dispersion
        placePieceInGridCell(imgEl, piece);
        piecesArea.appendChild(imgEl);

        // **Add touch event listeners for iPad**
        imgEl.addEventListener('touchstart', touchStartHandler, { passive: false });
        imgEl.addEventListener('touchmove', touchMoveHandler, { passive: false });
        imgEl.addEventListener('touchend', touchEndHandler);
      });
    }

    /* Place a piece within a specific grid cell to ensure better dispersion */
    function placePieceInGridCell(pieceEl, piece) {
      // Assign to a random grid cell
      const totalCells = ROWS * COLS;
      const availableCells = [...Array(totalCells).keys()];
      // Randomly pick an available cell and remove it from the list to avoid multiple pieces per cell
      const randomIndex = Math.floor(Math.random() * availableCells.length);
      const selectedCell = availableCells.splice(randomIndex, 1)[0];

      // Calculate grid row and column
      const cellRow = Math.floor(selectedCell / COLS);
      const cellCol = selectedCell % COLS;

      // Calculate cell position within #piecesArea
      const piecesAreaWidth = piecesArea.clientWidth;
      const piecesAreaHeight = piecesArea.clientHeight;
      const cellWidth = piecesAreaWidth / COLS;
      const cellHeight = piecesAreaHeight / ROWS;

      // Calculate random offset within the cell to prevent perfect alignment
      const maxOffsetX = cellWidth - PIECE_SIZE - 10; // 10px padding
      const maxOffsetY = cellHeight - PIECE_SIZE - 10; // 10px padding
      const offsetX = Math.floor(Math.random() * Math.max(1, maxOffsetX));
      const offsetY = Math.floor(Math.random() * Math.max(1, maxOffsetY));

      // Set the position
      pieceEl.style.left = (cellCol * cellWidth + offsetX) + 'px';
      pieceEl.style.top  = (cellRow * cellHeight + offsetY) + 'px';
    }

    /* DRAG & DROP LOGIC */

    // Common dragstart
    function onDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.index);
      e.target.classList.add('dragging');
    }

    // Common dragend
    function onDragEnd(e) {
      e.target.classList.remove('dragging');
    }

    // Must prevent default to allow dropping
    function allowDrop(e) {
      e.preventDefault();
    }

    // Highlight on drag enter
    function onDragEnter(e) {
      e.currentTarget.classList.add('highlight');
    }

    // Remove highlight on drag leave
    function onDragLeave(e) {
      e.currentTarget.classList.remove('highlight');
    }

    // Dropping onto a puzzle slot
    function onDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('highlight'); // remove highlight
      const pieceIndex = e.dataTransfer.getData('text/plain');
      const slot = e.currentTarget;
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);
      if (!draggedImg) return;

      // If there's a piece in this slot, swap
      const existingPiece = slot.querySelector('img');
      const oldParent     = draggedImg.parentElement;
      if (existingPiece) {
        // Move existing piece back to piecesArea
        piecesArea.appendChild(existingPiece);
        existingPiece.style.position = 'absolute';
        existingPiece.style.width  = PIECE_SIZE + "px";
        existingPiece.style.height = PIECE_SIZE + "px";
        placePieceInGridCell(existingPiece, puzzlePieces[existingPiece.dataset.index]);
      }

      // Place dragged piece into this slot
      slot.innerHTML = "";
      slot.appendChild(draggedImg);

      // Ensure the piece fits nicely within the slot
      draggedImg.style.position = 'absolute';
      draggedImg.style.left = '0';
      draggedImg.style.top  = '0';
      draggedImg.style.width  = '100%';
      draggedImg.style.height = '100%';

      // Optionally check puzzle completion
      checkPuzzleCompletion();
    }

    // Dropping back into the left piecesArea
    function onDropLeft(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('highlight'); // remove highlight
      const pieceIndex = e.dataTransfer.getData('text/plain');
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);
      if (!draggedImg) return;

      // If it was in a slot, remove it from there
      const oldParent = draggedImg.parentElement;
      if (oldParent && oldParent.classList.contains('slot')) {
        oldParent.innerHTML = ""; // remove the piece from that slot
      }

      // Now place it in the left area
      piecesArea.appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.width  = PIECE_SIZE + "px";
      draggedImg.style.height = PIECE_SIZE + "px";
      placePieceInGridCell(draggedImg, puzzlePieces[pieceIndex]);
    }

    /* Shuffle array in-place */
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    /* OPTIONAL: puzzle completion check */
    function checkPuzzleCompletion() {
      let correct = 0;
      const slots = document.querySelectorAll('.slot');
      slots.forEach(slot => {
        const slotIndex = slot.dataset.index;
        const pieceImg  = slot.querySelector('img');
        if (pieceImg && pieceImg.dataset.index === slotIndex) {
          correct++;
        }
      });
      if (correct === ROWS * COLS) {
        alert("ðŸŽ‰ Puzzle terminÃ© ! ðŸŽ‰");
      }
    }

    /* Touch Event Handling for iPad */

    let touchData = {
      dragging: false,
      element: null,
      originalParent: null,
      originalPosition: { left: 0, top: 0 },
      offsetX: 0,
      offsetY: 0
    };

    // Touch Start Handler
    function touchStartHandler(e) {
      e.preventDefault();
      const touch = e.touches[0];
      touchData.dragging = true;
      touchData.element = e.target;
      touchData.originalParent = touchData.element.parentElement;

      touchData.element.classList.add('active');

      const rect = touchData.element.getBoundingClientRect();
      touchData.offsetX = touch.clientX - rect.left;
      touchData.offsetY = touch.clientY - rect.top;

      // Store original position
      touchData.originalPosition.left = rect.left;
      touchData.originalPosition.top = rect.top;

      // Bring the element to front
      touchData.element.style.zIndex = 1000;

      // Change position to fixed to allow dragging across the screen
      touchData.element.style.position = 'fixed';
      touchData.element.style.left = `${touch.clientX - touchData.offsetX}px`;
      touchData.element.style.top  = `${touch.clientY - touchData.offsetY}px`;
    }

    // Touch Move Handler
    function touchMoveHandler(e) {
      if (!touchData.dragging) return;
      e.preventDefault();
      const touch = e.touches[0];
      // Set position to fixed based on touch coordinates
      touchData.element.style.left = `${touch.clientX - touchData.offsetX}px`;
      touchData.element.style.top  = `${touch.clientY - touchData.offsetY}px`;
    }

    // Touch End Handler
    function touchEndHandler(e) {
      if (!touchData.dragging) return;
      touchData.dragging = false;
      touchData.element.classList.remove('active');

      // Get the touch end position
      const touch = e.changedTouches[0];

      // **Temporarily hide the dragged element to detect the drop target**
      touchData.element.style.display = 'none';

      const dropTarget = getDropTarget(touch.clientX, touch.clientY);

      // Show the dragged element again
      touchData.element.style.display = '';

      if (dropTarget) {
        if (dropTarget.classList.contains('slot')) {
          onDropTouch(touch.clientX, touch.clientY, dropTarget, touchData.element);
        } else if (dropTarget.id === 'piecesArea') {
          onDropLeftTouch(touch.clientX, touch.clientY, touchData.element);
        } else {
          // Snap back to original position if not a valid drop target
          resetTouchElementPosition(touchData.element);
        }
      } else {
        // Snap back to original position if not dropped on a valid target
        resetTouchElementPosition(touchData.element);
      }

      // Reset zIndex and position
      touchData.element.style.zIndex = '';
      touchData.element.style.position = 'absolute';
      touchData.element = null;
    }

    // Handle dropping a piece onto a puzzle slot via touch
    function onDropTouch(clientX, clientY, slotEl, draggedImg) {
      // If there's a piece already in the slot, swap
      const existingPiece = slotEl.querySelector('img');
      const oldParent     = draggedImg.parentElement;
      const pieceIndex    = draggedImg.dataset.index;

      if (existingPiece) {
        // Move existing piece back to piecesArea
        piecesArea.appendChild(existingPiece);
        existingPiece.style.position = 'absolute';
        existingPiece.style.width  = PIECE_SIZE + "px";
        existingPiece.style.height = PIECE_SIZE + "px";
        placePieceInGridCell(existingPiece, puzzlePieces[existingPiece.dataset.index]);
      }

      // Place dragged piece into this slot
      slotEl.innerHTML = "";
      slotEl.appendChild(draggedImg);

      // Ensure the piece fits nicely within the slot
      draggedImg.style.position = 'absolute';
      draggedImg.style.left = '0';
      draggedImg.style.top  = '0';
      draggedImg.style.width  = '100%';
      draggedImg.style.height = '100%';

      // Optionally check puzzle completion
      checkPuzzleCompletion();
    }

    // Handle dropping a piece back into the piecesArea via touch
    function onDropLeftTouch(clientX, clientY, draggedImg) {
      // If the piece was in a slot, remove it from there
      const oldParent = draggedImg.parentElement;
      if (oldParent && oldParent.classList.contains('slot')) {
        oldParent.innerHTML = ""; // remove the piece from that slot
      }

      // Now place it in the left area
      piecesArea.appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.width  = PIECE_SIZE + "px";
      draggedImg.style.height = PIECE_SIZE + "px";
      placePieceInGridCell(draggedImg, puzzlePieces[pieceIndex]);
    }

    // Reset the position of the touched element if not dropped on a valid target
    function resetTouchElementPosition(pieceEl) {
      // If the piece is in the piecesArea, ensure it's correctly placed
      if (pieceEl.parentElement.id === 'piecesArea') {
        placePieceInGridCell(pieceEl, puzzlePieces[pieceEl.dataset.index]);
      } else {
        // If the piece was in a slot but not dropped correctly, snap back
        // Implement snapping back logic if needed
      }
    }

    /* Helper function to get the drop target element based on coordinates */
    function getDropTarget(x, y) {
      const elem = document.elementFromPoint(x, y);
      if (!elem) return null;
      return elem.closest('.slot') || (elem.id === 'piecesArea' ? elem : null);
    }

  </script>
</body>
</html>
