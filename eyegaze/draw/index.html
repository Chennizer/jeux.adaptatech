<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title class="translate"
         data-fr="Dessiner dans les contours"
         data-en="Draw within the outline">Dessiner dans les contours</title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <style>
    :root {
      --toolbar-bg: rgba(6, 15, 25, 0.78);
      --toolbar-border: rgba(20, 184, 166, 0.45);
      --stage-bg: radial-gradient(1200px 600px at 60% -10%, #1a2330 0%, #0b0f14 60%, #080c11 100%);
      --panel-shadow: 0 18px 48px rgba(2, 12, 24, 0.55);
      --status-muted: rgba(15, 23, 42, 0.72);
    }

    body {
      background: #02060c;
      color: #e6edf3;
      font-family: 'Segoe UI', Roboto, system-ui, -apple-system, sans-serif;
    }

    body.light { background-color: #fff; color: #000; }
    body.dark  { background-color: #000; color: #fff; }

    #langToggle {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 1200;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 10px;
      border: 2px solid #009688;
      background: #fff;
      color: #009688;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
    }
    body.dark #langToggle {
      background: #111;
      color: #14b8a6;
      border-color: #14b8a6;
    }

    #game-options #control-panel-options {
      max-width: 940px;
    }

    #game-options h2 {
      margin: 0;
      font-size: clamp(1.4rem, 2.6vw, 2rem);
      color: #0f172a;
    }

    #game-options .intro {
      margin-top: 8px;
      font-size: 1rem;
      color: #1f2937;
    }

    #options-inline-container {
      align-items: stretch;
    }

    #options-inline-container h3 {
      margin: 0 0 0.75rem;
      font-size: 1.05rem;
      color: #0f172a;
    }

    .options-column {
      padding: 4px 12px;
      gap: 12px;
    }

    .options-column .option-item {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .options-column .control-label {
      font-weight: 700;
      color: #0f172a;
      margin-bottom: 6px;
    }

    .options-column .styled-input,
    .options-column .styled-select {
      width: 100%;
    }

    .styled-select {
      background-color: #fff;
    }

    .menu-slider-value {
      font-weight: 700;
      color: #065f46;
    }

    .upload-field input[type="file"] {
      font-size: 0.95rem;
      padding: 10px 12px;
      border: 2px dashed #009688;
      border-radius: 12px;
      cursor: pointer;
    }

    .upload-field input[type="file"]::-webkit-file-upload-button {
      border: none;
      margin-right: 10px;
      padding: 6px 10px;
      background: #009688;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
    }

    .upload-field small {
      margin-top: 6px;
      color: #374151;
      line-height: 1.4;
    }

    .preset-picker {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 12px 14px 16px;
      border-radius: 14px;
      border: 2px solid rgba(0, 150, 136, 0.25);
      background: rgba(14, 116, 144, 0.08);
    }

    .preset-picker select {
      max-width: 320px;
    }

    .preset-carousel {
      position: relative;
      width: 100%;
      max-width: 340px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .carousel-track {
      display: flex;
      gap: 10px;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(15, 118, 110, 0.2);
      background: rgba(255, 255, 255, 0.72);
    }

    .carousel-item {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid transparent;
      border-radius: 10px;
      background: #fff;
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease;
    }

    .carousel-item:hover {
      transform: translateY(-2px);
      border-color: rgba(20, 184, 166, 0.45);
    }

    .carousel-item.selected {
      border-color: #009688;
      box-shadow: 0 8px 20px rgba(0, 150, 136, 0.18);
    }

    .carousel-item img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      pointer-events: none;
    }

    .carousel-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: rgba(14, 116, 144, 0.16);
      color: #0f766e;
      font-size: 1.6rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .carousel-arrow:hover {
      background: rgba(14, 116, 144, 0.36);
      transform: translateY(-50%) scale(1.05);
    }

    #carouselPrev { left: -18px; }
    #carouselNext { right: -18px; }

    .preset-status {
      font-size: 0.92rem;
      color: #036666;
      text-align: center;
    }

    .test-results {
      width: 100%;
      font-size: 0.88rem;
      line-height: 1.4;
      text-align: left;
      margin-top: 10px;
      max-height: 140px;
      overflow: auto;
      background: rgba(240, 249, 255, 0.55);
      border-radius: 10px;
      padding: 10px 12px;
      color: #0f172a;
    }

    #gameContainer {
      display: none;
      width: 100vw;
      height: 100vh;
      align-items: stretch;
      justify-content: center;
    }

    .draw-stage {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
    }

    #toolbar {
      position: relative;
      z-index: 10;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 14px;
      padding: 14px 20px;
      background: var(--toolbar-bg);
      backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--toolbar-border);
      box-shadow: var(--panel-shadow);
    }

    .toolbar-group {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: #f8fafc;
      font-size: 0.95rem;
    }

    .toolbar-group label {
      font-weight: 600;
      color: #e0f2f1;
    }

    .toolbar-group input[type="range"] {
      width: 140px;
      accent-color: #14b8a6;
    }

    .toolbar-group input[type="color"] {
      width: 48px;
      height: 32px;
      border: none;
      border-radius: 6px;
      padding: 0;
      cursor: pointer;
    }

    .toolbar-group select {
      min-width: 120px;
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(12, 74, 110, 0.5);
      color: #e0f2f1;
    }

    .toolbar-group button,
    #optionsButton,
    #clearCanvas,
    #downloadImage {
      border: 1px solid rgba(45, 212, 191, 0.45);
      background: rgba(13, 148, 136, 0.35);
      color: #ecfeff;
      padding: 8px 14px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.15s ease;
    }

    #optionsButton {
      margin-right: 8px;
    }

    .toolbar-group button:hover,
    #optionsButton:hover,
    #clearCanvas:hover,
    #downloadImage:hover {
      background: rgba(13, 148, 136, 0.55);
      transform: translateY(-1px);
    }

    .canvas-wrapper {
      position: relative;
      flex: 1;
      background: var(--stage-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .canvas-wrapper canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .badge {
      position: absolute;
      top: 16px;
      right: 20px;
      z-index: 15;
      background: rgba(8, 145, 178, 0.35);
      color: #e0f2f1;
      padding: 8px 16px;
      border-radius: 999px;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      border: 1px solid rgba(45, 212, 191, 0.45);
    }

    .empty-msg {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      color: #334155;
      font-weight: 600;
    }

    @media (max-width: 960px) {
      #carouselPrev { left: -8px; }
      #carouselNext { right: -8px; }
    }

    @media (max-width: 840px) {
      #options-inline-container {
        grid-template-columns: 1fr;
      }

      #options-inline-container > div {
        border-right: none !important;
        border-bottom: 2px solid #009688;
        padding-bottom: 18px;
      }
      #options-inline-container > div:last-child {
        border-bottom: none;
      }

      .carousel-arrow { display: none; }
      .preset-carousel { height: auto; }
    }

    @media (max-width: 720px) {
      #toolbar {
        flex-direction: column;
        align-items: flex-start;
      }
      .toolbar-group { width: 100%; }
      .toolbar-group input[type="range"] { flex: 1; }
    }
  </style>

  <script src="../../js/cvipngarray.js" defer></script>
</head>
<body class="light">
  <button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

  <div id="game-options" class="modal" style="display: flex;">
    <div id="control-panel-options">
      <div id="options-title-bar">
        <h2 class="translate" data-fr="Dessiner dans les contours" data-en="Draw within the outline">
          Dessiner dans les contours
        </h2>
      </div>
      <p class="intro translate"
         data-fr="Choisissez la taille de votre brosse, la couleur et le contour à suivre."
         data-en="Choose the brush, colour and outline you would like to use.">
        Choisissez la taille de votre brosse, la couleur et le contour à suivre.
      </p>

      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <h3 class="translate" data-fr="Brosse" data-en="Brush">Brosse</h3>
          <div class="option-item">
            <label class="control-label translate"
                   data-fr="Taille de la brosse"
                   data-en="Brush size">
              Taille de la brosse
              (<span id="menuBrushValue" class="menu-slider-value">18</span> px)
            </label>
            <input id="menuBrush" type="range" min="3" max="64" value="18" class="styled-slider" />
          </div>
          <div class="option-item">
            <label class="control-label translate" data-fr="Couleur de la brosse" data-en="Brush colour">
              Couleur de la brosse
            </label>
            <input id="menuColor" type="color" value="#ff7a59" class="styled-input" />
          </div>
          <div class="option-item">
            <label class="control-label translate" data-fr="Mode" data-en="Mode">Mode</label>
            <select id="menuMode" class="styled-select">
              <option value="draw" selected class="translate" data-fr="Dessiner" data-en="Draw">Dessiner</option>
              <option value="erase" class="translate" data-fr="Effacer" data-en="Erase">Effacer</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <h3 class="translate" data-fr="Contours" data-en="Outlines">Contours</h3>
          <div class="option-item">
            <label class="control-label translate"
                   data-fr="Forme intégrée"
                   data-en="Built-in outline">
              Forme intégrée
            </label>
            <select id="shapeSelect" class="styled-select">
              <option value="blob" selected class="translate" data-fr="Goutte" data-en="Blob">Goutte</option>
              <option value="star" class="translate" data-fr="Étoile" data-en="Star">Étoile</option>
              <option value="heart" class="translate" data-fr="Cœur" data-en="Heart">Cœur</option>
              <option value="rect" class="translate" data-fr="Rectangle arrondi" data-en="Rounded rectangle">Rectangle arrondi</option>
            </select>
          </div>

          <div class="preset-picker">
            <label class="control-label translate"
                   data-fr="Bibliothèque d’images"
                   data-en="Image library">
              Bibliothèque d’images
            </label>
            <select id="presetCategory" class="styled-select" disabled>
              <option class="translate" data-fr="Chargement..." data-en="Loading...">Chargement...</option>
            </select>
            <div class="preset-carousel">
              <button id="carouselPrev" type="button" class="carousel-arrow" aria-label="Précédent">‹</button>
              <div id="carouselTrack" class="carousel-track">
                <div class="empty-msg translate" data-fr="Aucune image" data-en="No images">Aucune image</div>
              </div>
              <button id="carouselNext" type="button" class="carousel-arrow" aria-label="Suivant">›</button>
            </div>
            <p id="presetStatus" class="preset-status translate"
               data-fr="Les images seront disponibles si le fichier cvipngarray est chargé."
               data-en="Images will appear when the cvipngarray file is available.">
              Les images seront disponibles si le fichier cvipngarray est chargé.
            </p>
          </div>
        </div>

        <div class="options-column">
          <h3 class="translate" data-fr="Importation" data-en="Import">Importation</h3>
          <div class="option-item upload-field">
            <label class="control-label translate"
                   for="outlineFile"
                   data-fr="Téléverser un contour (PNG ou SVG)"
                   data-en="Upload outline (PNG or SVG)">
              Téléverser un contour (PNG ou SVG)
            </label>
            <input id="outlineFile" type="file" accept="image/png, image/svg+xml" />
            <small class="translate"
                   data-fr="L’image importée est utilisée comme masque : la zone opaque devient la zone à colorier."
                   data-en="Opaque parts of the image become the area where you can draw.">
              L’image importée est utilisée comme masque : la zone opaque devient la zone à colorier.
            </small>
          </div>
          <div class="option-item">
            <label class="control-label translate" data-fr="Ajuster l’image" data-en="Fit uploaded image">
              Ajuster l’image
            </label>
            <select id="fitMode" class="styled-select">
              <option value="contain" selected class="translate" data-fr="Contenir (garder les proportions)" data-en="Contain (keep aspect)">
                Contenir (garder les proportions)
              </option>
              <option value="cover" class="translate" data-fr="Couvrir" data-en="Cover">Couvrir</option>
              <option value="stretch" class="translate" data-fr="Étirer" data-en="Stretch">Étirer</option>
            </select>
          </div>
          <div class="option-item">
            <label class="control-label translate" data-fr="Source du masque" data-en="Mask source">
              Source du masque
            </label>
            <select id="maskSource" class="styled-select">
              <option value="alpha" selected class="translate" data-fr="Alpha (opaque = dedans)" data-en="Alpha (opaque = inside)">
                Alpha (opaque = dedans)
              </option>
              <option value="luma" class="translate" data-fr="Luminance (blanc = dedans)" data-en="Luminance (white = inside)">
                Luminance (blanc = dedans)
              </option>
              <option value="alpha-invert" class="translate" data-fr="Alpha inversé" data-en="Alpha inverted">
                Alpha inversé
              </option>
            </select>
          </div>
          <div class="option-item">
            <button id="runTests" type="button" class="button translate"
                    data-fr="Tests intégrés"
                    data-en="Run self tests">
              Tests intégrés
            </button>
          </div>
          <div id="testResults" class="test-results"></div>
        </div>
      </div>

      <div id="mode-divider"></div>

      <button id="startButton" class="button translate"
              data-fr="Lancer le dessin"
              data-en="Start drawing">
        Lancer le dessin
      </button>
    </div>
  </div>

  <div id="gameContainer" class="game-container">
    <div class="draw-stage">
      <header id="toolbar">
        <button id="optionsButton" type="button" class="translate" data-fr="Menu" data-en="Menu">Menu</button>
        <div class="toolbar-group">
          <label class="translate" data-fr="Taille" data-en="Size">Taille</label>
          <input id="brush" type="range" min="3" max="64" value="18" />
          <span><span id="brushValue">18</span> px</span>
        </div>
        <div class="toolbar-group">
          <label class="translate" data-fr="Couleur" data-en="Colour">Couleur</label>
          <input id="color" type="color" value="#ff7a59" />
        </div>
        <div class="toolbar-group">
          <label class="translate" data-fr="Mode" data-en="Mode">Mode</label>
          <select id="mode">
            <option value="draw" class="translate" data-fr="Dessiner" data-en="Draw">Dessiner</option>
            <option value="erase" class="translate" data-fr="Effacer" data-en="Erase">Effacer</option>
          </select>
        </div>
        <div class="toolbar-group">
          <button id="clearCanvas" type="button" class="translate" data-fr="Effacer" data-en="Clear">Effacer</button>
          <button id="downloadImage" type="button" class="translate" data-fr="Sauvegarder" data-en="Save PNG">Sauvegarder</button>
        </div>
      </header>

      <div class="canvas-wrapper">
        <div class="badge translate" data-fr="Mode dessin" data-en="Drawing mode">Mode dessin</div>
        <canvas id="ink" width="1400" height="900" aria-label="Couche d’encre"></canvas>
        <canvas id="outline" width="1400" height="900" aria-label="Contour"></canvas>
      </div>
    </div>
  </div>

  <script>
    /* === Language toggle === */
    const LS_LANG_KEY = 'siteLanguage';
    const langToggle = document.getElementById('langToggle');
    function getLang(){
      try {
        const stored = localStorage.getItem(LS_LANG_KEY);
        if (stored === 'en' || stored === 'fr') return stored;
      } catch (err) {}
      return (document.documentElement.lang === 'en') ? 'en' : 'fr';
    }
    function setLang(lang){
      const safe = (lang === 'en') ? 'en' : 'fr';
      document.documentElement.lang = safe;
      try { localStorage.setItem(LS_LANG_KEY, safe); } catch(err){}
      document.querySelectorAll('.translate').forEach(el => {
        const fr = el.getAttribute('data-fr');
        const en = el.getAttribute('data-en');
        if (safe === 'fr' && fr != null) el.textContent = fr;
        if (safe === 'en' && en != null) el.textContent = en;
      });
      updatePresetMessage();
    }
    (function initLang(){
      let initial = 'fr';
      try {
        const stored = localStorage.getItem(LS_LANG_KEY);
        initial = (stored === 'en' || stored === 'fr') ? stored : initial;
        if (stored !== initial) localStorage.setItem(LS_LANG_KEY, initial);
      } catch (err) {}
      setLang(initial);
    })();
    langToggle.addEventListener('click', () => setLang(getLang() === 'fr' ? 'en' : 'fr'));

    /* === Elements === */
    const menuModal = document.getElementById('game-options');
    const startButton = document.getElementById('startButton');
    const optionsButton = document.getElementById('optionsButton');
    const gameContainer = document.getElementById('gameContainer');

    const menuBrushEl = document.getElementById('menuBrush');
    const menuBrushValue = document.getElementById('menuBrushValue');
    const menuColorEl = document.getElementById('menuColor');
    const menuModeEl = document.getElementById('menuMode');

    const brushEl = document.getElementById('brush');
    const brushValue = document.getElementById('brushValue');
    const colorEl = document.getElementById('color');
    const modeEl = document.getElementById('mode');
    const clearEl = document.getElementById('clearCanvas');
    const downloadEl = document.getElementById('downloadImage');

    const shapeEl = document.getElementById('shapeSelect');
    const outlineFileEl = document.getElementById('outlineFile');
    const fitModeEl = document.getElementById('fitMode');
    const maskSourceEl = document.getElementById('maskSource');

    const catEl = document.getElementById('presetCategory');
    const carouselTrack = document.getElementById('carouselTrack');
    const prevBtn = document.getElementById('carouselPrev');
    const nextBtn = document.getElementById('carouselNext');
    const presetStatus = document.getElementById('presetStatus');
    const testResults = document.getElementById('testResults');
    const runTestsBtn = document.getElementById('runTests');

    const ink = document.getElementById('ink');
    const out = document.getElementById('outline');
    const ic = ink.getContext('2d');
    const oc = out.getContext('2d');

    /* === Menu controls === */
    menuBrushEl.addEventListener('input', () => {
      menuBrushValue.textContent = menuBrushEl.value;
    });

    function syncMenuFromToolbar(){
      menuBrushEl.value = brushEl.value;
      menuBrushValue.textContent = brushEl.value;
      menuColorEl.value = colorEl.value;
      menuModeEl.value = modeEl.value;
    }

    function applyMenuToToolbar(){
      brushEl.value = menuBrushEl.value;
      brushValue.textContent = menuBrushEl.value;
      colorEl.value = menuColorEl.value;
      modeEl.value = menuModeEl.value;
    }

    function hideMenu(){
      menuModal.style.display = 'none';
    }

    function showMenu(){
      syncMenuFromToolbar();
      menuModal.style.display = 'flex';
    }

    optionsButton.addEventListener('click', showMenu);

    startButton.addEventListener('click', () => {
      applyMenuToToolbar();
      applyPendingPreset();
      menuModal.style.display = 'none';
      gameContainer.style.display = 'flex';
      requestResize();
    });

    /* === Toolbar controls === */
    brushEl.addEventListener('input', () => {
      brushValue.textContent = brushEl.value;
    });

    clearEl.addEventListener('click', () => {
      ic.clearRect(0, 0, ink.width, ink.height);
    });

    downloadEl.addEventListener('click', () => {
      const url = mergeForExport();
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drawing.png';
      a.click();
    });

    /* === Canvas sizing === */
    let resizePending = false;
    function fitCanvas(cnv){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = cnv.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width * dpr));
      const h = Math.max(1, Math.round(rect.height * dpr));
      if (cnv.width !== w || cnv.height !== h){
        cnv.width = w;
        cnv.height = h;
        const ctx = cnv.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }
    function resizeAllImmediate(){
      fitCanvas(ink);
      fitCanvas(out);
      drawOutline();
      syncScratch();
      rebuildMaskCache();
    }
    function requestResize(){
      if (resizePending) return;
      resizePending = true;
      requestAnimationFrame(() => {
        resizePending = false;
        resizeAllImmediate();
      });
    }
    const ro = new ResizeObserver(() => requestResize());
    ro.observe(out);

    /* === Preset carousel === */
    let allPresets = [];
    let presetCategories = [];
    let currentCategory = null;
    let carouselIndex = 0;
    let selectedPreset = null;
    let presetMessage = { type: 'loading', arg: null };

    function setPresetMessage(type, arg){
      presetMessage = { type, arg }; updatePresetMessage();
    }
    function updatePresetMessage(){
      const lang = getLang();
      const { type, arg } = presetMessage;
      let text = '';
      if (type === 'loading') {
        text = (lang === 'fr') ? 'Chargement des images...' : 'Loading images...';
      } else if (type === 'disabled') {
        text = (lang === 'fr') ?
          'Impossible de charger la bibliothèque. Assurez-vous que cvipngarray est disponible.' :
          'Could not load the library. Make sure cvipngarray is available.';
      } else if (type === 'ready') {
        const { count, categories } = arg || { count: 0, categories: 0 };
        text = (lang === 'fr') ?
          `${count} images disponibles dans ${categories} catégories.` :
          `${count} images available across ${categories} categories.`;
      } else if (type === 'selected') {
        text = (lang === 'fr') ? `Sélectionné : ${arg}` : `Selected: ${arg}`;
      } else if (type === 'empty') {
        text = (lang === 'fr') ? 'Aucune image dans cette catégorie.' : 'No images in this category.';
      }
      if (text) presetStatus.textContent = text;
    }

    function enablePresets(){
      if (!window.PNG_ARRAY || !Array.isArray(window.PNG_ARRAY) || window.PNG_ARRAY.length === 0){
        catEl.disabled = true;
        setPresetMessage('disabled');
        return;
      }
      allPresets = [...window.PNG_ARRAY];
      presetCategories = [...new Set(allPresets.map(item => item.category))].sort((a, b) => a.localeCompare(b));
      catEl.innerHTML = '';
      presetCategories.forEach(cat => {
        const opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat;
        catEl.appendChild(opt);
      });
      catEl.disabled = false;
      currentCategory = presetCategories[0];
      catEl.value = currentCategory;
      carouselIndex = 0;
      selectedPreset = null;
      renderCarousel();
      setPresetMessage('ready', { count: allPresets.length, categories: presetCategories.length });
    }

    function renderCarousel(){
      const items = allPresets.filter(item => item.category === currentCategory);
      carouselTrack.innerHTML = '';
      if (!items.length){
        const empty = document.createElement('div');
        empty.className = 'empty-msg translate';
        empty.setAttribute('data-fr', 'Aucune image');
        empty.setAttribute('data-en', 'No images');
        empty.textContent = (getLang() === 'fr') ? 'Aucune image' : 'No images';
        carouselTrack.appendChild(empty);
        selectedPreset = null;
        setPresetMessage('empty');
        return;
      }
      if (carouselIndex >= items.length) carouselIndex = 0;
      const showCount = Math.min(items.length, 4);
      for (let i = 0; i < showCount; i++){
        const idx = (carouselIndex + i) % items.length;
        const item = items[idx];
        const div = document.createElement('div');
        div.className = 'carousel-item';
        div.innerHTML = `<img src="${item.file}" alt="${item.name}">`;
        if (selectedPreset && selectedPreset.file === item.file){
          div.classList.add('selected');
        }
        div.addEventListener('click', () => {
          selectedPreset = item;
          carouselTrack.querySelectorAll('.carousel-item').forEach(el => el.classList.remove('selected'));
          div.classList.add('selected');
          setPresetMessage('selected', item.name);
        });
        carouselTrack.appendChild(div);
      }
      if (!selectedPreset){
        selectedPreset = items[carouselIndex];
        setPresetMessage('selected', selectedPreset.name);
        const first = carouselTrack.querySelector('.carousel-item');
        first?.classList.add('selected');
      }
    }

    catEl.addEventListener('change', () => {
      currentCategory = catEl.value;
      carouselIndex = 0;
      selectedPreset = null;
      renderCarousel();
    });

    prevBtn.addEventListener('click', () => {
      const items = allPresets.filter(item => item.category === currentCategory);
      if (!items.length) return;
      carouselIndex = (carouselIndex - 1 + items.length) % items.length;
      renderCarousel();
    });

    nextBtn.addEventListener('click', () => {
      const items = allPresets.filter(item => item.category === currentCategory);
      if (!items.length) return;
      carouselIndex = (carouselIndex + 1) % items.length;
      renderCarousel();
    });

    function applyPendingPreset(){
      if (selectedPreset){
        loadUserMaskFromURL(selectedPreset.file);
      } else if (!outlineFileEl.files?.length){
        userMask = null;
        rebuildMaskCache();
        drawOutline();
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(enablePresets, 0);
    });

    /* === Mask + outline logic (from original implementation) === */
    let shapePath = null;

    function makePath(kind, w, h){
      const p = new Path2D();
      const pad = Math.min(w, h) * 0.12;
      const cx = w / 2;
      const cy = h / 2;
      if (kind === 'rect'){
        const r = Math.min(w, h) * 0.18;
        const x = pad, y = pad, rw = w - 2 * pad, rh = h - 2 * pad;
        roundRectPath(p, x, y, rw, rh, r);
      } else if (kind === 'blob'){
        const rx = w * 0.32;
        const ry = h * 0.28;
        blobPath(p, cx, cy, rx, ry);
      } else if (kind === 'star'){
        starPath(p, cx, cy, Math.min(w, h) * 0.36, 5);
      } else if (kind === 'heart'){
        heartPath(p, cx, cy, Math.min(w, h) * 0.36);
      }
      return p;
    }

    function roundRectPath(p, x, y, w, h, r){
      p.moveTo(x + r, y);
      p.arcTo(x + w, y, x + w, y + h, r);
      p.arcTo(x + w, y + h, x, y + h, r);
      p.arcTo(x, y + h, x, y, r);
      p.arcTo(x, y, x + w, y, r);
      p.closePath();
    }

    function blobPath(p, cx, cy, rx, ry){
      p.moveTo(cx, cy - ry);
      p.bezierCurveTo(cx + rx * 0.6, cy - ry, cx + rx, cy - ry * 0.2, cx + rx, cy);
      p.bezierCurveTo(cx + rx, cy + ry * 0.6, cx + rx * 0.4, cy + ry, cx, cy + ry);
      p.bezierCurveTo(cx - rx * 0.6, cy + ry, cx - rx, cy + ry * 0.2, cx - rx, cy);
      p.bezierCurveTo(cx - rx, cy - ry * 0.6, cx - rx * 0.4, cy - ry, cx, cy - ry);
      p.closePath();
    }

    function starPath(p, cx, cy, r, spikes){
      const step = Math.PI / spikes;
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy - r;
      p.moveTo(cx, cy - r);
      for (let i = 0; i < spikes; i++){
        x = cx + Math.cos(rot) * r;
        y = cy + Math.sin(rot) * r;
        p.lineTo(x, y);
        rot += step;
        x = cx + Math.cos(rot) * r * 0.5;
        y = cy + Math.sin(rot) * r * 0.5;
        p.lineTo(x, y);
        rot += step;
      }
      p.closePath();
    }

    function heartPath(p, cx, cy, s){
      const top = cy - s * 0.25;
      p.moveTo(cx, top);
      p.bezierCurveTo(cx + s * 0.5, top - s * 0.6, cx + s, cy - s * 0.05, cx, cy + s * 0.75);
      p.bezierCurveTo(cx - s, cy - s * 0.05, cx - s * 0.5, top - s * 0.6, cx, top);
      p.closePath();
    }

    function drawOutline(){
      if (!out.width || !out.height){
        return;
      }
      const rect = out.getBoundingClientRect();
      shapePath = makePath(shapeEl.value, rect.width, rect.height);
      oc.clearRect(0, 0, out.width, out.height);
      if (userMask){
        redrawMaskGuide();
      } else {
        oc.save();
        oc.fillStyle = 'white';
        oc.globalAlpha = 0.06;
        oc.fill(shapePath);
        oc.globalAlpha = 1;
        oc.lineWidth = 6;
        oc.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--edge') || '#e2e8f0';
        oc.stroke(shapePath);
        oc.restore();
      }
    }

    let userMask = null;
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    let maskImageData = null;

    async function loadUserMaskFromFile(file){
      const url = URL.createObjectURL(file);
      await loadUserMaskFromURL(url, true);
    }
    function loadUserMaskFromURL(url, revoke = false){
      const img = new Image();
      img.onload = () => {
        if (revoke) URL.revokeObjectURL(url);
        userMask = img;
        rebuildMaskCache();
        drawOutline();
      };
      img.onerror = () => {
        if (revoke) URL.revokeObjectURL(url);
        alert('Could not load image. Try a PNG or SVG.');
      };
      img.src = url;
    }

    function computeFit(destW, destH, imgW, imgH, mode){
      if (mode === 'stretch') return { x: 0, y: 0, w: destW, h: destH };
      const r = imgW / imgH;
      const R = destW / destH;
      if (mode === 'cover'){
        const w = R > r ? destW : destH * r;
        const h = R > r ? destW / r : destH;
        const x = (destW - w) / 2;
        const y = (destH - h) / 2;
        return { x, y, w, h };
      }
      const w = R > r ? destH * r : destW;
      const h = R > r ? destH : destW / r;
      const x = (destW - w) / 2;
      const y = (destH - h) / 2;
      return { x, y, w, h };
    }

    function rebuildMaskCache(){
      if (!userMask){
        maskImageData = null;
        return;
      }
      maskCanvas.width = out.width;
      maskCanvas.height = out.height;
      maskCtx.setTransform(oc.getTransform());
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      maskCtx.drawImage(userMask, fit.x, fit.y, fit.w, fit.h);
      const img = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
      const data = img.data;
      const mode = maskSourceEl.value;
      for (let i = 0; i < data.length; i += 4){
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];
        let alpha = a;
        if (mode === 'luma'){
          const y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          alpha = y;
        } else if (mode === 'alpha-invert'){
          alpha = 255 - a;
        }
        data[i] = 255;
        data[i + 1] = 255;
        data[i + 2] = 255;
        data[i + 3] = alpha;
      }
      maskCtx.putImageData(img, 0, 0);
      maskImageData = img;
    }

    function redrawMaskGuide(){
      oc.clearRect(0, 0, out.width, out.height);
      if (!userMask){
        oc.save();
        oc.fillStyle = 'white';
        oc.globalAlpha = 0.06;
        if (shapePath) oc.fill(shapePath);
        oc.globalAlpha = 1;
        oc.lineWidth = 6;
        oc.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--edge') || '#e2e8f0';
        if (shapePath) oc.stroke(shapePath);
        oc.restore();
        return;
      }
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      oc.save();
      oc.globalAlpha = 0.25;
      oc.drawImage(userMask, fit.x, fit.y, fit.w, fit.h);
      oc.restore();
    }

    let drawing = false;
    let prev = null;

    const supportsPathClip = (function(){
      try {
        const c = document.createElement('canvas').getContext('2d');
        const p = new Path2D();
        p.rect(0, 0, 1, 1);
        c.save();
        c.clip(p);
        c.restore();
        return true;
      } catch (e){
        return false;
      }
    })();

    const scratch = document.createElement('canvas');
    const sc = scratch.getContext('2d');

    function syncScratch(){
      scratch.width = ink.width;
      scratch.height = ink.height;
      sc.setTransform(ic.getTransform());
      sc.clearRect(0, 0, scratch.width, scratch.height);
    }

    function getPos(e){
      const r = ink.getBoundingClientRect();
      if (e.touches && e.touches[0]){
        return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top };
      }
      return { x: (e.clientX || e.x) - r.left, y: (e.clientY || e.y) - r.top };
    }

    function begin(e){
      drawing = true;
      prev = getPos(e);
      e.preventDefault();
    }
    function end(){
      drawing = false;
      prev = null;
    }

    function draw(e){
      if (!drawing) return;
      const cur = getPos(e);
      const size = +brushEl.value;
      const color = colorEl.value;
      const erasing = (modeEl.value === 'erase');

      if (userMask){
        sc.save();
        sc.lineCap = 'round';
        sc.lineJoin = 'round';
        sc.lineWidth = size;
        sc.globalCompositeOperation = 'source-over';
        sc.strokeStyle = erasing ? '#000' : color;
        sc.beginPath();
        sc.moveTo(prev.x, prev.y);
        sc.lineTo(cur.x, cur.y);
        sc.stroke();
        sc.globalCompositeOperation = 'destination-in';
        sc.drawImage(maskCanvas, 0, 0);
        sc.restore();
        ic.save();
        ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
        ic.drawImage(scratch, 0, 0);
        ic.restore();
        sc.clearRect(0, 0, scratch.width, scratch.height);
      } else {
        if (!shapePath) return;
        if (supportsPathClip){
          ic.save();
          ic.clip(shapePath);
          ic.lineCap = 'round';
          ic.lineJoin = 'round';
          ic.lineWidth = size;
          ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
          ic.strokeStyle = erasing ? 'rgba(0,0,0,1)' : color;
          ic.beginPath();
          ic.moveTo(prev.x, prev.y);
          ic.lineTo(cur.x, cur.y);
          ic.stroke();
          ic.restore();
        } else {
          if (!maskImageData){
            maskCanvas.width = out.width;
            maskCanvas.height = out.height;
            maskCtx.setTransform(oc.getTransform());
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            maskCtx.fillStyle = '#fff';
            if (shapePath) maskCtx.fill(shapePath);
            maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
          }
          sc.save();
          sc.lineCap = 'round';
          sc.lineJoin = 'round';
          sc.lineWidth = size;
          sc.globalCompositeOperation = 'source-over';
          sc.strokeStyle = erasing ? '#000' : color;
          sc.beginPath();
          sc.moveTo(prev.x, prev.y);
          sc.lineTo(cur.x, cur.y);
          sc.stroke();
          sc.globalCompositeOperation = 'destination-in';
          sc.putImageData(maskImageData, 0, 0);
          sc.restore();
          ic.save();
          ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
          ic.drawImage(scratch, 0, 0);
          ic.restore();
          sc.clearRect(0, 0, scratch.width, scratch.height);
        }
      }
      prev = cur;
      e.preventDefault();
    }

    ink.addEventListener('pointerdown', begin);
    window.addEventListener('pointerup', end);
    window.addEventListener('pointercancel', end);
    window.addEventListener('pointerout', e => { if (e.target === ink) end(); });
    window.addEventListener('pointermove', draw, { passive: false });
    ink.addEventListener('touchstart', begin, { passive: false });
    window.addEventListener('touchend', end, { passive: false });
    window.addEventListener('touchmove', draw, { passive: false });

    requestResize();

    function mergeForExport(){
      const merge = document.createElement('canvas');
      merge.width = ink.width;
      merge.height = ink.height;
      const mc = merge.getContext('2d');
      mc.setTransform(ic.getTransform());
      mc.drawImage(out, 0, 0);
      mc.drawImage(ink, 0, 0);
      return merge.toDataURL('image/png');
    }

    runTestsBtn?.addEventListener('click', runSelfTests);
    function runSelfTests(){
      const results = [];
      try {
        results.push(['API: Path2D exists', typeof Path2D === 'function']);
        results.push(['API: Have clip(Path2D) OR fallback mask', typeof ic.clip === 'function' || true]);
        const c = document.createElement('canvas');
        c.width = 100; c.height = 100;
        const ctx = c.getContext('2d');
        const rect = new Path2D(); rect.rect(20, 20, 60, 60);
        try {
          ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6;
          ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(100, 10); ctx.stroke(); ctx.restore();
        } catch {}
        const pxOutside = ctx.getImageData(10, 10, 1, 1).data[3];
        results.push(['Clip: outside does not render', pxOutside === 0]);
        try {
          ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6;
          ctx.beginPath(); ctx.moveTo(10, 50); ctx.lineTo(90, 50); ctx.stroke(); ctx.restore();
        } catch {}
        const pxInside = ctx.getImageData(50, 50, 1, 1).data[3];
        results.push(['Clip: inside renders', pxInside > 0]);

        const ctx2 = document.createElement('canvas').getContext('2d');
        ctx2.canvas.width = 100; ctx2.canvas.height = 100;
        try { ctx2.save(); ctx2.clip(rect); } catch {}
        ctx2.fillStyle = '#fff'; ctx2.fillRect(20, 20, 60, 60);
        ctx2.restore?.(); ctx2.save?.();
        try { ctx2.clip(rect); } catch {}
        ctx2.globalCompositeOperation = 'destination-out';
        ctx2.lineWidth = 8;
        ctx2.strokeStyle = 'rgba(0,0,0,1)';
        ctx2.beginPath(); ctx2.moveTo(20, 50); ctx2.lineTo(80, 50); ctx2.stroke();
        ctx2.restore?.();
        const erased = ctx2.getImageData(50, 50, 1, 1).data[3];
        results.push(['Erase: destination-out clears pixels', erased === 0]);

        const fc = document.createElement('canvas'); fc.width = 100; fc.height = 100;
        const fctx = fc.getContext('2d');
        const fScratch = document.createElement('canvas');
        fScratch.width = 100; fScratch.height = 100;
        const fsc = fScratch.getContext('2d');
        const fRect = new Path2D(); fRect.rect(20, 20, 60, 60);
        fsc.save(); fsc.strokeStyle = '#fff'; fsc.lineWidth = 6;
        fsc.beginPath(); fsc.moveTo(0, 10); fsc.lineTo(100, 10); fsc.stroke();
        fsc.globalCompositeOperation = 'destination-in';
        fsc.fillStyle = '#fff'; fsc.fill(fRect);
        fsc.restore();
        fctx.drawImage(fScratch, 0, 0);
        const fOutside = fctx.getImageData(10, 10, 1, 1).data[3];
        results.push(['Mask fallback: outside does not render', fOutside === 0]);
        fsc.clearRect(0, 0, 100, 100);
        fsc.save(); fsc.strokeStyle = '#fff'; fsc.lineWidth = 6;
        fsc.beginPath(); fsc.moveTo(10, 50); fsc.lineTo(90, 50); fsc.stroke();
        fsc.globalCompositeOperation = 'destination-in';
        fsc.fillStyle = '#fff'; fsc.fill(fRect);
        fsc.restore();
        fctx.clearRect(0, 0, 100, 100);
        fctx.drawImage(fScratch, 0, 0);
        const fInside = fctx.getImageData(50, 50, 1, 1).data[3];
        results.push(['Mask fallback: inside renders', fInside > 0]);

        const testInk = document.createElement('canvas');
        testInk.width = 50; testInk.height = 50;
        const ti = testInk.getContext('2d');
        const testOut = document.createElement('canvas');
        testOut.width = 50; testOut.height = 50;
        const to = testOut.getContext('2d');
        ti.fillStyle = '#fff'; ti.fillRect(10, 10, 10, 10);
        to.strokeStyle = '#fff'; to.strokeRect(5, 5, 20, 20);
        const merged = (function(){
          const merge = document.createElement('canvas');
          merge.width = 50; merge.height = 50;
          const mc = merge.getContext('2d');
          mc.drawImage(testOut, 0, 0);
          mc.drawImage(testInk, 0, 0);
          return mc.getImageData(12, 12, 1, 1).data[3];
        })();
        results.push(['Export: merged image contains pixels', merged > 0]);

        const fake = [
          { name: 'a', file: 'a.png', category: 'x' },
          { name: 'b', file: 'b.png', category: 'y' },
          { name: 'c', file: 'c.png', category: 'x' }
        ];
        const cats = [...new Set(fake.map(x => x.category))].sort();
        results.push(['Presets: unique categories computed', cats.join(',') === 'x,y']);
        const inX = fake.filter(x => x.category === 'x').map(x => x.name).sort().join(',');
        results.push(['Presets: items filter by category', inX === 'a,c']);
      } catch (err){
        results.push([`Exception during tests: ${err?.message || err}`, false]);
      }
      testResults.innerHTML = results.map(([name, ok]) => ok ?
        `<div class="ok">✔ ${name}</div>` : `<div class="bad">✖ ${name}</div>`).join('');
    }

    shapeEl.addEventListener('change', () => {
      selectedPreset = null;
      userMask = null;
      rebuildMaskCache();
      drawOutline();
    });

    fitModeEl.addEventListener('change', () => {
      rebuildMaskCache();
      redrawMaskGuide();
    });

    maskSourceEl.addEventListener('change', () => {
      rebuildMaskCache();
      redrawMaskGuide();
    });

    outlineFileEl.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      selectedPreset = null;
      await loadUserMaskFromFile(file);
      redrawMaskGuide();
    });
  </script>
</body>
</html>
