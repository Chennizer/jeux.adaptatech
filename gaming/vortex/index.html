<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title 
    class="translate"
    data-fr="Switch : vortex" 
    data-en="Switch: Vortex">
    Switch : vortex
  </title>
  <link rel="stylesheet" href="../../css/otherswitch.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  <style>
    /* Style for the 3x3 matrix container */
    #vortexMatrix {
      position: fixed;
      top: 10px;
      right: 10px;
      display: grid;
      grid-template-columns: repeat(3, 20px);
      grid-gap: 10px;
      z-index: 1000;
    }
    .matrixDot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #888;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .matrixDot.selected {
      border-color: #fff;
    }
  </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
<body>
<body>
  <!-- Prompt Overlay with translation markup -->
  <div id="promptOverlay">
    <button id="infoButton" title="Plus d'infos" class="translate" data-fr="ⓘ" data-en="ⓘ">ⓘ</button>
    <p class="translate" data-fr="Jeu pour une switch, maintenir pour activer une animation de vortex spatial" 
       data-en="Game for a switch, hold to activate a spatial vortex animation.">
      Jeu pour une switch, maintenir pour activer l'animation et la musique.
    </p>
    <button id="startButton" class="translate" data-fr="Commencer" data-en="Start">Commencer</button>
  </div>
  
  <!-- Info Modal with translation markup (single paragraph) -->
  <div id="infoModal" style="display:none;">
    <p class="translate" data-fr="Compétence: appuyer et maintenir<br>SENICT switch skills niveau 2<br>Switch Progression Roadmap niveau 11 à 13" 
       data-en="Skill: press and hold<br>SENICT switch skills level 2<br>Switch Progression Roadmap levels 11 to 13">
      Compétence: appuyer et maintenir<br>SENICT switch skills niveau 2<br>Switch Progression Roadmap niveau 11 à 13
    </p>
    <button id="closeModal" class="translate" data-fr="Fermer" data-en="Close">Fermer</button>
  </div>
  
  <!-- 3x3 matrix for selecting vortex spawn position (hidden by default) -->
  <div id="vortexMatrix" style="display:none;">
    <!-- The dots will be generated by JavaScript -->
  </div>
  
  <script>
    let started = false;
    let canvas;
    let vortexActive = false;
    let activationLocked = false;
    let vortexParticles = [];
    let shootingStars = [];
    // Default vortex origin is the center of the canvas.
    let vortexOriginX, vortexOriginY;
    const shootingStarInterval = 5000;
    let lastShootingStarTime = 0;
    const waveDuration = 3000;
    const wavePause = 2000;
    let lastWaveCycle = 0;
    let swStars = [];
    const numSWStars = 200;
    let songPaths = [
      "../../songs/space/spacevortex1.mp3",
      "../../songs/space/spacevortex2.mp3",
      "../../songs/space/spacevortex3.mp3",
      "../../songs/space/spacevortex4.mp3",
      "../../songs/space/spacevortex5.mp3"
    ];
    let songs = [];
    let currentSong = null;
    let palettes = [
      { name: "cold", colors: [] },
      { name: "hot", colors: [] }
    ];
    let currentPalette = null;
    
    function preload() {
      for (let i = 0; i < songPaths.length; i++) {
        songs[i] = loadSound(songPaths[i]);
      }
      palettes[0].colors = [color('#00ccff'), color('#cc00ff'), color('#66ccff')];
      palettes[1].colors = [color('#ff0000'), color('#ff6600'), color('#ffcc00')];
    }
    
    function setup() {
      canvas = createCanvas(windowWidth, windowHeight);
      canvas.position(0, 0);
      // Make canvas focusable so it can capture key events.
      canvas.elt.setAttribute('tabindex', '0');
      canvas.elt.focus();
      vortexOriginX = width / 2;
      vortexOriginY = height / 2;
      lastWaveCycle = millis();
      for (let i = 0; i < numSWStars; i++) {
        swStars.push(new Star());
      }
      createVortexMatrix();
    }
    
    function draw() {
      background(0, 20);
      push();
        translate(width / 2, height / 2);
        for (let star of swStars) {
          star.update();
          star.display();
        }
      pop();
      if (!started) return;
      if (vortexActive) {
        let waveTime = millis() - lastWaveCycle;
        if (waveTime < waveDuration) {
          for (let i = 0; i < 3; i++) {
            vortexParticles.push(new VortexParticle());
          }
        } else if (waveTime > waveDuration + wavePause) {
          lastWaveCycle = millis();
        }
      }
      for (let i = vortexParticles.length - 1; i >= 0; i--) {
        vortexParticles[i].update();
        vortexParticles[i].display();
        if (vortexParticles[i].alpha <= 0) {
          vortexParticles.splice(i, 1);
        }
      }
      if (millis() - lastShootingStarTime > shootingStarInterval) {
        shootingStars.push(new ShootingStar());
        lastShootingStarTime = millis();
      }
      for (let i = shootingStars.length - 1; i >= 0; i--) {
        shootingStars[i].update();
        shootingStars[i].display();
        if (shootingStars[i].isOffScreen()) {
          shootingStars.splice(i, 1);
        }
      }
    }
    
    // Modified VortexParticle uses vortexOriginX and vortexOriginY
    class VortexParticle {
      constructor() {
        this.angle = random(TWO_PI);
        this.radius = random(0, 10);
        this.angularSpeed = random(0.010, 0.02);
        this.radialSpeed = random(2, 2.5);
        this.col = currentPalette ? random(currentPalette) : color('#00ccff');
        this.size = random(4, 8);
        this.alpha = 255;
      }
      update() {
        this.radius += this.radialSpeed;
        this.angle += this.angularSpeed;
        if (!vortexActive) {
          this.alpha -= 5;
        }
      }
      display() {
        let x = vortexOriginX + this.radius * cos(this.angle);
        let y = vortexOriginY + this.radius * sin(this.angle);
        noStroke();
        fill(red(this.col), green(this.col), blue(this.col), this.alpha);
        ellipse(x, y, this.size);
      }
    }
    
    class ShootingStar {
      constructor() {
        if (random() < 0.5) {
          this.x = -50;
          this.y = random(height);
        } else {
          this.x = random(width);
          this.y = -50;
        }
        this.vel = createVector(random(5, 10), random(5, 10));
        this.trailLength = random(50, 150);
        this.alpha = 255;
      }
      update() {
        this.x += this.vel.x;
        this.y += this.vel.y;
        this.alpha -= 5;
      }
      display() {
        stroke(255, this.alpha);
        strokeWeight(2);
        line(this.x, this.y, this.x - this.vel.x * this.trailLength / 20, this.y - this.vel.y * this.trailLength / 20);
        noStroke();
        fill(255, this.alpha);
        ellipse(this.x, this.y, 4);
      }
      isOffScreen() {
        return this.x > width + 50 || this.y > height + 50 || this.alpha <= 0;
      }
    }
    
    class Star {
      constructor() {
        this.x = random(-width / 2, width / 2);
        this.y = random(-height / 2, height / 2);
        this.z = random(width);
        this.origZ = this.z;
      }
      update() {
        let speed = 0.2;
        this.z -= speed;
        if (this.z < 1) {
          this.z = this.origZ;
          this.x = random(-width / 2, width / 2);
          this.y = random(-height / 2, height / 2);
        }
      }
      display() {
        fill(255);
        noStroke();
        let sx = (this.x / this.z) * width / 2;
        let sy = (this.y / this.z) * height / 2;
        let r = map(this.z, 0, width, 3, 0);
        ellipse(sx, sy, r, r);
      }
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      vortexOriginX = width / 2;
      vortexOriginY = height / 2;
      lastWaveCycle = millis();
      createVortexMatrix();
    }
    
    function goFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.error(`Erreur: ${err.message}`);
        });
      }
    }
    
    function pickRandomSong() {
      let index = floor(random(songs.length));
      return songs[index];
    }
    
    function keyPressed() {
      if (!started || activationLocked) return;
      if (key === ' ') {
        vortexActive = true;
        currentPalette = random(palettes).colors;
        lastWaveCycle = millis();
        if (currentSong === null) {
          currentSong = pickRandomSong();
          currentSong.onended(() => {
            if (vortexActive) {
              currentSong = pickRandomSong();
              currentSong.onended(arguments.callee);
              currentSong.play();
            }
          });
          currentSong.play();
        } else if (!currentSong.isPlaying()) {
          currentSong.play();
        }
      }
    }
    
    function keyReleased() {
      if (!started) return;
      if (key === ' ') {
        vortexActive = false;
        if (currentSong && currentSong.isPlaying()) {
          currentSong.pause();
        }
        activationLocked = true;
        setTimeout(() => {
          activationLocked = false;
        }, 1000);
      }
    }
    
    document.getElementById("startButton").addEventListener("click", function() {
      started = true;
      document.getElementById("promptOverlay").style.display = "none";
      // Show the dot matrix after starting.
      document.getElementById("vortexMatrix").style.display = "grid";
      goFullscreen();
      canvas.elt.focus();
    });
    
    document.getElementById("infoButton").addEventListener("click", function() {
      document.getElementById("infoModal").style.display = "block";
    });
    
    document.getElementById("closeModal").addEventListener("click", function() {
      document.getElementById("infoModal").style.display = "none";
    });
    
    // --- New code for the vortex matrix ---
    function createVortexMatrix() {
      const matrixContainer = document.getElementById('vortexMatrix');
      // Clear any existing dots
      matrixContainer.innerHTML = '';
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          let dot = document.createElement('div');
          dot.classList.add('matrixDot');
          dot.dataset.row = row;
          dot.dataset.col = col;
          // Highlight center dot by default
          if (row === 1 && col === 1) {
            dot.classList.add('selected');
          }
          dot.addEventListener('click', function() {
            vortexOriginX = ((parseInt(dot.dataset.col) + 0.5) / 3) * width;
            vortexOriginY = ((parseInt(dot.dataset.row) + 0.5) / 3) * height;
            document.querySelectorAll('.matrixDot').forEach(d => d.classList.remove('selected'));
            dot.classList.add('selected');
            canvas.elt.focus();
          });
          matrixContainer.appendChild(dot);
        }
      }
    }
  </script>
  <script src="../../js/translationonly.js"></script>

    <script src="../../js/home-button.js" defer></script>
</body>
</html>
