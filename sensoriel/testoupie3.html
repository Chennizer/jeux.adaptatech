<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Ensure viewport fits the screen completely, including iOS safe areas -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../../images/binou.png">
  <!-- Link to external stylesheet -->
  <link rel="stylesheet" href="../../css/ipadteachh.css">
  <link rel="stylesheet" href="../../css/control-panel.css">
  <title>2Ã—2 Puzzle with Bold Border and No Scrolling</title>

  <style>
    /* 1. Reset and Global Styles */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* 2. Puzzle Container */
    .puzzle-container {
      width: calc(100vw - 60px);  /* 100vw minus 30px border on each side */
      height: calc(100vh - 60px); /* 100vh minus 30px border on top and bottom */
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 40px;                   /* Space between left and right areas */
      padding: 20px;
      flex-wrap: wrap;             /* Allow wrapping on smaller screens */
      overflow: hidden;            /* Prevent internal scrolling */
      position: relative;
    }

    /* 3. Scrambled Pieces Area */
    #piecesArea {
      position: relative;
      width: 350px;                /* Adjusted width to fit within container */
      height: 350px;               /* Adjusted height to fit within container */
      background: #ddd;
      border: 2px solid #999;
      border-radius: 8px;
      display: grid;
      grid-template-columns: repeat(2, 1fr); /* 2 columns for 2x2 grid */
      grid-template-rows: repeat(2, 1fr);    /* 2 rows for 2x2 grid */
      gap: 20px;                              /* Space between grid cells */
      overflow: hidden;                       /* Hide overflow */
      max-width: 90%;
      max-height: 90%;
    }

    /* 4. Puzzle Board Area */
    #puzzleArea {
      width: 268px;                /* 2 columns Ã— 130px each + 8px border (4px each side) */
      height: 268px;               /* 2 rows Ã— 130px each + 8px border */
      background: #fff;
      border: 4px solid #000;      /* Bold black border */
      border-radius: 8px;
      display: grid;
      grid-template-columns: repeat(2, 130px); /* 2 columns of 130px each */
      grid-template-rows: repeat(2, 130px);    /* 2 rows of 130px each */
      gap: 0;                                     /* No gaps */
      box-sizing: border-box;                    /* Include border in dimensions */
      position: relative;
      max-width: 90%;
      max-height: 90%;
    }

    #toggleReferenceContainer {
      position: fixed;
      bottom: 40px; /* Distance from bottom */
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      text-align: center;
    }

    /* 5. Puzzle Slots */
    .slot {
      width: 130px;
      height: 130px;
      background: #e2e2e2;
      border: 1px solid #ccc;
      position: relative;
      overflow: hidden; 
      box-sizing: border-box;
    }

    /* 6. Draggable Puzzle Pieces */
    .draggable-piece {
      width: 130px;
      height: 130px;
      cursor: grab;
      border: 2px solid transparent;
      border-radius: 4px;
      object-fit: cover;  
      position: absolute; /* Initial absolute positioning */
      touch-action: none; /* Prevent default touch actions */
      user-select: none;   /* Prevent text selection */
      transition: opacity 0.2s;
    }

    .draggable-piece.active {
      opacity: 0.8;
      cursor: grabbing;
      z-index: 1000; /* Bring to front when dragging */
    }

    /* 7. Hidden Canvas for Image Slicing */
    #hiddenCanvas {
      display: none;
    }

    /* 8. Title Styling */
    h1 {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 1.5rem;
      color: #333;
      z-index: 10;
    }

    /* 9. Highlight Indicator */
    .highlight {
      outline: 3px dashed #00aaff; 
      outline-offset: -5px;
      background-color: rgba(0, 170, 255, 0.1); /* Subtle highlight */
    }

    /* 10. Modal Styles */

    /* Modal Overlay */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1000; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0, 0, 0, 0.5); /* Black w/ opacity */
        justify-content: center; /* Center horizontally */
        align-items: center; /* Center vertically */
    }

    /* Modal Content */
    .modal-content {
        background-color: #fefefe;
        padding: 20px;
        border-radius: 8px;
        position: relative;
        max-width: 90%;
        max-height: 90%;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    /* Close Button */
    .close {
        background: none;
        border: none;
        font-size: 28px;
        font-weight: bold;
        position: absolute;
        top: 10px;
        right: 15px;
        color: #aaa;
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }

    .close:hover,
    .close:focus {
        color: #000;
    }

    /* Show Modal as Flex when Displayed */
    .modal.flex {
        display: flex;
    }

    @media (max-width: 800px) {
      #piecesArea {
        width: 300px;
        height: 300px;
      }
      #puzzleArea {
        width: 268px;
        height: 268px;
      }
      .puzzle-container {
        gap: 20px;
        padding: 10px;
      }
    }

    @media (max-width: 600px) {
      #piecesArea {
        width: 250px;
        height: 250px;
      }
      #puzzleArea {
        width: 218px;
        height: 218px;
      }
      .draggable-piece {
        width: 100px;
        height: 100px;
      }
      h1 {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>

  <h1>Enhanced Dispersed Puzzle with Moana Background</h1>

  <div class="puzzle-container">
    <!-- Scrambled Pieces Area -->
    <div id="piecesArea">
      <!-- Puzzle pieces will be dynamically inserted here -->
    </div>
    <!-- Puzzle Board Area -->
    <div id="puzzleArea">
      <!-- Puzzle slots will be dynamically inserted here -->
    </div>
  </div>

  <!-- Toggle Reference Button Container -->
  <div id="toggleReferenceContainer">
    <button id="toggleReference" class="button">Show Reference</button>
  </div>

  <!-- Modal Structure -->
  <div id="referenceModal" class="modal">
    <div class="modal-content">
        <button class="close" aria-label="Close Modal">&times;</button>
        <img class="modal-image" src="../../images/moana-background.jpg" alt="Completed Puzzle Model">
    </div>
  </div>
  
  <!-- Hidden Canvas for Image Slicing -->
  <canvas id="hiddenCanvas"></canvas>

  <script>
    /* 
      Puzzle Logic:
      1. Load an image and slice it into 2Ã—2 pieces.
      2. Shuffle the pieces and place them in the scrambled area.
      3. Allow drag-and-drop functionality to place pieces into puzzle slots.
      4. Implement swapping of pieces when dropping onto an occupied slot.
      5. Detect puzzle completion.
    */

    // Configuration Constants
    const ROWS = 2;
    const COLS = 2;
    const PIECE_SIZE = 130; // px
    const puzzleImagePath = "../../images/moana-background.jpg"; // Update path as needed

    let puzzlePieces = [];

    /* Grab DOM References */
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const piecesArea   = document.getElementById('piecesArea');
    const puzzleArea   = document.getElementById('puzzleArea');
    const ctx          = hiddenCanvas.getContext('2d');

    const referenceModal = document.getElementById('referenceModal');
    const closeModalBtn = document.querySelector('.close');
    const toggleReferenceBtn = document.getElementById('toggleReference');

    /* Function to Open the Modal */
    const openModal = () => {
        referenceModal.classList.add('flex'); // Use the helper class to display the modal
        document.documentElement.style.overflow = 'hidden'; // Prevents body scrolling
    };

    /* Function to Close the Modal */
    const closeModal = () => {
        referenceModal.classList.remove('flex'); // Hide the modal
        document.documentElement.style.overflow = ''; // Restore scrolling
    };

    /* Event Listeners for Opening Modal */
    toggleReferenceBtn.addEventListener('click', openModal);
    toggleReferenceBtn.addEventListener('touchend', openModal);

    /* Event Listeners for Closing Modal via Close Button */
    closeModalBtn.addEventListener('click', closeModal);
    closeModalBtn.addEventListener('touchend', closeModal);

    /* Event Listener for Closing Modal When Clicking or Touching Outside Modal Content */
    referenceModal.addEventListener('click', (event) => {
        // If the user clicks directly on the modal overlay (not the modal content or its children)
        if (event.target === referenceModal) {
            closeModal();
        }
    });

    /* Prevent Clicks/Taps Inside Modal Content from Closing the Modal */
    const modalContent = document.querySelector('.modal-content');

    modalContent.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevents the click from bubbling up to the modal overlay
    });

    modalContent.addEventListener('touchend', (event) => {
        event.stopPropagation(); // Prevents the touch from bubbling up to the modal overlay
    });

    /* Optional: Close modal on 'Escape' key press for better accessibility */
    window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            closeModal();
        }
    });

    /* On Page Load, Initialize Puzzle */
    window.addEventListener('load', () => {
      const puzzleImage = new Image();
      puzzleImage.src = puzzleImagePath;
      puzzleImage.onload = () => createPuzzleFromImage(puzzleImage);
      puzzleImage.onerror = err => console.error("Image failed to load:", err);
    });

    /* Create Puzzle by Slicing the Image */
    function createPuzzleFromImage(image) {
      // Clear any existing puzzle pieces
      puzzleArea.innerHTML = "";
      piecesArea.innerHTML = "";
      puzzlePieces = [];

      // Set canvas size to image size
      hiddenCanvas.width = image.width;
      hiddenCanvas.height = image.height;
      ctx.drawImage(image, 0, 0);

      // Calculate piece dimensions
      const sourcePieceWidth  = image.width  / COLS;
      const sourcePieceHeight = image.height / ROWS;

      // Slice the image into pieces
      let pieceIndex = 0;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const pieceCanvas = document.createElement('canvas');
          pieceCanvas.width = sourcePieceWidth;
          pieceCanvas.height = sourcePieceHeight;
          const pieceCtx = pieceCanvas.getContext('2d');

          // Draw the slice onto the piece canvas
          pieceCtx.drawImage(
            image,
            col * sourcePieceWidth,
            row * sourcePieceHeight,
            sourcePieceWidth,
            sourcePieceHeight,
            0,
            0,
            sourcePieceWidth,
            sourcePieceHeight
          );

          // Convert to Data URL
          const pieceDataURL = pieceCanvas.toDataURL();

          // Store piece data
          puzzlePieces.push({
            index: pieceIndex,
            row,
            col,
            img: pieceDataURL
          });

          pieceIndex++;
        }
      }

      // Build Puzzle Slots
      for (let i = 0; i < puzzlePieces.length; i++) {
        const slot = document.createElement('div');
        slot.classList.add('slot');
        slot.dataset.index = i; // For correctness check

        // Make slot droppable
        slot.addEventListener('dragover', allowDrop);
        slot.addEventListener('drop', onDrop);

        // Highlight on drag enter/leave
        slot.addEventListener('dragenter', onDragEnter);
        slot.addEventListener('dragleave', onDragLeave);

        puzzleArea.appendChild(slot);
      }

      // Allow dropping back into the pieces area
      piecesArea.addEventListener('dragover', allowDrop);
      piecesArea.addEventListener('drop', onDropLeft);
      piecesArea.addEventListener('dragenter', onDragEnter);
      piecesArea.addEventListener('dragleave', onDragLeave);

      // Shuffle and place pieces in scrambled area
      shuffleArray(puzzlePieces);
      puzzlePieces.forEach(piece => {
        const imgEl = document.createElement('img');
        imgEl.src = piece.img;
        imgEl.classList.add('draggable-piece');
        imgEl.draggable = true;
        imgEl.dataset.index = piece.index;

        // Set size
        imgEl.style.width  = PIECE_SIZE + "px";
        imgEl.style.height = PIECE_SIZE + "px";

        // Drag events
        imgEl.addEventListener('dragstart', onDragStart);
        imgEl.addEventListener('dragend',   onDragEnd);

        // Place randomly within their assigned grid cell
        placePieceInGridCell(imgEl, piece);
        piecesArea.appendChild(imgEl);

        // Add touch event listeners for iPad
        imgEl.addEventListener('touchstart', touchStartHandler, { passive: false });
        imgEl.addEventListener('touchmove', touchMoveHandler, { passive: false });
        imgEl.addEventListener('touchend', touchEndHandler);
      });
    }

    /* Place a Piece Randomly Within a Grid Cell in #piecesArea */
    function placePieceInGridCell(pieceEl, piece) {
      const totalCells = ROWS * COLS;
      const availableCells = [...Array(totalCells).keys()];

      // Randomly select a cell
      const randomIndex = Math.floor(Math.random() * availableCells.length);
      const selectedCell = availableCells.splice(randomIndex, 1)[0];

      const cellRow = Math.floor(selectedCell / COLS);
      const cellCol = selectedCell % COLS;

      const piecesAreaWidth = piecesArea.clientWidth;
      const piecesAreaHeight = piecesArea.clientHeight;
      const cellWidth = piecesAreaWidth / COLS;
      const cellHeight = piecesAreaHeight / ROWS;

      // Random offset within the cell
      const maxOffsetX = cellWidth - PIECE_SIZE - 10; // 10px padding
      const maxOffsetY = cellHeight - PIECE_SIZE - 10; // 10px padding
      const offsetX = Math.floor(Math.random() * Math.max(1, maxOffsetX));
      const offsetY = Math.floor(Math.random() * Math.max(1, maxOffsetY));

      // Position the piece
      pieceEl.style.left = (cellCol * cellWidth + offsetX) + 'px';
      pieceEl.style.top  = (cellRow * cellHeight + offsetY) + 'px';
    }

    /* Drag and Drop Handlers */

    // Start Dragging
    function onDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.index);
      e.target.classList.add('active');

      // Record the original container and slot (if any)
      const originalParent = e.target.parentElement;
      e.target.dataset.originalParent = originalParent.id || originalParent.className;
      if (originalParent.classList.contains('slot')) {
        e.target.dataset.originalSlot = originalParent.dataset.index;
      } else {
        e.target.dataset.originalSlot = 'piecesArea';
      }
    }

    // End Dragging
    function onDragEnd(e) {
      e.target.classList.remove('active');
    }

    // Allow Drop
    function allowDrop(e) {
      e.preventDefault();
    }

    // Highlight Slot on Drag Enter
    function onDragEnter(e) {
      e.currentTarget.classList.add('highlight');
    }

    // Remove Highlight on Drag Leave
    function onDragLeave(e) {
      e.currentTarget.classList.remove('highlight');
    }

    // Handle Drop into Puzzle Slot
    function onDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('highlight');

      const pieceIndex = e.dataTransfer.getData('text/plain');
      const slot = e.currentTarget;
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);

      if (!draggedImg) return;

      // Get original container and slot
      const originalParentId = draggedImg.dataset.originalParent;
      const originalSlot = draggedImg.dataset.originalSlot;

      // Check if the target slot already has a piece
      const existingPiece = slot.querySelector('img');

      if (existingPiece) {
        // Swap the pieces
        // Move the existing piece back to the original container
        if (originalParentId === 'piecesArea') {
          piecesArea.appendChild(existingPiece);
          existingPiece.style.position = 'absolute';
          existingPiece.style.width  = PIECE_SIZE + "px";
          existingPiece.style.height = PIECE_SIZE + "px";
          placePieceInGridCell(existingPiece, puzzlePieces[existingPiece.dataset.index]);
        } else {
          // If the original container was a slot, place the existing piece there
          const originalSlotElement = document.querySelector(`.slot[data-index='${originalSlot}']`);
          if (originalSlotElement) {
            originalSlotElement.innerHTML = '';
            originalSlotElement.appendChild(existingPiece);
            existingPiece.style.position = 'absolute';
            existingPiece.style.left = '0';
            existingPiece.style.top = '0';
            existingPiece.style.width = '100%';
            existingPiece.style.height = '100%';
          }
        }
      }

      // Place the dragged piece into the slot
      slot.innerHTML = '';
      slot.appendChild(draggedImg);

      // Adjust styling
      draggedImg.style.position = 'absolute';
      draggedImg.style.left = '0';
      draggedImg.style.top  = '0';
      draggedImg.style.width  = '100%';
      draggedImg.style.height = '100%';

      // Update dataset to reflect new container
      draggedImg.dataset.originalParent = slot.classList.contains('slot') ? slot.className : slot.id;
      draggedImg.dataset.originalSlot = slot.dataset.index;

      // Check for puzzle completion
      checkPuzzleCompletion();
    }

    // Handle Drop Back into Pieces Area
    function onDropLeft(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('highlight');

      const pieceIndex = e.dataTransfer.getData('text/plain');
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);

      if (!draggedImg) return;

      // Get original container and slot
      const originalParentId = draggedImg.dataset.originalParent;
      const originalSlot = draggedImg.dataset.originalSlot;

      // If it was in a slot, remove it from there
      if (originalParentId !== 'piecesArea') {
        const originalSlotElement = document.querySelector(`.slot[data-index='${originalSlot}']`);
        if (originalSlotElement) {
          originalSlotElement.innerHTML = "";
        }
      }

      // Place it back into piecesArea
      piecesArea.appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.width  = PIECE_SIZE + "px";
      draggedImg.style.height = PIECE_SIZE + "px";
      placePieceInGridCell(draggedImg, puzzlePieces[pieceIndex]);

      // Update dataset to reflect new container
      draggedImg.dataset.originalParent = 'piecesArea';
      draggedImg.dataset.originalSlot = 'piecesArea';
    }

    /* Shuffle Array In-Place */
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    /* Check if Puzzle is Completed */
    function checkPuzzleCompletion() {
      let correct = 0;
      const slots = document.querySelectorAll('.slot');
      slots.forEach(slot => {
        const slotIndex = slot.dataset.index;
        const pieceImg  = slot.querySelector('img');
        if (pieceImg && pieceImg.dataset.index === slotIndex) {
          correct++;
        }
      });
      if (correct === ROWS * COLS) {
        alert("ðŸŽ‰ Puzzle Completed! ðŸŽ‰");
      }
    }

    /* Touch Event Handling for iPad */

    let touchData = {
      dragging: false,
      element: null,
      originalParent: null,
      originalSlot: null,
      originalPosition: { left: 0, top: 0 },
      offsetX: 0,
      offsetY: 0
    };

    // Touch Start Handler
    function touchStartHandler(e) {
      e.preventDefault();
      const touch = e.touches[0];
      touchData.dragging = true;
      touchData.element = e.target;
      touchData.originalParent = touchData.element.parentElement;
      if (touchData.element.parentElement.classList.contains('slot')) {
        touchData.originalSlot = touchData.element.parentElement.dataset.index;
      } else {
        touchData.originalSlot = 'piecesArea';
      }

      touchData.element.classList.add('active');

      const rect = touchData.element.getBoundingClientRect();
      touchData.offsetX = touch.clientX - rect.left;
      touchData.offsetY = touch.clientY - rect.top;

      // Store original position
      touchData.originalPosition.left = rect.left;
      touchData.originalPosition.top = rect.top;

      // Bring the element to front
      touchData.element.style.zIndex = 1000;

      // Change position to fixed to allow dragging across the screen
      touchData.element.style.position = 'fixed';
      touchData.element.style.left = `${touch.clientX - touchData.offsetX}px`;
      touchData.element.style.top  = `${touch.clientY - touchData.offsetY}px`;
    }

    // Touch Move Handler
    function touchMoveHandler(e) {
      if (!touchData.dragging) return;
      e.preventDefault();
      const touch = e.touches[0];
      // Set position to fixed based on touch coordinates
      touchData.element.style.left = `${touch.clientX - touchData.offsetX}px`;
      touchData.element.style.top  = `${touch.clientY - touchData.offsetY}px`;
    }

    // Touch End Handler
    function touchEndHandler(e) {
      if (!touchData.dragging) return;
      touchData.dragging = false;
      touchData.element.classList.remove('active');

      // Get the touch end position
      const touch = e.changedTouches[0];

      // Instead of hiding the element, set pointer-events to none for drop detection
      touchData.element.style.pointerEvents = 'none';

      const dropTarget = getDropTarget(touch.clientX, touch.clientY);

      // Restore pointer-events
      touchData.element.style.pointerEvents = '';

      if (dropTarget) {
        if (dropTarget.classList.contains('slot')) {
          onDropTouch(touch.clientX, touch.clientY, dropTarget, touchData.element);
        } else if (dropTarget.id === 'piecesArea') {
          onDropLeftTouch(touch.clientX, touch.clientY, touchData.element);
        } else {
          // Snap back to original position if not a valid drop target
          resetTouchElementPosition(touchData.element);
        }
      } else {
        // Snap back to original position if not dropped on a valid target
        resetTouchElementPosition(touchData.element);
      }

      // Reset zIndex and position
      touchData.element.style.zIndex = '';
      touchData.element.style.position = 'absolute';
      touchData.element = null;
    }

    // Handle Dropping onto a Puzzle Slot via Touch
    function onDropTouch(clientX, clientY, slotEl, draggedImg) {
      // Get original container and slot
      const originalParentId = touchData.originalParent.id || touchData.originalParent.className;
      const originalSlot = touchData.originalSlot;

      // If the slot already has a piece, swap it
      const existingPiece = slotEl.querySelector('img');

      if (existingPiece) {
        // Swap the pieces
        // Move the existing piece back to the original container
        if (originalParentId === 'piecesArea') {
          piecesArea.appendChild(existingPiece);
          existingPiece.style.position = 'absolute';
          existingPiece.style.width  = PIECE_SIZE + "px";
          existingPiece.style.height = PIECE_SIZE + "px";
          placePieceInGridCell(existingPiece, puzzlePieces[existingPiece.dataset.index]);
        } else {
          // If original container was a slot, place existing piece there
          const originalSlotElement = document.querySelector(`.slot[data-index='${originalSlot}']`);
          if (originalSlotElement) {
            originalSlotElement.innerHTML = '';
            originalSlotElement.appendChild(existingPiece);
            existingPiece.style.position = 'absolute';
            existingPiece.style.left = '0';
            existingPiece.style.top = '0';
            existingPiece.style.width = '100%';
            existingPiece.style.height = '100%';
          }
        }
      }

      // Place dragged piece into the slot
      slotEl.innerHTML = '';
      slotEl.appendChild(draggedImg);

      // Adjust styling
      draggedImg.style.position = 'absolute';
      draggedImg.style.left = '0';
      draggedImg.style.top  = '0';
      draggedImg.style.width  = '100%';
      draggedImg.style.height = '100%';

      // Update dataset to reflect new container
      draggedImg.dataset.originalParent = slotEl.classList.contains('slot') ? slotEl.className : slotEl.id;
      draggedImg.dataset.originalSlot = slotEl.dataset.index;

      // Check for puzzle completion
      checkPuzzleCompletion();
    }

    // Handle Dropping Back into Pieces Area via Touch
    function onDropLeftTouch(clientX, clientY, draggedImg) {
      // If the piece was in a slot, remove it from there
      const oldParent = draggedImg.parentElement;
      if (oldParent && oldParent.classList.contains('slot')) {
        oldParent.innerHTML = ""; // Remove the piece from that slot
      }

      // Place it back into piecesArea
      piecesArea.appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.width  = PIECE_SIZE + "px";
      draggedImg.style.height = PIECE_SIZE + "px";
      placePieceInGridCell(draggedImg, puzzlePieces[draggedImg.dataset.index]);

      // Update dataset to reflect new container
      draggedImg.dataset.originalParent = 'piecesArea';
      draggedImg.dataset.originalSlot = 'piecesArea';
    }

    // Reset Position if Dropped Outside Valid Targets
    function resetTouchElementPosition(pieceEl) {
      // If the piece is in the piecesArea, ensure it's correctly placed
      if (pieceEl.parentElement.id === 'piecesArea') {
        placePieceInGridCell(pieceEl, puzzlePieces[pieceEl.dataset.index]);
      } else {
        // If the piece was in a slot but not dropped correctly, snap back
        // Implement snapping back logic if needed
      }
    }

    /* Helper Function to Get Drop Target Based on Coordinates */
    function getDropTarget(x, y) {
      const elem = document.elementFromPoint(x, y);
      if (!elem) return null;
      return elem.closest('.slot') || (elem.id === 'piecesArea' ? elem : null);
    }

    /* Handle Touch Drop into Slot */
    function onDropTouch(clientX, clientY, slotEl, draggedImg) {
      // This function was defined earlier; ensure it's included once
    }

    /* Helper Functions for Touch Events */

    /* Note: Ensure that onDropTouch and onDropLeftTouch are properly defined above */

  </script>
</body>
</html>
