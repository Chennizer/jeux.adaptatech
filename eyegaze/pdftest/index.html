<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title class="translate" data-fr="PDF ‚Äî Avancer en cliquant" data-en="PDF ‚Äî Click to Advance">PDF ‚Äî Avancer en cliquant</title>

  <!-- pdf.js (CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.worker.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>

  <style>
    :root{ --teal:#009688; --bg:#000; --fg:#fff; }
    html,body{ margin:0; height:100%; background:var(--bg); color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; overflow:hidden; }

    /* Canvas layer (below UI) */
    #stage{
      position:fixed; inset:0; display:grid; place-items:center; background:#000;
      cursor:pointer; z-index:1;   /* <- keep BELOW the UI */
    }
    canvas{ display:block; max-width:100vw; max-height:100vh; }

    /* UI layers (above canvas) */
    #topbar{
      position:fixed; top:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center;
      justify-content:space-between; z-index:5;    /* <- above */
    }
    #pickerRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .btn{
      background:var(--teal); color:#fff; border:none; border-radius:12px; padding:12px 16px;
      font-weight:800; cursor:pointer; font-size:16px; box-shadow:0 2px 10px rgba(0,0,0,.25);
    }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    #fileInput{ padding:8px; border-radius:10px; border:1px solid #333; background:#111; color:#ddd; }
    #tips{ display:inline-flex; gap:8px; align-items:center; padding:8px 10px;
      border:1px dashed #444; border-radius:10px; background:#0a0a0a; color:#ddd; font-size:14px; z-index:5; }

    #centerPrompt{
      position:fixed; inset:0; display:grid; place-items:center; z-index:6;  /* <- above everything */
      background: radial-gradient(transparent, rgba(0,0,0,.35) 60%);
    }
    #centerPrompt .card{
      text-align:center; background:#111; border:1px solid #333; border-radius:16px;
      padding:20px; max-width:min(700px,90vw); box-shadow:0 10px 30px rgba(0,0,0,.4);
    }
    #chooseBtnBig{ font-size:18px; padding:14px 18px; }

    #hud{
      position:fixed; left:12px; bottom:12px; padding:6px 10px;
      background:rgba(0,0,0,.5); border:1px solid rgba(255,255,255,.2);
      border-radius:10px; font-size:14px; user-select:none; z-index:5;
      display:flex; align-items:center; gap:8px; min-height:28px;
      transition:border-color 160ms ease, box-shadow 160ms ease;
    }
    #hud[data-speaking="true"]{
      border-color:rgba(0,150,136,0.8);
      box-shadow:0 0 10px rgba(0,150,136,0.35);
    }
    #hudStatus{ opacity:.8; font-weight:600; min-width:50px; }

    #langToggle{
      position:fixed; top:10px; right:10px; z-index:7;
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px;
      border-radius:10px; border:2px solid var(--teal); background:#111; color:#fff; cursor:pointer; user-select:none;
    }
  </style>
</head>
<body>
  <!-- Language toggle -->
  <div id="langToggle" title="Basculer la langue / Toggle language">FR / EN</div>

  <div id="topbar">
    <div id="pickerRow">
      <button id="chooseBtn" class="btn">
        <span class="translate" data-fr="Choisir un PDF" data-en="Choose PDF">Choisir un PDF</span>
      </button>
      <input id="fileInput" type="file" accept="application/pdf" />
      <button id="startBtn" class="btn" disabled>
        <span class="translate" data-fr="Mode plein √©cran" data-en="Fullscreen mode">Mode plein √©cran</span>
      </button>
    </div>
    <div id="tips">
      <span>üñ±Ô∏è</span>
      <span class="translate" data-fr="Cliquez n‚Äôimporte o√π pour avancer. Reboucle √† la fin."
            data-en="Click anywhere to advance. Loops at the end.">
        Cliquez n‚Äôimporte o√π pour avancer. Reboucle √† la fin.
      </span>
    </div>
  </div>

  <!-- Big central prompt (first-run helper) -->
  <div id="centerPrompt">
    <div class="card">
      <h2 class="translate" data-fr="Charger un PDF" data-en="Load a PDF">Charger un PDF</h2>
      <p class="translate" data-fr="Appuyez sur le bouton ci-dessous pour choisir un fichier PDF multi-pages."
         data-en="Press the button below to choose a multi-page PDF file.">
        Appuyez sur le bouton ci-dessous pour choisir un fichier PDF multi-pages.
      </p>
      <button id="chooseBtnBig" class="btn">
        <span class="translate" data-fr="Choisir un PDF‚Ä¶" data-en="Choose PDF‚Ä¶">Choisir un PDF‚Ä¶</span>
      </button>
      <p style="opacity:.8; margin-top:10px" class="translate"
         data-fr="Astuce : vous pouvez aussi d√©poser un PDF dans la fen√™tre."
         data-en="Tip: you can also drop a PDF into the window.">
         Astuce : vous pouvez aussi d√©poser un PDF dans la fen√™tre.
      </p>
    </div>
  </div>

  <!-- Canvas display (below UI) -->
  <div id="stage" aria-label="Zone d‚Äôaffichage PDF">
    <canvas id="pageCanvas" aria-hidden="true"></canvas>
  </div>

  <div id="hud" data-speaking="false">
    <span id="pageLabel">‚Äî</span>
    <span id="hudStatus"></span>
  </div>

  <script>
    // ===== Language toggle =====
    const langToggle = document.getElementById('langToggle');
    let currentLang = 'fr';
    function applyLang(){
      document.querySelectorAll('.translate').forEach(el=>{
        const txt = el.dataset[currentLang];
        if (txt) el.textContent = txt;
      });
      updateSpeakingStatus();
    }
    langToggle.addEventListener('click', async ()=>{
      invalidateAnnouncements();
      cancelSpeech();
      currentLang = (currentLang === 'fr') ? 'en' : 'fr';
      applyLang();
      if (canUseSpeech()) choosePreferredVoice();
      if (started && canUseSpeech()) await announceCurrentPage();
    });
    applyLang();

    // ===== Elements =====
    const pdfjsLibGlobal = window['pdfjsLib'];
    const chooseBtn = document.getElementById('chooseBtn');
    const chooseBtnBig = document.getElementById('chooseBtnBig');
    const fileInput = document.getElementById('fileInput');
    const startBtn  = document.getElementById('startBtn');
    const stage     = document.getElementById('stage');
    const canvas    = document.getElementById('pageCanvas');
    const ctx       = canvas.getContext('2d');
    const hud       = document.getElementById('hud');
    const hudLabel  = document.getElementById('pageLabel');
    const hudStatus = document.getElementById('hudStatus');
    const centerPrompt = document.getElementById('centerPrompt');
    updateSpeakingStatus();

    // ===== State =====
    let pdfDoc = null, currentPageNum = 1, totalPages = 0, started = false, loading = false, pdfData = null;
    let preferredVoice = null;
    let speaking = false;
    let analyzingPage = false;
    const ocrCache = new Map();
    let announceToken = 0;

    const canUseSpeech = () => typeof window !== 'undefined'
      && 'speechSynthesis' in window
      && typeof window.SpeechSynthesisUtterance !== 'undefined';

    function updateSpeakingStatus(){
      if (!hudStatus || !hud) return;
      if (!started){
        hudStatus.textContent = '';
        hud.setAttribute('data-speaking','false');
        return;
      }
      if (analyzingPage){
        hudStatus.textContent = currentLang === 'fr' ? 'Analyse‚Ä¶' : 'Analyzing‚Ä¶';
        hud.setAttribute('data-speaking','true');
        return;
      }
      if (!canUseSpeech()){
        hudStatus.textContent = currentLang === 'fr' ? 'Synth√®se indisponible' : 'Speech unavailable';
        hud.setAttribute('data-speaking','false');
        return;
      }
      if (speaking){
        hudStatus.textContent = currentLang === 'fr' ? 'Lecture‚Ä¶' : 'Speaking‚Ä¶';
        hud.setAttribute('data-speaking','true');
      }else{
        hudStatus.textContent = currentLang === 'fr' ? 'Pr√™t' : 'Ready';
        hud.setAttribute('data-speaking','false');
      }
    }

    function setHUD(){
      hudLabel.textContent = pdfDoc ? `${currentPageNum} / ${totalPages}` : '‚Äî';
      updateSpeakingStatus();
    }

    function cancelSpeech(){
      if (!canUseSpeech()){
        speaking = false;
        updateSpeakingStatus();
        return;
      }
      try{ speechSynthesis.cancel(); }catch(_){ }
      speaking = false;
      updateSpeakingStatus();
    }

    const invalidateAnnouncements = () => { announceToken++; };

    function choosePreferredVoice(){
      if (!canUseSpeech()) return;
      const ss = window.speechSynthesis;
      if (!ss || !ss.getVoices) return;
      const voices = ss.getVoices() || [];
      if (!voices.length) return;

      const lang = currentLang;
      const pick = (fn) => voices.find(fn);
      if (lang === 'fr'){
        preferredVoice =
          pick(v => /sylvie/i.test(v.name || '') && /^fr[-_]?CA/i.test(v.lang || '')) ||
          pick(v => /^fr[-_]?CA/i.test(v.lang || '')) ||
          pick(v => /^fr[-_]?FR/i.test(v.lang || '')) ||
          pick(v => (v.lang || '').toLowerCase().startsWith('fr')) ||
          voices[0];
      }else{
        preferredVoice =
          pick(v => /^en[-_]?CA/i.test(v.lang || '')) ||
          pick(v => /^en[-_]?US/i.test(v.lang || '')) ||
          pick(v => /^en[-_]?GB/i.test(v.lang || '')) ||
          pick(v => (v.lang || '').toLowerCase().startsWith('en')) ||
          voices[0];
      }
    }

    function voicesReady(){
      return new Promise((resolve)=>{
        if (!canUseSpeech()) return resolve();
        const ss = window.speechSynthesis;
        if (!ss) return resolve();
        const list = ss.getVoices();
        if (list && list.length) return resolve();
        const handle = () => {
          ss.removeEventListener('voiceschanged', handle);
          resolve();
        };
        ss.addEventListener('voiceschanged', handle);
      });
    }

    async function getPageText(pageNum){
      if (!pdfDoc) return '';
      const cacheKey = `${pageNum}:${currentLang}`;
      if (ocrCache.has(cacheKey)) return ocrCache.get(cacheKey);
      let page = null;
      let offscreen = null;
      try{
        page = await pdfDoc.getPage(pageNum);
        const textContent = await page.getTextContent();
        const raw = (textContent?.items || []).map(item => item?.str || '').join(' ');
        const cleaned = raw.replace(/\s+/g, ' ').trim();
        if (cleaned){
          ocrCache.set(cacheKey, cleaned);
          return cleaned;
        }
        if (!window.Tesseract){
          return '';
        }
        analyzingPage = true;
        updateSpeakingStatus();
        const viewport = page.getViewport({ scale: Math.max(2, (window.devicePixelRatio || 1) * 1.5) });
        offscreen = document.createElement('canvas');
        offscreen.width = Math.floor(viewport.width);
        offscreen.height = Math.floor(viewport.height);
        const offCtx = offscreen.getContext('2d');
        await page.render({ canvasContext: offCtx, viewport }).promise;
        const langCode = currentLang === 'fr' ? 'fra' : 'eng';
        let text = '';
        try{
          const result = await Tesseract.recognize(offscreen, langCode, {
            logger: ()=>{},
            workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/worker.min.js',
            corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract-core-simd.wasm.js',
            langPath: 'https://tessdata.projectnaptha.com/5.0.0_fast'
          });
          text = (result?.data?.text || '').replace(/\s+/g, ' ').trim();
        }catch(ocrErr){
          console.error('OCR error:', ocrErr);
        }
        ocrCache.set(cacheKey, text);
        return text;
      }catch(err){
        console.error('Text extraction error:', err);
        return '';
      }finally{
        analyzingPage = false;
        updateSpeakingStatus();
        if (offscreen){
          offscreen.width = 0;
          offscreen.height = 0;
          if (typeof offscreen.remove === 'function') offscreen.remove();
        }
        try{ page?.cleanup?.(); }catch(_){ }
      }
    }

    async function speakPageText(text){
      if (!canUseSpeech() || !text) return;
      cancelSpeech();
      await voicesReady();
      choosePreferredVoice();

      return new Promise((resolve)=>{
        if (!canUseSpeech()) return resolve();
        let resolved = false;
        const finish = () => {
          if (resolved) return;
          resolved = true;
          speaking = false;
          updateSpeakingStatus();
          resolve();
        };
        try{
          const utterance = new SpeechSynthesisUtterance(text);
          const fallbackLang = currentLang === 'fr' ? 'fr-CA' : 'en-US';
          if (preferredVoice){
            utterance.voice = preferredVoice;
            utterance.lang = preferredVoice.lang || fallbackLang;
          }else{
            utterance.lang = fallbackLang;
          }
          utterance.rate = 1.0;
          utterance.volume = 1.0;
          utterance.onend = finish;
          utterance.onerror = finish;
          speaking = true;
          updateSpeakingStatus();
          speechSynthesis.speak(utterance);
        }catch(err){
          console.error('Speech synthesis error:', err);
          finish();
        }
      });
    }

    async function announceCurrentPage(){
      const token = ++announceToken;
      if (!started){
        updateSpeakingStatus();
        return;
      }
      if (!canUseSpeech()){
        updateSpeakingStatus();
        return;
      }
      const text = await getPageText(currentPageNum);
      if (token !== announceToken) return;
      if (!text){
        speaking = false;
        updateSpeakingStatus();
        return;
      }
      await speakPageText(text);
    }

    async function updatePageView({ announce = true } = {}){
      await renderPage(currentPageNum);
      setHUD();
      if (announce) await announceCurrentPage();
    }
    async function goFullscreen(){ if (!document.fullscreenElement){ try{ await document.documentElement.requestFullscreen(); }catch(_){ } } }
    function hideCenterPrompt(){ centerPrompt.style.display = 'none'; }

    if (canUseSpeech()){
      try{
        speechSynthesis.addEventListener('voiceschanged', ()=>{
          choosePreferredVoice();
          updateSpeakingStatus();
        });
      }catch(_){ }
      choosePreferredVoice();
    }

    // Clear "Choose PDF" handlers
    chooseBtn.addEventListener('click', ()=> fileInput.click());
    chooseBtnBig.addEventListener('click', ()=> fileInput.click());

    // Drag & drop
    ;['dragenter','dragover'].forEach(ev=>{
      window.addEventListener(ev, e=>{ e.preventDefault(); }, {passive:false});
    });
    window.addEventListener('drop', async e=>{
      e.preventDefault();
      const file = [...(e.dataTransfer?.files||[])].find(f=>f.type==='application/pdf' || f.name?.toLowerCase().endsWith('.pdf'));
      if (file){ await loadPDFFile(file); }
    });

    // File selection
    fileInput.addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if(!file) return;
      await loadPDFFile(file);
    });

    async function loadPDFFile(file){
      cancelSpeech();
      invalidateAnnouncements();
      analyzingPage = false;
      started = false;
      pdfDoc = null;
      totalPages = 0;
      setHUD();
      ocrCache.clear();
      const arrBuf = await file.arrayBuffer();
      pdfData = arrBuf;
      fileInput.value = '';
      startBtn.disabled = false;
      hideCenterPrompt();
      updateSpeakingStatus();
      await openAndRender();
    }

    // Start viewer
    startBtn.addEventListener('click', async ()=>{
      if (!pdfData) return;
      await goFullscreen();
      if (!pdfDoc){
        await openAndRender();
      }else{
        await updatePageView();
      }
    });

    async function openAndRender(){
      if (!pdfData) return;
      try{
        cancelSpeech();
        invalidateAnnouncements();
        analyzingPage = false;
        const loadingTask = pdfjsLibGlobal.getDocument({ data: pdfData });
        pdfDoc = await loadingTask.promise;
        totalPages = pdfDoc.numPages;
        currentPageNum = 1;
        started = true;
        updateSpeakingStatus();
        if (canUseSpeech()) choosePreferredVoice();
        await updatePageView();
      }catch(err){
        console.error('PDF load error:', err);
        started = false;
        pdfDoc = null;
        totalPages = 0;
        setHUD();
        invalidateAnnouncements();
        updateSpeakingStatus();
        alert(currentLang === 'fr' ? "Erreur de chargement du PDF." : "Error loading PDF.");
      }
    }

    // Render page
    async function renderPage(pageNum){
      if (!pdfDoc || loading) return;
      loading = true;
      try{
        const page = await pdfDoc.getPage(pageNum);
        const viewportUnscaled = page.getViewport({ scale: 1 });
        const availW = window.innerWidth;
        const availH = window.innerHeight;
        const scale = Math.min(availW / viewportUnscaled.width, availH / viewportUnscaled.height);
        const viewport = page.getViewport({ scale: scale * (window.devicePixelRatio || 1) });

        canvas.width  = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width  = Math.floor(viewport.width  / (window.devicePixelRatio || 1)) + 'px';
        canvas.style.height = Math.floor(viewport.height / (window.devicePixelRatio || 1)) + 'px';

        await page.render({ canvasContext: ctx, viewport }).promise;
      }catch(err){
        console.error('Render error:', err);
      }finally{
        loading = false;
      }
    }

    // Advance on click/tap anywhere
    stage.addEventListener('click', async ()=>{
      if (!started || !pdfDoc || loading) return;
      currentPageNum = (currentPageNum % totalPages) + 1;
      await updatePageView();
    });

    // Keyboard controls
    window.addEventListener('keydown', async (e)=>{
      if (!started || !pdfDoc || loading) return;
      if (e.code === 'Space' || e.code === 'ArrowRight'){
        e.preventDefault();
        currentPageNum = (currentPageNum % totalPages) + 1;
        await updatePageView();
      } else if (e.code === 'ArrowLeft'){
        e.preventDefault();
        currentPageNum = (currentPageNum - 2 + totalPages) % totalPages + 1;
        await updatePageView();
      }
    });

    // Re-fit on resize
    window.addEventListener('resize', ()=>{
      if (!started || !pdfDoc) return;
      clearTimeout(window.__resizeT);
      window.__resizeT = setTimeout(()=>{ updatePageView({ announce: false }); }, 100);
    });

    // Auto-hide cursor after inactivity
    let hideTimer = null;
    function scheduleCursorHide(){
      document.body.style.cursor = 'default';
      clearTimeout(hideTimer);
      hideTimer = setTimeout(()=>{ document.body.style.cursor = 'none'; }, 1500);
    }
    ['mousemove','mousedown','touchstart','keydown'].forEach(ev=>{
      window.addEventListener(ev, scheduleCursorHide, {passive:true});
    });
    scheduleCursorHide();
  </script>
</body>
</html>
