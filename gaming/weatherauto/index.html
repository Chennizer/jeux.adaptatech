<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title class="translate" data-fr="Météo" data-en="Weather">Weather</title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <style>
    /* ===== THEME (page background only) ===== */
    body.light { --menu-bg:#fff; background:#fff; color:#000; }
    body.dark  { --menu-bg:#000; background:#000; color:#fff; }

    /* ===== LANGUAGE TOGGLE ===== */
    #langToggle{
      position:fixed; top:10px; right:10px; z-index:99999;
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:10px; border:2px solid #009688;
      background:#fff; color:#009688; font-weight:700; cursor:pointer; user-select:none;
    }
    body.dark #langToggle{ background:#111; color:#14b8a6; border-color:#14b8a6; }

    /* ===== START MENU (Number Hunt look) ===== */
.modal{
  position:fixed; inset:0;
  display:grid; grid-template-rows:auto auto; /* title + card */
  justify-items:center;
  row-gap:20px;
  padding:clamp(84px, 12vh, 128px) 16px 28px;
  background:#000;               /* <-- fixed black */
  z-index:40;
  min-height:100dvh;
}

    /* Title pill bar */
    #options-title-bar{
      width:min(920px,92vw);
      display:grid; place-items:center;
      margin:0 auto 8px auto;
      padding:0; border:0; background:transparent;
    }
    #options-main-title{
      display:inline-block; width:auto; max-width:100%;
      margin:0;
      background:#009688; color:#fff;
      padding:14px 24px; border-radius:12px;
      font-size:1.6rem; font-weight:800; letter-spacing:.02em;
      box-shadow:0 6px 18px rgba(0,0,0,.25);
    }

    /* White options card with teal border + separators */
    #control-panel-options{
      width:min(920px,92vw);
      background:#ffffff; color:#222;
      border:3px solid #009688; border-radius:10px;
      box-shadow:0 6px 24px rgba(0,0,0,.25);
      padding:18px 18px 24px; display:grid; gap:16px;
    }
    #mode-divider, .bar{ height:2px; width:100%; background:#009688; border-radius:2px; }

    /* Three columns layout */
#options-inline-container{
  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  gap:18px;
  align-items:stretch;            /* allow columns to stretch */
}
.options-column{
  display:flex; flex-direction:column;
  gap:14px; padding:4px 10px;
  justify-content:center;         /* <-- vertical centering */
  min-height:clamp(180px,24vh,320px); /* gives columns height to “center within” */
}
    .with-right-sep{ border-right:3px solid #009688; }
    @media(max-width:900px){
      #options-inline-container{ grid-template-columns:1fr; }
      .with-right-sep{ border:none; }
    }

    /* Labels & controls */
    .teal-label{ font-weight:800; color:#333; }
    .option-item{ display:flex; flex-direction:column; gap:8px; }
    .label-block{ margin-bottom:6px; }
    .hidden{ display:none !important; }

    .styled-number, .styled-select{
      width:100%; padding:10px 14px; border-radius:10px; font-weight:700;
      border:2px solid #009688; background:#fff; color:#111; outline:none;
      transition:border-color .2s, box-shadow .2s;
    }
    .styled-number:focus, .styled-select:focus{ box-shadow:0 0 0 3px rgba(0,150,136,.2); }

    .styled-select.compact-field,
    .styled-number.compact-field{
      height:38px; font-size:16px; padding:8px 10px;
    }

    .chk-row{ display:flex; align-items:center; gap:10px; }
    input[type="checkbox"]{ width:20px; height:20px; accent-color:#009688; }

    /* Start button */
    .button{
      background:#e75b2f; color:#fff; border:none; border-radius:18px; padding:12px 26px;
      font-weight:800; font-size:1.05rem; box-shadow:0 6px 0 rgba(0,0,0,.25); cursor:pointer;
    }
    .button:active{ transform:translateY(1px); box-shadow:0 5px 0 rgba(0,0,0,.25); }

    /* ===== GAME GRID / TILES ===== */
    :root{
      --tile-bg:#fff; --tile-fg:#000; --tile-border:rgba(0,0,0,.14);
      --gap: clamp(20px,6vmin,56px); --card-size: clamp(200px,32vmin,360px);
    }
    main{ min-height:100dvh; display:none; place-items:center; padding:clamp(20px,6vmin,48px) }
    .mode-chip{
      display:inline-flex; flex-direction:column; align-items:center; justify-content:center; gap:4px;
      padding:10px 22px; border-radius:999px; border:none;
      background:rgba(0,150,136,.18); color:#76fff0; letter-spacing:.08em; font-weight:800; text-transform:uppercase; font-size:.95rem;
      cursor:pointer; transition:transform .18s ease, box-shadow .18s ease;
    }
    .mode-chip:focus-visible{ outline:3px solid rgba(118,255,240,.85); outline-offset:3px; }
    .mode-chip__label{ font-size:.95rem; }
    .mode-chip__menu{ font-size:.72rem; letter-spacing:.14em; opacity:.85; color:#c4fff6; }
    @media(hover:hover) and (pointer:fine){ .mode-chip:hover{ transform:translateY(-2px); box-shadow:0 8px 20px rgba(0,0,0,.35); } }
    .weather-grid{ display:grid; place-content:center; justify-items:center; align-items:center;
      grid-template-columns:repeat(2,var(--card-size)); grid-auto-rows:var(--card-size); gap:var(--gap); width:100% }

    .weather-card{
      all:unset; position:relative; width:100%; height:100%; aspect-ratio:1/1; cursor:pointer;
      background:var(--tile-bg); color:var(--tile-fg); border-radius:16px; border:2px solid var(--tile-border); overflow:hidden;
      display:flex; align-items:center; justify-content:center; transition:transform .14s ease, box-shadow .14s ease, border-color .14s ease
    }
    @media(hover:hover) and (pointer:fine){ .weather-card:hover{ transform:translateY(-4px); box-shadow:0 18px 36px rgba(0,0,0,.6) } }

    /* Remove blue outline: we manage selection visually with .is-selected */
    .weather-card:focus, .weather-card:focus-visible{ outline:none; }

    .weather-card.is-selected{
      border-color:#ff4d4d;
      box-shadow:0 0 0 4px rgba(255,77,77,.35),0 24px 40px rgba(0,0,0,.7)
    }
    .weather-card img{ width:100%; height:100%; object-fit:cover }
    .tile-title{ position:absolute; inset:auto 0 0; padding:16px; color:#fff;
      background:linear-gradient(180deg,rgba(0,0,0,.02) 0%,rgba(0,0,0,.85) 100%); text-align:center }
    .tile-title h3{ margin:0; font-size:clamp(1.05rem,2.2vmin,1.6rem); text-transform:uppercase; letter-spacing:.08em }

    /* Overlay honors theme */
    .game-overlay{ position:fixed; inset:0; display:flex; align-items:stretch; justify-content:center;
      background:#000; z-index:50; opacity:0; pointer-events:none; transition:opacity 220ms ease }
    .game-overlay.light{ background:#fff; }
    .game-overlay[hidden]{ display:none } .game-overlay.visible{ opacity:1; pointer-events:auto }
    .game-overlay .back-button{
      position:absolute; top:clamp(16px,4vmin,32px); left:clamp(16px,4vmin,32px); z-index:2;
      border:none; border-radius:999px; padding:12px 24px; background:rgba(255,255,255,.18); color:#fff;
      font-size:1rem; letter-spacing:.08em; text-transform:uppercase; font-weight:700; cursor:pointer;
    }
    .game-overlay.light .back-button{ background:rgba(0,0,0,.12); color:#000; }
    iframe{ flex:1; border:none; width:100%; background:#000 }
    .game-overlay.light iframe{ background:#fff; }

    /* Input overflow safety */
    .styled-number, .styled-select { box-sizing:border-box; max-width:100%; }
    #options-inline-container, .options-column, .option-item { min-width:0; }
  </style>
</head>
<body class="dark">
  <!-- ===== LANGUAGE TOGGLE ===== -->
  <button id="langToggle" title="Basculer la langue / Toggle language">EN / FR</button>

  <!-- ===== START MENU ===== -->
  <div id="game-options" class="modal" role="dialog" aria-modal="true">
    <div id="options-title-bar">
      <h2 id="options-main-title" class="translate"
          data-fr="Météo"
          data-en="Weather">Météo</h2>
    </div>

    <div id="control-panel-options" aria-label="Options de démarrage">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <!-- LEFT: Timer -->
        <div class="options-column with-right-sep">
          <label class="chk-row">
            <input type="checkbox" id="returnTimerEnabled">
            <span class="teal-label translate" data-fr="Activer la minuterie (retour automatique)" data-en="Enable timer (auto return)">Activer la minuterie (retour automatique)</span>
          </label>

          <div class="option-item">
            <label for="returnTimerMin" class="teal-label label-block">
              <span class="translate" data-fr="Durée" data-en="Duration">Durée</span> —
              <span id="rtmLabel" class="translate" data-fr="3 minutes" data-en="3 minutes">3 minutes</span>
            </label>
            <select id="returnTimerMin" class="styled-select compact-field">
              <option value="0.5" class="translate" data-fr="30 secondes" data-en="30 seconds">30 secondes</option>
              <option value="1"  class="translate" data-fr="1 minute" data-en="1 minute">1 minute</option>
              <option value="1.5" class="translate" data-fr="1 minute 30 secondes" data-en="1 minute 30 seconds">1 minute 30 secondes</option>
              <option value="2"  class="translate" data-fr="2 minutes" data-en="2 minutes">2 minutes</option>
              <option value="3"  selected class="translate" data-fr="3 minutes" data-en="3 minutes">3 minutes</option>
              <option value="5"  class="translate" data-fr="5 minutes" data-en="5 minutes">5 minutes</option>
              <option value="10" class="translate" data-fr="10 minutes" data-en="10 minutes">10 minutes</option>
            </select>
          </div>
        </div>

        <!-- CENTER: Navigation mode (+ scan interval) -->
        <div class="options-column with-right-sep">
          <div class="option-item">
            <label for="modeSelect" class="teal-label label-block translate" data-fr="Mode de navigation" data-en="Navigation mode">Mode de navigation</label>
            <select id="modeSelect" class="styled-select compact-field" role="listbox">
              <option value="touch"   selected class="translate" data-fr="Mode tactile"      data-en="Touch mode">Mode tactile</option>
              <option value="single"  class="translate" data-fr="Mode un bouton"            data-en="Single-switch mode">Mode un bouton</option>
              <option value="multiple"class="translate" data-fr="Mode choix multiples"      data-en="Multiple choice mode">Mode choix multiples</option>
              <option value="scan"    class="translate" data-fr="Mode balayage"             data-en="Scanning mode">Mode balayage</option>
            </select>
          </div>

          <!-- Scan interval (shown only when Scan is selected) -->
          <div class="option-item hidden" id="scanTimeRow">
            <label for="scanSeconds" class="teal-label label-block translate"
                   data-fr="Intervalle du balayage (secondes)" data-en="Scan interval (seconds)">
              Intervalle du balayage (secondes)
            </label>
            <input id="scanSeconds" class="styled-number compact-field" type="number" min="2" max="60" step="1" value="10">
          </div>
        </div>

        <!-- RIGHT: Theme -->
        <div class="options-column">
          <div class="option-item">
            <label for="themeSelect" class="teal-label label-block translate" data-fr="Thème" data-en="Theme">Thème</label>
            <select id="themeSelect" class="styled-select compact-field">
              <option value="dark"  selected class="translate" data-fr="Sombre (noir)" data-en="Dark (black)">Sombre (noir)</option>
              <option value="light"          class="translate" data-fr="Clair (blanc)" data-en="Light (white)">Clair (blanc)</option>
            </select>
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <div style="display:flex; justify-content:center; padding-top:8px;">
        <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
      </div>
    </div>
  </div>

  <!-- ===== MAIN CONTENT (hidden until start) ===== -->
  <main id="mainContent">
    <button class="mode-chip" id="modeChip" type="button">
      <span id="modeChipLabel" class="mode-chip__label translate" data-fr="Mode tactile" data-en="Touch mode">Mode tactile</span>
      <span id="modeChipMenu" class="mode-chip__menu translate" data-fr="Retour au menu" data-en="Back to menu">Retour au menu</span>
    </button>

    <section id="weatherChooser" class="weather-grid" role="list">
      <button class="weather-card" type="button" role="listitem"
        data-index="0" data-src="../sunauto/index.html" aria-label="Soleil - Ambiance lumineuse" tabindex="0">
        <img src="../../images/sun.png" alt="Icône de soleil">
        <div class="tile-title"><h3 class="translate" data-fr="Soleil" data-en="Sun">Soleil</h3></div>
      </button>
      <button class="weather-card" type="button" role="listitem"
        data-index="1" data-src="../cloudauto/index.html" aria-label="Nuages - Douce brise" tabindex="0">
        <img src="../../images/cloud.png" alt="Icône de nuage">
        <div class="tile-title"><h3 class="translate" data-fr="Nuages" data-en="Clouds">Nuages</h3></div>
      </button>
      <button class="weather-card" type="button" role="listitem"
        data-index="2" data-src="../stormauto/index.html" aria-label="Pluie - Orage relaxant" tabindex="0">
        <img src="../../images/rain.png" alt="Icône de pluie">
        <div class="tile-title"><h3 class="translate" data-fr="Pluie" data-en="Rain">Pluie</h3></div>
      </button>
      <button class="weather-card" type="button" role="listitem"
        data-index="3" data-src="../snowauto/index.html" aria-label="Neige - Flocons scintillants" tabindex="0">
        <img src="../../images/snow.png" alt="Icône de neige">
        <div class="tile-title"><h3 class="translate" data-fr="Neige" data-en="Snow">Neige</h3></div>
      </button>
    </section>
  </main>

  <!-- Overlay -->
  <div class="game-overlay" id="gameOverlay" hidden>
    <button class="back-button translate" id="backButton" type="button" data-fr="Retour" data-en="Back">Retour</button>
    <iframe id="gameFrame" title="Jeu météo automatique"
            allow="autoplay; fullscreen" allowfullscreen
            sandbox="allow-scripts allow-same-origin allow-pointer-lock allow-orientation-lock allow-popups"
            tabindex="-1"></iframe>
  </div>

  <script>
    /* ===== Language ===== */
    const LS_LANG_KEY='siteLanguage';

    const MODES = {
      touch:    { frLabel:'Mode tactile',        enLabel:'Touch mode' },
      single:   { frLabel:'Mode un bouton',      enLabel:'Single-switch mode' },
      multiple: { frLabel:'Mode choix multiples', enLabel:'Multiple choice mode' },
      scan:     { frLabel:'Mode balayage',       enLabel:'Scanning mode' }
    };

    const MIN_RETURN_MINUTES = 0.5;
    const MAX_RETURN_MINUTES = 10;

    let modeKey='touch', highlightIndex=-1, scanTimer=null, lastCard=null, gameActive=false;
    let scanIntervalMs = 10000;
    let autoReturnHandle=null;

    function updateModeChipLabel(langOverride){
      const label=document.getElementById('modeChipLabel');
      if(!label) return;
      const lang=langOverride||getLang();
      const data=MODES[modeKey]||MODES.touch;
      label.dataset.fr=data.frLabel;
      label.dataset.en=data.enLabel;
      label.textContent=(lang==='fr')?data.frLabel:data.enLabel;

      const menuSpan=document.getElementById('modeChipMenu');
      const menuFr=menuSpan?.dataset?.fr||'Retour au menu';
      const menuEn=menuSpan?.dataset?.en||'Back to menu';
      const button=document.getElementById('modeChip');
      if(button){
        button.setAttribute('aria-label', lang==='fr'
          ? `${data.frLabel} — ${menuFr}`
          : `${data.enLabel} — ${menuEn}`);
      }
    }
    function getLang(){ try{const s=localStorage.getItem(LS_LANG_KEY); if(s==='en'||s==='fr') return s;}catch(e){} return (document.documentElement.lang==='en')?'en':'fr'; }
    function setLang(lang){
      const safe=(lang==='en')?'en':'fr';
      document.documentElement.lang=safe;
      try{ localStorage.setItem(LS_LANG_KEY, safe); }catch(e){}
      document.querySelectorAll('.translate').forEach(el=>{
        const fr=el.getAttribute('data-fr'); const en=el.getAttribute('data-en');
        if (safe==='fr' && fr!=null) el.textContent=fr;
        if (safe==='en' && en!=null) el.textContent=en;
      });
      updateModeChipLabel(safe);
    }
    (function initLang(){
      let initial='fr';
      try{
        const saved=localStorage.getItem(LS_LANG_KEY);
        initial=(saved==='en'||saved==='fr')?saved:(document.documentElement.lang==='en'?'en':'fr');
        localStorage.setItem(LS_LANG_KEY,initial);
      }catch(e){ initial=(document.documentElement.lang==='en'?'en':'fr'); }
      setLang(initial);
      const lt=document.getElementById('langToggle');
      lt.textContent=(initial==='fr')?'EN / FR':'FR / EN';
      lt.addEventListener('click', ()=>{
        const next=getLang()==='fr'?'en':'fr';
        setLang(next);
        lt.textContent=(next==='fr')?'EN / FR':'FR / EN';
      });
    })();

    /* ===== Elements ===== */
    const startButton = document.getElementById('startButton');
    const mainContent = document.getElementById('mainContent');
    const gameOverlay = document.getElementById('gameOverlay');
    const gameFrame   = document.getElementById('gameFrame');
    const backButton  = document.getElementById('backButton');
    const modeChip    = document.getElementById('modeChip');
    const modeSelect  = document.getElementById('modeSelect');
    const themeSelect = document.getElementById('themeSelect');
    const scanTimeRow = document.getElementById('scanTimeRow');
    const scanSeconds = document.getElementById('scanSeconds');
    const gameOptions = document.getElementById('game-options');
    const langToggleButton = document.getElementById('langToggle');

    modeKey = modeSelect?.value || modeKey;
    updateModeChipLabel();

    /* Timer controls */
    const returnTimerEnabled = document.getElementById('returnTimerEnabled');
    const returnTimerMin     = document.getElementById('returnTimerMin');
    const rtmLabel           = document.getElementById('rtmLabel');

    const cards = Array.from(document.querySelectorAll('.weather-card'));
    const fsKey = 'weatherAutoFS';

    const cycleSfx = new Audio('../../sounds/woosh.mp3');
    cycleSfx.preload = 'auto';
    cycleSfx.load();

    function applyTheme(theme){
      const t=(theme==='light')?'light':'dark';
      document.body.classList.remove('light','dark'); document.body.classList.add(t);
      gameOverlay.classList.toggle('light', t==='light');
    }
    applyTheme(themeSelect.value||'dark');
    themeSelect.addEventListener('change', ()=> applyTheme(themeSelect.value));

    function setScanRowVisibility(){
      const isScan = (modeSelect.value === 'scan');
      scanTimeRow.classList.toggle('hidden', !isScan);
    }
    setScanRowVisibility();

    function refreshModeUI(){
      updateModeChipLabel();
    }

    function playCycleSound(){
      try {
        cycleSfx.currentTime = 0;
        const playPromise = cycleSfx.play();
        if (playPromise !== undefined) {
          playPromise.catch(() => {});
        }
      } catch (e) {
        console.error(e);
      }
    }

    function clearHighlight(){
      cards.forEach(c=>{ c.classList.remove('is-selected'); c.removeAttribute('aria-selected'); });
      highlightIndex = -1;
    }

    function setHighlightByCard(card){
      const idx = cards.indexOf(card);
      if (idx === -1) return;
      highlightCard(idx);
    }

    modeSelect.addEventListener('change', ()=>{
      modeKey=modeSelect.value;
      setScanRowVisibility();

      // Stop scanning when leaving scan mode
      if (modeKey!=='scan') stopScanTimer();

      // Touch: no highlight; Single: highlight waits for click; Multiple/Scan: show a highlight when grid visible
      if (modeKey==='touch'){
        clearHighlight();
      } else if ((modeKey==='multiple' || modeKey==='scan') && mainContent.style.display==='grid') {
        if (highlightIndex < 0) highlightCard(0);
      } else if (modeKey==='single'){
        clearHighlight(); // none until a card is clicked
      }
      refreshModeUI();
    });
    refreshModeUI();

    function clamp(n,lo,hi){ return Math.max(lo,Math.min(hi,n)); }
    function minutesToMs(m){
      const minutes = clamp(Number(m) || 3, MIN_RETURN_MINUTES, MAX_RETURN_MINUTES);
      return Math.round(minutes * 60 * 1000);
    }
    function normalizeMinutesValue(value){
      return (Math.round(value * 120) / 120).toString().replace(/\.0+$/,'').replace(/(\.\d*[1-9])0+$/,'$1');
    }
    function formatDurationLabel(minutes, lang){
      const totalSeconds = Math.round(minutes * 60);
      const mins = Math.floor(totalSeconds / 60);
      const secs = totalSeconds % 60;
      const isFrench = (lang === 'fr');

      if (mins === 0){
        const secondsWord = isFrench ? (secs > 1 ? 'secondes' : 'seconde') : (secs > 1 ? 'seconds' : 'second');
        return `${secs} ${secondsWord}`;
      }

      const minuteWord = isFrench ? (mins > 1 ? 'minutes' : 'minute') : (mins > 1 ? 'minutes' : 'minute');
      if (secs === 0){
        return `${mins} ${minuteWord}`;
      }

      const secondsWord = isFrench ? (secs > 1 ? 'secondes' : 'seconde') : (secs > 1 ? 'seconds' : 'second');
      return `${mins} ${minuteWord} ${secs} ${secondsWord}`;
    }
    function updateReturnTimerLabel(langOverride){
      if (!returnTimerMin || !rtmLabel) return;
      const lang = langOverride || getLang();
      let value = Number(returnTimerMin.value);
      if (Number.isNaN(value)) value = 3;
      value = clamp(value, MIN_RETURN_MINUTES, MAX_RETURN_MINUTES);

      const normalized = normalizeMinutesValue(value);
      if (normalized !== returnTimerMin.value) {
        returnTimerMin.value = normalized;
      }

      const frLabel = formatDurationLabel(value, 'fr');
      const enLabel = formatDurationLabel(value, 'en');
      rtmLabel.dataset.fr = frLabel;
      rtmLabel.dataset.en = enLabel;
      rtmLabel.textContent = (lang === 'fr') ? frLabel : enLabel;
    }
    updateReturnTimerLabel();
    returnTimerMin.addEventListener('change', updateReturnTimerLabel);
    returnTimerMin.addEventListener('input', updateReturnTimerLabel);
    if (langToggleButton) {
      langToggleButton.addEventListener('click', () => updateReturnTimerLabel());
    }
    function clearAutoReturn(){ if(autoReturnHandle){ clearTimeout(autoReturnHandle); autoReturnHandle=null; } }
    function startAutoReturnIfEnabled(){ clearAutoReturn(); if(!returnTimerEnabled.checked) return; autoReturnHandle=setTimeout(()=>closeGame(), minutesToMs(returnTimerMin.value)); }

    function enterFullscreen(){
      const el=document.documentElement; const req=el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen;
      if(!req) return Promise.resolve(false); return req.call(el).then(()=>true).catch(()=>false);
    }

    function exitFullscreenSafe(){
      const exit=document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen;
      if(exit && document.fullscreenElement){
        try{ exit.call(document); }catch(e){}
      }
    }

    function highlightCard(i){
      if(!cards.length) return;
      const n=((i%cards.length)+cards.length)%cards.length;
      if (n === highlightIndex) return;
      clearHighlight();
      const card=cards[n]; if(card){ card.classList.add('is-selected'); card.setAttribute('aria-selected','true'); }
      highlightIndex=n;
      playCycleSound();
    }
    function stopScanTimer(){ if(scanTimer){ clearInterval(scanTimer); scanTimer=null; } }
    function startScanTimer(){ stopScanTimer(); scanTimer=setInterval(()=>highlightCard((highlightIndex+1+cards.length)%cards.length), scanIntervalMs); }

    // Scan interval control
    scanSeconds.addEventListener('input', ()=>{
      const v = clamp(parseInt(scanSeconds.value||'10',10), 2, 60);
      scanSeconds.value = String(v);
      scanIntervalMs = v * 1000;
      if (scanTimer){ startScanTimer(); } // apply immediately if scanning
    });

    async function showGame(card){
      if(!card) return;
      lastCard=card; stopScanTimer();
      const src=card.dataset.src||''; if(src) gameFrame.src=src;
      gameActive=true; sessionStorage.setItem(fsKey,'1');
      applyTheme(themeSelect.value||'dark');
      await enterFullscreen();
      gameOverlay.removeAttribute('hidden');
      requestAnimationFrame(()=>{ gameOverlay.classList.add('visible'); try{gameFrame.contentWindow?.focus();}catch(e){} try{gameFrame.focus({preventScroll:true});}catch(e){gameFrame.focus();} });
      startAutoReturnIfEnabled();
    }

    function closeGame(){
      if(!gameActive) return;
      clearAutoReturn();
      gameOverlay.classList.remove('visible');
      setTimeout(()=>{
        if(!gameOverlay.classList.contains('visible')){
          gameActive=false; gameOverlay.setAttribute('hidden',''); gameFrame.src='about:blank';

          // >>> Remove lingering browser focus ring by blurring, and do NOT re-focus any card
          try{ document.activeElement && document.activeElement.blur && document.activeElement.blur(); }catch(e){}

          // Resume scanning if applicable
          if(modeKey==='scan' && mainContent.style.display==='grid') startScanTimer();
        }
      },220);
    }

    backButton.addEventListener('click', closeGame);
    gameOverlay.addEventListener('click', e=>{ if(e.target===gameOverlay) closeGame(); });

    function returnToMenu(){
      if(mainContent.style.display!=='grid') return;
      if(gameActive) closeGame();
      stopScanTimer();
      clearHighlight();
      mainContent.style.display='none';
      if(gameOptions) gameOptions.classList.remove('hidden');
      if(langToggleButton) langToggleButton.classList.remove('hidden');
      exitFullscreenSafe();
      modeChip?.blur();
      requestAnimationFrame(()=>{ try{ startButton?.focus({preventScroll:true}); }catch(e){ startButton?.focus(); } });
    }

    modeChip?.addEventListener('click', returnToMenu);

    document.addEventListener('keydown', e=>{
      if(!gameOverlay.hasAttribute('hidden')){
        const k=(e.key||'').toLowerCase(); if(k==='escape'||k==='esc'||k==='q'){ e.preventDefault(); closeGame(); }
        return;
      }
      if(mainContent.style.display==='none') return;

      if(modeKey==='multiple'){
        if(e.key==='Enter'){ e.preventDefault(); highlightCard((highlightIndex+1+cards.length)%cards.length); }
        else if(e.code==='Space'||e.key===' '){ e.preventDefault(); if(highlightIndex>=0) showGame(cards[highlightIndex]); }
      }else if(modeKey==='scan'){
        // Enter is reserved for multiple-choice mode; scan advances automatically
        if(e.code==='Space'||e.key===' '){ e.preventDefault(); if(highlightIndex>=0) showGame(cards[highlightIndex]); }
      }else if(modeKey==='single'){
        // Space launches currently highlighted (selected via click)
        if(e.code==='Space'||e.key===' '){ e.preventDefault(); if(highlightIndex>=0) showGame(cards[highlightIndex]); }
      }
    });

    /* Start: hide menu; only show tiles after Start */
    startButton.addEventListener('click', async ()=>{
      await enterFullscreen();
      gameOptions?.classList.add('hidden');
      langToggleButton?.classList.add('hidden');
      mainContent.style.display='grid';

      // Initial highlight rules per mode
      if (modeKey==='touch'){
        clearHighlight();
      } else if (modeKey==='multiple' || modeKey==='scan'){
        highlightCard(0);
        if(modeKey==='scan' && !gameActive) startScanTimer();
      } else if (modeKey==='single'){
        clearHighlight(); // wait for user click to set selection
      }

      refreshModeUI();
    });

    /* Card interactions */
    document.querySelectorAll('.weather-card').forEach(card=>{
      // Click behavior per mode
      card.addEventListener('click', ()=>{
        if(mainContent.style.display!=='grid') return;
        if(modeKey==='touch'){
          showGame(card); // touch = direct
        }else if(modeKey==='single'){
          setHighlightByCard(card); // select only; launch with Space
        }else{
          // multiple/scan: select, then show (mouse users can still click to launch)
          setHighlightByCard(card);
          showGame(card);
        }
      });

    });

    /* Close with Esc from inside iframe */
    gameFrame.addEventListener('load', ()=>{
      if(!gameActive) return;
      try{
        const w=gameFrame.contentWindow; if(!w) return;
        const keyListener=(ev)=>{ if(!gameActive){ w.removeEventListener('keydown',keyListener); return; }
          const k=(ev.key||'').toLowerCase(); if(k==='escape'||k==='esc'||k==='q'){ ev.preventDefault(); closeGame(); } };
        w.addEventListener('keydown', keyListener);
      }catch(e){}
    });
  </script>

  <script src="../../js/translationmain.js"></script>
</body>
</html>
