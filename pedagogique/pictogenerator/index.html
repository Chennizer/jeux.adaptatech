<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Pictogram Customizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <link rel="stylesheet" href="../../css/choix.css"/>
  <link rel="stylesheet" href="../../css/cvigenerator.css"/>

  <style>
    :root{ --accent:#009688; --line:#e6eaef; }
    html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#fff;color:#000;font-family:Arial,sans-serif}
    .app-container{display:flex;height:100vh;width:100%}

    /* Sidebar */
    #menu{
      width:30vw; min-width:260px; max-width:520px; padding:20px;
      background:#fff; color:#000; border-right:4px solid var(--accent);
      overflow-y:auto; box-sizing:border-box;
    }
    #menu h2{
      margin:0 0 1rem; color:var(--accent); font-size:1.5rem;
      border-bottom:2px solid var(--accent); padding-bottom:.5rem; text-align:center;
    }

    .group{ box-shadow:0 1px 4px rgba(0,0,0,.15); border-radius:6px; padding:1rem 1.2rem; background:#fff; margin:1rem 0; }
    .group h3{ margin:0 0 .6rem; color:#333; }
    .row{ display:flex; align-items:center; gap:.6rem; margin:.5rem 0; }
    .row input[type="text"], .row input[type="number"], .row select{
      flex:1; padding:.6rem .75rem; border:1px solid var(--line); border-radius:6px; background:#fff; color:#000;
    }
    .row input[type="color"]{ width:42px; height:32px; border:none; background:transparent; padding:0; }
    .row input[type="range"]{ flex:1; }
    .inline{ display:flex; align-items:center; justify-content:space-between; background:#eefaf8; border:1px solid #bfe7e1; padding:.55rem .7rem; border-radius:6px; }
    .export-btn{ display:inline-block; padding:10px 16px; margin:4px; font-size:1rem; background:#009688; color:#fff; border:none; border-radius:4px; cursor:pointer; }
    .export-btn.alt{ background:#fff; color:#009688; border:2px solid #009688; }

    /* Preview */
    #content{ flex:1; display:flex; justify-content:center; align-items:center; background:#f3f4f6; }
    #previewCanvas{ width:min(72vmin,860px); height:min(72vmin,860px); background:#fff; border:1px solid var(--line); border-radius:10px; }

    /* Floating toolbar */
    #toolbar{
      position:fixed; right:20px; bottom:20px; display:flex; gap:10px; flex-wrap:wrap;
      background:#fff; border:1px solid var(--line); border-radius:10px; padding:10px; box-shadow:0 8px 24px rgba(0,0,0,.08);
    }

    /* Modal */
    .modal{ display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); justify-content:center; align-items:flex-start; padding-top:5%; opacity:0; transition:opacity .25s ease; z-index:2000; pointer-events:none; }
    .modal.show{ display:flex; opacity:1; pointer-events:auto; }
    .modal-content{ background:#fff; color:#000; border:2px solid #009688; border-radius:6px; padding:16px; width:min(1100px,92vw); max-height:80vh; overflow:auto; }

    .gm-toolbar{ display:flex; gap:.5rem; align-items:center; margin-bottom:.6rem; }
    .gm-grid{ --cell:120px; display:grid; grid-template-columns:repeat(auto-fill,minmax(var(--cell),1fr)); gap:10px; }
    .gm-item{ border:1px solid var(--line); border-radius:8px; background:#fff; aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; cursor:pointer; }
    .gm-item img{ width:100%; height:100%; object-fit:contain; }
    #advPanel{ display:none; }
  </style>
</head>
<body>
  <div class="app-container">
    <aside id="menu">
      <h2>Pictogram Customizer</h2>

      <div class="group">
        <h3>Image</h3>
        <div class="row" style="justify-content:center;">
          <button id="openGalleryBtn" class="export-btn">Open folder gallery</button>
          <input id="uploadInput" type="file" accept="image/*" multiple style="display:none;">
          <button id="uploadBtn" class="export-btn alt">Upload…</button>
        </div>
      </div>

      <div class="group">
        <h3>Captions</h3>
        <div class="row"><input id="topLabelText" type="text" placeholder="Top text (black, ~64px)"></div>
        <div class="row"><input id="labelText" type="text" placeholder="Bottom text (black, ~64px)"></div>
      </div>

      <div class="group">
        <h3>Export</h3>
        <div class="row" style="justify-content:center;">
          <button id="downloadBtn" class="export-btn">Download PNG</button>
        </div>
      </div>

      <div class="toggle-container" style="margin-top:30px">
        <label class="teal-label">
          <input type="checkbox" id="toggleAdvanced">
          <span>Show advanced settings</span>
        </label>
      </div>

      <div id="advPanel">
        <!-- Background / Shape -->
        <div class="group">
          <h3>Background / Shape</h3>

          <!-- SAME markup pattern as the Advanced toggle (checkbox then label text) -->
          <div class="row inline">
            <label class="teal-label">
              <input id="bgTransparent" type="checkbox">
              <span>Transparent background</span>
            </label>
          </div>

          <div class="row">
            <label>Color <input id="bgColor" type="color" value="#ffffff"></label>
            <label style="flex:1">Shape
              <select id="bgShape">
                <option value="none">None</option>
                <option value="rounded" selected>Rounded square</option>
                <option value="circle">Circle</option>
                <option value="roundedRect">Rounded rectangle</option>
              </select>
            </label>
          </div>

          <div class="row">
            <label style="flex:1">Corner radius (%) <input id="cornerPct" type="range" min="0" max="50" value="22"></label>
            <label style="flex:1">Padding (%) <input id="paddingPct" type="range" min="0" max="40" value="10"></label>
          </div>

          <div class="row inline">
            <label class="teal-label">
              <input id="strokeOn" type="checkbox">
              <span>Border</span>
            </label>
          </div>

          <div class="row">
            <label>Color <input id="strokeColor" type="color" value="#000000"></label>
            <label style="flex:1">Thickness (%) <input id="strokePct" type="range" min="0" max="8" value="2"></label>
          </div>

          <div class="row inline">
            <label class="teal-label">
              <input id="shadowOn" type="checkbox">
              <span>Shadow</span>
            </label>
          </div>
        </div>

        <!-- Icon -->
        <div class="group">
          <h3>Icon</h3>
          <div class="row">
            <label style="flex:1">Tint (%) <input id="tintPct" type="range" min="0" max="100" value="0"></label>
            <label>Color <input id="tintColor" type="color" value="#000000"></label>
          </div>
          <div class="row">
            <label style="flex:1">Scale (%) <input id="iconScalePct" type="range" min="40" max="110" value="100"></label>
          </div>
        </div>

        <!-- Text options -->
        <div class="group">
          <h3>Text options</h3>
          <div class="row">
            <label>Size (px) <input id="labelSize" type="number" min="8" max="240" value="64"></label>
            <label>Color <input id="labelColor" type="color" value="#000000"></label>
          </div>

          <div class="row inline">
            <label class="teal-label">
              <input id="labelBandOn" type="checkbox" checked>
              <span>Banner behind text</span>
            </label>
          </div>

          <div class="row">
            <label>Banner color <input id="labelBandColor" type="color" value="#ffffff"></label>
            <label style="flex:1">Banner padding (%) <input id="labelBandPadPct" type="range" min="0" max="20" value="6"></label>
          </div>

          <div class="row">
            <label style="flex:1">Top offset (%) <input id="topOffsetPct" type="range" min="-10" max="60" value="6"></label>
            <label style="flex:1">Bottom offset (%) <input id="bottomOffsetPct" type="range" min="-10" max="60" value="6"></label>
          </div>
        </div>

        <div class="group">
          <h3>Export (Advanced)</h3>
          <div class="row">
            <label style="flex:1">PNG size (px)
              <input id="sizePx" type="range" min="128" max="2048" step="128" value="512">
            </label>
            <span id="sizePxVal">512</span>
          </div>
          <div class="row" style="justify-content:center;">
            <button id="clearSavedBtn" class="export-btn alt">Clear saved options</button>
          </div>
        </div>
      </div>
    </aside>

    <main id="content">
      <canvas id="previewCanvas" width="1024" height="1024" aria-label="Preview"></canvas>
      <div id="toolbar">
        <button id="clearBtn" class="export-btn alt" title="Clear image and text">Clear</button>
      </div>
    </main>
  </div>

  <!-- Gallery modal -->
  <div id="galleryModal" class="modal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-label="Folder gallery">
      <h3>Folder gallery</h3>
      <div class="gm-toolbar">
        <input id="gmSearch" type="text" placeholder="Filter…">
        <label>Thumb size <input id="gmSize" type="range" min="90" max="220" value="120"></label>
        <button id="gmClose" class="export-btn">Close</button>
      </div>
      <div id="gmGrid" class="gm-grid"></div>
    </div>
  </div>

  <script>
    // ===== Canvas & elements =====
    const cvs = document.getElementById('previewCanvas');
    const ctx = cvs.getContext('2d');

    // Quick controls
    const topLabelText   = document.getElementById('topLabelText');
    const bottomLabelText= document.getElementById('labelText');
    const downloadBtn    = document.getElementById('downloadBtn');
    const clearSavedBtn  = document.getElementById('clearSavedBtn');
    const sizePx         = document.getElementById('sizePx');
    const sizePxVal      = document.getElementById('sizePxVal');

    // Advanced toggle + panel
    const toggleAdvanced = document.getElementById('toggleAdvanced');
    const advPanel       = document.getElementById('advPanel');

    // Advanced controls
    const bgTransparent  = document.getElementById('bgTransparent');
    const bgShape        = document.getElementById('bgShape');
    const bgColor        = document.getElementById('bgColor');
    const cornerPct      = document.getElementById('cornerPct');
    const paddingPct     = document.getElementById('paddingPct');
    const strokeOn       = document.getElementById('strokeOn');
    const strokeColor    = document.getElementById('strokeColor');
    const strokePct      = document.getElementById('strokePct');
    const shadowOn       = document.getElementById('shadowOn');
    const tintPct        = document.getElementById('tintPct');
    const tintColor      = document.getElementById('tintColor');
    const iconScalePct   = document.getElementById('iconScalePct');
    const labelSize      = document.getElementById('labelSize');
    const labelColor     = document.getElementById('labelColor');
    const labelBandOn    = document.getElementById('labelBandOn');
    const labelBandColor = document.getElementById('labelBandColor');
    const labelBandPadPct= document.getElementById('labelBandPadPct');
    const topOffsetPct   = document.getElementById('topOffsetPct');
    const bottomOffsetPct= document.getElementById('bottomOffsetPct');

    // Buttons
    const clearBtn       = document.getElementById('clearBtn');
    const openGalleryBtn = document.getElementById('openGalleryBtn');
    const uploadBtn      = document.getElementById('uploadBtn');
    const uploadInput    = document.getElementById('uploadInput');

    // Modal (simplified)
    const galleryModal   = document.getElementById('galleryModal');
    const gmGrid         = document.getElementById('gmGrid');
    const gmSearch       = document.getElementById('gmSearch');
    const gmSize         = document.getElementById('gmSize');
    const gmClose        = document.getElementById('gmClose');

    // State
    let img = null;
    let exportSize = parseInt(sizePx?.value ?? 512,10);
    let manifest = null;
    let gridItems = [];
    const LS_KEY = 'pictosCustomizer:v2';
    let currentImageMeta = { type:'none' };

    // Helpers
    function roundRectPath(ctx,x,y,w,h,r){
      const rr=Math.max(0,Math.min(r,Math.min(w,h)/2));
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
    function drawShape(ctx,shape,x,y,w,h,radiusPct){
      if(shape==='none'){ ctx.beginPath(); ctx.rect(x,y,w,h); ctx.closePath(); return; }
      if(shape==='circle'){
        const cx=x+w/2, cy=y+h/2, r=Math.min(w,h)/2;
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.closePath();
      } else {
        const rr=(Math.min(w,h)*(radiusPct/100));
        roundRectPath(ctx,x,y,w,h,rr);
      }
    }
    function labelBandHeight(ctx, text, px, bandPad){
      if(!text) return 0;
      ctx.save();
      ctx.font=`600 ${px}px Arial, sans-serif`;
      const m=ctx.measureText(text);
      const ascent=m.actualBoundingBoxAscent||px*.8;
      const descent=m.actualBoundingBoxDescent||px*.2;
      const textH=ascent+descent;
      const pad=px*bandPad;
      const bandH=textH+pad*2;
      ctx.restore();
      return bandH;
    }
    function drawLabelAtY(ctx, text, px, color, bandOn, bandColor, bandPad, x, y, w){
      if(!text) return 0;
      ctx.save();
      ctx.font=`600 ${px}px Arial, sans-serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      const m=ctx.measureText(text);
      const ascent=m.actualBoundingBoxAscent||px*.8;
      const descent=m.actualBoundingBoxDescent||px*.2;
      const textH=ascent+descent;
      const pad=px*bandPad;
      const bandH=textH+pad*2;
      if(bandOn){
        ctx.fillStyle=bandColor;
        roundRectPath(ctx, x, y, w, bandH, Math.min(16, bandH*0.3));
        ctx.fill();
      }
      ctx.fillStyle=color;
      ctx.fillText(text, x + w/2, y + bandH/2);
      ctx.restore();
      return bandH;
    }
    function drawTinted(ctx,image,dx,dy,dw,dh,color,alpha){
      ctx.save();
      ctx.drawImage(image,dx,dy,dw,dh);
      if(alpha>0){
        ctx.globalCompositeOperation='source-atop';
        ctx.globalAlpha=alpha;
        ctx.fillStyle=color;
        ctx.fillRect(dx,dy,dw,dh);
      }
      ctx.restore();
    }

    function render(size=cvs.width){
      cvs.width=cvs.height=size;
      ctx.clearRect(0,0,size,size);

      // Read UI
      const topText     = topLabelText.value.trim();
      const bottomText  = bottomLabelText.value.trim();
      const labelPx     = parseInt(labelSize.value||64,10);
      const labelCol    = labelColor.value || '#000000';

      const padPctVal   = parseFloat(paddingPct.value)/100;
      const corner      = parseFloat(cornerPct.value);
      const shape       = bgShape.value;
      const transparent = bgTransparent.checked;   // default: false (white background)
      const strokeEnabled = strokeOn.checked;
      const strokeW     = (parseFloat(strokePct.value)/100) * size;
      const shadow      = shadowOn.checked;

      const bandOn      = labelBandOn.checked;
      const bandCol     = labelBandColor.value;
      const bandPad     = parseFloat(labelBandPadPct.value)/100;

      const topOffset   = (parseFloat(topOffsetPct.value)||0)/100 * size;
      const bottomOffset= (parseFloat(bottomOffsetPct.value)||0)/100 * size;

      const box = {x:0,y:0,w:size,h:size};

      // --- Background ---
      if(!transparent){
        // Always paint the whole canvas first so export is not transparent
        ctx.fillStyle = bgColor.value || '#ffffff';
        ctx.fillRect(box.x, box.y, box.w, box.h);

        // Optional shadow around the shape
        if(shadow && shape!=='none'){
          ctx.save();
          ctx.shadowColor='rgba(0,0,0,0.35)';
          ctx.shadowBlur=Math.max(2,size*0.02);
          ctx.shadowOffsetY=size*0.01;
          ctx.fillStyle = bgColor.value || '#ffffff';
          drawShape(ctx,shape,box.x,box.y,box.w,box.h,corner);
          ctx.fill();
          ctx.restore();
        }
      }

      // Frame (inside padding and border thickness)
      const padPx = size * padPctVal;
      const strokeInset = (strokeEnabled && shape!=='none') ? Math.max(1, strokeW*0.5) : 0;
      const frame = {
        x: box.x + padPx + strokeInset,
        y: box.y + padPx + strokeInset,
        w: box.w - 2*(padPx + strokeInset),
        h: box.h - 2*(padPx + strokeInset)
      };

      // Clip to inner shape
      ctx.save();
      if (shape !== 'none'){
        drawShape(ctx, shape,
          box.x + strokeInset, box.y + strokeInset,
          box.w - 2*strokeInset, box.h - 2*strokeInset, corner);
        ctx.clip();
      }

      // Band heights
      const hTop = labelBandHeight(ctx, topText, labelPx, bandPad);
      const hBot = labelBandHeight(ctx, bottomText, labelPx, bandPad);

      // 1) Place captions at fixed offsets from the frame edges
      let topY = frame.y + topOffset;
      let botY = frame.y + frame.h - bottomOffset - hBot;

      // Keep order (if offsets too large, they just meet)
      if (topY + hTop > botY) {
        const mid = frame.y + frame.h/2;
        topY = mid - hTop;
        botY = mid;
      }

      if (topText)   drawLabelAtY(ctx, topText,   labelPx, labelCol, bandOn, bandCol, bandPad, frame.x, topY, frame.w);
      if (bottomText)drawLabelAtY(ctx, bottomText,labelPx, labelCol, bandOn, bandCol, bandPad, frame.x, botY, frame.w);

      // 2) Image: centered in the remaining vertical slot
      const slotTop = topText ? topY + hTop : frame.y;
      const slotBot = bottomText ? botY : frame.y + frame.h;
      const slotH   = Math.max(0, slotBot - slotTop);

      if (img && slotH > 0){
        const asp = img.width / img.height;
        let dw = frame.w;
        let dh = dw / asp;
        if (dh > slotH){ dh = slotH; dw = dh * asp; }
        const dx = frame.x + (frame.w - dw)/2;
        const dy = slotTop + (slotH - dh)/2;
        const a = parseFloat(tintPct.value)/100;
        drawTinted(ctx, img, dx, dy, dw, dh, tintColor.value, a);
      }

      ctx.restore(); // end clip

      // Border on top
      if(strokeEnabled && shape!=='none'){
        ctx.save();
        ctx.lineWidth = Math.max(1, strokeW);
        ctx.strokeStyle = strokeColor.value;
        drawShape(ctx, shape, box.x + ctx.lineWidth/2, box.y + ctx.lineWidth/2, box.w - ctx.lineWidth, box.h - ctx.lineWidth, corner);
        ctx.stroke();
        ctx.restore();
      }
    }

    // ===== Persist simple state =====
    function readState(){
      return {
        advOpen: !!toggleAdvanced.checked,
        exportSize: parseInt(sizePx?.value ?? 512,10),
        quick: { topText: topLabelText.value || '', bottomText: bottomLabelText.value || '' },
        text: {
          size: parseInt(labelSize.value,10),
          color: labelColor.value,
          bandOn: !!labelBandOn.checked,
          bandColor: labelBandColor.value,
          bandPadPct: parseFloat(labelBandPadPct.value),
          topOffsetPct: parseFloat(topOffsetPct.value),
          bottomOffsetPct: parseFloat(bottomOffsetPct.value),
        },
        bg: {
          transparent: !!bgTransparent.checked,
          color: bgColor.value,
          shape: bgShape.value,
          cornerPct: parseFloat(cornerPct.value),
          paddingPct: parseFloat(paddingPct.value),
          strokeOn: !!strokeOn.checked,
          strokeColor: strokeColor.value,
          strokePct: parseFloat(strokePct.value),
          shadowOn: !!shadowOn.checked
        },
        icon: {
          tintPct: parseFloat(tintPct.value),
          tintColor: tintColor.value,
          scalePct: parseFloat(iconScalePct.value)
        },
        image: currentImageMeta
      };
    }
    function writeState(s){
      if (!s) return;
      toggleAdvanced.checked = !!s.advOpen;
      advPanel.style.display = toggleAdvanced.checked ? 'block' : 'none';

      if (Number.isFinite(s.exportSize)) {
        if (sizePx) sizePx.value = s.exportSize;
        exportSize = s.exportSize;
        if (sizePxVal) sizePxVal.textContent = s.exportSize;
      }

      if (s.quick){ topLabelText.value = s.quick.topText ?? ''; bottomLabelText.value = s.quick.bottomText ?? ''; }

      if (s.text){
        labelSize.value       = Number.isFinite(s.text.size) ? s.text.size : 64;
        labelColor.value      = s.text.color || '#000000';
        labelBandOn.checked   = !!s.text.bandOn;
        labelBandColor.value  = s.text.bandColor || '#ffffff';
        labelBandPadPct.value = Number.isFinite(s.text.bandPadPct) ? s.text.bandPadPct : 6;
        topOffsetPct.value    = Number.isFinite(s.text.topOffsetPct) ? s.text.topOffsetPct : 6;
        bottomOffsetPct.value = Number.isFinite(s.text.bottomOffsetPct) ? s.text.bottomOffsetPct : 6;
      }

      if (s.bg){
        bgTransparent.checked = !!s.bg.transparent;
        bgColor.value         = s.bg.color || '#ffffff';
        bgShape.value         = s.bg.shape || 'rounded';
        cornerPct.value       = Number.isFinite(s.bg.cornerPct) ? s.bg.cornerPct : 22;
        paddingPct.value      = Number.isFinite(s.bg.paddingPct) ? s.bg.paddingPct : 10;
        strokeOn.checked      = !!s.bg.strokeOn;
        strokeColor.value     = s.bg.strokeColor || '#000000';
        strokePct.value       = Number.isFinite(s.bg.strokePct) ? s.bg.strokePct : 2;
        shadowOn.checked      = !!s.bg.shadowOn;
      }

      if (s.icon){
        tintPct.value     = Number.isFinite(s.icon.tintPct) ? s.icon.tintPct : 0;
        tintColor.value   = s.icon.tintColor || '#000000';
        iconScalePct.value= Number.isFinite(s.icon.scalePct) ? s.icon.scalePct : 100;
      }

      currentImageMeta = s.image || { type:'none' };
    }
    function save(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(readState())); }catch(e){} }
    function load(){ try{ const raw=localStorage.getItem(LS_KEY); return raw?JSON.parse(raw):null; }catch(e){ return null; } }
    const debounce=(fn,ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
    const saveDebounced = debounce(save, 180);

    // ===== Init & bindings =====
    advPanel.style.display = 'none';
    toggleAdvanced.addEventListener('change', ()=>{ advPanel.style.display = toggleAdvanced.checked ? 'block' : 'none'; render(cvs.width); saveDebounced(); });

    function fitPreview(){
      const s=Math.min(window.innerWidth-360, window.innerHeight-100);
      const size=Math.max(256, Math.min(1024, Math.floor(s)));
      render(size);
    }
    window.addEventListener('resize', fitPreview);

    // Inputs that trigger re-render
    [
      sizePx, topLabelText, bottomLabelText,
      bgTransparent,bgShape,bgColor,cornerPct,paddingPct,
      strokeOn,strokeColor,strokePct,shadowOn,
      tintPct,tintColor,iconScalePct,
      labelSize,labelColor,labelBandOn,labelBandColor,labelBandPadPct,
      topOffsetPct,bottomOffsetPct
    ].forEach(el=>el && el.addEventListener('input', ()=>{ if (sizePx===el){ exportSize=parseInt(sizePx.value,10); sizePxVal.textContent=exportSize; } render(cvs.width); saveDebounced(); }));

    // Clear
    clearBtn.addEventListener('click', ()=>{
      img = null; currentImageMeta = { type:'none' };
      topLabelText.value = ''; bottomLabelText.value = '';
      render(); saveDebounced();
    });

    // Download
    downloadBtn.addEventListener('click', ()=>{
      const off=document.createElement('canvas');
      const octx=off.getContext('2d');
      off.width=off.height=exportSize;
      const prev=cvs.width;
      render(exportSize);
      octx.drawImage(cvs,0,0,exportSize,exportSize);
      render(prev);
      off.toBlob(blob=>{
        const baseName = (bottomLabelText.value.trim() || topLabelText.value.trim() || 'pictogram')
          .toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9-_]/g,'');
        const a=document.createElement('a');
        a.download=`${baseName}-${exportSize}.png`;
        a.href=URL.createObjectURL(blob); a.click();
        setTimeout(()=>URL.revokeObjectURL(a.href),800);
      },'image/png');
    });

    if (clearSavedBtn) clearSavedBtn.addEventListener('click', ()=>{ localStorage.removeItem(LS_KEY); alert('Saved options cleared.'); });

    // ===== Gallery (simplified) =====
    function showModal(){ galleryModal.classList.add('show'); }
    function hideModal(){ galleryModal.classList.remove('show'); }
    openGalleryBtn.onclick = ()=>{ showModal(); buildGrid(false); };
    gmClose.onclick=hideModal;

    gmSize.oninput=()=>document.querySelector('.gm-grid').style.setProperty('--cell', gmSize.value+'px');
    gmSearch.oninput=()=>filterGrid(gmSearch.value.trim().toLowerCase());

    async function fetchManifest(){
      const res=await fetch('../../images/pictos/index.json',{cache:'no-store'});
      if(!res.ok) throw new Error(res.status+' '+res.statusText);
      const data=await res.json();
      if(!data || !Array.isArray(data.files)) throw new Error('Invalid manifest format');
      return data;
    }
    async function buildGrid(alsoTryRestore){
      try{
        manifest = manifest || await fetchManifest();
        const base = manifest.base || '../../images/pictos/';
        gridItems = manifest.files.map(fn=>({name:fn, src:base+fn}));
        renderGrid(gridItems);

        if (alsoTryRestore && currentImageMeta?.type === 'gallery' && currentImageMeta.src){
          const hit = gridItems.find(it => it.src === currentImageMeta.src);
          if (hit){
            const imageEl=new Image(); imageEl.crossOrigin='anonymous';
            imageEl.onload=()=>{ img=imageEl; render(); hideModal(); };
            imageEl.src=hit.src;
          }
        }
      }catch(err){
        console.error('Could not load manifest:', err);
      }
    }
    function renderGrid(list){
      gmGrid.innerHTML='';
      list.forEach(item=>{
        const cell=document.createElement('button'); cell.className='gm-item'; cell.title=item.name;
        const im=document.createElement('img'); im.loading='lazy'; im.alt=item.name; im.src=item.src; cell.appendChild(im);
        cell.onclick=()=>{
          const imageEl=new Image(); imageEl.crossOrigin='anonymous';
          imageEl.onload=()=>{ img=imageEl; currentImageMeta = { type:'gallery', src:item.src, name:item.name }; render(); hideModal(); saveDebounced(); };
          imageEl.src=item.src;
        };
        gmGrid.appendChild(cell);
      });
    }
    function filterGrid(q){
      const arr=q ? gridItems.filter(it=>it.name.toLowerCase().includes(q)) : gridItems;
      renderGrid(arr);
    }

    // Upload local
    uploadBtn.onclick=()=>uploadInput.click();
    uploadInput.onchange=e=>{
      const f=e.target.files?.[0]; if(!f) return;
      const url=URL.createObjectURL(f);
      const im=new Image();
      im.onload=()=>{ img=im; currentImageMeta = { type:'local', name:f.name }; render(); URL.revokeObjectURL(url); saveDebounced(); };
      im.src=url;
    };

    // ===== Init =====
    (function init(){
      const saved = load();
      if (saved) writeState(saved);
      else {
        // default background color already #fff, bgTransparent unchecked => white export by default
      }
      if (saved?.image?.type === 'gallery' && saved.image.src){
        const imageEl=new Image(); imageEl.crossOrigin='anonymous';
        imageEl.onload=()=>{ img=imageEl; render(); };
        imageEl.onerror=()=>{ render(); };
        imageEl.src=saved.image.src;
      } else {
        render(); // initial
      }
      fitPreview();
    })();
  </script>

  <script src="../../js/translationonly.js"></script>
</body>
</html>
