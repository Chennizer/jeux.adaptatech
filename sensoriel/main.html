<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../../images/binou.png">
  <link rel="stylesheet" href="../../css/ipadteachh.css">
  <link rel="stylesheet" href="css/main.css">
  <title>Game Selection</title>
</head>
<body class="selection-page">

  <div class="selection-container game-container">
    <h1>Choix d'activités et options</h1>
    <form id="selectionForm">
      <!-- Grid container for basket-themed game selections -->
      <div id="gameSelections">
        <!-- Basket containers will be appended here -->
      </div>
      <button type="button" id="addGameBtn">Ajouter un panier</button>

      <!-- Media theme selection -->
      <div class="media-selection">
        <label for="mediaOption">Sélectionner le thème à appliquer</label>
        <select id="mediaOption" name="mediaOption" required>
          <option value="">Sélectionner</option>
          <!-- Options from themes.js will be appended here -->
        </select>
      </div>

      <!-- New Reinforcer Options Section -->
      <div class="reinforcer-options">
        <label for="reinforcerType">Sélectionner le type de renforcement</label>
        <select id="reinforcerType" name="reinforcerType" required>
          <option value="shortvideo" selected>Vidéo Courte</option>
          <option value="image">Image Courte</option>
        </select>
      </div>

      <button type="submit">Commencer la séquence d'activités</button>
      <div class="error" id="errorMsg"></div>
    </form>
  </div>

  <!-- Template for basket-themed game selection block -->
  <template id="gameSelectionTemplate">
    <div class="game-selection-block basket">
      <h3 class="basket-title">Panier <span class="game-number"></span></h3>
      <select class="game-select" required>
        <option value="">--Choisir l'activité--</option>
      </select>
      <div class="game-specific-options"></div>
      <button type="button" class="remove-game-btn">Retirer</button>
    </div>
  </template>

  <!-- 1. Load themes.js FIRST so we have window.themes. -->
  <script src="../js/themes.js"></script>
  <script src="js/games-config.js"></script>
  <script src="js/fullscreen.js"></script>

  <!-- 2. Then our main logic script. -->
  <script>
    const maxGames = 10;
    const FULLSCREEN_PREFERENCE_KEY = 'sensorielFullscreenPreferred';
    const gameSelectionsContainer = document.getElementById('gameSelections');
    const addGameBtn = document.getElementById('addGameBtn');
    const selectionForm = document.getElementById('selectionForm');
    const errorMsg = document.getElementById('errorMsg');
    const gameSelectionTemplate = document.getElementById('gameSelectionTemplate');

    const gamesConfig = Array.isArray(window.gamesConfig) ? window.gamesConfig : [];
    const availableGames = gamesConfig.filter(game => !game.disabled);
    const gameConfigMap = new Map();
    gamesConfig.forEach(game => {
      if (game && game.id) {
        gameConfigMap.set(game.id, game);
      }
    });

    let gameCount = 0;

    function populateGameSelect(selectElement) {
      if (!selectElement) {
        return;
      }
      selectElement.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = "--Choisir l'activité--";
      selectElement.appendChild(placeholder);

      availableGames.forEach(game => {
        const option = document.createElement('option');
        option.value = game.id;
        option.textContent = game.label;
        selectElement.appendChild(option);
      });
    }

    function getGameConfigById(gameId) {
      if (!gameId) {
        return null;
      }
      return gameConfigMap.get(gameId) || null;
    }

    function getGameFileById(gameId) {
      const config = getGameConfigById(gameId);
      const rawPath = config && config.file ? config.file : `${gameId}.html`;
      try {
        return encodeURI(rawPath);
      } catch (error) {
        console.warn('Unable to encode game file path:', rawPath, error);
        return rawPath;
      }
    }

    function formatThemeLabel(themeId, theme) {
      if (theme && typeof theme.displayName === 'string' && theme.displayName.trim()) {
        return theme.displayName.trim();
      }

      const cleanedId = themeId
        .replace(/^picto_/, '')
        .replace(/[_-]+/g, ' ')
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .trim();

      if (!cleanedId) {
        return themeId;
      }

      return cleanedId
        .split(' ')
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }

    function populateThemesDropdown() {
      const themesDropdown = document.getElementById('mediaOption');
      if (!themesDropdown || !window.themes) {
        return;
      }

      const previousValue = themesDropdown.value;
      themesDropdown.innerHTML = '';

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Sélectionner';
      themesDropdown.appendChild(placeholder);

      const seen = new Set();
      Object.entries(window.themes).forEach(([themeKey, themeValue]) => {
        if (!themeValue || typeof themeValue !== 'object') {
          return;
        }

        const canonicalId = themeValue.id || themeKey;
        if (canonicalId === 'default' || seen.has(canonicalId)) {
          return;
        }

        seen.add(canonicalId);

        const option = document.createElement('option');
        option.value = canonicalId;
        option.textContent = formatThemeLabel(canonicalId, themeValue);
        themesDropdown.appendChild(option);
      });

      if (previousValue && seen.has(previousValue)) {
        themesDropdown.value = previousValue;
      }
    }

    // Standard function to add a basket container (non-animated, for initial load)
    function addGameSelection() {
      if (gameCount >= maxGames) return;
      gameCount++;
      const template = gameSelectionTemplate.content.cloneNode(true);
      const block = template.querySelector('.game-selection-block');
      block.querySelector('.game-number').textContent = gameCount;

      // Attach remove logic using our custom removal animation function.
      block.querySelector('.remove-game-btn').addEventListener('click', () => {
        removeGameSelectionAnimated(block);
      });

      // Attach game select logic
      const gameSelect = block.querySelector('.game-select');
      populateGameSelect(gameSelect);
      gameSelect.addEventListener('change', (e) => {
        handleGameSelectionChange(e, block);
      });

      gameSelectionsContainer.appendChild(block);
      updateGameNumbers();
    }

    // Animated add: similar to the standard add, with an extra sliding-in basket PNG.
    function addGameSelectionAnimated() {
      if (gameCount >= maxGames) return;
      gameCount++;
      const template = gameSelectionTemplate.content.cloneNode(true);
      const block = template.querySelector('.game-selection-block');
      block.querySelector('.game-number').textContent = gameCount;
      
      // Attach remove logic using our custom removal animation function.
      block.querySelector('.remove-game-btn').addEventListener('click', () => {
        removeGameSelectionAnimated(block);
      });
      // Attach game select logic
      const gameSelect = block.querySelector('.game-select');
      populateGameSelect(gameSelect);
      gameSelect.addEventListener('change', (e) => {
        handleGameSelectionChange(e, block);
      });
      
      // Hide the block until the animation completes.
      block.style.opacity = "0";
      gameSelectionsContainer.appendChild(block);
      
      requestAnimationFrame(() => {
        const blockRect = block.getBoundingClientRect();
        const containerRect = gameSelectionsContainer.getBoundingClientRect();
        // Compute final destination; add 20px correction plus extra 10px to end slightly more right.
        const destX = blockRect.left - containerRect.left + 20 + 10;
        const destY = blockRect.top - containerRect.top;
        
        // Fixed start offset: 200px.
        const startOffset = 200;
        // Determine offset: if odd, start 200px to the left; if even, 200px to the right.
        const offset = (gameCount % 2 === 1) ? -startOffset : startOffset;
        
        // Create the animated basket image element using your transparent basket PNG.
        const animatedBasket = document.createElement('img');
        animatedBasket.src = "../images/plasticbasket.png";
        animatedBasket.style.width = "200px";
        animatedBasket.style.position = "absolute";
        animatedBasket.style.left = (destX + offset) + "px";
        animatedBasket.style.top = destY + "px";
        
        gameSelectionsContainer.appendChild(animatedBasket);
        
        // Animate the basket image sliding in.
        animatedBasket.animate([
          { transform: `translateX(0px)`, opacity: 1 },
          { transform: `translateX(${ -offset }px)`, opacity: 1 },
          { transform: `translateX(${ -offset }px)`, opacity: 0 }
        ], {
          duration: 1000,
          fill: 'forwards',
          easing: 'linear'
        });
        
        setTimeout(() => {
          animatedBasket.remove();
          block.style.opacity = "1";
          updateGameNumbers();
        }, 1000);
      });
    }

    // New removal function: do the reverse of the add animation.
    function removeGameSelectionAnimated(block) {
      // Get the block's current position relative to the container.
      const containerRect = gameSelectionsContainer.getBoundingClientRect();
      const blockRect = block.getBoundingClientRect();
      const destX = blockRect.left - containerRect.left;
      const destY = blockRect.top - containerRect.top;
      
      // Create an animated basket image element at the block's position.
      const animatedBasket = document.createElement('img');
      animatedBasket.src = "../../images/plasticbasket.png";
      animatedBasket.style.width = "200px";
      animatedBasket.style.position = "absolute";
      animatedBasket.style.left = destX + "px";
      animatedBasket.style.top = destY + "px";
      
      gameSelectionsContainer.appendChild(animatedBasket);
      
      // Animate the basket image to slide out in the reverse direction.
      const startOffset = 200;
      const offset = (gameCount % 2 === 1) ? -startOffset : startOffset;
      
      animatedBasket.animate([
        { transform: `translateX(0px)`, opacity: 1 },
        { transform: `translateX(${ offset }px)`, opacity: 1 },
        { transform: `translateX(${ offset }px)`, opacity: 0 }
      ], {
        duration: 1000,
        fill: 'forwards',
        easing: 'linear'
      });
      
      setTimeout(() => {
        animatedBasket.remove();
      }, 1000);
      
      // Immediately remove the basket block.
      block.remove();
      gameCount--;
      updateGameNumbers();
    }

    function updateGameNumbers() {
      const blocks = gameSelectionsContainer.querySelectorAll('.game-selection-block');
      blocks.forEach((block, index) => {
        block.querySelector('.game-number').textContent = index + 1;
      });
    }

    function handleGameSelectionChange(event, block) {
      const selectedGame = event.target.value;
      const optionsContainer = block.querySelector('.game-specific-options');
      optionsContainer.innerHTML = '';

      const config = getGameConfigById(selectedGame);
      if (config && Array.isArray(config.options) && config.options.length > 0) {
        config.options.forEach(option => {
          if (option.type === 'checkbox') {
            const container = document.createElement('div');
            container.className = 'checkbox-container';
            const textSpan = document.createElement('span');
            textSpan.textContent = option.label;
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.name = option.name;
            if (option.defaultChecked) {
              input.checked = true;
            }
            container.appendChild(textSpan);
            container.appendChild(input);
            optionsContainer.appendChild(container);
          } else {
            const label = document.createElement('label');
            label.textContent = option.label;
            label.setAttribute('for', option.name);
            optionsContainer.appendChild(label);
            let input;
            if (option.type === 'select') {
              input = document.createElement('select');
              input.name = option.name;
              input.required = true;
              option.options.forEach(opt => {
                const optionElem = document.createElement('option');
                optionElem.value = opt.value;
                optionElem.textContent = opt.text;
                input.appendChild(optionElem);
              });
            } else if (option.type === 'text') {
              input = document.createElement('input');
              input.type = 'text';
              input.name = option.name;
              input.required = true;
            } else if (option.type === 'number') {
              input = document.createElement('input');
              input.type = 'number';
              input.name = option.name;
              input.min = option.min || 0;
              input.max = option.max || 1000;
              if (option.value !== undefined) {
                input.value = option.value;
              }
              input.required = true;
            }
            optionsContainer.appendChild(input);
          }
        });
        optionsContainer.style.display = 'block';
      } else {
        optionsContainer.style.display = 'none';
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      populateThemesDropdown();
      // Add 2 baskets on load (using standard add)
      addGameSelection();
      addGameSelection();
    });

    document.addEventListener('themes:pictoThemesLoaded', () => {
      populateThemesDropdown();
    });

    addGameBtn.addEventListener('click', addGameSelectionAnimated);

    function setFullscreenPreference() {
      try {
        localStorage.setItem(FULLSCREEN_PREFERENCE_KEY, 'true');
      } catch (error) {
        console.warn('Unable to store fullscreen preference:', error);
      }
    }

    async function requestDocumentFullscreen() {
      const element = document.documentElement;
      if (!element) {
        return false;
      }

      const request =
        element.requestFullscreen ||
        element.webkitRequestFullscreen ||
        element.msRequestFullscreen ||
        element.mozRequestFullScreen;

      if (!request) {
        return false;
      }

      try {
        const result = request.call(element, { navigationUI: 'hide' });
        if (result && typeof result.then === 'function') {
          await result;
        }
        return true;
      } catch (error) {
        console.warn('Fullscreen request from main page failed:', error);
        return false;
      }
    }

    selectionForm.addEventListener('submit', async function(e) {
      e.preventDefault();
      errorMsg.textContent = '';

      const gameBlocks = gameSelectionsContainer.querySelectorAll('.game-selection-block');
      const selectedGames = [];
      const gameDetails = [];
      let duplicateSelection = false;

      for (const block of gameBlocks) {
        const gameSelect = block.querySelector('.game-select');
        const selectedGame = gameSelect.value;
        if (selectedGame === '') {
          continue;
        }

        if (selectedGames.includes(selectedGame)) {
          errorMsg.textContent = "Each game must be unique. Please adjust your selections.";
          duplicateSelection = true;
          break;
        }
        selectedGames.push(selectedGame);

        const optionsContainer = block.querySelector('.game-specific-options');
        const inputs = optionsContainer.querySelectorAll('input, select');
        const options = {};
        inputs.forEach(input => {
          if (input.type === "checkbox") {
            options[input.name] = input.checked ? "true" : "false";
          } else if (input.type === "number") {
            // Use valueAsNumber to store a numeric value
            options[input.name] = input.valueAsNumber;
          } else {
            options[input.name] = input.value;
          }
        });
        gameDetails.push({
          id: selectedGame,
          options: options
        });
      }

      if (duplicateSelection) {
        return;
      }

      if (gameDetails.length < 1) {
        errorMsg.textContent = "Please select at least one game.";
        return;
      }

      gameDetails.forEach(game => {
        if (game.id === "denombrer" && game.options) {
          if (game.options.difficulty) {
            localStorage.setItem("difficulty", game.options.difficulty);
          }
          if (game.options.activityRepetitions) {
            localStorage.setItem("activityRepetitions", game.options.activityRepetitions);
          }
        }
      });

      const mediaOption = document.getElementById('mediaOption').value;
      if (!mediaOption) {
        errorMsg.textContent = "Please select a media theme.";
        return;
      }

      // Retrieve the user-chosen reinforcer type
      const reinforcerTypeSelect = document.getElementById('reinforcerType');
      const reinforcerType = reinforcerTypeSelect ? reinforcerTypeSelect.value : "shortvideo";

      const selectionsObj = {
        gameOrder: gameDetails.map(game => game.id),
        gameOptions: gameDetails.map(game => game.options),
        mediaOption: mediaOption,
        // Save the chosen reinforcer type
        reinforcerType: reinforcerType
      };

      localStorage.setItem('gameSelections', JSON.stringify(selectionsObj));
      localStorage.setItem('currentGameIndex', 0);

      const firstGameId = selectionsObj.gameOrder[0];
      const firstGameFile = getGameFileById(firstGameId);
      if (!firstGameFile) {
        errorMsg.textContent = "L'activité sélectionnée est introuvable.";
        return;
      }
      setFullscreenPreference();

      if (window.SensorielFullscreen && typeof window.SensorielFullscreen.markPreferred === 'function') {
        window.SensorielFullscreen.markPreferred(true);
        try {
          await window.SensorielFullscreen.ensure();
        } catch (error) {
          console.warn('Sensoriel fullscreen helper error:', error);
        }
      } else {
        await requestDocumentFullscreen();
      }

      window.location.href = firstGameFile;
    });
  </script>
</body>
</html>
