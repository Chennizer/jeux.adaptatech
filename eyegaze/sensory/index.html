<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Eyegaze — Sensory Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    body.light { background:#fff; color:#000; }
    body.dark  { background:#000; color:#fff; }

    html, body { height:100%; margin:0; overflow:hidden; }
    canvas#c { position:fixed; inset:0; display:none; }

    #game-options.modal {
      display:flex; align-items:center; justify-content:center;
    }

    .value-badge{
      display:inline-block; min-width:2ch; padding:2px 6px; border-radius:8px;
      background:rgba(255,255,255,.12); color:#0b1a18; font-variant-numeric:tabular-nums
    }
    body.light .value-badge{ background:rgba(0,0,0,.08); color:inherit; }
  </style>
</head>
<body class="dark">
  <canvas id="c"></canvas>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title">Laboratoire Sensoriel</h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="muteSFX">
              <span>Désactiver les sons</span>
            </label>
          </div>
          <div class="option-item">
            <label for="sfxVol" class="teal-label">
              <span>Volume des sons:&nbsp;</span>
              <span id="sfxVolVal" class="value-badge">50</span>
            </label>
            <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="themeSelect" class="teal-label label-block">Mode</label>
            <select id="themeSelect" class="styled-select">
              <option value="light">Clair</option>
              <option value="dark" selected>Sombre</option>
            </select>
          </div>

          <div class="option-item">
            <label for="sceneSelect" class="teal-label label-block">Scène</label>
            <select id="sceneSelect" class="styled-select">
              <option value="aurora">Aurora</option>
              <option value="ripples">Ondes</option>
              <option value="fireworks">Feux d’artifice</option>
              <option value="kaleido">Kaleido</option>
              <option value="fireflies">Lucioles</option>
              <option value="confetti">Confetti</option>
              <option value="nebula">Nébuleuse</option>
              <option value="jelly">Gelée</option>
              <option value="snow">Neige-Boule</option>
              <option value="sand">Sable Arc-en-ciel</option>
              <option value="magnet">Essaim Magnétique</option>
              <option value="glass">Vitrail</option>
              <option value="streamers">Rubans de Soie</option>
              <option value="laserharp" selected>Harpe Laser</option>
              <option value="bubblepop">Bulle-Pop</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="intensitySlider" class="teal-label">
              <span>Intensité:&nbsp;</span>
              <span id="intensityVal" class="value-badge">85</span>
            </label>
            <input type="range" id="intensitySlider" class="styled-slider" min="0" max="100" value="85">
          </div>

          <div class="option-item">
            <label for="sizeSlider" class="teal-label">
              <span>Taille:&nbsp;</span>
              <span id="sizeVal" class="value-badge">140</span>
            </label>
            <input type="range" id="sizeSlider" class="styled-slider" min="10" max="200" value="140">
          </div>

          <div class="option-item">
            <label for="trailSlider" class="teal-label">
              <span>Traînée:&nbsp;</span>
              <span id="trailVal" class="value-badge">60</span>
            </label>
            <input type="range" id="trailSlider" class="styled-slider" min="0" max="100" value="60">
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button">Commencer</button>
    </div>
  </div>

  <script src="../../js/eyegaze-menu.js"></script>

  <script>
  /* =========================
     UI + base
     ========================= */
  const startButton = document.getElementById('startButton');
  const themeSel  = document.getElementById('themeSelect');
  const sceneSel  = document.getElementById('sceneSelect');

  const muteSFX   = document.getElementById('muteSFX');
  const sfxVol    = document.getElementById('sfxVol');
  const sfxVolVal = document.getElementById('sfxVolVal');

  const intSlider = document.getElementById('intensitySlider');
  const sizeSlider= document.getElementById('sizeSlider');
  const trailSlider= document.getElementById('trailSlider');
  const intVal    = document.getElementById('intensityVal');
  const sizeVal   = document.getElementById('sizeVal');
  const trailVal  = document.getElementById('trailVal');

  function reflectSliders(){
    sfxVolVal.textContent = sfxVol.value;
    intVal.textContent = intSlider.value;
    sizeVal.textContent = sizeSlider.value;
    trailVal.textContent = trailSlider.value;
  }
  [sfxVol,intSlider,sizeSlider,trailSlider].forEach(el=>el.addEventListener('input', reflectSliders));
  reflectSliders();

  function applyTheme(){
    document.body.classList.remove('light','dark');
    document.body.classList.add(themeSel.value === 'light' ? 'light' : 'dark');
  }
  themeSel.addEventListener('change', applyTheme);
  applyTheme();

  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d', { alpha:false });
  let W = innerWidth, H = innerHeight;
  cvs.width = W; cvs.height = H;

  addEventListener('resize', ()=>{
    W=innerWidth; H=innerHeight; cvs.width=W; cvs.height=H;
    if (typeof resizeGlass === 'function') resizeGlass();
    if (typeof resizeLaser === 'function') resizeLaser();
    if (typeof caSandOnResize === 'function') caSandOnResize();
    if (typeof auroraResize === 'function') auroraResize(); /* NEW: resize hook for Aurora */
  });

  let menuOpen = true;
  cvs.style.display = 'none';

  let ac=null;
  function ensureAC(){ if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)(); return ac; }
  function playPing(f=440, len=0.2, gain=0.05){
    if (menuOpen) return;
    try{
      ensureAC();
      const o=ac.createOscillator(), g=ac.createGain();
      o.type='sine'; o.frequency.value=f;
      const vol = (muteSFX.checked?0:1) * Math.max(0, Math.min(1, (parseInt(sfxVol.value,10)||50)/100));
      g.gain.value = gain * vol;
      o.connect(g).connect(ac.destination);
      const t = ac.currentTime;
      o.start(t); g.gain.exponentialRampToValueAtTime(0.0001, t+len); o.stop(t+len+0.02);
    }catch(e){}
  }

  const ui = {
    get mode(){ return sceneSel; },
    get intensity(){ return intSlider; },
    get size(){ return sizeSlider; },
    get trail(){ return trailSlider; }
  };

  let paused=false;
  let mouse = { x:W/2, y:H/2, vx:0, vy:0, speed:0 };
  let last  = { x:mouse.x, y:mouse.y, t:performance.now() };
  let lastMoveT = performance.now();
  let dwellMs = 0;
  let now = performance.now();

  addEventListener('mousemove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const nx=e.clientX, ny=e.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
  }, {passive:true});

  addEventListener('touchmove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const touch=e.touches[0]; if(!touch) return;
    const nx=touch.clientX, ny=touch.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
  }, {passive:true});

  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const mapTrail=()=> clamp( (100-ui.trail.value)/100 * 0.9 + 0.05 , 0.02, 0.95 );
  const mapIntensity=()=> Number(ui.intensity.value)/100;
  const mapSize=()=> Number(ui.size.value);
  const dwellFactor=()=> clamp(dwellMs/1200,0,1);
  let lastDwellStage=0;
  function dwellJustCrossed(ms){
    const stage = dwellMs >= ms ? 1 : 0;
    const crossed = stage > lastDwellStage;
    lastDwellStage = stage;
    return crossed;
  }
  function clearToBg(hard=false){
    const isLight = document.body.classList.contains('light');
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = hard ? (isLight ? '#fff' : '#000')
                         : (isLight ? `rgba(255,255,255,${mapTrail()})` : `rgba(0,0,0,${mapTrail()})`);
    ctx.fillRect(0,0,W,H);
  }

  /* =========================
     AURORA — vibrant ribbons + stars (IMPROVED)
     ========================= */
  const AUR = {
    t: 0,
    hueBase: 140,
    stars: [],
    ribbons: [],
    cols: 28, // ray columns
  };

  // simple smooth 1D fbm using layered sines (fast, no lib)
  function fbm(x, t=0){
    let v=0, a=0.5, f=1.0;
    for(let i=0;i<4;i++){
      v += a * Math.sin(x*f + t*(0.35 + i*0.07) + i*1.3);
      a *= 0.5; f *= 1.8;
    }
    return v;
  }

  function auroraInit(){
    // stars
    const n = Math.floor((W*H)/18000); // density scales with screen
    AUR.stars = Array.from({length:n}, ()=>({
      x: Math.random()*W,
      y: Math.random()*H,
      z: Math.random()*1,   // depth for parallax
      a: 0.15 + Math.random()*0.5
    }));

    // layered ribbons, back-to-front
    AUR.ribbons = [
      { amp: 70, thick: 42, hue: (AUR.hueBase+40)%360, speed: 0.5, alpha:0.10, warp:0.75, offsetY: 0.58, jitter: 0.5 },
      { amp: 95, thick: 58, hue: (AUR.hueBase+0)%360,  speed: 0.7, alpha:0.16, warp:1.00, offsetY: 0.52, jitter: 0.9 },
      { amp:120, thick: 64, hue: (AUR.hueBase-40+360)%360, speed: 0.9, alpha:0.20, warp:1.15, offsetY: 0.46, jitter: 1.2 },
    ];
  }
  function auroraResize(){ auroraInit(); }
  auroraInit();

  function drawStars(dt){
    ctx.globalCompositeOperation = 'screen';
    for (const s of AUR.stars){
      // tiny parallax drift based on mouse velocity
      s.x += mouse.vx * 0.00002 * (0.3 + s.z);
      if (s.x < -5) s.x = W+5; if (s.x > W+5) s.x = -5;
      const r = 0.6 + s.z*1.4;
      ctx.fillStyle = `hsla(200,100%,${70+25*s.z}%,${s.a})`;
      ctx.beginPath(); ctx.arc(s.x, s.y, r, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawCurtainRibbon(rib, t, intensity){
    // Responsive amplitude & thickness
    const amp   = rib.amp   * (0.8 + 0.7*intensity) * (1 + dwellFactor()*0.25);
    const thick = rib.thick * (0.8 + 0.6*intensity);

    const baseY = H * rib.offsetY + (mouse.y - H*0.5) * 0.05; // slight follow
    const step = 12; // horizontal sampling
    const upper = [];
    const lower = [];

    // Build a soft, closed ribbon polygon following a noisy curve
    for (let x=0; x<=W; x+=step){
      const u = x/W;
      const n = fbm(u*6*rib.warp + rib.jitter*0.6, t*rib.speed);
      const y = baseY + n * amp + Math.sin(u*3 + t*0.3)*amp*0.05;

      // thickness subtly breathes with noise
      const localThick = thick * (0.85 + 0.25*Math.abs(n));
      upper.push([x, y - localThick]);
      lower.push([x, y + localThick]);
    }

    // color gradient across ribbon width
    const hue = (rib.hue + 20*Math.sin(t*0.15))%360;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = `hsla(${hue}, 95%, 60%, ${rib.alpha})`;

    ctx.beginPath();
    // upper edge
    for (let i=0;i<upper.length;i++){
      const [x,y]=upper[i];
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    // lower edge (reverse)
    for (let i=lower.length-1;i>=0;i--){
      const [x,y]=lower[i];
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();

    // soft glow along centerline (screen)
    ctx.globalCompositeOperation = 'screen';
    const g = ctx.createLinearGradient(0, baseY-amp*0.2, 0, baseY+amp*0.2);
    g.addColorStop(0, `hsla(${(hue+60)%360},95%,75%,0)`);
    g.addColorStop(0.5, `hsla(${hue},95%,75%,0.25)`);
    g.addColorStop(1, `hsla(${(hue+300)%360},95%,75%,0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    for (let i=0;i<upper.length;i++){
      const [x,y]=upper[i];
      ctx.lineTo(x,y + (thick*0.55)); // shift down to center glow strip
    }
    for (let i=lower.length-1;i>=0;i--){
      const [x,y]=lower[i];
      ctx.lineTo(x,y - (thick*0.55));
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawVerticalRays(t, intensity){
    // faint columns that sway; stronger near the pointer
    const cols = AUR.cols;
    const nearX = mouse.x / W;
    for (let i=0;i<cols;i++){
      const u = (i+0.5)/cols;
      // proximity modulation
      const prox = Math.max(0, 1 - Math.abs(u - nearX)*2.2);
      const n = fbm(u*8 + t*0.2, t*0.4);
      const alpha = (0.06 + 0.18*prox) * (0.5 + 0.5*intensity) * Math.max(0, 1 - Math.abs(n)*0.6);
      if (alpha < 0.01) continue;

      const x = u*W + Math.sin((u*8 + t*0.8))*18;
      const h = (AUR.hueBase + 120*Math.sin(u*2 + t*0.3))%360;

      const grad = ctx.createLinearGradient(x, 0, x, H);
      grad.addColorStop(0.0, `hsla(${(h+10)%360},100%,60%,0)`);
      grad.addColorStop(0.5, `hsla(${h},100%,60%,${alpha})`);
      grad.addColorStop(1.0, `hsla(${(h+350)%360},100%,60%,0)`);

      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = grad;
      ctx.lineWidth = 2 + 10*prox*(0.6 + 0.6*intensity);
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
  }

  function renderAurora(dt){
    AUR.t += dt;
    AUR.hueBase = (AUR.hueBase + 12*dt) % 360;

    // background clear with slight trail for dreamy blending
    ctx.globalCompositeOperation='source-over';
    const isLight = document.body.classList.contains('light');
    const fade = isLight ? `rgba(255,255,255,${mapTrail()*0.9})` : `rgba(0,0,0,${mapTrail()*0.9})`;
    ctx.fillStyle = fade; ctx.fillRect(0,0,W,H);

    const intensity = mapIntensity();

    // subtle starfield (behind ribbons)
    drawStars(dt);

    // back-to-front curtains
    for (let i=0;i<AUR.ribbons.length;i++){
      const rib = AUR.ribbons[i];
      rib.hue = (rib.hue + 6*dt) % 360;
      drawCurtainRibbon(rib, AUR.t + i*0.12, intensity);
    }

    // vertical rays (after ribbons, adds sparkle)
    drawVerticalRays(AUR.t, intensity);

    // pulses when dwelling
    if (dwellMs>500){
      ctx.globalCompositeOperation='screen';
      const r = 120 + 260*intensity;
      const g = ctx.createRadialGradient(mouse.x, mouse.y, r*0.1, mouse.x, mouse.y, r);
      g.addColorStop(0, `hsla(${(AUR.hueBase+90)%360},100%,75%,0.20)`);
      g.addColorStop(1, `hsla(0,0%,0%,0)`);
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, r, 0, Math.PI*2); ctx.fill();
    }
  }

  /* =========================
     Other scenes
     ========================= */
  // Keep a global hueBase to drive color shifts in some scenes (e.g., fireworks)
  let hueBase = 0;

  const ripples = [];
  const leaves = Array.from({length:40}, ()=>({ x: Math.random()*W, y: Math.random()*H, r: 3+Math.random()*5, t: Math.random()*1000 }));
  function emitRipple(x,y, r0=2){ ripples.push({x,y, r:r0, a:1}); }
  function renderRipples(dt){
    clearToBg(false);
    const speedN = clamp(mouse.speed/1200, 0, 1);
    if (speedN>0.25 && Math.random()<0.5) emitRipple(mouse.x, mouse.y, 2+speedN*6);
    if (dwellMs>500 && Math.random()<0.12) emitRipple(mouse.x, mouse.y, 6 + mapSize()*0.15);
    ripples.forEach(r=>{
      r.r += 60*dt; r.a *= (1 - 0.8*dt);
      ctx.strokeStyle = `hsla(${(200 + r.r*0.2)%360},80%,70%,${r.a*0.6})`;
      ctx.lineWidth = 1.5; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.stroke();
    });
    for (let i=ripples.length-1;i>=0;i--) if (ripples[i]?.a < 0.02) ripples.splice(i,1);
    ctx.globalCompositeOperation='lighter';
    leaves.forEach(L=>{
      L.t += dt; const dx = mouse.x - L.x, dy = mouse.y - L.y;
      L.x += Math.cos(L.t*0.6)*10*dt + dx*0.02*mapIntensity();
      L.y += Math.sin(L.t*0.8)*8*dt + dy*0.02*mapIntensity();
      if (L.x<-10) L.x=W+10; if (L.x>W+10) L.x=-10;
      if (L.y<-10) L.y=H+10; if (L.y>H+10) L.y=-10;
      ctx.fillStyle = `hsla(${(180+dx*0.02)%360},70%,60%,0.6)`; ctx.beginPath(); ctx.arc(L.x, L.y, L.r, 0, Math.PI*2); ctx.fill();
    });
  }

  const sparks = [];
  function emitSpark(x,y, n=40, power=3){
    for (let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2, s = (0.8+Math.random()*0.6)*power;
      sparks.push({x,y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: 60+Math.random()*40, h:(hueBase+Math.random()*50)%360});
    }
  }
  function renderFireworks(dt){
    clearToBg(false);
    const sN = clamp(mouse.speed/1400, 0, 1);
    if (sN>0.35 && Math.random()<0.5) emitSpark(mouse.x, mouse.y, 18, 2.5);
    if (dwellJustCrossed(600)){ playPing(400+Math.random()*300, 0.25, 0.06); emitSpark(mouse.x, mouse.y, 120, 4.2); }
    ctx.globalCompositeOperation='lighter';
    for (let i=sparks.length-1;i>=0;i--){
      const p = sparks[i]; p.x += p.vx; p.y += p.vy; p.vx *= 0.985; p.vy = p.vy*0.985 + 0.02; p.life -= 1;
      const a = clamp(p.life/80, 0, 1); ctx.fillStyle = `hsla(${p.h},90%,60%,${0.7*a})`;
      ctx.beginPath(); ctx.arc(p.x,p.y, 2.2+ (1-a)*2.2, 0, Math.PI*2); ctx.fill();
      if (p.life<=0) sparks.splice(i,1);
    }
  }

  let kaleidoAngle=0;
  function renderKaleido(dt){
    const segs=8, r=mapSize()*0.8; kaleidoAngle += dt*0.4;
    clearToBg(false);
    const cx=W/2, cy=H/2, dx=mouse.x-cx, dy=mouse.y-cy;
    const baseHue=(performance.now()*0.02)%360, w=7+mapIntensity()*18;
    ctx.globalCompositeOperation='lighter'; ctx.lineCap='round'; ctx.lineJoin='round';
    for (let i=0;i<segs;i++){
      const a=(i/segs)*Math.PI*2 + kaleidoAngle;
      const x = cx + (dx*Math.cos(a) - dy*Math.sin(a));
      const y = cy + (dx*Math.sin(a) + dy*Math.cos(a));
      const h=(baseHue + i*(360/segs))%360;
      ctx.strokeStyle=`hsla(${h},85%,65%,0.5)`; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(lerp(cx,x,0.55), lerp(cy,y,0.55)); ctx.lineTo(x,y); ctx.stroke();
      ctx.fillStyle=`hsla(${(h+40)%360},85%,60%,0.25)`; ctx.beginPath(); ctx.arc(x,y, r*0.28, 0, Math.PI*2); ctx.fill();
    }
    if (dwellMs>600){
      const s=r*(1+0.12*Math.sin(performance.now()*0.006));
      ctx.strokeStyle=`hsla(${(baseHue+120)%360},90%,75%,0.35)`; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(cx,cy,s,0,Math.PI*2); ctx.stroke();
    }
  }

  const fireflies = Array.from({length:50},()=>({ x: Math.random()*W, y: Math.random()*H, vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6, glow: Math.random()*0.6 }));
  function renderFireflies(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    const attract = 15*mapIntensity();
    fireflies.forEach(f=>{
      f.vx += (Math.random()-0.5)*0.05; f.vy += (Math.random()-0.5)*0.05;
      f.vx += (mouse.x - f.x)/W * attract*dt; f.vy += (mouse.y - f.y)/H * attract*dt;
      f.vx = clamp(f.vx, -1.2, 1.2); f.vy = clamp(f.vy, -1.2, 1.2);
      f.x += f.vx; f.y += f.vy;
      if (f.x<-10) f.x=W+10; if (f.x>W+10) f.x=-10; if (f.y<-10) f.y=H+10; if (f.y>H+10) f.y=-10;
      const d = Math.hypot(mouse.x-f.x, mouse.y-f.y), charge = clamp(1 - d/220, 0, 1);
      f.glow = clamp(f.glow + (charge*1.6 - 0.4)*dt, 0.1, 1.4);
      const h = (200 + f.glow*100)%360, r = 2 + f.glow*4 + mapSize()*0.05;
      ctx.fillStyle = `hsla(${h},90%,65%,${0.6*f.glow})`; ctx.beginPath(); ctx.arc(f.x, f.y, r, 0, Math.PI*2); ctx.fill();
    });
    if (dwellJustCrossed(800)){ playPing(660,0.15,0.045); fireflies.forEach(f=> f.glow = Math.max(f.glow, 1.2)); }
  }

  const confettis = Array.from({length:220},()=>resetPiece({}));
  function resetPiece(p){
    p.x=Math.random()*W; p.y=Math.random()*H; p.vx=(Math.random()-0.5)*0.7; p.vy=Math.random()*0.6+0.2;
    p.size=2+Math.random()*4; p.h=Math.random()*360; p.spin=(Math.random()-0.5)*0.15; return p;
  }
  function renderConfetti(dt){
    clearToBg(false);
    const windX = clamp(mouse.vx/400, -1.5, 1.5) * (0.5 + mapIntensity());
    const windY = 0.15 + (dwellMs>600 ? 0.25 : 0);
    ctx.globalCompositeOperation='lighter';
    confettis.forEach(p=>{
      const dx = mouse.x - p.x, dy = mouse.y - p.y, pull = 0.02*mapIntensity();
      p.vx += windX*dt + dx*pull*dt; p.vy += windY*dt + dy*pull*dt;
      p.x += p.vx; p.y += p.vy; p.h += p.spin;
      ctx.fillStyle = `hsla(${(p.h)%360},90%,60%,0.8)`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
      if (p.x<-20||p.x>W+20||p.y<-20||p.y>H+20) resetPiece(p);
    });
    if (dwellJustCrossed(700)){
      playPing(550,0.12,0.04);
      for(let i=0;i<50;i++){ const q=resetPiece({}); q.x=mouse.x; q.y=mouse.y; q.vx=(Math.random()-0.5)*3.2; q.vy=Math.random()*-1.8; confettis.push(q); }
      if (confettis.length>400) confettis.splice(0, confettis.length-400);
    }
  }

  let nebulaHue = 0;
  function renderNebula(dt){
    nebulaHue = (nebulaHue + 18*dt) % 360;
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    const layers = 3 + Math.floor(mapIntensity()*3);
    for (let i=0;i<layers;i++){
      const s = mapSize()*(0.8 + i*0.35), h = (nebulaHue + i*40) % 360;
      const g = ctx.createRadialGradient(mouse.x, mouse.y, s*0.1, mouse.x, mouse.y, s);
      g.addColorStop(0, `hsla(${h},85%,60%,0.18)`); g.addColorStop(0.6, `hsla(${(h+30)%360},85%,50%,0.08)`); g.addColorStop(1, `hsla(${(h+60)%360},85%,45%,0)`);
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, s, 0, Math.PI*2); ctx.fill();
    }
    if (dwellMs>650){
      ctx.globalCompositeOperation='screen'; ctx.strokeStyle = `hsla(${(nebulaHue+150)%360},90%,75%,0.4)`; ctx.lineWidth = 1.5;
      const m = 6; for (let i=0;i<m;i++){ const a=(i/m)*Math.PI*2 + performance.now()*0.0015, r=mapSize()*1.1;
        ctx.beginPath(); ctx.arc(mouse.x + Math.cos(a)*r, mouse.y + Math.sin(a)*r, r*0.15, 0, Math.PI*2); ctx.stroke(); }
    }
  }

  const blobs = Array.from({length:6}, ()=>({ x: W*(0.2+0.6*Math.random()), y: H*(0.2+0.6*Math.random()), r: 40+Math.random()*80, hue: Math.random()*360, vx:0, vy:0 }));
  function renderJelly(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter'; const pull = 30*mapIntensity();
    blobs.forEach(b=>{
      const dx = mouse.x - b.x, dy = mouse.y - b.y;
      b.vx += dx * pull * 0.0002; b.vy += dy * pull * 0.0002;
      b.vx *= 0.985; b.vy = b.vy*0.985 + 0.02; b.x += b.vx; b.y += b.vy;
      const squish = clamp(1 + (Math.hypot(b.vx, b.vy))*0.03, 1, 1.6) * (1 + dwellFactor()*0.2);
      const rx = b.r * squish * (mapSize()/80), ry = b.r * (2 - squish) * (mapSize()/80);
      const h = (b.hue + performance.now()*0.02)%360;
      const g = ctx.createRadialGradient(b.x, b.y, Math.min(rx,ry)*0.3, b.x, b.y, Math.max(rx,ry));
      g.addColorStop(0, `hsla(${h},85%,70%,0.55)`); g.addColorStop(1, `hsla(${(h+60)%360},85%,45%,0.0)`); ctx.fillStyle = g;
      ctx.beginPath(); ctx.ellipse(b.x, b.y, rx, ry, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.fill();
    });
    if (dwellJustCrossed(900)){ playPing(330,0.12,0.05); blobs.forEach(b=>{ b.vx*=0.6; b.vy*=-0.8; }); }
  }

  const flakes = Array.from({length:350},()=>({x:Math.random()*W,y:Math.random()*H,z:Math.random()*1,vx:0,vy:0,h:Math.random()*360}));
  function renderSnow(dt){
    clearToBg(false);
    const wind = clamp(mouse.vx/800, -1, 1) * (0.5+mapIntensity());
    flakes.forEach(f=>{
      const dx = mouse.x - f.x, dy = mouse.y - f.y, r2 = dx*dx+dy*dy, pull = 2000/(r2+2000);
      f.vx += wind*dt + (-dy)*0.0008 + dx*pull*0.0006;
      f.vy += 0.05 + dy*pull*0.0006 + (dwellMs>700?0.1:0);
      f.x += f.vx*(0.6+f.z*0.6); f.y += f.vy*(0.6+f.z*0.6);
      if (f.y>H+5){ f.y=-5; f.x=Math.random()*W; f.vx=0; f.vy=0; }
      if (f.x<-5) f.x=W+5; if (f.x>W+5) f.x=-5;
      ctx.fillStyle=`hsla(${(200+f.h)%360},90%,${60+f.z*30}%,${0.7-f.z*0.5})`;
      ctx.beginPath(); ctx.arc(f.x,f.y, 1.2+f.z*2.2, 0, Math.PI*2); ctx.fill();
    });
    if (dwellJustCrossed(800)) playPing(880,0.2,0.045);
  }

  /* =========================
     SAND (cellular automaton) — pointer-only spawn (no background rain)
     ========================= */
  const SAND_CELL = (()=> {
    const state = {
      cellSize: 3,
      cols: 0,
      rows: 0,
      grid: null,          // Int16Array storing hue (0..359) or -1 for empty
      palette: [],
      lastHueBase: 0
    };

    function allocGrid(){
      state.cols = Math.floor(W / state.cellSize);
      state.rows = Math.floor(H / state.cellSize);
      state.grid = new Int16Array(state.cols * state.rows);
      state.grid.fill(-1);
      state.palette = new Array(360);
      for (let h=0; h<360; h++){
        state.palette[h] = `hsla(${h},95%,60%,1)`;
      }
    }

    function idx(x,y){ return y*state.cols + x; }
    function inBounds(x,y){ return (x>=0 && x<state.cols && y>=0 && y<state.rows); }

    function caSandReset(){ allocGrid(); }
    function caSandOnResize(){ allocGrid(); }

    // Emit N grains around (px,py) in pixels — pointer-controlled only
    function caEmitSand(px, py, n){
      const cs = state.cellSize;
      const cx = Math.floor(px / cs);
      const cy = Math.floor(py / cs);
      for (let i=0;i<n;i++){
        const rx = cx + Math.floor((Math.random()*5)-2);
        const ry = cy + Math.floor((Math.random()*5)-2);
        if (!inBounds(rx, ry)) continue;
        const id = idx(rx, ry);
        if (state.grid[id] === -1){
          const hue = ((state.lastHueBase + Math.floor(Math.random()*40)) % 360)|0;
          state.grid[id] = hue;
        }
      }
    }

    // One simulation pass (bottom-up)
    function caStep(windBias){
      const C = state.cols;
      const R = state.rows;
      const leftFirst = windBias < 0 ? true : windBias > 0 ? false : (Math.random() < 0.5);

      for (let y=R-2; y>=0; y--){
        const xStartLeft = (Math.random() < 0.5);
        if (xStartLeft){
          for (let x=0; x<C; x++){
            const i = y*C + x;
            const hue = state.grid[i];
            if (hue === -1) continue;

            const iD = i + C;
            if (state.grid[iD] === -1){
              state.grid[i] = -1; state.grid[iD] = hue; continue;
            }

            const tryDiag = leftFirst ? [-1,1] : [1,-1];
            for (let k=0;k<2;k++){
              const nx = x + tryDiag[k], ny = y + 1;
              if (nx<0 || nx>=C) continue;
              const ii = ny*C + nx;
              if (state.grid[ii] === -1){
                state.grid[i] = -1; state.grid[ii] = hue; break;
              }
            }
          }
        } else {
          for (let x=C-1; x>=0; x--){
            const i = y*C + x;
            const hue = state.grid[i];
            if (hue === -1) continue;

            const iD = i + C;
            if (state.grid[iD] === -1){
              state.grid[i] = -1; state.grid[iD] = hue; continue;
            }

            const tryDiag = leftFirst ? [-1,1] : [1,-1];
            for (let k=0;k<2;k++){
              const nx = x + tryDiag[k], ny = y + 1;
              if (nx<0 || nx>=C) continue;
              const ii = ny*C + nx;
              if (state.grid[ii] === -1){
                state.grid[i] = -1; state.grid[ii] = hue; break;
              }
            }
          }
        }
      }
    }

    function caDraw(){
      const cs = state.cellSize;
      const C = state.cols, R = state.rows;

      // background
      const isLight = document.body.classList.contains('light');
      ctx.globalCompositeOperation='source-over';
      ctx.fillStyle = isLight ? '#ffffff' : '#000000';
      ctx.fillRect(0,0,W,H);

      // draw cells (batch horizontal runs)
      for (let y=0; y<R; y++){
        let x=0;
        while (x<C){
          const h = state.grid[y*C + x];
          if (h === -1){ x++; continue; }
          let run = 1;
          while (x+run < C && state.grid[y*C + (x+run)] === h) run++;
          ctx.fillStyle = state.palette[h];
          ctx.fillRect(x*cs, y*cs, run*cs, cs);
          x += run;
        }
      }
    }

    function caRender(dt){
      state.lastHueBase = (state.lastHueBase + 60*dt) % 360;

      const baseRate = 4 + Math.floor(12 * mapIntensity());
      const dwellBoost = dwellMs>600 ? 4 : 0;
      const toSpawn = baseRate + dwellBoost;

      // Only spawn where the user points (no ambient rain)
      caEmitSand(mouse.x, mouse.y, toSpawn + Math.floor(mouse.speed/250));

      const windBias = clamp(mouse.vx/1000, -1, 1);
      const subSteps = 2;
      for (let s=0; s<subSteps; s++) caStep(windBias);

      caDraw();

      if (dwellJustCrossed(700)) playPing(700,0.12,0.05);
    }

    return {
      caSandReset,
      caSandOnResize,
      caRender
    };
  })();

  // wire resize/reset for sand
  function caSandOnResize(){ SAND_CELL.caSandOnResize(); }
  (function(){ SAND_CELL.caSandReset(); })();

  /* =========================
     Magnet, Glass, Streamers, Laser, BubblePop
     ========================= */
  const pins = Array.from({length:240},()=>({x:Math.random()*W,y:Math.random()*H, vx:0, vy:0}));
  function renderMagnet(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    pins.forEach(p=>{
      const dx = mouse.x - p.x, dy = mouse.y - p.y, d = Math.hypot(dx,dy)+0.0001;
      const force = (dwellMs>600?-1:1) * 80/(d*d);
      p.vx += dx*force; p.vy += dy*force;
      p.vx*=0.95; p.vy*=0.95; p.x += p.vx; p.y += p.vy;
      const nx = p.vy, ny = -p.vx;
      const h = (200 + d*0.3)%360;
      ctx.strokeStyle=`hsla(${h},90%,65%,0.5)`; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.moveTo(p.x-nx, p.y-ny); ctx.lineTo(p.x+nx, p.y+ny); ctx.stroke();
    });
  }

  let glassCells=[], glassCols=20, glassRows=12;
  function resizeGlass(){ glassCells=[]; const cw=W/glassCols, ch=H/glassRows;
    for(let y=0;y<glassRows;y++)for(let x=0;x<glassCols;x++){ glassCells.push({x:x*cw,y:y*ch,w:cw,h:ch,hue:Math.random()*360}); } }
  resizeGlass();
  function renderGlass(dt){
    clearToBg(false);
    const Lx=mouse.x, Ly=mouse.y, intensity=mapIntensity();
    const radius = 220 + mapSize()*1.4;
    glassCells.forEach(c=>{
      const cx=c.x+c.w/2, cy=c.y+c.h/2;
      const d = Math.hypot(Lx-cx, Ly-cy);
      const n = clamp(1 - (d/radius), 0, 1);
      const curve = Math.pow(n, 1.2 + 1.5*intensity);
      const L = 18 + curve* (82 * (0.6 + 0.8*intensity));
      ctx.fillStyle=`hsla(${c.hue},85%,${L}%,${0.95})`;
      ctx.fillRect(c.x+1, c.y+1, c.w-2, c.h-2);
    });
    ctx.globalCompositeOperation='screen';
    const bloomR = radius * (0.65 + 0.45*intensity);
    const g = ctx.createRadialGradient(Lx, Ly, bloomR*0.15, Lx, Ly, bloomR);
    g.addColorStop(0, `hsla(${(performance.now()*0.02)%360},90%,75%,${0.25+0.25*intensity})`);
    g.addColorStop(1, `hsla(0,0%,0%,0)`);
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(Lx, Ly, bloomR, 0, Math.PI*2); ctx.fill();
    const rays=12, rayLen=bloomR*1.2, t=performance.now()*0.0006; ctx.globalAlpha=0.35+0.25*intensity;
    for(let i=0;i<rays;i++){
      const a = t + (i/rays)*Math.PI*2; const x2=Lx+Math.cos(a)*rayLen, y2=Ly+Math.sin(a)*rayLen;
      const grd = ctx.createLinearGradient(Lx,Ly,x2,y2);
      grd.addColorStop(0, `hsla(${(200+i*12)%360},95%,80%,0.30)`); grd.addColorStop(1, `hsla(0,0%,0%,0)`);
      ctx.strokeStyle=grd; ctx.lineWidth=2+mapSize()*0.04;
      ctx.beginPath(); ctx.moveTo(Lx,Ly); ctx.lineTo(x2,y2); ctx.stroke();
    }
    ctx.globalAlpha=1;
  }

  function makeRope(n, y){
    n = Math.max(2, n|0);
    const pts=[]; const step=(W-1)/(n-1); const sag=H*0.06;
    for(let i=0;i<n;i++){
      const x=i*step; const t=(n===1)?0:i/(n-1); const yy=y + (1 - Math.cos(Math.PI*t))*0.5*sag;
      pts.push({x, y:yy, px:x, py:yy});
    }
    return { pts, color: Math.random()*360 };
  }
  const ropes = Array.from({length:4},(_,i)=>makeRope(40,(i+1)/(5)*H));
  function verlet(p){ const x=p.x,y=p.y; p.x += (p.x-p.px); p.y += (p.y-p.py) + 0.15; p.px=x; p.py=y; }
  function constrain(rope){
    const segLen=W/(rope.pts.length-1);
    for(let k=0;k<2;k++){
      for(let i=0;i<rope.pts.length-1;i++){
        const a=rope.pts[i], b=rope.pts[i+1], dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy)||1, diff=(d-segLen)/d;
        const off=0.5*diff; a.x += dx*off; a.y += dy*off; b.x -= dx*off; b.y -= dy*off;
      }
      rope.pts[0].x = lerp(rope.pts[0].x, 0, 0.3); rope.pts[0].y = lerp(rope.pts[0].y, 0, 0.3);
      rope.pts.at(-1).x = lerp(rope.pts.at(-1).x, W, 0.3); rope.pts.at(-1).y = lerp(rope.pts.at(-1).y, H, 0.3);
    }
  }
  function renderStreamers(dt){
    clearToBg(false);
    const windX = mouse.vx*0.02*(0.5+mapIntensity()), windY = mouse.vy*0.01;
    ropes.forEach(r=>{
      r.pts.forEach(p=>{
        p.x += windX + (mouse.x-p.x)*0.0005*mapIntensity();
        p.y += windY + (mouse.y-p.y)*0.0004*mapIntensity();
        verlet(p);
      });
      constrain(r);
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`hsla(${r.color},90%,65%,0.6)`; ctx.lineWidth=8+mapSize()*0.06;
      ctx.beginPath(); ctx.moveTo(r.pts[0].x,r.pts[0].y);
      for(let i=1;i<r.pts.length;i++) ctx.lineTo(r.pts[i].x,r.pts[i].y);
      ctx.stroke();
    });
    if (dwellJustCrossed(900)) playPing(523,0.12,0.05);
  }

  let laserCols=11;
  const laserGap = ()=> W / (laserCols + 1);
  let harpPalette = Array.from({ length: laserCols }, (_, i) => (i * (360 / laserCols)) | 0);
  let harpBeams=[], beamDwell=[], beamCooldown=[], beamHold=[], beamVoice=[];
  function initLaserArrays(){
    harpPalette = Array.from({length:laserCols},(_,i)=>(i*(360/laserCols))|0);
    harpBeams = Array.from({length:laserCols},(_,i)=>({energy:0,rippleT:0,rippleY:H/2,hue:harpPalette[i]}));
    beamDwell=new Array(laserCols).fill(0);
    beamCooldown=new Array(laserCols).fill(0);
    beamHold=new Array(laserCols).fill(false);
    beamVoice=new Array(laserCols).fill(null);
  }
  initLaserArrays();

  function harpEnsureAudio(){
    if (menuOpen) return;
    ensureAC();
    if (!harpEnsureAudio.master){
      const master=ac.createGain(); master.gain.value = (parseInt(sfxVol.value,10)||50)/100 * (muteSFX.checked?0:1) * 0.24;
      const delay = ac.createDelay(); delay.delayTime.value=0.18;
      const fb = ac.createGain(); fb.gain.value=0.38;
      delay.connect(fb).connect(delay);
      delay.connect(master);
      master.connect(ac.destination);
      harpEnsureAudio.master=master; harpEnsureAudio.delay=delay;
    }
  }
  function harpNote(i){
    const pent=[0,2,4,7,9]; const base=220;
    const si=i%pent.length, oct=Math.floor(i/pent.length);
    return base * Math.pow(2, (pent[si] + 12*oct)/12);
  }
  function harpPluck(i, y, velocity=1){
    if (menuOpen) return;
    harpEnsureAudio();
    const f=harpNote(i), det=(Math.random()*14-7), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=det;
    const g=ac.createGain(); const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2200+1800*velocity;
    const A=0.005, D=0.08, S=0.25*velocity, R=0.35+0.25*(1-velocity);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.9*velocity, t+A);
    g.gain.exponentialRampToValueAtTime(Math.max(S,0.08), t+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t+A+D+R);
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t); o1.stop(t+A+D+R+0.02); o2.stop(t+A+D+R+0.02);
    const b=harpBeams[i]; b.energy=Math.min(1, b.energy + 0.6*velocity); b.rippleT=0; b.rippleY=y;
    for(let k=0;k<12;k++){
      sparks.push({x:(i+1)*laserGap(), y, vx:(Math.random()-0.5)*2.4, vy:(Math.random()-0.5)*2.4, life:26+Math.random()*18, h:(b.hue+10+Math.random()*40)%360});
    }
  }
  function startVoice(i){
    if (menuOpen) return;
    harpEnsureAudio();
    if (beamVoice[i]) return;
    const f=harpNote(i), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=-6;
    const g=ac.createGain(); g.gain.value=0.0001;
    const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1400;
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t);
    g.gain.linearRampToValueAtTime(0.18 + 0.10*mapIntensity(), t + 0.08);
    beamVoice[i]={o1,o2,g,lp,baseF:f,t0:t};
  }
  function stopVoice(i){
    const v=beamVoice[i]; if(!v||!ac){ beamVoice[i]=null; return; }
    const t=ac.currentTime;
    try{
      v.g.gain.cancelScheduledValues(t);
      v.g.gain.setValueAtTime(v.g.gain.value, t);
      v.g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      v.o1.stop(t+0.22); v.o2.stop(t+0.22);
    }catch(e){}
    beamVoice[i]=null;
  }
  function updateVoice(i){
    const v=beamVoice[i]; if(!v||!ac) return;
    const t=ac.currentTime, e=harpBeams[i].energy;
    const vib=0.25+0.35*mapIntensity(), amt=7+10*mapIntensity(), phase=(t-v.t0);
    const mod=Math.sin(phase*2*Math.PI*vib)*amt;
    v.o1.frequency.setValueAtTime(v.baseF,t); v.o2.frequency.setValueAtTime(v.baseF,t);
    v.o2.detune.setValueAtTime(mod,t);
    v.lp.frequency.setValueAtTime(1200 + 1200*e, t);
    const targetGain = 0.14 + 0.10*mapIntensity();
    v.g.gain.setTargetAtTime(targetGain, t, 0.08);
  }
  function resizeLaser(){
    if (harpBeams.length !== laserCols) initLaserArrays();
    for (let i=0;i<harpBeams.length;i++) harpBeams[i].rippleY = Math.min(harpBeams[i].rippleY, H);
  }
  function renderLaser(dt){
    clearToBg(false);
    const gap=laserGap(); const lineBase=10 + mapSize()*0.14;
    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap; const nearRadius=34 + lineBase*1.7;
      const near = Math.abs(mouse.x - x) < nearRadius;
      const stationary = mouse.speed < 60;
      const velocity = clamp(mouse.speed/1400, 0.05, 1);
      if (near && velocity>0.25){
        harpPluck(i, mouse.y, velocity);
        lastMoveT = performance.now();
        beamCooldown[i]=160; beamHold[i]=false; stopVoice(i);
      }
      beamCooldown[i]=Math.max(0, beamCooldown[i]-dt*1000);
      if (near){
        beamDwell[i]+=dt*1000;
        const dwellThreshold=450;
        if (!beamHold[i] && stationary && beamDwell[i]>=dwellThreshold && beamCooldown[i]===0){
          const vel=0.72+0.28*mapIntensity();
          harpPluck(i, mouse.y, vel); beamHold[i]=true; startVoice(i);
        }
      } else {
        if (beamHold[i]) stopVoice(i);
        beamDwell[i]=0; beamHold[i]=false;
      }
    }

    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap, b=harpBeams[i];
      const decay = beamHold[i] ? 0.96 : 0.82;
      b.energy *= Math.pow(decay, dt*60);
      b.rippleT += dt;
      if (beamHold[i]){ b.energy = lerp(b.energy, 0.85, 0.12); updateVoice(i); }

      ctx.globalCompositeOperation='screen';
      const e=b.energy; const hue=(b.hue + Math.sin((performance.now()*0.001+i)*0.7)*6)%360;

      const grad=ctx.createLinearGradient(x,0,x,H);
      grad.addColorStop(0.0, `hsla(${(hue+6)%360},100%,55%,${0.35+0.20*e})`);
      grad.addColorStop(0.5, `hsla(${(hue)%360},100%,52%,${0.65+0.30*e})`);
      grad.addColorStop(1.0, `hsla(${(hue+12)%360},100%,55%,${0.35+0.20*e})`);
      const w=Math.max(2, lineBase * (beamHold[i] ? 1.8 : (1 + 1.3*e)));
      ctx.strokeStyle=grad; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      ctx.strokeStyle=`hsla(${hue},100%,50%,${0.22+0.25*e})`; ctx.lineWidth=w*1.9;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      const waveAmp=(10+mapSize()*0.028)*e*(beamHold[i]?0.35:1.0);
      const waveFreq=0.02+0.035*mapIntensity();
      ctx.strokeStyle=`hsla(${(hue+200)%360},100%,80%,${0.55+0.35*e})`;
      ctx.lineWidth=Math.max(1.5, w*0.22);
      ctx.beginPath();
      for (let y=0;y<=H;y+=7){
        const off = Math.sin((y + performance.now()*0.6)*waveFreq)*waveAmp;
        ctx.lineTo(x+off, y);
      }
      ctx.stroke();

      if (e>0.02){
        const speed=480 + 420*mapIntensity();
        const r=Math.max(10,(b.rippleT*speed) % (H*1.2));
        ctx.strokeStyle=`hsla(${(hue+60)%360},100%,70%,${(beamHold[i]?0.28:0.42)*e})`;
        ctx.lineWidth=2.2;
        ctx.beginPath();
        ctx.arc(x, b.rippleY, r*(0.12+0.12*e), 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  const bubbles = Array.from({length:70},()=>({x:Math.random()*W,y:H+Math.random()*200,r:8+Math.random()*22,vx:(Math.random()-0.5)*0.2,vy:-(0.4+Math.random()*0.6),charge:0,h:Math.random()*360}));
  function renderBubblePop(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    for(let i=bubbles.length-1;i>=0;i--){
      const b=bubbles[i];
      if (b.cool===undefined) b.cool=0;
      if (b.phase===undefined) b.phase=0;
      if (b.maxCharge===undefined) b.maxCharge=2.0;
      const d=Math.hypot(mouse.x-b.x, mouse.y-b.y);
      const near=clamp(1 - d/160, 0, 1);
      const baseGrow=(near*2.2 - 0.18)*dt;
      const dwellBoost=(dwellMs>600 ? 0.8*near*dt : 0);
      b.charge = clamp((b.charge||0) + baseGrow + dwellBoost, 0, b.maxCharge);
      b.phase += dt*(0.8 + b.charge*0.6);
      const pulse=1 + 0.04*Math.sin(b.phase*2.7);
      const growth=1 + Math.pow(b.charge,1.25)*2.6;
      const R=b.r*growth*pulse;
      const g=ctx.createRadialGradient(b.x,b.y,R*0.4,b.x,b.y,R*1.2);
      g.addColorStop(0,`hsla(${b.h},90%,70%,${0.10+0.25*near})`);
      g.addColorStop(1,`hsla(${(b.h+60)%360},90%,45%,0)`);
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=`hsla(${b.h},90%,70%,${0.22+0.5*near})`;
      ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=`hsla(${(b.h+40)%360},90%,85%,0.9)`; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.arc(b.x - R*0.35, b.y - R*0.35, R*0.32, 0, Math.PI*2); ctx.stroke();
      b.x += b.vx + (mouse.x-b.x)*0.00035*mapIntensity();
      b.y += b.vy - (mouse.y-b.y)*0.00025*mapIntensity();
      if (b.y<-R-20){ b.y=H+40; b.x=Math.random()*W; b.vx=(Math.random()-0.5)*0.2; b.vy=-(0.4+Math.random()*0.6); b.charge=0; b.cool=0; }
      const canPop=(b.cool<=0) && (b.charge>=1.7) && (near>0.6);
      if (canPop){
        playPing(740,0.12,0.06);
        for(let k=0;k<22;k++){
          sparks.push({x:b.x,y:b.y,vx:Math.cos(k*Math.PI/11)*(2.2+Math.random()*1.6),vy:Math.sin(k*Math.PI/11)*(2.2+Math.random()*1.6),life:40+Math.random()*20,h:(b.h+Math.random()*50)%360});
        }
        for(let d2=0; d2<8; d2++){ sparks.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*4.5,vy:(Math.random()-0.5)*4.5,life:28,h:(b.h+20)%360}); }
        ctx.globalCompositeOperation='screen';
        ctx.strokeStyle=`hsla(${(b.h+20)%360},95%,80%,0.8)`; ctx.lineWidth=2.2;
        ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.stroke();
        b.charge=0.15; b.cool=0.25;
      }
      if (b.cool>0) b.cool -= dt;
    }
  }

  /* =========================
     Boucle principale
     ========================= */
  function tick(t){
    const dt = clamp((t - now)/1000, 0, 0.05);
    now = t;
    dwellMs = t - lastMoveT;

    // keep hueBase cycling globally for scenes that use it (e.g., fireworks)
    hueBase = (hueBase + 24*dt) % 360;

    if (menuOpen || paused){
      return requestAnimationFrame(tick);
    }

    switch (ui.mode.value){
      case 'aurora':    renderAurora(dt);     break;
      case 'ripples':   renderRipples(dt);    break;
      case 'fireworks': renderFireworks(dt);  break;
      case 'kaleido':   renderKaleido(dt);    break;
      case 'fireflies': renderFireflies(dt);  break;
      case 'confetti':  renderConfetti(dt);   break;
      case 'nebula':    renderNebula(dt);     break;
      case 'jelly':     renderJelly(dt);      break;
      case 'snow':      renderSnow(dt);       break;
      case 'sand':      SAND_CELL.caRender(dt); break;  /* pointer-only sand */
      case 'magnet':    renderMagnet(dt);     break;
      case 'glass':     renderGlass(dt);      break;
      case 'streamers': renderStreamers(dt);  break;
      case 'laserharp': renderLaser(dt);      break;
      case 'bubblepop': renderBubblePop(dt);  break;
    }
    requestAnimationFrame(tick);
  }
  clearToBg(true);
  requestAnimationFrame(tick);

  startButton.addEventListener('click', () => {
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen();
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if (el.msRequestFullscreen) el.msRequestFullscreen();

    document.getElementById('game-options').style.display = 'none';
    cvs.style.display = 'block';
    menuOpen = false;

    cvs.addEventListener('pointerdown', ()=>{ playPing(523,0.08,0.03); }, {once:true});
  });
  </script>
</body>
</html>
