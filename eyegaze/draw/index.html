<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title class="translate" data-fr="Dessine dans la forme (Eyegaze)" data-en="Draw within the outline (Eyegaze)">
    Dessine dans la forme (Eyegaze)
  </title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #0f172a;
      --ink: #f5f5f5;
      --accent: #4fd1c5;
      --edge: #38d0c7;
      --ok: #22c55e;
      --bad: #ef4444;
    }

    body {
      background: var(--bg);
      color: #e6edf3;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      display: block;
      height: 100vh;
      overflow: hidden;
    }

    body.dark { background: var(--bg); color: #e6edf3; }
    body.light { background: #f6f9fb; color: #0f172a; }

    #langToggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 99999;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 2px solid #009688;
      background: #fff;
      color: #009688;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
    }
    body.dark #langToggle { background: #111; color: #14b8a6; border-color: #14b8a6; }

    #drawGame {
      display: none;
      width: 100vw;
      height: 100vh;
    }

    #workspace {
      display: grid;
      grid-template-columns: minmax(280px, 360px) 1fr;
      width: 100%;
      height: 100%;
    }

    #controlPanel {
      background: var(--panel);
      color: inherit;
      padding: 20px 18px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      overflow-y: auto;
      box-shadow: inset -1px 0 0 rgba(255,255,255,0.05);
    }

    .panel-card {
      background: rgba(13,20,32,0.65);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel-card h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: #9eeaf9;
    }

    .control-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control-row label {
      font-size: 0.85rem;
      font-weight: 600;
      color: rgba(255,255,255,0.85);
    }

    input[type="color"],
    select,
    input[type="file"] {
      width: 100%;
      font-size: 0.95rem;
      border-radius: 10px;
      padding: 8px 10px;
      border: 2px solid rgba(79,209,197,0.5);
      background: rgba(9,14,24,0.9);
      color: inherit;
    }

    input[type="color"] {
      padding: 0;
      height: 42px;
      border-radius: 10px;
      cursor: pointer;
    }

    input[type="range"] {
      width: 100%;
    }

    .small-label {
      font-size: 0.8rem;
      color: rgba(255,255,255,0.75);
    }

    .button,
    button.primary {
      background-color: #14b8a6;
      color: #03141d;
      border: none;
      border-radius: 12px;
      padding: 10px 16px;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .button:hover,
    button.primary:hover {
      background-color: #0d9488;
    }

    .button[disabled],
    button.primary[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #actionButtons {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    #canvasStage {
      position: relative;
      background: radial-gradient(1200px 600px at 60% -10%, #1a2330 0%, #0b0f14 60%, #080c11 100%);
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    #canvasStage canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }

    #ink, #outline {
      position: absolute;
      inset: 0;
    }

    #outline { pointer-events: none; }

    .badge {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(11, 21, 32, 0.8);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.75rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    #presetPreviewWrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #presetPreview {
      width: 100%;
      max-width: 160px;
      aspect-ratio: 1 / 1;
      object-fit: contain;
      background: rgba(6, 12, 20, 0.8);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
    }

    #carousel-container {
      position: relative;
      display: flex;
      align-items: center;
      margin: 0;
      gap: 12px;
      height: 140px;
    }

    .carousel-arrow {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      border: none;
      background: rgba(79, 209, 197, 0.25);
      color: #9eeaf9;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .carousel-arrow:hover { background: rgba(79, 209, 197, 0.45); }

    #carousel-track {
      flex: 1;
      display: flex;
      gap: 10px;
      height: 100%;
      overflow-x: auto;
      scrollbar-width: thin;
      padding: 4px 2px;
    }

    .carousel-item {
      flex: 0 0 110px;
      border-radius: 10px;
      border: 2px solid transparent;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(12, 19, 30, 0.9);
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    .carousel-item.selected {
      border-color: #4fd1c5;
      transform: translateY(-4px);
    }

    .carousel-item img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
    }

    #carousel-track .empty-msg {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255,255,255,0.6);
      font-size: 0.9rem;
      text-align: center;
    }

    #presetStatus {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.6);
    }

    details {
      background: rgba(13,20,32,0.55);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px;
      color: inherit;
    }

    details summary { cursor: pointer; font-weight: 600; }
    #testResults { font-size: 0.8rem; line-height: 1.5; margin-top: 8px; }
    .ok { color: var(--ok); }
    .bad { color: var(--bad); }

    #menu-instructions {
      font-size: 0.9rem;
      line-height: 1.5;
      text-align: left;
      color: #0f172a;
      background: #e0f7f5;
      border-radius: 12px;
      padding: 12px;
    }

    #menu-instructions strong { color: #006d68; }

    @media (max-width: 1100px) {
      #workspace { grid-template-columns: minmax(260px, 320px) 1fr; }
    }

    @media (max-width: 900px) {
      #workspace {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
      #controlPanel { flex-direction: row; overflow-x: auto; }
      #controlPanel .panel-card { min-width: 260px; }
      #canvasStage { min-height: 60vh; }
    }
  </style>

  <script src="../../js/cvipngarray.js" defer></script>
</head>
<body class="dark">
  <button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title" class="translate"
          data-fr="Dessine dans la forme (Eyegaze)"
          data-en="Draw within the outline (Eyegaze)">
        Dessine dans la forme (Eyegaze)
      </h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <h3 class="translate" data-fr="Pinceau" data-en="Brush">Pinceau</h3>
          <div class="option-item">
            <label class="teal-label" for="menuBrush">
              <span class="translate" data-fr="Taille du pinceau" data-en="Brush size">Taille du pinceau</span>
              <span id="menuBrushVal">18</span> px
            </label>
            <input id="menuBrush" class="styled-slider" type="range" min="3" max="64" value="18" />
          </div>
          <div class="option-item">
            <label class="teal-label" for="menuColor">
              <span class="translate" data-fr="Couleur du pinceau" data-en="Brush color">Couleur du pinceau</span>
            </label>
            <input id="menuColor" type="color" value="#ff7a59" />
          </div>
        </div>

        <div class="options-column">
          <h3 class="translate" data-fr="Contour de départ" data-en="Starting outline">Contour de départ</h3>
          <div class="option-item">
            <label class="teal-label label-block" for="menuShape">
              <span class="translate" data-fr="Forme intégrée" data-en="Built-in shape">Forme intégrée</span>
            </label>
            <select id="menuShape" class="styled-select">
              <option value="blob" class="translate" data-fr="Goutte" data-en="Blob">Goutte</option>
              <option value="star" class="translate" data-fr="Étoile" data-en="Star">Étoile</option>
              <option value="heart" class="translate" data-fr="Cœur" data-en="Heart">Cœur</option>
              <option value="rect" class="translate" data-fr="Rectangle arrondi" data-en="Rounded rectangle">Rectangle arrondi</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <h3 class="translate" data-fr="Astuces" data-en="Tips">Astuces</h3>
          <div id="menu-instructions" class="translate"
               data-fr="<strong>Commencez</strong> avec une forme intégrée ou téléversez votre propre contour après le lancement.<br><br>Utilisez le <strong>carrousel</strong> pour choisir une image DVC comme guide et dessinez à l'intérieur des zones opaques."
               data-en="<strong>Start</strong> with a built-in shape or upload your own outline after launch.<br><br>Use the <strong>carousel</strong> to pick a CVI-friendly image and draw inside the opaque area.">
            <strong>Commencez</strong> avec une forme intégrée ou téléversez votre propre contour après le lancement.<br><br>
            Utilisez le <strong>carrousel</strong> pour choisir une image DVC comme guide et dessinez à l'intérieur des zones opaques.
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
    </div>
  </div>

  <div class="game-container" id="drawGame">
    <div id="workspace">
      <aside id="controlPanel">
        <section class="panel-card">
          <h3 class="translate" data-fr="Pinceau" data-en="Brush">Pinceau</h3>
          <div class="control-row">
            <label for="brush" class="translate" data-fr="Taille du pinceau" data-en="Brush size">Taille du pinceau</label>
            <span class="small-label"><span id="brushV">18</span> px</span>
            <input id="brush" type="range" min="3" max="64" value="18" />
          </div>
          <div class="control-row">
            <label for="color" class="translate" data-fr="Couleur du pinceau" data-en="Brush color">Couleur du pinceau</label>
            <input id="color" type="color" value="#ff7a59" />
          </div>
          <div class="control-row">
            <label for="mode" class="translate" data-fr="Mode" data-en="Mode">Mode</label>
            <select id="mode">
              <option value="draw" class="translate" data-fr="Dessiner" data-en="Draw">Dessiner</option>
              <option value="erase" class="translate" data-fr="Effacer" data-en="Erase">Effacer</option>
            </select>
          </div>
          <div id="actionButtons">
            <button id="clear" class="button translate" data-fr="Effacer" data-en="Clear">Effacer</button>
            <button id="download" class="button translate" data-fr="Enregistrer" data-en="Save PNG">Enregistrer</button>
          </div>
        </section>

        <section class="panel-card">
          <h3 class="translate" data-fr="Bibliothèque d'images" data-en="Image library">Bibliothèque d'images</h3>
          <div class="control-row">
            <label for="presetCategory" class="translate" data-fr="Catégorie" data-en="Category">Catégorie</label>
            <select id="presetCategory" disabled>
              <option class="translate" data-fr="Chargement…" data-en="Loading…">Chargement…</option>
            </select>
          </div>
          <div id="carousel-container">
            <button id="carouselPrev" class="carousel-arrow" aria-label="Précédent / Previous">‹</button>
            <div id="carousel-track"></div>
            <button id="carouselNext" class="carousel-arrow" aria-label="Suivant / Next">›</button>
          </div>
          <select id="presetItem" hidden></select>
          <div id="presetPreviewWrap">
            <img id="presetPreview" alt="aperçu" />
            <button id="loadPreset" class="button translate" data-fr="Utiliser comme contour" data-en="Use as outline" disabled>
              Utiliser comme contour
            </button>
          </div>
          <p id="presetStatus" class="translate"
             data-fr="Les préréglages s'activent si le fichier ../../js/cvipngarray.js est présent."
             data-en="Presets activate when ../../js/cvipngarray.js is available.">
            Les préréglages s'activent si le fichier ../../js/cvipngarray.js est présent.
          </p>
        </section>

        <section class="panel-card">
          <h3 class="translate" data-fr="Contour personnalisé" data-en="Custom outline">Contour personnalisé</h3>
          <div class="control-row">
            <label for="shape" class="translate" data-fr="Forme intégrée" data-en="Built-in shape">Forme intégrée</label>
            <select id="shape">
              <option value="blob" class="translate" data-fr="Goutte" data-en="Blob">Goutte</option>
              <option value="star" class="translate" data-fr="Étoile" data-en="Star">Étoile</option>
              <option value="heart" class="translate" data-fr="Cœur" data-en="Heart">Cœur</option>
              <option value="rect" class="translate" data-fr="Rectangle arrondi" data-en="Rounded rectangle">Rectangle arrondi</option>
            </select>
          </div>
          <div class="control-row">
            <label for="outlineFile" class="translate" data-fr="Téléverser un contour" data-en="Upload outline">Téléverser un contour</label>
            <input id="outlineFile" type="file" accept="image/png, image/svg+xml" />
          </div>
          <div class="control-row">
            <label for="fitMode" class="translate" data-fr="Ajustement" data-en="Fit mode">Ajustement</label>
            <select id="fitMode">
              <option value="contain" class="translate" data-fr="Contenir (garder les proportions)" data-en="Contain (keep aspect)" selected>
                Contenir (garder les proportions)
              </option>
              <option value="cover" class="translate" data-fr="Couvrir" data-en="Cover">Couvrir</option>
              <option value="stretch" class="translate" data-fr="Étirer" data-en="Stretch">Étirer</option>
            </select>
          </div>
          <div class="control-row">
            <label for="maskSource" class="translate" data-fr="Zone dessinable" data-en="Drawable area">Zone dessinable</label>
            <select id="maskSource">
              <option value="alpha" class="translate" data-fr="Pixels opaques" data-en="Alpha (opaque = inside)" selected>
                Pixels opaques
              </option>
              <option value="luma" class="translate" data-fr="Pixels clairs" data-en="Luminance (white = inside)">
                Pixels clairs
              </option>
              <option value="alpha-invert" class="translate" data-fr="Pixels transparents" data-en="Alpha inverted">
                Pixels transparents
              </option>
            </select>
          </div>
        </section>

        <section class="panel-card">
          <details>
            <summary class="translate" data-fr="Diagnostics" data-en="Diagnostics">Diagnostics</summary>
            <div class="control-row" style="margin-top:8px;">
              <button id="runTests" class="button translate" data-fr="Lancer les tests" data-en="Run tests">Lancer les tests</button>
            </div>
            <div id="testResults" class="translate"
                 data-fr="Aucun test exécuté." data-en="No tests run yet.">
              Aucun test exécuté.
            </div>
          </details>
        </section>
      </aside>

      <main id="canvasStage">
        <div class="badge translate" data-fr="Mode dessin" data-en="Drawing mode">Mode dessin</div>
        <canvas id="ink" width="1400" height="900" aria-label="Couche d'encre"></canvas>
        <canvas id="outline" width="1400" height="900" aria-label="Couche du contour"></canvas>
      </main>
    </div>
  </div>

  <script>
    const LS_LANG_KEY = 'siteLanguage';
    const langToggle = document.getElementById('langToggle');
    const menuInstructions = document.getElementById('menu-instructions');

    function applyText(el, text){
      if (el.tagName === 'INPUT' && (el.type === 'button' || el.type === 'submit')) {
        el.value = text;
      } else {
        el.textContent = text;
      }
    }

    function getLang(){
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr') return saved;
      } catch (e) {}
      return (document.documentElement.lang === 'en') ? 'en' : 'fr';
    }

    function setLang(lang){
      const safe = (lang === 'en') ? 'en' : 'fr';
      document.documentElement.lang = safe;
      try { localStorage.setItem(LS_LANG_KEY, safe); } catch (e) {}
      document.querySelectorAll('.translate').forEach(el => {
        const fr = el.getAttribute('data-fr');
        const en = el.getAttribute('data-en');
        if (el === menuInstructions){
          if (safe === 'fr' && fr != null) el.innerHTML = fr;
          else if (safe === 'en' && en != null) el.innerHTML = en;
          return;
        }
        if (safe === 'fr' && fr != null) {
          applyText(el, fr);
        } else if (safe === 'en' && en != null) {
          applyText(el, en);
        }
      });
      updatePresetStatusMessage();
      if (carouselEmptyState) renderCarouselEmpty(carouselEmptyState);
    }

    (function initLang(){
      let initial = 'fr';
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr') initial = saved;
        else initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
        localStorage.setItem(LS_LANG_KEY, initial);
      } catch (e) {
        initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
      }
      setLang(initial);
    })();

    langToggle.addEventListener('click', () => {
      setLang(getLang() === 'fr' ? 'en' : 'fr');
    });

    const menuBrush = document.getElementById('menuBrush');
    const menuBrushVal = document.getElementById('menuBrushVal');
    menuBrush.addEventListener('input', () => { menuBrushVal.textContent = menuBrush.value; });

    const menuColor = document.getElementById('menuColor');
    const menuShape = document.getElementById('menuShape');

    const startButton = document.getElementById('startButton');
    const gameOptions = document.getElementById('game-options');
    const drawGame = document.getElementById('drawGame');

    async function enterFullscreen(){
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
        else if (el.msRequestFullscreen) await el.msRequestFullscreen();
      } catch (e) {}
    }

    const brushEl = document.getElementById('brush');
    const brushV = document.getElementById('brushV');
    const colorEl = document.getElementById('color');
    const modeEl = document.getElementById('mode');
    const clearEl = document.getElementById('clear');
    const dlEl = document.getElementById('download');
    const shapeEl = document.getElementById('shape');
    const outlineFileEl = document.getElementById('outlineFile');
    const fitModeEl = document.getElementById('fitMode');
    const maskSourceEl = document.getElementById('maskSource');
    const catEl = document.getElementById('presetCategory');
    const itemEl = document.getElementById('presetItem');
    const loadPresetBtn = document.getElementById('loadPreset');
    const presetPreview = document.getElementById('presetPreview');
    const presetStatus = document.getElementById('presetStatus');
    const runTestsBtn = document.getElementById('runTests');
    const testResults = document.getElementById('testResults');
    const carouselTrack = document.getElementById('carousel-track');
    const carouselPrev = document.getElementById('carouselPrev');
    const carouselNext = document.getElementById('carouselNext');

    let presetCounts = { available: false, total: 0, categories: 0, known: false };
    let carouselEmptyState = null;

    function updatePresetStatusMessage(){
      const lang = getLang();
      if (!presetCounts.known){
        const lang = getLang();
        presetStatus.textContent = (lang === 'fr') ? (presetStatus.dataset.fr || presetStatus.textContent)
                                                   : (presetStatus.dataset.en || presetStatus.textContent);
        return;
      }
      if (!presetCounts.available){
        const fr = "Liste des préréglages introuvable. Assurez-vous que ../../js/cvipngarray.js est chargé.";
        const en = "Preset list not found. Ensure ../../js/cvipngarray.js is loaded.";
        presetStatus.dataset.fr = fr;
        presetStatus.dataset.en = en;
        presetStatus.textContent = (lang === 'fr') ? fr : en;
        return;
      }
      const fr = `Chargement de ${presetCounts.total} images réparties dans ${presetCounts.categories} catégories.`;
      const en = `Loaded ${presetCounts.total} preset PNGs across ${presetCounts.categories} categories.`;
      presetStatus.dataset.fr = fr;
      presetStatus.dataset.en = en;
      presetStatus.textContent = (lang === 'fr') ? fr : en;
    }

    function renderCarouselEmpty(kind){
      carouselEmptyState = kind;
      if (!kind){
        carouselTrack.innerHTML = '';
        return;
      }
      let frMsg = '';
      let enMsg = '';
      if (kind === 'missing'){
        frMsg = 'PNG_ARRAY introuvable.';
        enMsg = 'PNG_ARRAY not found.';
      } else if (kind === 'empty'){
        frMsg = 'Aucune image dans cette catégorie.';
        enMsg = 'No images in this category.';
      }
      const msg = (getLang() === 'fr') ? frMsg : enMsg;
      carouselTrack.innerHTML = `<div class="empty-msg">${msg}</div>`;
    }

    startButton.addEventListener('click', async () => {
      brushEl.value = menuBrush.value;
      brushV.textContent = menuBrush.value;
      colorEl.value = menuColor.value;
      shapeEl.value = menuShape.value;

      await enterFullscreen();
      gameOptions.style.display = 'none';
      langToggle.style.display = 'none';
      drawGame.style.display = 'block';
      requestResize();
    });

    brushEl.addEventListener('input', () => brushV.textContent = brushEl.value);
    clearEl.addEventListener('click', () => { ic.clearRect(0, 0, ink.width, ink.height); });
    dlEl.addEventListener('click', () => {
      const url = mergeForExport();
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drawing.png';
      a.click();
    });
    shapeEl.addEventListener('change', () => { userMask = null; drawOutline(); });
    fitModeEl.addEventListener('change', () => { rebuildMaskCache(); redrawMaskGuide(); });
    maskSourceEl.addEventListener('change', () => { rebuildMaskCache(); redrawMaskGuide(); });

    outlineFileEl.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      await loadUserMaskFromFile(file);
      redrawMaskGuide();
      e.target.value = '';
    });

    const ink = document.getElementById('ink');
    const out = document.getElementById('outline');
    const ic = ink.getContext('2d');
    const oc = out.getContext('2d');

    let resizePending = false;
    function fitCanvas(cnv){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = cnv.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width * dpr));
      const h = Math.max(1, Math.round(rect.height * dpr));
      if (cnv.width !== w || cnv.height !== h){
        cnv.width = w; cnv.height = h;
        const ctx = cnv.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
    }

    function resizeAllImmediate(){
      fitCanvas(ink);
      fitCanvas(out);
      drawOutline();
      syncScratch();
      rebuildMaskCache();
    }

    function requestResize(){
      if (resizePending) return;
      resizePending = true;
      requestAnimationFrame(() => {
        resizePending = false;
        resizeAllImmediate();
      });
    }

    const ro = new ResizeObserver(() => { requestResize(); });
    ro.observe(out);

    let shapePath = null;

    function makePath(kind, w, h){
      const p = new Path2D();
      const pad = Math.min(w,h) * 0.12;
      const cx = w / 2, cy = h / 2;
      if (kind === 'rect'){
        const r = Math.min(w,h) * 0.18;
        const x = pad, y = pad, rw = w - 2 * pad, rh = h - 2 * pad;
        roundRectPath(p,x,y,rw,rh,r);
      } else if (kind === 'blob'){
        const rx = w * 0.32, ry = h * 0.28;
        blobPath(p, cx, cy, rx, ry);
      } else if (kind === 'star'){
        starPath(p, cx, cy, Math.min(w,h) * 0.36, 5);
      } else if (kind === 'heart'){
        heartPath(p, cx, cy, Math.min(w,h) * 0.36);
      }
      return p;
    }

    function roundRectPath(p,x,y,w,h,r){
      p.moveTo(x+r,y);
      p.arcTo(x+w,y,x+w,y+h,r);
      p.arcTo(x+w,y+h,x,y+h,r);
      p.arcTo(x,y+h,x,y,r);
      p.arcTo(x,y,x+w,y,r);
      p.closePath();
    }

    function blobPath(p, cx, cy, rx, ry){
      p.moveTo(cx, cy-ry);
      p.bezierCurveTo(cx+rx*0.6, cy-ry, cx+rx, cy-ry*0.2, cx+rx, cy);
      p.bezierCurveTo(cx+rx, cy+ry*0.6, cx+rx*0.4, cy+ry, cx, cy+ry);
      p.bezierCurveTo(cx-rx*0.6, cy+ry, cx-rx, cy+ry*0.2, cx-rx, cy);
      p.bezierCurveTo(cx-rx, cy-ry*0.6, cx-rx*0.4, cy-ry, cx, cy-ry);
      p.closePath();
    }

    function starPath(p, cx, cy, r, spikes){
      const step = Math.PI / spikes;
      let rot = Math.PI / 2 * 3;
      let x = cx;
      p.moveTo(cx, cy - r);
      for(let i=0;i<spikes;i++){
        x = cx + Math.cos(rot) * r;
        let y = cy + Math.sin(rot) * r;
        p.lineTo(x,y); rot += step;
        x = cx + Math.cos(rot) * r * 0.5;
        y = cy + Math.sin(rot) * r * 0.5;
        p.lineTo(x,y); rot += step;
      }
      p.closePath();
    }

    function heartPath(p, cx, cy, s){
      const top = cy - s * 0.25;
      p.moveTo(cx, top);
      p.bezierCurveTo(cx + s*0.5, top - s*0.6, cx + s, cy - s*0.05, cx, cy + s*0.75);
      p.bezierCurveTo(cx - s, cy - s*0.05, cx - s*0.5, top - s*0.6, cx, top);
      p.closePath();
    }

    function drawOutline(){
      const rect = out.getBoundingClientRect();
      shapePath = makePath(shapeEl.value, rect.width, rect.height);
      oc.clearRect(0,0,out.width,out.height);
      if (userMask){ redrawMaskGuide(); }
      else {
        oc.save();
        oc.fillStyle='white'; oc.globalAlpha=0.06; oc.fill(shapePath);
        oc.globalAlpha=1; oc.lineWidth=6;
        oc.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge')||'#38d0c7';
        oc.stroke(shapePath);
        oc.restore();
      }
    }

    let userMask = null;
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    let maskImageData = null;

    async function loadUserMaskFromFile(file){
      const url = URL.createObjectURL(file);
      await loadUserMaskFromURL(url, true);
    }

    function loadUserMaskFromURL(url, revoke=false){
      const img = new Image();
      img.onload = () => {
        if (revoke) URL.revokeObjectURL(url);
        userMask = img;
        rebuildMaskCache();
        drawOutline();
      };
      img.onerror = () => {
        if (revoke) URL.revokeObjectURL(url);
        alert('Could not load image. Try a PNG or SVG.');
      };
      img.src = url;
    }

    function computeFit(destW,destH,imgW,imgH,mode){
      if (mode === 'stretch') return { x:0, y:0, w:destW, h:destH };
      const r = imgW / imgH, R = destW / destH;
      if (mode === 'cover'){
        const w = R>r ? destW : destH*r;
        const h = R>r ? destW/r : destH;
        const x = (destW - w)/2;
        const y = (destH - h)/2;
        return {x,y,w,h};
      } else {
        const w = R>r ? destH*r : destW;
        const h = R>r ? destH : destW/r;
        const x = (destW - w)/2;
        const y = (destH - h)/2;
        return {x,y,w,h};
      }
    }

    function rebuildMaskCache(){
      if (!userMask){ maskImageData = null; return; }
      maskCanvas.width = out.width;
      maskCanvas.height = out.height;
      maskCtx.setTransform(oc.getTransform());
      maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      maskCtx.drawImage(userMask, fit.x, fit.y, fit.w, fit.h);

      const img = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
      const data = img.data;
      const mode = maskSourceEl.value;
      for(let i=0;i<data.length; i+=4){
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        let alpha = a;
        if (mode === 'luma'){
          const y = 0.2126*r + 0.7152*g + 0.0722*b;
          alpha = y;
        } else if (mode === 'alpha-invert'){
          alpha = 255 - a;
        }
        data[i]=255; data[i+1]=255; data[i+2]=255; data[i+3]=alpha;
      }
      maskCtx.putImageData(img,0,0);
      maskImageData = img;
    }

    function redrawMaskGuide(){
      oc.clearRect(0,0,out.width,out.height);
      if (!userMask){
        oc.save(); oc.fillStyle='white'; oc.globalAlpha=0.06; oc.fill(shapePath);
        oc.globalAlpha=1; oc.lineWidth=6;
        oc.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge')||'#38d0c7';
        oc.stroke(shapePath); oc.restore();
        return;
      }
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      oc.save(); oc.globalAlpha = 0.25; oc.drawImage(userMask, fit.x, fit.y, fit.w, fit.h); oc.restore();
    }

    let drawing=false, prev=null;

    const supportsPathClip = (function(){
      try {
        const c = document.createElement('canvas').getContext('2d');
        const p = new Path2D();
        p.rect(0,0,1,1); c.save(); c.clip(p); c.restore();
        return true;
      } catch(e){ return false; }
    })();

    const scratch = document.createElement('canvas');
    const sc = scratch.getContext('2d');

    function syncScratch(){
      scratch.width = ink.width;
      scratch.height = ink.height;
      sc.setTransform(ic.getTransform());
      sc.clearRect(0,0,scratch.width,scratch.height);
    }

    function getPos(e){
      const r = ink.getBoundingClientRect();
      if (e.touches && e.touches[0]){
        return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top };
      }
      return { x: (e.clientX||e.x) - r.left, y: (e.clientY||e.y) - r.top };
    }

    function begin(e){ drawing=true; prev=getPos(e); e.preventDefault(); }
    function end(){ drawing=false; prev=null; }

    function draw(e){
      if(!drawing) return;
      const cur = getPos(e);
      const size = +brushEl.value;
      const color = colorEl.value;
      const erasing = (modeEl.value==='erase');

      if (userMask){
        sc.save();
        sc.lineCap='round'; sc.lineJoin='round'; sc.lineWidth=size;
        sc.globalCompositeOperation='source-over';
        sc.strokeStyle = erasing ? '#000' : color;
        sc.beginPath(); sc.moveTo(prev.x, prev.y); sc.lineTo(cur.x, cur.y); sc.stroke();
        sc.globalCompositeOperation='destination-in';
        sc.drawImage(maskCanvas,0,0);
        sc.restore();

        ic.save();
        ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
        ic.drawImage(scratch,0,0);
        ic.restore();
        sc.clearRect(0,0,scratch.width,scratch.height);
      } else {
        if (!shapePath) return;
        if (supportsPathClip){
          ic.save(); ic.clip(shapePath);
          ic.lineCap='round'; ic.lineJoin='round'; ic.lineWidth=size;
          ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
          ic.strokeStyle = erasing ? 'rgba(0,0,0,1)' : color;
          ic.beginPath(); ic.moveTo(prev.x, prev.y); ic.lineTo(cur.x, cur.y); ic.stroke();
          ic.restore();
        } else {
          if (!maskImageData){
            maskCanvas.width = out.width;
            maskCanvas.height = out.height;
            maskCtx.setTransform(oc.getTransform());
            maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
            maskCtx.fillStyle = '#fff';
            maskCtx.fill(shapePath);
            maskImageData = maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height);
          }
          sc.save();
          sc.lineCap='round'; sc.lineJoin='round'; sc.lineWidth=size;
          sc.globalCompositeOperation='source-over';
          sc.strokeStyle = erasing ? '#000' : color;
          sc.beginPath(); sc.moveTo(prev.x, prev.y); sc.lineTo(cur.x, cur.y); sc.stroke();
          sc.globalCompositeOperation='destination-in';
          sc.putImageData(maskImageData,0,0);
          sc.restore();

          ic.save(); ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
          ic.drawImage(scratch,0,0);
          ic.restore();
          sc.clearRect(0,0,scratch.width,scratch.height);
        }
      }

      prev = cur;
      e.preventDefault();
    }

    ink.addEventListener('pointerdown', begin);
    window.addEventListener('pointerup', end);
    window.addEventListener('pointercancel', end);
    window.addEventListener('pointerout', (e)=>{ if(e.target===ink) end(); });
    window.addEventListener('pointermove', draw, {passive:false});
    ink.addEventListener('touchstart', begin, {passive:false});
    window.addEventListener('touchend', end, {passive:false});
    window.addEventListener('touchmove', draw, {passive:false});

    requestResize();

    function mergeForExport(){
      const merge = document.createElement('canvas');
      merge.width = ink.width; merge.height = ink.height;
      const mc = merge.getContext('2d');
      mc.setTransform(ic.getTransform());
      mc.drawImage(out,0,0);
      mc.drawImage(ink,0,0);
      return merge.toDataURL('image/png');
    }

    runTestsBtn?.addEventListener('click', runSelfTests);

    function runSelfTests(){
      const results = [];
      try {
        results.push(["API: Path2D exists", typeof Path2D === 'function']);
        results.push(["API: Have clip(Path2D) OR fallback mask", typeof ic.clip === 'function' || true]);

        const c = document.createElement('canvas'); c.width = 100; c.height = 100; const ctx = c.getContext('2d');
        const rect = new Path2D(); rect.rect(20,20,60,60);
        try{ ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(100,10); ctx.stroke(); ctx.restore(); }catch{}
        const pxOutside = ctx.getImageData(10,10,1,1).data[3]; results.push(["Clip: outside does not render", pxOutside === 0]);
        try{ ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(10,50); ctx.lineTo(90,50); ctx.stroke(); ctx.restore(); }catch{}
        const pxInside = ctx.getImageData(50,50,1,1).data[3]; results.push(["Clip: inside renders", pxInside > 0]);

        const ctx2 = document.createElement('canvas').getContext('2d'); ctx2.canvas.width=100; ctx2.canvas.height=100;
        try{ ctx2.save(); ctx2.clip(rect); }catch{}
        ctx2.fillStyle = '#fff'; ctx2.fillRect(20,20,60,60);
        ctx2.restore?.(); ctx2.save?.();
        try{ ctx2.clip(rect); }catch{}
        ctx2.globalCompositeOperation='destination-out'; ctx2.lineWidth = 8; ctx2.strokeStyle = 'rgba(0,0,0,1)';
        ctx2.beginPath(); ctx2.moveTo(20,50); ctx2.lineTo(80,50); ctx2.stroke(); ctx2.restore?.();
        const erased = ctx2.getImageData(50,50,1,1).data[3];
        results.push(["Erase: destination-out clears pixels", erased === 0]);

        const fc = document.createElement('canvas'); fc.width=100; fc.height=100; const fctx = fc.getContext('2d');
        const fScratch = document.createElement('canvas'); fScratch.width=100; fScratch.height=100; const fsc = fScratch.getContext('2d');
        const fRect = new Path2D(); fRect.rect(20,20,60,60);
        fsc.save(); fsc.strokeStyle='#fff'; fsc.lineWidth=6; fsc.beginPath(); fsc.moveTo(0,10); fsc.lineTo(100,10); fsc.stroke();
        fsc.globalCompositeOperation='destination-in'; fsc.fillStyle='#fff'; fsc.fill(fRect); fsc.restore();
        fctx.drawImage(fScratch,0,0);
        const fOutside = fctx.getImageData(10,10,1,1).data[3];
        results.push(["Mask fallback: outside does not render", fOutside === 0]);
        fsc.clearRect(0,0,100,100);
        fsc.save(); fsc.strokeStyle='#fff'; fsc.lineWidth=6; fsc.beginPath(); fsc.moveTo(10,50); fsc.lineTo(90,50); fsc.stroke();
        fsc.globalCompositeOperation='destination-in'; fsc.fillStyle='#fff'; fsc.fill(fRect); fsc.restore();
        fctx.clearRect(0,0,100,100);
        fctx.drawImage(fScratch,0,0);
        const fInside = fctx.getImageData(50,50,1,1).data[3];
        results.push(["Mask fallback: inside renders", fInside > 0]);

        const testInk = document.createElement('canvas'); testInk.width=50; testInk.height=50; const ti = testInk.getContext('2d');
        const testOut = document.createElement('canvas'); testOut.width=50; testOut.height=50; const to = testOut.getContext('2d');
        ti.fillStyle='#fff'; ti.fillRect(10,10,10,10);
        to.strokeStyle='#fff'; to.strokeRect(5,5,20,20);
        const merged = (function(){
          const merge = document.createElement('canvas');
          merge.width=50; merge.height=50; const mc = merge.getContext('2d');
          mc.drawImage(testOut,0,0);
          mc.drawImage(testInk,0,0);
          return mc.getImageData(12,12,1,1).data[3];
        })();
        results.push(["Export: merged image contains pixels", merged > 0]);

        const fake = [ {name:'a',file:'a.png',category:'x'}, {name:'b',file:'b.png',category:'y'}, {name:'c',file:'c.png',category:'x'} ];
        const cats = [...new Set(fake.map(x=>x.category))].sort();
        results.push(["Presets: unique categories computed", cats.join(',')==='x,y']);
        const inX = fake.filter(x=>x.category==='x').map(x=>x.name).sort().join(',');
        results.push(["Presets: items filter by category", inX==='a,c']);

      } catch (err){
        results.push([`Exception during tests: ${err?.message||err}`, false]);
      }

      testResults.innerHTML = results.map(([name, ok]) => ok ? `<div class="ok">✔ ${name}</div>` : `<div class="bad">✖ ${name}</div>`).join('');
    }

    function enablePresets(){
      if (!window.PNG_ARRAY || !Array.isArray(window.PNG_ARRAY) || window.PNG_ARRAY.length===0){
        catEl.disabled = true;
        itemEl.disabled = true;
        loadPresetBtn.disabled = true;
        presetCounts = { available: false, total: 0, categories: 0, known: true };
        updatePresetStatusMessage();
        renderCarouselEmpty('missing');
        itemEl.innerHTML = '';
        presetPreview.src = '';
        presetPreview.alt = '';
        return;
      }
      const cats = [...new Set(window.PNG_ARRAY.map(x=>x.category))].sort((a,b)=>a.localeCompare(b));
      catEl.innerHTML = cats.map(c=>`<option value="${c}">${c}</option>`).join('');
      catEl.disabled = false;
      itemEl.disabled = false;
      presetCounts = { available: true, total: window.PNG_ARRAY.length, categories: cats.length, known: true };
      updatePresetStatusMessage();
      renderCarouselEmpty(null);
      updateItems();
    }

    function updateItems(){
      const cat = catEl.value;
      const items = window.PNG_ARRAY
        .filter(x=>x.category===cat)
        .sort((a,b)=>a.name.localeCompare(b.name));

      itemEl.innerHTML = items.map(i=>`<option value="${i.file}" data-name="${i.name}">${i.name}</option>`).join('');

      if (!items.length){
        renderCarouselEmpty('empty');
        presetPreview.src = '';
        presetPreview.alt = '';
        loadPresetBtn.disabled = true;
        return;
      }

      renderCarouselEmpty(null);
      items.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'carousel-item';
        div.dataset.src = item.file;
        div.dataset.name = item.name;
        const img = document.createElement('img');
        img.src = item.file;
        img.alt = item.name;
        div.appendChild(img);
        div.addEventListener('click', () => selectCarouselIndex(idx, true));
        carouselTrack.appendChild(div);
      });

      selectCarouselIndex(0, false);
    }

    function selectCarouselIndex(idx, smooth){
      const items = [...carouselTrack.querySelectorAll('.carousel-item')];
      if (!items.length) return;
      items.forEach((el,i) => el.classList.toggle('selected', i===idx));
      const target = items[idx];
      if (!target){
        itemEl.value = '';
        presetPreview.src = '';
        presetPreview.alt = '';
        loadPresetBtn.disabled = true;
        return;
      }
      itemEl.value = target.dataset.src;
      itemEl.dispatchEvent(new Event('change'));
      loadPresetBtn.disabled = false;
      if (smooth) target.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'});
    }

    carouselPrev.addEventListener('click', () => {
      const items = [...carouselTrack.querySelectorAll('.carousel-item')];
      if (!items.length) return;
      const current = items.findIndex(el => el.classList.contains('selected'));
      const idx = current <= 0 ? items.length - 1 : current - 1;
      selectCarouselIndex(idx, true);
    });

    carouselNext.addEventListener('click', () => {
      const items = [...carouselTrack.querySelectorAll('.carousel-item')];
      if (!items.length) return;
      const current = items.findIndex(el => el.classList.contains('selected'));
      const idx = current >= items.length - 1 ? 0 : current + 1;
      selectCarouselIndex(idx, true);
    });

    catEl.addEventListener('change', updateItems);
    itemEl.addEventListener('change', () => {
      const opt = itemEl.selectedOptions[0];
      if (opt){
        presetPreview.src = opt.value;
        presetPreview.alt = opt.dataset.name || opt.textContent || 'preview';
      }
    });

    loadPresetBtn.addEventListener('click', () => {
      const src = itemEl.value;
      if (!src) return;
      loadUserMaskFromURL(src);
    });

    window.addEventListener('DOMContentLoaded', () => { setTimeout(enablePresets, 0); });
  </script>
</body>
</html>
