<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title class="translate" data-fr="Dessiner dans les contours (Eyegaze)" data-en="Draw inside the lines (Eyegaze)">Dessiner dans les contours (Eyegaze)</title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />
  <script src="../../js/cvipngarray.js" defer></script>

  <style>
    :root{
      --ui-scale: 1;

      /* Sidebar sizing */
      --sidebar-w: clamp(96px, calc(120px * var(--ui-scale)), 180px);
      --sidebar-pad-x: clamp(8px, calc(12px * var(--ui-scale)), 16px);
      --sidebar-pad-y: clamp(8px, calc(12px * var(--ui-scale)), 16px);

      /* Swatches (JS adjusts to fit) */
      --swatch-size: 84px;
      --swatch-gap: 12px;
      --swatch-border: clamp(3px, calc(5px * var(--ui-scale)), 6px);
      --swatch-outline: clamp(3px, calc(5px * var(--ui-scale)), 6px);

      /* Brushes + Save */
      --brush-btn: clamp(36px, calc(44px * var(--ui-scale)), 56px);
      --brush-dot-s: clamp(6px,  calc(8px * var(--ui-scale)),  10px);
      --brush-dot-m: clamp(12px, calc(16px * var(--ui-scale)), 20px);
      --brush-dot-l: clamp(22px, calc(28px * var(--ui-scale)), 34px);
      --brush-gap: clamp(8px, calc(12px * var(--ui-scale)), 16px);

      --save-btn: clamp(36px, calc(44px * var(--ui-scale)), 56px);
      --save-radius: clamp(8px, calc(10px * var(--ui-scale)), 12px);

      /* Cursor preview */
      --cursor-outline: clamp(1px, calc(2px * var(--ui-scale)), 3px);

      /* Palette constraints */
      --swatch-min: 26px;
      --swatch-max: 96px;
      --palette-cols: 1;

      /* Dwell tint */
      --dwell-red: rgba(255, 64, 64, 0.48);
    }

    body.light { background-color: #fff; color: #000; }
    body.dark  { background-color: #000; color: #fff; }

    #langToggle{
      position: fixed; top: 10px; right: 10px; z-index: 99999;
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 10px; border: 2px solid #009688;
      background: #fff; color: #009688; font-weight: 700; cursor: pointer; user-select: none;
    }
    body.dark #langToggle { background:#111; color:#14b8a6; border-color:#14b8a6; }

    .game-container { width: 100%; height: 100%; display: none; }

    canvas#c { position: fixed; inset: 0; cursor: none; } /* custom preview cursor */

    #sidebar{
      position: fixed; left: 0; top: 0; bottom: 0; z-index: 20;
      width: var(--sidebar-w);
      display: flex; flex-direction: column;
      padding: var(--sidebar-pad-y) var(--sidebar-pad-x);
      gap: clamp(12px, calc(14px * var(--ui-scale)), 18px);
      background: #fff; border-right: 1px solid #e6e6e6;
      box-shadow: 0 0 18px rgba(0,0,0,.05);
      color: #000;
    }
    /* Keep left menu white even in dark mode */
    body.dark #sidebar{ background:#fff; border-right-color:#e6e6e6; color:#000; }

    #palette{
      flex: 1;
      display: grid;
      grid-template-columns: repeat(var(--palette-cols, 1), var(--swatch-size));
      grid-auto-rows: var(--swatch-size);
      justify-content: center;
      align-content: start;
      gap: var(--swatch-gap);
      overflow: hidden;          /* no scrolling */
      padding-inline: 8px;       /* breathing room on tiny widths */
    }

    .swatch{
      width: var(--swatch-size); height: var(--swatch-size);
      border-radius: 50%;
      border: var(--swatch-border) solid #ffffff;
      box-shadow: 0 1px 6px rgba(0,0,0,.22) inset, 0 3px 10px rgba(0,0,0,.12);
      transition: transform .12s ease;
      position: relative;
      flex: 0 0 auto;
      overflow: hidden; /* keep dwell clipped to the circle */
    }

    /* Selection ring */
    .swatch.active{ transform: scale(1.03); }
    .swatch.active::before{
      content:"";
      position:absolute;
      inset: calc(var(--swatch-outline) + 2px);
      border: var(--swatch-outline) solid #111;
      border-radius: 50%;
      pointer-events:none;
      z-index: 2; /* above dwell */
    }
    /* In dark mode the sidebar is still white, so keep the dark ring for contrast */
    body.dark .swatch.active::before{ border-color:#111; }

    /* Dwell overlay (below ring) — shared by swatches + brush buttons + save */
    .swatch .dwell,
    .brushBtn .dwell,
    #saveBtn .dwell{
      position: absolute;
      left: 50%; top: 50%;
      width: 100%; height: 100%;
      transform: translate(-50%, -50%) scale(0.08); /* tiny dot */
      transform-origin: center center;
      pointer-events: none;
      border-radius: 50%;
      background-color: var(--dwell-red);
      will-change: transform;
      z-index: 1;
    }

    @keyframes dwellGrow{
      from { transform: translate(-50%, -50%) scale(0.08); }
      to   { transform: translate(-50%, -50%) scale(1.02); } /* slight overshoot */
    }

    .flash::after{
      content:""; position:absolute; left:50%; top:50%;
      width:100%; height:100%; transform:translate(-50%,-50%) scale(1);
      border-radius:50%;
      box-shadow: 0 0 0 0 rgba(17,17,17,0.35);
      animation: ringPulse 420ms ease-out;
      pointer-events:none;
    }
    @keyframes ringPulse{
      0%   { box-shadow: 0 0 0 0 rgba(17,17,17,0.35); transform:translate(-50%,-50%) scale(1.0); }
      60%  { box-shadow: 0 0 0 18px rgba(17,17,17,0.0); transform:translate(-50%,-50%) scale(1.08); }
      100% { box-shadow: 0 0 0 24px rgba(17,17,17,0.0); transform:translate(-50%,-50%) scale(1.0); }
    }

    #brushSizes{
      display: flex; flex-direction: column; align-items: center;
      gap: var(--brush-gap); margin-top: 4px;
    }
    .brushBtn{
      width: var(--brush-btn); height: var(--brush-btn);
      border-radius: 50%;
      border: 2px solid #aaa; background: #f8f8f8;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,.1) inset;
      transition: transform .12s ease, background-color .12s ease;
      position: relative;
      overflow: hidden; /* keep dwell clipped to the circle */
    }
    .brushBtn span{ display: block; border-radius: 50%; background: #333; }
    .brushBtn.small  span{ width: var(--brush-dot-s); height: var(--brush-dot-s); }
    .brushBtn.medium span{ width: var(--brush-dot-m); height: var(--brush-dot-m); }
    .brushBtn.large  span{ width: var(--brush-dot-l); height: var(--brush-dot-l); }
    .brushBtn.active{ border-color:#333; transform: scale(1.08); background:#ececec; }

    /* Ensure light look inside white sidebar even in dark mode */
    body.dark #sidebar .brushBtn{ background:#f8f8f8; border-color:#aaa; }
    body.dark #sidebar .brushBtn span{ background:#333; }
    body.dark #sidebar .brushBtn.active{ background:#ececec; }

    #saveBtn{
      appearance: none; border: 1px solid #ddd; background: #fafafa;
      width: var(--save-btn); height: var(--save-btn);
      border-radius: var(--save-radius); cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      font: clamp(14px, calc(18px * var(--ui-scale)), 22px)/1 system-ui, Arial;
      margin-top: 2px;
      align-self: center; /* centered in sidebar */
      color:#000;
      overflow: hidden; /* clip dwell overlay */
      position: relative; /* anchor dwell overlay */
    }
    #saveBtn:hover{ background:#f2f2f2; }
    /* Keep save button light in dark mode (since sidebar is white) */
    body.dark #sidebar #saveBtn{ background:#fafafa; border-color:#ddd; color:#000; }
    body.dark #sidebar #saveBtn:hover{ background:#f2f2f2; }

    #cursorPreview{
      position: fixed; left: 0; top: 0; width: 20px; height: 20px; border-radius: 50%;
      pointer-events: none; z-index: 15; mix-blend-mode: multiply;
      transform: translate(-50%,-50%); opacity: .65;
      outline: var(--cursor-outline) solid rgba(0,0,0,.18);
    }
    .cursor-pop{ animation: cursorPop 260ms ease-out; }
    @keyframes cursorPop{
      0%   { transform: translate(-50%,-50%) scale(1.00); outline-width: var(--cursor-outline); }
      60%  { transform: translate(-50%,-50%) scale(1.14); outline-width: calc(var(--cursor-outline) * 2.2); }
      100% { transform: translate(-50%,-50%) scale(1.00); outline-width: var(--cursor-outline); }
    }

    #selectPulse{
      position: fixed; left: 0; top: 0; pointer-events: none; z-index: 14;
      width: 22px; height: 22px; border-radius: 50%;
      transform: translate(-50%, -50%) scale(1);
      opacity: 0; border: 4px solid transparent;
    }
    .pulse-show{ animation: pulseExpand 420ms ease-out; }
    @keyframes pulseExpand{
      0%   { opacity: .8; transform: translate(-50%,-50%) scale(1.0); }
      70%  { opacity: .25; transform: translate(-50%,-50%) scale(2.8); }
      100% { opacity: 0;  transform: translate(-50%,-50%) scale(3.2); }
    }

    /* ——— Signature controls ——— */
    #signatureRow { display:flex; flex-direction:column; align-items:flex-start; gap:8px; }
    #signatureText { display:none; max-width: 220px; }

    /* === Mask selection summary === */
    .mask-option-card{
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 12px;
      border-radius:14px;
      border:2px solid rgba(20,184,166,0.35);
      background:#f5fffd;
      box-shadow:0 6px 20px rgba(15,23,42,0.08);
    }
    .mask-option-card img{
      width:84px; height:84px;
      object-fit:contain;
      border-radius:12px;
      border:2px solid rgba(20,184,166,0.35);
      background:#ffffff;
    }
    .mask-option-text{ display:flex; flex-direction:column; gap:4px; font-size:0.9rem; }
    .mask-option-text strong{ font-size:1rem; }
    .mask-buttons{ display:flex; flex-direction:column; gap:10px; }
    #maskUpload{ width:100%; }
    #resetMask{ width:100%; }

    /* Overlay to guide the drawable area */
    #maskOverlay{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:12;
      opacity:0.55;
      mix-blend-mode:multiply;
    }
    #maskOverlay.hidden{ display:none; }

    /* === Library modal === */
    #libraryBackdrop{
      position:fixed;
      inset:0;
      background:rgba(7,17,27,0.82);
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
      z-index:10000;
    }
    #libraryBackdrop.show{ display:flex; }
    #libraryModal{
      width:min(920px,96vw);
      max-height:90vh;
      background:#ffffff;
      border-radius:24px;
      box-shadow:0 30px 80px rgba(15,23,42,0.32);
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .library-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      padding:20px 24px;
      background:linear-gradient(130deg,#ecfeff,#f0fdf4);
      border-bottom:1px solid rgba(15,23,42,0.08);
    }
    .library-header h3{ margin:0; font-size:1.25rem; color:#0f172a; }
    .library-close{
      appearance:none;
      border:none;
      border-radius:999px;
      padding:8px 16px;
      font-weight:600;
      background:rgba(15,23,42,0.08);
      color:#0f172a;
      cursor:pointer;
    }
    .library-body{
      display:grid;
      grid-template-columns:260px 1fr;
      gap:0;
      min-height:320px;
    }
    .library-list{
      background:#f8fafc;
      padding:20px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .library-thumb{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
      border-radius:16px;
      background:#ffffff;
      border:2px solid transparent;
      cursor:pointer;
      transition:transform .18s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .library-thumb img{ max-width:100%; max-height:100%; object-fit:contain; }
    .library-thumb.active{
      border-color:#14b8a6;
      box-shadow:0 14px 36px rgba(20,184,166,0.18);
      transform:translateY(-2px);
    }
    .library-preview{
      padding:24px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:16px;
      background:#ffffff;
    }
    .library-preview img{
      max-width:100%;
      max-height:360px;
      object-fit:contain;
      border-radius:18px;
      border:2px solid rgba(15,23,42,0.08);
      padding:16px;
      background:#ffffff;
    }
    .library-preview p{
      margin:0;
      color:#475569;
      font-size:0.95rem;
      text-align:center;
    }
    .library-actions{
      padding:16px 24px;
      background:#f8fafc;
      border-top:1px solid rgba(15,23,42,0.08);
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:12px;
    }
    .library-actions button{
      min-width:130px;
    }
    .button.secondary{ background:#e2e8f0; color:#0f172a; }

    @media (max-width:900px){
      .library-body{ grid-template-columns:1fr; }
      .library-list{ flex-direction:row; flex-wrap:wrap; justify-content:center; }
    }
  </style>
</head>
<body class="dark">
<button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

<!-- ===== Start Menu ===== -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title" class="translate"
        data-fr="Dessiner dans les contours (Eyegaze)"
        data-en="Draw inside the lines (Eyegaze)">Dessiner dans les contours (Eyegaze)</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Column 1 -->
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span class="translate" data-fr="Désactiver les sons" data-en="Disable sounds">Désactiver les sons (SFX)</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span class="translate" data-fr="Volume des sons:" data-en="Sound volume:">Volume des sons:</span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Column 2 -->
      <div class="options-column">
        <div class="option-item">
          <label for="themeSelect" class="teal-label label-block translate" data-fr="Mode" data-en="Theme">Mode</label>
          <select id="themeSelect" class="styled-select">
            <option value="light" selected class="translate" data-fr="Clair" data-en="Light">Clair</option>
            <option value="dark"  class="translate" data-fr="Sombre" data-en="Dark">Sombre</option>
          </select>
        </div>
      </div>

      <!-- Column 3 (palette size + signature) -->
      <div class="options-column">
        <div class="option-item">
          <label for="paletteSizeSelect" class="teal-label label-block translate"
                 data-fr="Nombre de couleurs" data-en="Number of colors">Nombre de couleurs</label>
          <select id="paletteSizeSelect" class="styled-select">
            <option value="4"  class="translate" data-fr="4 couleurs"  data-en="4 colors">4 couleurs</option>
            <option value="7"  selected class="translate" data-fr="7 couleurs"  data-en="7 colors">7 couleurs</option>
            <option value="13" class="translate" data-fr="13 couleurs" data-en="13 colors">13 couleurs</option>
          </select>
        </div>

        <!-- ✍️ Signature controls -->
        <div class="option-item" id="signatureRow">
          <label class="teal-label" for="signatureEnable" style="user-select:none;">
            <input type="checkbox" id="signatureEnable">
            <span class="translate" data-fr="Signature" data-en="Signature">Signature</span>
          </label>
          <input type="text" id="signatureText" class="styled-input" placeholder="Votre nom / Your name" />
        </div>

        <div class="option-item">
          <label for="shapeSelect" class="teal-label label-block translate"
                 data-fr="Contour intégré" data-en="Built-in outline">Contour intégré</label>
          <select id="shapeSelect" class="styled-select">
            <option value="blob" class="translate" data-fr="Forme organique" data-en="Organic shape">Forme organique</option>
            <option value="star" class="translate" data-fr="Étoile" data-en="Star">Étoile</option>
            <option value="heart" class="translate" data-fr="Cœur" data-en="Heart">Cœur</option>
            <option value="rect" class="translate" data-fr="Rectangle arrondi" data-en="Rounded rectangle">Rectangle arrondi</option>
          </select>
        </div>

        <div class="option-item">
          <div class="mask-option-card">
            <img id="maskThumb" alt="aperçu" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAoMBgS5momgAAAAASUVORK5CYII=">
            <div class="mask-option-text">
              <strong id="selectedMaskLabel">Contour : Forme organique</strong>
              <span id="maskStatus" class="translate" data-fr="Aucune image personnalisée" data-en="No custom image">Aucune image personnalisée</span>
            </div>
          </div>
        </div>

        <div class="option-item mask-buttons">
          <button id="openLibrary" type="button" class="button translate"
                  data-fr="Bibliothèque d'images" data-en="Image library">Bibliothèque d'images</button>
          <button id="resetMask" type="button" class="button secondary translate"
                  data-fr="Réinitialiser le contour" data-en="Reset outline">Réinitialiser le contour</button>
        </div>

        <div class="option-item">
          <label for="maskUpload" class="teal-label label-block translate"
                 data-fr="Importer un contour (PNG/SVG)" data-en="Upload outline (PNG/SVG)">Importer un contour (PNG/SVG)</label>
          <input type="file" id="maskUpload" accept="image/png,image/svg+xml">
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
  </div>
</div>

<!-- ===== Painting App (shown after Start) ===== -->
<div class="game-container" id="drawGame">
  <aside id="sidebar">
    <div id="palette"><!-- swatches injected dynamically --></div>

    <div id="brushSizes">
      <div class="brushBtn small"  data-size="small"  title="Petit / Small"><span></span></div>
      <div class="brushBtn medium active" data-size="medium" title="Moyen / Medium"><span></span></div>
      <div class="brushBtn large"  data-size="large"  title="Grand / Large"><span></span></div>
    </div>

    <button id="saveBtn" type="button" aria-label="Enregistrer PNG" title="Enregistrer PNG">💾</button>
  </aside>

  <canvas id="c" aria-label="drawing canvas"></canvas>
  <canvas id="maskOverlay" aria-hidden="true" class="hidden"></canvas>
  <div id="cursorPreview" aria-hidden="true"></div>
  <div id="selectPulse" aria-hidden="true"></div>
</div>

<div id="libraryBackdrop" role="dialog" aria-modal="true">
  <div id="libraryModal">
    <div class="library-header">
      <h3 class="translate" data-fr="Bibliothèque de contours" data-en="Outline library">Bibliothèque de contours</h3>
      <button id="closeLibrary" type="button" class="library-close translate"
              data-fr="Fermer" data-en="Close">Fermer</button>
    </div>
    <div class="library-body">
      <div class="library-list" id="libraryList"></div>
      <div class="library-preview">
        <img id="libraryPreviewImg" alt="aperçu" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAoMBgS5momgAAAAASUVORK5CYII=">
        <p id="libraryPreviewLabel" class="translate"
           data-fr="Choisissez une image dans la liste" data-en="Pick an image from the list">Choisissez une image dans la liste</p>
      </div>
    </div>
    <div class="library-actions">
      <button id="cancelLibrary" type="button" class="button secondary translate"
              data-fr="Annuler" data-en="Cancel">Annuler</button>
      <button id="confirmLibrary" type="button" class="button translate"
              data-fr="Utiliser cette image" data-en="Use this image">Utiliser cette image</button>
    </div>
  </div>
</div>

<script>
/* === Language toggle === */
const LS_LANG_KEY = 'siteLanguage';
const LS_PALETTE_KEY = 'paint_palette_size';
const langToggle  = document.getElementById('langToggle');
function getLang(){ try{const s=localStorage.getItem(LS_LANG_KEY); if(s==='en'||s==='fr') return s;}catch(e){} return (document.documentElement.lang==='en')?'en':'fr'; }
function setLang(lang){
  const safe=(lang==='en')?'en':'fr';
  document.documentElement.lang=safe;
  try{localStorage.setItem(LS_LANG_KEY,safe);}catch(e){}
  document.querySelectorAll('.translate').forEach(el=>{
    const fr=el.getAttribute('data-fr'); const en=el.getAttribute('data-en');
    if (safe==='fr' && fr!=null) el.textContent=fr;
    if (safe==='en' && en!=null) el.textContent=en;
  });
  updateMaskSummary();
}
(function initLang(){
  let initial='fr';
  try{
    const saved=localStorage.getItem(LS_LANG_KEY);
    initial=(saved==='en'||saved==='fr')?saved:(document.documentElement.lang==='en'?'en':'fr');
    localStorage.setItem(LS_LANG_KEY,initial);
  }catch(e){
    initial=(document.documentElement.lang==='en'?'en':'fr');
  }
  setLang(initial);
})();
langToggle.addEventListener('click', ()=> setLang(getLang()==='fr'?'en':'fr'));

/* === Minimal menu controls === */
const themeSelect   = document.getElementById('themeSelect');
const paletteSizeSelect = document.getElementById('paletteSizeSelect');
const shapeSelect = document.getElementById('shapeSelect');
const maskThumb = document.getElementById('maskThumb');
const maskStatusEl = document.getElementById('maskStatus');
const maskLabelEl = document.getElementById('selectedMaskLabel');
const openLibraryBtn = document.getElementById('openLibrary');
const resetMaskBtn = document.getElementById('resetMask');
const maskUploadInput = document.getElementById('maskUpload');
const libraryBackdrop = document.getElementById('libraryBackdrop');
const libraryList = document.getElementById('libraryList');
const libraryPreviewImg = document.getElementById('libraryPreviewImg');
const libraryPreviewLabel = document.getElementById('libraryPreviewLabel');
const closeLibraryBtn = document.getElementById('closeLibrary');
const cancelLibraryBtn = document.getElementById('cancelLibrary');
const confirmLibraryBtn = document.getElementById('confirmLibrary');
function applyTheme(theme){
  document.body.classList.remove('light','dark');
  document.body.classList.add(theme==='dark'?'dark':'light');
}

/* Signature controls */
const signatureEnable = document.getElementById('signatureEnable');
const signatureTextInput = document.getElementById('signatureText');
signatureEnable.addEventListener('change', ()=>{
  signatureTextInput.style.display = signatureEnable.checked ? 'block' : 'none';
});

/* Persist / init palette size */
(function initPaletteSize(){
  try{
    const saved = localStorage.getItem(LS_PALETTE_KEY);
    if(saved==='4'||saved==='7'||saved==='13'){
      paletteSizeSelect.value = saved;
    }
  }catch(e){}
})();
paletteSizeSelect.addEventListener('change', ()=>{
  try{ localStorage.setItem(LS_PALETTE_KEY, paletteSizeSelect.value); }catch(e){}
  if (document.getElementById('drawGame').style.display === 'block') {
    buildPalette(parseInt(paletteSizeSelect.value,10));
  }
});

/* === Mask + outline handling === */
const SHAPE_LABELS = {
  blob:  { fr: 'Forme organique',      en: 'Organic shape' },
  star:  { fr: 'Étoile',               en: 'Star' },
  heart: { fr: 'Cœur',                 en: 'Heart' },
  rect:  { fr: 'Rectangle arrondi',    en: 'Rounded rectangle' }
};
const STATUS_LABELS = {
  none:   { fr: 'Aucune image personnalisée',   en: 'No custom image' },
  preset: { fr: 'Bibliothèque : {name}',        en: 'Library: {name}' },
  upload: { fr: 'Importé : {name}',             en: 'Uploaded: {name}' }
};

const maskOverlayCanvas = document.getElementById('maskOverlay');
const maskOverlayCtx = maskOverlayCanvas.getContext('2d');
const maskAlphaCanvas = document.createElement('canvas');
const maskAlphaCtx = maskAlphaCanvas.getContext('2d');
const maskWorkCanvas = document.createElement('canvas');
const maskWorkCtx = maskWorkCanvas.getContext('2d');
const scratchCanvas = document.createElement('canvas');
const scratchCtx = scratchCanvas.getContext('2d');

let currentShape = 'blob';
let currentMaskMode = 'shape'; // shape, preset, upload
let currentPreset = null;
let currentUploadName = '';
let userMaskImage = null;
let maskPath = null;
let maskFit = { x: 0, y: 0, width: 0, height: 0 };
let librarySelection = null;
let presetItems = [];

function clearCtx(ctxObj, canvasEl){
  ctxObj.save();
  ctxObj.setTransform(1,0,0,1,0,0);
  ctxObj.clearRect(0,0,canvasEl.width,canvasEl.height);
  ctxObj.restore();
}

function computeDrawingBounds(){
  const sidebarEl = document.getElementById('sidebar');
  const side = sidebarEl ? sidebarEl.getBoundingClientRect().width : 0;
  const paddingX = Math.max(32, Math.min((innerWidth - side) * 0.08, 120));
  const paddingY = Math.max(32, Math.min(innerHeight * 0.08, 120));
  const width = Math.max(64, innerWidth - side - paddingX * 2);
  const height = Math.max(64, innerHeight - paddingY * 2);
  return { x: side + paddingX, y: paddingY, width, height };
}

function shapePathForBounds(shape, bounds){
  const { x, y, width: w, height: h } = bounds;
  const p = new Path2D();
  const pad = Math.min(w, h) * 0.08;
  const left = x + pad;
  const top = y + pad;
  const width = Math.max(10, w - pad * 2);
  const height = Math.max(10, h - pad * 2);
  const cx = left + width / 2;
  const cy = top + height / 2;
  if (shape === 'rect'){
    const r = Math.min(width, height) * 0.18;
    p.moveTo(left + r, top);
    p.arcTo(left + width, top, left + width, top + height, r);
    p.arcTo(left + width, top + height, left, top + height, r);
    p.arcTo(left, top + height, left, top, r);
    p.arcTo(left, top, left + width, top, r);
    p.closePath();
  } else if (shape === 'blob'){
    const rx = width * 0.36;
    const ry = height * 0.32;
    p.moveTo(cx, cy - ry);
    p.bezierCurveTo(cx + rx * 0.6, cy - ry, cx + rx, cy - ry * 0.2, cx + rx, cy);
    p.bezierCurveTo(cx + rx, cy + ry * 0.6, cx + rx * 0.4, cy + ry, cx, cy + ry);
    p.bezierCurveTo(cx - rx * 0.6, cy + ry, cx - rx, cy + ry * 0.2, cx - rx, cy);
    p.bezierCurveTo(cx - rx, cy - ry * 0.6, cx - rx * 0.4, cy - ry, cx, cy - ry);
    p.closePath();
  } else if (shape === 'star'){
    const spikes = 5;
    const outer = Math.min(width, height) * 0.36;
    const inner = outer * 0.45;
    let rot = Math.PI / 2 * 3;
    p.moveTo(cx, cy - outer);
    for (let i = 0; i < spikes; i++){
      let x = cx + Math.cos(rot) * outer;
      let y = cy + Math.sin(rot) * outer;
      p.lineTo(x, y);
      rot += Math.PI / spikes;
      x = cx + Math.cos(rot) * inner;
      y = cy + Math.sin(rot) * inner;
      p.lineTo(x, y);
      rot += Math.PI / spikes;
    }
    p.closePath();
  } else if (shape === 'heart'){
    const s = Math.min(width, height) * 0.38;
    const top = cy - s * 0.25;
    p.moveTo(cx, top);
    p.bezierCurveTo(cx + s * 0.5, top - s * 0.6, cx + s, cy - s * 0.05, cx, cy + s * 0.75);
    p.bezierCurveTo(cx - s, cy - s * 0.05, cx - s * 0.5, top - s * 0.6, cx, top);
    p.closePath();
  }
  return p;
}

function computeContainFit(bounds, imgW, imgH){
  const r = imgW / Math.max(1, imgH);
  const R = bounds.width / Math.max(1, bounds.height);
  let width, height;
  if (R > r){
    height = bounds.height;
    width = height * r;
  } else {
    width = bounds.width;
    height = width / r;
  }
  const x = bounds.x + (bounds.width - width) / 2;
  const y = bounds.y + (bounds.height - height) / 2;
  return { x, y, width, height };
}

function updateMaskSummary(){
  const lang = getLang();
  const shapeLabel = SHAPE_LABELS[currentShape]?.[lang] || SHAPE_LABELS.blob[lang];
  const prefix = lang === 'fr' ? 'Contour :' : 'Outline:';
  let labelText = `${prefix} ${shapeLabel}`;
  if (currentMaskMode === 'preset' && userMaskImage){
    labelText = `${prefix} ${lang === 'fr' ? 'Image bibliothèque' : 'Library image'}`;
  } else if (currentMaskMode === 'upload' && userMaskImage){
    labelText = `${prefix} ${lang === 'fr' ? 'Image importée' : 'Uploaded image'}`;
  }
  maskLabelEl.textContent = labelText;
  let statusTemplate = STATUS_LABELS.none[lang];
  if (currentMaskMode === 'preset' && currentPreset){
    statusTemplate = STATUS_LABELS.preset[lang].replace('{name}', currentPreset.name || currentPreset.file || 'PNG');
  } else if (currentMaskMode === 'upload' && currentUploadName){
    statusTemplate = STATUS_LABELS.upload[lang].replace('{name}', currentUploadName);
  }
  maskStatusEl.textContent = statusTemplate;
}

function updateMaskThumbnail(){
  const size = 160;
  const preview = document.createElement('canvas');
  preview.width = size;
  preview.height = size;
  const pc = preview.getContext('2d');
  pc.fillStyle = '#ffffff';
  pc.fillRect(0,0,size,size);
  pc.strokeStyle = 'rgba(15,23,42,0.08)';
  pc.strokeRect(0,0,size,size);
  const bounds = { x: size * 0.12, y: size * 0.12, width: size * 0.76, height: size * 0.76 };
  if (userMaskImage){
    const fit = computeContainFit(bounds, userMaskImage.naturalWidth, userMaskImage.naturalHeight);
    pc.save();
    pc.globalAlpha = 0.9;
    pc.drawImage(userMaskImage, fit.x, fit.y, fit.width, fit.height);
    pc.restore();
  } else {
    const path = shapePathForBounds(currentShape, bounds);
    pc.save();
    pc.globalAlpha = 0.12;
    pc.fillStyle = '#0f172a';
    pc.fill(path);
    pc.globalAlpha = 0.9;
    pc.lineWidth = 4;
    pc.strokeStyle = 'rgba(20,184,166,0.65)';
    pc.stroke(path);
    pc.restore();
  }
  maskThumb.src = preview.toDataURL('image/png');
  maskThumb.alt = maskLabelEl.textContent;
}

function drawMaskOverlay(){
  clearCtx(maskOverlayCtx, maskOverlayCanvas);
  if (!canvas.width || !canvas.height) return;
  const transform = ctx.getTransform();
  maskOverlayCtx.setTransform(transform);
  if (userMaskImage && maskFit.width && maskFit.height){
    maskOverlayCtx.save();
    maskOverlayCtx.globalAlpha = 0.32;
    maskOverlayCtx.drawImage(userMaskImage, maskFit.x, maskFit.y, maskFit.width, maskFit.height);
    maskOverlayCtx.restore();
    maskOverlayCtx.save();
    maskOverlayCtx.globalAlpha = 0.85;
    maskOverlayCtx.lineWidth = 4;
    maskOverlayCtx.strokeStyle = 'rgba(20,184,166,0.8)';
    maskOverlayCtx.strokeRect(maskFit.x, maskFit.y, maskFit.width, maskFit.height);
    maskOverlayCtx.restore();
  } else if (maskPath){
    maskOverlayCtx.save();
    maskOverlayCtx.globalAlpha = 0.08;
    maskOverlayCtx.fillStyle = '#0f172a';
    maskOverlayCtx.fill(maskPath);
    maskOverlayCtx.globalAlpha = 0.9;
    maskOverlayCtx.lineWidth = 4;
    maskOverlayCtx.strokeStyle = 'rgba(20,184,166,0.75)';
    maskOverlayCtx.stroke(maskPath);
    maskOverlayCtx.restore();
  }
}

function rebuildMask({ preserveInk = true } = {}){
  if (!canvas.width || !canvas.height) return;
  maskOverlayCanvas.width = canvas.width;
  maskOverlayCanvas.height = canvas.height;
  maskOverlayCanvas.style.width = canvas.style.width;
  maskOverlayCanvas.style.height = canvas.style.height;
  maskAlphaCanvas.width = canvas.width;
  maskAlphaCanvas.height = canvas.height;
  maskWorkCanvas.width = canvas.width;
  maskWorkCanvas.height = canvas.height;
  scratchCanvas.width = canvas.width;
  scratchCanvas.height = canvas.height;

  clearCtx(maskAlphaCtx, maskAlphaCanvas);
  clearCtx(maskWorkCtx, maskWorkCanvas);
  clearCtx(scratchCtx, scratchCanvas);

  const bounds = computeDrawingBounds();
  maskPath = shapePathForBounds(currentShape, bounds);
  const transform = ctx.getTransform();
  maskAlphaCtx.setTransform(transform);
  maskWorkCtx.setTransform(transform);
  scratchCtx.setTransform(transform);

  if (userMaskImage){
    maskFit = computeContainFit(bounds, userMaskImage.naturalWidth, userMaskImage.naturalHeight);
    maskWorkCtx.drawImage(userMaskImage, maskFit.x, maskFit.y, maskFit.width, maskFit.height);
    const data = maskWorkCtx.getImageData(0,0,maskWorkCanvas.width, maskWorkCanvas.height);
    const buf = data.data;
    for (let i = 0; i < buf.length; i += 4){
      const a = buf[i+3];
      buf[i] = 255; buf[i+1] = 255; buf[i+2] = 255; buf[i+3] = a;
    }
    maskWorkCtx.putImageData(data,0,0);
    maskAlphaCtx.save();
    maskAlphaCtx.setTransform(1,0,0,1,0,0);
    maskAlphaCtx.drawImage(maskWorkCanvas,0,0);
    maskAlphaCtx.restore();
  } else if (maskPath){
    maskAlphaCtx.save();
    maskAlphaCtx.fillStyle = '#ffffff';
    maskAlphaCtx.fill(maskPath);
    maskAlphaCtx.restore();
    maskFit = bounds;
  }

  if (!preserveInk){
    ctx.fillStyle = getCanvasBg();
    ctx.fillRect(0,0,innerWidth,innerHeight);
    if (SIG_ENABLED) drawSignatureIfEnabled();
  }

  drawMaskOverlay();
  updateMaskThumbnail();
}

function ensurePresetItems(){
  if (presetItems.length) return;
  if (Array.isArray(window.PNG_ARRAY)){
    presetItems = window.PNG_ARRAY.map((item, index)=>({
      name: item.name || `${index + 1}`,
      file: item.file,
      category: item.category || ''
    }));
  }
}

function closeLibraryModal(){
  libraryBackdrop.classList.remove('show');
}

function openLibraryModal(){
  ensurePresetItems();
  librarySelection = null;
  libraryList.innerHTML = '';
  confirmLibraryBtn.disabled = true;
  libraryPreviewImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAoMBgS5momgAAAAASUVORK5CYII=';
  libraryPreviewLabel.textContent = getLang() === 'fr' ? 'Choisissez une image dans la liste' : 'Pick an image from the list';

  if (!presetItems.length){
    const msg = document.createElement('p');
    msg.style.margin = '0';
    msg.style.fontSize = '0.95rem';
    msg.style.color = '#475569';
    msg.textContent = getLang() === 'fr'
      ? 'Aucune image disponible. Ajoutez ../../js/cvipngarray.js pour charger la bibliothèque.'
      : 'No images available. Add ../../js/cvipngarray.js to enable the library.';
    libraryList.appendChild(msg);
  } else {
    presetItems.forEach((item, idx)=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'library-thumb';
      const img = document.createElement('img');
      img.src = item.file;
      img.alt = item.name || `Preset ${idx+1}`;
      btn.appendChild(img);
      btn.addEventListener('click', ()=> selectLibraryItem(idx));
      libraryList.appendChild(btn);
    });
  }

  libraryBackdrop.classList.add('show');
}

function selectLibraryItem(idx){
  const items = Array.from(libraryList.children);
  items.forEach((el, i)=> el.classList.toggle('active', i === idx));
  librarySelection = presetItems[idx] || null;
  if (librarySelection){
    libraryPreviewImg.src = librarySelection.file;
    libraryPreviewLabel.textContent = librarySelection.name || '';
    confirmLibraryBtn.disabled = false;
  }
}

function loadMaskFromURL(url, { mode = 'preset', preset = null, label = '', revoke = false } = {}){
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    if (revoke) URL.revokeObjectURL(url);
    userMaskImage = img;
    currentMaskMode = mode;
    if (mode === 'preset'){
      currentPreset = preset || { name: label, file: url };
      currentUploadName = '';
    } else if (mode === 'upload'){
      currentUploadName = label || '';
      currentPreset = null;
    }
    rebuildMask({ preserveInk: false });
    updateMaskSummary();
    closeLibraryModal();
    playClick();
  };
  img.onerror = ()=>{
    if (revoke) URL.revokeObjectURL(url);
    alert(getLang() === 'fr' ? "Impossible de charger l'image sélectionnée." : 'Unable to load the selected image.');
  };
  img.src = url;
}

function loadMaskFromFile(file){
  const url = URL.createObjectURL(file);
  loadMaskFromURL(url, { mode: 'upload', label: file.name || 'PNG', revoke: true });
}

shapeSelect.addEventListener('change', ()=>{
  currentShape = shapeSelect.value || 'blob';
  if (!userMaskImage){
    currentMaskMode = 'shape';
  }
  rebuildMask({ preserveInk: false });
  updateMaskSummary();
});

resetMaskBtn.addEventListener('click', ()=>{
  userMaskImage = null;
  currentMaskMode = 'shape';
  currentPreset = null;
  currentUploadName = '';
  maskUploadInput.value = '';
  rebuildMask({ preserveInk: false });
  updateMaskSummary();
  playClick();
});

maskUploadInput.addEventListener('change', ()=>{
  const file = maskUploadInput.files && maskUploadInput.files[0];
  if (file){
    loadMaskFromFile(file);
  }
});

openLibraryBtn.addEventListener('click', ()=>{
  openLibraryModal();
});

closeLibraryBtn.addEventListener('click', closeLibraryModal);
cancelLibraryBtn.addEventListener('click', closeLibraryModal);
libraryBackdrop.addEventListener('click', (e)=>{
  if (e.target === libraryBackdrop){
    closeLibraryModal();
  }
});

confirmLibraryBtn.addEventListener('click', ()=>{
  if (librarySelection){
    loadMaskFromURL(librarySelection.file, { mode: 'preset', preset: librarySelection });
  }
});

updateMaskSummary();
updateMaskThumbnail();

/* === UI scale (responsive) === */
function updateUiScale(){
  const vmin = Math.min(window.innerWidth, window.innerHeight);
  const scale = Math.min(1.6, Math.max(0.70, vmin / 900));
  document.documentElement.style.setProperty('--ui-scale', scale.toFixed(3));
}
updateUiScale();
addEventListener('resize', updateUiScale, {passive:true});

/* Start */
const startButton = document.getElementById('startButton');
const gameOptions = document.getElementById('game-options');
const gameArea    = document.getElementById('drawGame');

async function enterFullscreen(){
  const el=document.documentElement;
  try{
    if(el.requestFullscreen) await el.requestFullscreen();
    else if(el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    else if(el.msRequestFullscreen) await el.msRequestFullscreen();
  }catch(e){}
}

/* === Background music (auto-starts on begin) === */
const MUSIC_TRACKS = [
  "../../songs/artgallery1.mp3",
  "../../songs/artgallery2.mp3",
  "../../songs/artgallery3.mp3",
  "../../songs/artgallery4.mp3"
];
let musicIdx = Math.floor(Math.random() * MUSIC_TRACKS.length); // start from a random track
let musicAudio = null;
let MUSIC_ENABLED = true; // toggled by the SFX mute checkbox

function playNextTrack(){
  if (!MUSIC_ENABLED) return; // respect mute
  if (musicAudio){
    musicAudio.onended = null;
    try { musicAudio.pause(); } catch(e){}
  }
  musicAudio = new Audio(MUSIC_TRACKS[musicIdx]);
  musicAudio.volume = 0.5;
  musicAudio.loop = false;
  musicAudio.play().catch(()=>{ /* ignore autoplay issues */ });
  musicAudio.onended = ()=>{
    if (!MUSIC_ENABLED) return;
    musicIdx = (musicIdx + 1) % MUSIC_TRACKS.length;
    playNextTrack();
  };
}

/* Tie music to the SFX mute checkbox */
const muteSFX = document.getElementById('muteSFX');
function updateAudioMute(){
  MUSIC_ENABLED = !muteSFX.checked;
  if (!MUSIC_ENABLED){
    if (musicAudio){
      try { musicAudio.pause(); } catch(e){}
    }
  } else {
    if (!musicAudio || musicAudio.paused){
      playNextTrack();
    }
  }
}
muteSFX.addEventListener('change', updateAudioMute);

/* ===== Signature state & helpers ===== */
let SIG_ENABLED = false;
let SIG_TEXT = "";
function drawSignatureIfEnabled(){
  if(!SIG_ENABLED || !SIG_TEXT) return;
  const margin = 14;
  const px = Math.max(18, Math.min(48, Math.round(innerWidth * 0.035)));
  const text = SIG_TEXT.trim();
  if(!text) return;

  // Draw stylized signature bottom-right
  ctx.save();
  ctx.font = `${px}px "Brush Script MT", "Segoe Script", "Comic Sans MS", cursive`;
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(0,0,0,0.92)';
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = Math.max(1.5, px * 0.10);
  ctx.shadowColor = 'rgba(0,0,0,0.15)';
  ctx.shadowBlur = Math.max(2, px * 0.2);

  const x = innerWidth - margin;
  const y = innerHeight - margin;
  ctx.strokeText(text, x, y);
  ctx.fillText(text, x, y);
  ctx.restore();
}

startButton.addEventListener('click', async ()=>{
  applyTheme(themeSelect.value);
  // Capture signature options at start
  SIG_ENABLED = !!signatureEnable.checked;
  SIG_TEXT = (signatureTextInput.value || '').trim();

  await enterFullscreen();
  gameOptions.style.display='none';
  langToggle.style.display='none';
  gameArea.style.display='block';

  updateAudioMute(); // initial music state
  playNextTrack();   // random start (no-op if muted)

  setTimeout(()=> {
    /* Do not preserve the initial dark snapshot so light mode is white */
    resize({preserve:false});
    buildPalette(parseInt(paletteSizeSelect.value,10) || 7);
    maskOverlayCanvas.classList.remove('hidden');
    rebuildMask({ preserveInk: false });
    updateMaskSummary();
    drawSignatureIfEnabled(); // draw once on fresh canvas
  }, 50);
});

/* === Painting logic === */
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d',{alpha:false});

/* Helper: background color per theme */
function getCanvasBg(){
  return document.body.classList.contains('dark') ? '#000000' : '#ffffff';
}

/* PRESERVING, HiDPI-safe resize */
function resize({preserve=true}={}){
  const dpr=Math.max(1,window.devicePixelRatio||1);

  let snapshot=null;
  if(preserve&&canvas.width&&canvas.height){
    snapshot=document.createElement('canvas');
    snapshot.width=canvas.width; snapshot.height=canvas.height;
    snapshot.getContext('2d').drawImage(canvas,0,0);
  }

  const cssW=innerWidth, cssH=innerHeight;
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  /* fill with theme-appropriate background */
  ctx.fillStyle = getCanvasBg();
  ctx.fillRect(0,0,cssW,cssH);

  if(snapshot){
    const prev=ctx.imageSmoothingEnabled;
    ctx.imageSmoothingEnabled=true;
    ctx.drawImage(snapshot,0,0,snapshot.width,snapshot.height,0,0,cssW,cssH);
    ctx.imageSmoothingEnabled=prev;
  }

  // Re-apply signature overlay on layout changes (does not affect drawing)
  drawSignatureIfEnabled();
  rebuildMask({ preserveInk: preserve });
}
addEventListener('resize',()=>{ resize({preserve:true}); layoutPalette(); },{passive:true});
['fullscreenchange','webkitfullscreenchange','msfullscreenchange']
  .forEach(evt=>document.addEventListener(evt,()=>{ resize({preserve:true}); layoutPalette(); }));
resize({preserve:false});

/* State */
let last=null,smoothW=2,currentColor="#000000",sizeMode="medium";
const cursorEl=document.getElementById('cursorPreview');
const pulseEl = document.getElementById('selectPulse');
const sidebar = document.getElementById('sidebar');
const paletteEl = document.getElementById('palette');
const brushBox = document.getElementById('brushSizes');
const saveBtn  = document.getElementById('saveBtn');
const sidebarW=()=>sidebar.getBoundingClientRect().width;

/* Simple SFX volume */
const sfxVol  = document.getElementById('sfxVol');
const sfxVolVal = document.getElementById('sfxVolVal');
sfxVol.addEventListener('input', ()=> sfxVolVal.textContent = sfxVol.value);
function playClick(){
  if (muteSFX?.checked) return;
  try{
    const ctxA = new (window.AudioContext||window.webkitAudioContext)();
    const o = ctxA.createOscillator(); const g = ctxA.createGain();
    o.type='triangle'; o.frequency.value=660;
    g.gain.value = (parseInt(sfxVol.value,10)||50)/800;
    o.connect(g); g.connect(ctxA.destination);
    o.start();
    setTimeout(()=>{ o.stop(); ctxA.close(); }, 90);
  }catch(e){}
}

/* Inverse speed → width (slow = thicker) with size modes */
function widthFromSpeed(speed){
  // Small unchanged; Medium & Large slightly reduced
  let minW, maxW;
  if (sizeMode === "small")      { minW = 1;  maxW = 10; }  // same
  else if (sizeMode === "medium"){ minW = 10; maxW = 40; }  // was 12–52
  else /* large */               { minW = 20; maxW = 80; }  // was 24–104

  const s = Math.min(speed / 1.8, 1);
  const ease = k => k*k*(3 - 2*k);
  const inv = 1 - ease(s); // slower movement -> thicker line
  return minW + (maxW - minW) * inv;
}
function stroke(a,b,w,color){
  if (!canvas.width || !canvas.height){ return; }
  scratchCtx.save();
  scratchCtx.setTransform(ctx.getTransform());
  scratchCtx.globalCompositeOperation = 'source-over';
  scratchCtx.lineCap = 'round';
  scratchCtx.lineJoin = 'round';
  scratchCtx.lineWidth = w;
  scratchCtx.strokeStyle = color;
  scratchCtx.beginPath();
  scratchCtx.moveTo(a.x,a.y);
  scratchCtx.lineTo(b.x,b.y);
  scratchCtx.stroke();

  scratchCtx.globalCompositeOperation = 'destination-in';
  scratchCtx.setTransform(1,0,0,1,0,0);
  scratchCtx.drawImage(maskAlphaCanvas,0,0);
  scratchCtx.restore();

  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.drawImage(scratchCanvas,0,0);
  ctx.restore();

  clearCtx(scratchCtx, scratchCanvas);
}
function updateCursor(x,y,w){
  if (x < sidebarW()){ cursorEl.style.opacity = 0; return; }
  cursorEl.style.opacity = .65;
  cursorEl.style.left = x + 'px';
  cursorEl.style.top  = y + 'px';

  // Preview diameter nudged down for medium/large
  const baseMin =
    (sizeMode === 'small')  ? 4  :
    (sizeMode === 'medium') ? 8  :
                              10;

  const d = Math.max(baseMin, w);
  cursorEl.style.width  = d + 'px';
  cursorEl.style.height = d + 'px';
  cursorEl.style.background = currentColor;
}




/* Pointer drawing */
function handleMove(x,y){
  if(x<sidebarW()){last=null;updateCursor(x,y,16);return;}
  const t=performance.now();
  if(!last){last={x,y,t};updateCursor(x,y,16);return;}
  const dx=x-last.x, dy=y-last.y, dt=Math.max(1,t-last.t);
  const speed=Math.hypot(dx,dy)/dt;
  const targetW=widthFromSpeed(speed);
  smoothW=smoothW*0.82+targetW*0.18;
  stroke(last,{x,y},smoothW,currentColor);
  updateCursor(x,y,smoothW);
  last={x,y,t};
}
canvas.addEventListener('mousemove',e=>handleMove(e.clientX,e.clientY),{passive:true});
canvas.addEventListener('mouseleave',()=>{last=null;cursorEl.style.opacity=0;},{passive:true});
canvas.addEventListener('mouseenter',e=>{last={x:e.clientX,y:e.clientY,t:performance.now()};updateCursor(e.clientX,e.clientY,16);},{passive:true});
canvas.addEventListener('touchmove',e=>{const t=e.touches[0]; if(t) handleMove(t.clientX,t.clientY);},{passive:true});
canvas.addEventListener('touchend',()=>{last=null;},{passive:true});

/* Visual feedback helpers */
function flashEl(el){
  el.classList.remove('flash'); void el.offsetWidth; el.classList.add('flash');
  setTimeout(()=> el.classList.remove('flash'), 460);
}
function popCursor(){
  cursorEl.classList.remove('cursor-pop'); void cursorEl.offsetWidth; cursorEl.classList.add('cursor-pop');
  setTimeout(()=> cursorEl.classList.remove('cursor-pop'), 300);
}
function pulseAt(x,y,color){
  pulseEl.style.left = x + 'px';
  pulseEl.style.top  = y + 'px';
  pulseEl.style.borderColor = color || 'rgba(0,0,0,.35)';
  pulseEl.classList.remove('pulse-show'); void pulseEl.offsetWidth; pulseEl.classList.add('pulse-show');
  setTimeout(()=> pulseEl.classList.remove('pulse-show'), 460);
}

/* ===== Dynamic palette building ===== */
const PALETTE_13 = [
  "#000000",
  "#FF6B6B", "#F94144",
  "#FFD166", "#F9C74F",
  "#06D6A0", "#90BE6D", "#43AA8B",
  "#118AB2", "#3A86FF",
  "#9B59B6", "#8338EC",
  "#FF9F1C"
];

function pickColors(n){
  if(n>=13) return PALETTE_13.slice(0,13);
  if(n===7){
    return ["#000000","#FF6B6B","#FFD166","#06D6A0","#118AB2","#9B59B6","#FF9F1C"];
  }
  if(n===4){
    return ["#000000","#FF6B6B","#06D6A0","#3A86FF"];
  }
  return PALETTE_13.slice(0,n);
}

/* === Color selection === */
function setColor(el, eventLike){
  document.querySelectorAll('.swatch').forEach(s=>s.classList.toggle('active',s===el));
  currentColor = el?.dataset?.color || "#000000";
  cursorEl.style.background = currentColor;
  const dw = el.querySelector('.dwell'); if (dw) dw.remove();
  flashEl(el);
  popCursor();
  const x = (eventLike?.clientX) ?? (window.innerWidth/2);
  const y = (eventLike?.clientY) ?? (window.innerHeight/2);
  pulseAt(x,y,currentColor);
  playClick();
}

function clearPalette(){
  while(paletteEl.firstChild) paletteEl.removeChild(paletteEl.firstChild);
}

function buildPalette(n){
  clearPalette();
  let colors = pickColors(n);

  /* In dark mode, replace the first (black) swatch with white */
  if (document.body.classList.contains('dark') && colors.length > 0){
    colors[0] = '#FFFFFF';
  }

  colors.forEach(col=>{
    const btn = document.createElement('button');
    btn.className = 'swatch';
    btn.style.background = col;
    btn.dataset.color = col;
    paletteEl.appendChild(btn);
  });

  wireSwatches();

  // 🔀 Pick a random starting color instead of the first swatch
  const swatches = document.querySelectorAll('.swatch');
  if (swatches.length){
    const rnd = Math.floor(Math.random() * swatches.length);
    setColor(swatches[rnd]);
  }

  layoutPalette();
}
/* ===== Dwell indicator ===== */
const HOVER_DWELL_MS = 650;
const SAVE_DWELL_MS  = 2500; // long gaze to save

function startDwellCircle(el, durationMs){
  let overlay = el.querySelector('.dwell');
  if(!overlay){
    overlay = document.createElement('div');
    overlay.className = 'dwell';
    el.appendChild(overlay);
  }
  overlay.style.animation = 'none';
  overlay.style.transform = 'translate(-50%, -50%) scale(0.08)';
  void overlay.offsetWidth; // restart anim
  overlay.style.animation = `dwellGrow ${durationMs}ms linear forwards`;
  return overlay;
}
function resetDwellCircle(el){
  const overlay = el.querySelector('.dwell');
  if(overlay) overlay.remove();
}

/* ===== Swatch interactions with dwell + indicator =====
   Do NOT reset the dwell while staying within the same swatch. */
function wireSwatches(){
  const swatches = document.querySelectorAll('.swatch');

  swatches.forEach(s=>{
    let timer = null;
    const clearTimer = ()=>{ if(timer){ clearTimeout(timer); timer=null; } };

    s.addEventListener('mouseenter', (e)=>{
      clearTimer();
      resetDwellCircle(s);
      startDwellCircle(s, HOVER_DWELL_MS);
      timer = setTimeout(()=>{ setColor(s, e); }, HOVER_DWELL_MS + 5);
    });

    // No reset on mousemove

    s.addEventListener('mouseleave', ()=>{
      clearTimer();
      resetDwellCircle(s);
    });

    // Click/tap selects immediately; also clear indicator
    s.addEventListener('click', (e)=>{ clearTimer(); resetDwellCircle(s); setColor(s, e); });
    s.addEventListener('touchstart', (e)=>{ clearTimer(); resetDwellCircle(s); setColor(s, e.touches?.[0] || e); });
  });
}

/* ===== Responsive palette layout ===== */
function layoutPalette(){
  const n = paletteEl.children.length;
  if(!n) return;

  const styles = getComputedStyle(sidebar);
  const padY = parseFloat(styles.getPropertyValue('padding-top')||'12')
             + parseFloat(styles.getPropertyValue('padding-bottom')||'12');
  const padX = parseFloat(styles.getPropertyValue('padding-left')||'12')
             + parseFloat(styles.getPropertyValue('padding-right')||'12');

  const reserve = brushBox.offsetHeight + saveBtn.offsetHeight + 24;

  const availH = Math.max(0, sidebar.clientHeight - padY - reserve);
  const availW = Math.max(0, sidebar.clientWidth - padX);

  const rootCS = getComputedStyle(document.documentElement);
  const uiScale = parseFloat(rootCS.getPropertyValue('--ui-scale')) || 1;

  let gap = Math.max(6, Math.min(14, Math.round(12 * uiScale)));

  const computeSize = (cols, minSize, maxSize) => {
    const rows = Math.ceil(n / cols);
    const sFromH = Math.floor((availH - (rows - 1) * gap) / rows);
    const sFromW = Math.floor((availW - (cols - 1) * gap) / cols);
    let s = Math.min(sFromH, sFromW);
    if (!Number.isFinite(s)) s = minSize;
    s = Math.max(minSize, Math.min(maxSize, s));
    return { s, rows, cols };
  };

  const nIs13 = (n >= 13);
  const minSize = nIs13 ? 24 : 28;
  const maxSize = nIs13 ? 52 : 96;

  let layout = computeSize(1, minSize, maxSize);
  if (layout.s <= minSize + 1 && n > 6) {
    layout = computeSize(2, minSize, maxSize);
  }

  sidebar.style.setProperty('--palette-cols', layout.cols.toString());
  sidebar.style.setProperty('--swatch-size', layout.s + 'px');
  sidebar.style.setProperty('--swatch-gap',  gap + 'px');

  const border  = Math.max(2, Math.round(layout.s * 0.06));
  const outline = Math.max(2, Math.round(layout.s * 0.06));
  sidebar.style.setProperty('--swatch-border',  border + 'px');
  sidebar.style.setProperty('--swatch-outline', outline + 'px');
}

/* ===== Brush sizes (with dwell hover like swatches) ===== */
const brushBtns = document.querySelectorAll('.brushBtn');
function setBrushSize(btn, eventLike){
  brushBtns.forEach(b=>b.classList.toggle('active',b===btn));
  sizeMode=btn.dataset.size;
  flashEl(btn); popCursor();
  const x = (eventLike?.clientX) ?? (window.innerWidth/2);
  const y = (eventLike?.clientY) ?? (window.innerHeight/2);
  pulseAt(x,y,'rgba(0,0,0,.45)');
  playClick();
}
function setBrushSizeByName(name){
  const btn=Array.from(brushBtns).find(b=>b.dataset.size===name) || brushBtns[1];
  setBrushSize(btn);
}

/* Add dwell-based selection to brush buttons — no reset while inside the same button */
brushBtns.forEach(b=>{
  let timer = null;
  const clearTimer = ()=>{ if(timer){ clearTimeout(timer); timer=null; } };

  b.addEventListener('mouseenter',(e)=>{
    clearTimer();
    resetDwellCircle(b);
    startDwellCircle(b, HOVER_DWELL_MS);
    timer = setTimeout(()=>{ setBrushSize(b, e); }, HOVER_DWELL_MS + 5);
  });

  b.addEventListener('mouseleave', ()=>{
    clearTimer();
    resetDwellCircle(b);
  });

  b.addEventListener('click',     (e)=>{ clearTimer(); resetDwellCircle(b); setBrushSize(b, e); });
  b.addEventListener('touchstart',(e)=>{ clearTimer(); resetDwellCircle(b); setBrushSize(b, e.touches?.[0] || e); });
});

/* ===== Save PNG helpers ===== */
function doSave(){
  // Ensure signature is present on export
  drawSignatureIfEnabled();

  // Crop out the sidebar area from the left
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const sideCssW = sidebarW();                       // CSS pixels
  const sx = Math.max(0, Math.min(canvas.width, Math.round(sideCssW * dpr))); // source x in device px
  const sw = Math.max(0, canvas.width - sx);
  const sh = canvas.height;

  if (sw > 0 && sh > 0){
    const off = document.createElement('canvas');
    off.width  = sw;
    off.height = sh;
    const octx = off.getContext('2d');
    // Copy only the drawable area (to the right of the sidebar)
    octx.drawImage(canvas, sx, 0, sw, sh, 0, 0, sw, sh);

    const link=document.createElement('a');
    link.href=off.toDataURL('image/png');
    link.download='eyegaze-art.png';
    link.click();
  } else {
    // Fallback: save full canvas if something goes wrong
    const link=document.createElement('a');
    link.href=canvas.toDataURL('image/png');
    link.download='eyegaze-art.png';
    link.click();
  }
}

/* Click to save (immediate) */
document.getElementById('saveBtn').addEventListener('click', doSave);

/* Long-dwell to save (2.5s) — no reset while staying on the button */
(function wireSaveDwell(){
  let timer = null;
  const clearTimer = ()=>{ if(timer){ clearTimeout(timer); timer=null; } };

  saveBtn.addEventListener('mouseenter', ()=>{
    clearTimer();
    resetDwellCircle(saveBtn);
    startDwellCircle(saveBtn, SAVE_DWELL_MS);
    timer = setTimeout(()=>{ doSave(); resetDwellCircle(saveBtn); }, SAVE_DWELL_MS + 5);
  });

  // No mousemove handler: we do not reset while inside the button.

  saveBtn.addEventListener('mouseleave', ()=>{
    clearTimer();
    resetDwellCircle(saveBtn);
  });

  // Touchstart: existing click behavior handles instant save if tapped.
})();
  
/* Clear via Space (not when UI focused) */
addEventListener('keydown',e=>{
  if(e.code!=='Space') return;
  const t=e.target;
  const isUI=t && (t.tagName==='INPUT'||t.tagName==='SELECT'||t.tagName==='TEXTAREA'||t.tagName==='BUTTON'||t.isContentEditable);
  if(isUI) return;
  ctx.fillStyle = getCanvasBg(); /* theme-appropriate clear */
  ctx.fillRect(0,0,innerWidth,innerHeight);
  last=null; e.preventDefault();
  drawSignatureIfEnabled(); // redraw signature after clear
});
</script>
</body>
</html>
