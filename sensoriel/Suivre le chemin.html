<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../../images/binou.png">
  <link rel="stylesheet" href="../../css/ipadteachh.css">
  <title>Tracing Labyrinth Activity</title>
  <!-- Load opentype.js from CDN (if needed) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
  <!-- Load shared themes file -->
  <script src="../../js/themes.js"></script>
  <style>
    /* Fullscreen reset */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    .game-container {
      width: 90vw;
      height: 90vh;
      max-width: 1200px;
      max-height: 800px;
      display: flex;
      position: relative;
      border-radius: 15px;
      background-color: #fff;
      overflow: hidden;
    }
    #game-content {
      position: relative;
      width: 100%;
      height: 100%;
    }
    @keyframes pulse {
      0%   { transform: scale(1); }
      50%  { transform: scale(1.35); }
      100% { transform: scale(1); }
    }
    /* SVG layer for boundaries (z-index: 2) */
    .svg-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }
    /* Interactive layer for markers and token (z-index: 3) */
    .interactive-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 3;
      /* For fade transition */
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    /* Marker styles */
    .marker {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid #444;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      background-color: white;
    }
    /* Token styles: smooth movement and drop shadow */
    .token {
      transition: left 0.1s ease-out, top 0.1s ease-out;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.5);
      cursor: grab;
      position: absolute;
      width: 80px;
      height: 80px;
      object-fit: contain;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
  </style>
</head>
<body>
  <!-- Activity overlay (shows the game index) -->
  <div id="activityNumberOverlay">
    <div class="number-text"></div>
  </div>
  
  <!-- Main game container -->
  <div class="game-container">
    <div id="game-content"></div>
  </div>
  
  <!-- Reinforcer overlay (common for all games) -->
  <div id="reinforcerOverlay">
    <button id="reinforcerButton" aria-label="Voir la vidéo de renforcement"></button>
    <video id="reinforcerVideo"
           playsinline
           webkit-playsinline
           disablepictureinpicture
           controlslist="nodownload noremoteplayback"
           preload="auto">
      <source id="reinforcerVideoSource" src="" type="video/mp4">
      Votre navigateur ne supporte pas la balise vidéo.
    </video>
    <div id="videoOverlayCover"></div>
  </div>
  
  <!-- Audio elements -->
  <audio id="error-sound" src="" preload="auto"></audio>
  <audio id="word-reward-sound" src="" preload="auto"></audio>
  <audio id="final-reward-sound" src="" preload="auto"></audio>
  
  <script>
    // Global variables to hold repetition count and target
    let repetitionCount = 0;
    let repetitionTarget = 1; // default
      
    document.addEventListener('DOMContentLoaded', function() {
      // --- Theme/Audio Setup (unchanged) ---
      const selections = JSON.parse(localStorage.getItem('gameSelections')) || {};
      const mediaOption = selections.mediaOption || "";
      const themeData = (window.themes && window.themes[mediaOption])
                        ? window.themes[mediaOption]
                        : window.themes["default"] || {};
      
      document.getElementById('error-sound').src = themeData.errorSound || "../../sounds/error.mp3";
      document.getElementById('word-reward-sound').src = themeData.reinforcerSound || "../../sounds/rooster.mp3";
      document.getElementById('final-reward-sound').src = themeData.finalRewardSound || "../../sounds/victory.mp3";
      
      const reinforcerVideoSource = document.getElementById('reinforcerVideoSource');
      if (themeData.reinforcerVideos && themeData.reinforcerVideos.length > 0) {
        reinforcerVideoSource.src = themeData.reinforcerVideos[Math.floor(Math.random() * themeData.reinforcerVideos.length)];
      } else {
        reinforcerVideoSource.src = "../../videos/africa.mp4";
      }
      const reinforcerVideo = document.getElementById('reinforcerVideo');
      reinforcerVideo.load();
      
      let overallGameIndex = parseInt(localStorage.getItem('currentGameIndex'), 10);
      if (isNaN(overallGameIndex)) {
        alert("Game selections not found. Redirecting to main page.");
        window.location.href = "main.html";
        return;
      }
      const activityOverlay = document.getElementById('activityNumberOverlay');
      const numberTextEl = activityOverlay.querySelector('.number-text');
      numberTextEl.textContent = (overallGameIndex + 1).toString();
      activityOverlay.style.display = 'flex';
      
      function hideOverlayAndStart() {
        if (themeData.startSound) {
          let sfx = new Audio(themeData.startSound);
          sfx.play().catch(err => console.warn('Sound play error:', err));
        }
        activityOverlay.style.display = 'none';
        document.removeEventListener('click', hideOverlayAndStart);
        document.removeEventListener('touchend', hideOverlayAndStart);
        // Initialize repetition count and target from localStorage
        repetitionCount = 0;
        repetitionTarget = parseInt(localStorage.getItem("activityRepetitions"), 10);
        if (isNaN(repetitionTarget) || repetitionTarget < 1) { 
          repetitionTarget = 1;
        }
        generatePath();
      }
      document.addEventListener('click', hideOverlayAndStart);
      document.addEventListener('touchend', hideOverlayAndStart);
      
      function navigateToNextGame() {
        const selections = JSON.parse(localStorage.getItem('gameSelections'));
        let currentGameIndex = parseInt(localStorage.getItem('currentGameIndex'), 10);
        currentGameIndex++;
        localStorage.setItem('currentGameIndex', currentGameIndex);
        if (currentGameIndex < selections.gameOrder.length) {
          window.location.href = selections.gameOrder[currentGameIndex] + ".html";
        } else {
          window.location.href = "completion.html";
        }
      }
      
      function showReinforcerSound() {
        setTimeout(() => {
          const wordRewardSound = document.getElementById('word-reward-sound');
          wordRewardSound.currentTime = 0;
          wordRewardSound.play().catch(error => console.error('Error playing reinforcer sound:', error));
        }, 200);
      }
      
      function showFinalReinforcerVideo() {
        const finalRewardSound = document.getElementById('final-reward-sound');
        finalRewardSound.currentTime = 0;
        finalRewardSound.play().catch(error => console.error('Error playing final reward sound:', error));
        const reinforcerOverlay = document.getElementById('reinforcerOverlay');
        reinforcerOverlay.style.display = 'flex';
        reinforcerVideo.style.display = 'none';
        document.getElementById('videoOverlayCover').style.display = 'none';
      }
      
      const reinforcerButton = document.getElementById('reinforcerButton');
      reinforcerButton.addEventListener('click', function() {
        reinforcerButton.style.display = 'none';
        const reinforcerOverlay = document.getElementById('reinforcerOverlay');
        reinforcerOverlay.style.background = '#000';
        reinforcerVideo.style.display = 'block';
        document.getElementById('videoOverlayCover').style.display = 'block';
        reinforcerVideo.play().catch(err => {
          console.warn('Video play failed:', err);
          hideReinforcer();
        });
      });
      reinforcerVideo.addEventListener('ended', function() {
        navigateToNextGame();
      }, { once: true });
      
      function hideReinforcer() {
        const reinforcerOverlay = document.getElementById('reinforcerOverlay');
        reinforcerOverlay.style.display = 'none';
        reinforcerButton.style.display = 'flex';
        reinforcerVideo.style.display = 'none';
        reinforcerVideo.pause();
        reinforcerVideo.currentTime = 0;
        document.getElementById('videoOverlayCover').style.display = 'none';
        reinforcerOverlay.style.background = 'rgba(0,0,0,0.8)';
      }
      
      // --- Global function to (re)generate a new tracing path ---
      function generatePath() {
        const gameContent = document.getElementById('game-content');
        gameContent.innerHTML = '';
      
        // Create container for game elements
        const pathContainer = document.createElement('div');
        pathContainer.style.position = 'relative';
        pathContainer.style.width = '100%';
        pathContainer.style.height = '100%';
        pathContainer.style.backgroundColor = 'transparent';
        pathContainer.style.border = 'none';
        pathContainer.style.overflow = 'hidden';
        gameContent.appendChild(pathContainer);
      
        // Create SVG layer (z-index 2)
        const svgNS = "http://www.w3.org/2000/svg";
        const svgElem = document.createElementNS(svgNS, "svg");
        svgElem.setAttribute("width", "100%");
        svgElem.setAttribute("height", "100%");
        svgElem.className = "svg-layer";
        pathContainer.appendChild(svgElem);
      
        // Create interactive layer (z-index 3)
        const interactiveLayer = document.createElement("div");
        interactiveLayer.className = "interactive-layer";
        interactiveLayer.style.top = "0";
        interactiveLayer.style.left = "0";
        interactiveLayer.style.width = "100%";
        interactiveLayer.style.height = "100%";
        pathContainer.appendChild(interactiveLayer);
      
        // --- Determine allowed zone width and hard mode from localStorage ---
        let offsetDist = 52; // default (medium)
        let hardMode = false;
        const selectionsObj = JSON.parse(localStorage.getItem('gameSelections'));
        if (selectionsObj && selectionsObj.gameOrder.includes("Suivre le chemin")) {
          const index = selectionsObj.gameOrder.indexOf("Suivre le chemin");
          if (selectionsObj.gameOptions &&
              selectionsObj.gameOptions[index] &&
              selectionsObj.gameOptions[index]["Largeur du tracé"]) {
            const tracingOption = selectionsObj.gameOptions[index]["Largeur du tracé"];
            // Mapping: "hard" → narrow (26px), "medium" → medium (52px), "easy" → wide (76px)
            switch(tracingOption) {
              case "hard":
                offsetDist = 26;
                break;
              case "easy":
                offsetDist = 76;
                break;
              case "medium":
              default:
                offsetDist = 52;
                break;
            }
          }
          if (selectionsObj.gameOptions &&
              selectionsObj.gameOptions[index] &&
              selectionsObj.gameOptions[index]["Hard mode"] === "true") {
            hardMode = true;
          }
        }
      
        // --- Generate a twisty randomized path using a Catmull-Rom spline ---
        const containerWidth = interactiveLayer.clientWidth;
        const containerHeight = interactiveLayer.clientHeight;
        const numPoints = 8;
        const keyPoints = [];
        keyPoints.push({
          x: containerWidth * 0.1,
          y: containerHeight * (0.3 + Math.random() * 0.4)
        });
        for (let i = 1; i < numPoints - 1; i++) {
          keyPoints.push({
            x: containerWidth * (0.1 + i * 0.8 / (numPoints - 1)) + (Math.random() - 0.5) * 50,
            y: containerHeight * (0.2 + Math.random() * 0.6)
          });
        }
        keyPoints.push({
          x: containerWidth * 0.9,
          y: containerHeight * (0.3 + Math.random() * 0.4)
        });
      
        function catmullRomToBezier(points) {
          let d = "M " + points[0].x + " " + points[0].y;
          for (let i = 0; i < points.length - 1; i++) {
            const p0 = i === 0 ? points[0] : points[i - 1];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = (i + 2 < points.length) ? points[i + 2] : p2;
            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;
            d += " C " + cp1x + " " + cp1y + ", " + cp2x + " " + cp2y + ", " + p2.x + " " + p2.y;
          }
          return d;
        }
      
        const pathData = catmullRomToBezier(keyPoints);
      
        // Create the main (invisible) path
        const mainPath = document.createElementNS(svgNS, "path");
        mainPath.setAttribute("d", pathData);
        mainPath.setAttribute("stroke", "none");
        mainPath.setAttribute("fill", "none");
        svgElem.appendChild(mainPath);
      
        // --- Generate parallel boundaries from the main path ---
        function generateOffsetBoundaries(pathElem, offset, samples = 150) {
          const totalLength = pathElem.getTotalLength();
          const upperPoints = [];
          const lowerPoints = [];
          for (let i = 0; i <= samples; i++) {
            const l = (i / samples) * totalLength;
            const p = pathElem.getPointAtLength(l);
            const delta = 0.1;
            const p2 = pathElem.getPointAtLength(Math.min(l + delta, totalLength));
            let dx = p2.x - p.x;
            let dy = p2.y - p.y;
            const mag = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= mag;
            dy /= mag;
            const nx = -dy, ny = dx;
            upperPoints.push({ x: p.x + nx * offset, y: p.y + ny * offset });
            lowerPoints.push({ x: p.x - nx * offset, y: p.y - ny * offset });
          }
          return { upperPoints, lowerPoints };
        }
      
        const { upperPoints, lowerPoints } = generateOffsetBoundaries(mainPath, offsetDist, 150);
      
        function createPolyline(points) {
          const polyline = document.createElementNS(svgNS, "polyline");
          const pointsAttr = points.map(p => `${p.x},${p.y}`).join(" ");
          polyline.setAttribute("points", pointsAttr);
          // Styling for boundaries
          polyline.setAttribute("stroke", "black");
          polyline.setAttribute("stroke-width", "5");
          polyline.setAttribute("fill", "none");
          polyline.setAttribute("stroke-linecap", "round");
          polyline.setAttribute("stroke-linejoin", "round");
          // Uncomment for a dashed effect:
          // polyline.setAttribute("stroke-dasharray", "8,4");
          return polyline;
        }
      
        const upperBoundary = createPolyline(upperPoints);
        const lowerBoundary = createPolyline(lowerPoints);
        svgElem.appendChild(upperBoundary);
        svgElem.appendChild(lowerBoundary);
      
        // --- Markers ---
        const totalLen = mainPath.getTotalLength();
        const actualStartPoint = mainPath.getPointAtLength(0);
        const actualEndPoint = mainPath.getPointAtLength(totalLen);
      
        function createMarker(point, text, bgColor) {
          const marker = document.createElement("div");
          marker.className = "marker";
          marker.style.left = (point.x - 30) + "px";
          marker.style.top = (point.y - 30) + "px";
          marker.style.backgroundColor = bgColor;
          marker.textContent = text;
          return marker;
        }
      
        const startMarker = createMarker(actualStartPoint, "Start", "#8be");
        const endMarker = createMarker(actualEndPoint, "End", "#cfc");
        interactiveLayerAppend(interactiveLayer, startMarker);
        interactiveLayerAppend(interactiveLayer, endMarker);
      
        // --- Draggable Token ---
        const token = document.createElement("img");
        token.src = (themeData.transparentPNGs && themeData.transparentPNGs.length > 0)
                    ? themeData.transparentPNGs[Math.floor(Math.random() * themeData.transparentPNGs.length)]
                    : "../../images/fallback.png";
        token.className = "token";
        token.style.left = (actualStartPoint.x - 40) + "px";
        token.style.top = (actualStartPoint.y - 40) + "px";
        interactiveLayerAppend(interactiveLayer, token);
      
        let lastAllowedLeft = parseFloat(token.style.left);
        let lastAllowedTop = parseFloat(token.style.top);
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;
      
        function distance(p1, p2) {
          return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }
      
        function distanceToPath(point, pathElem, samples = 150) {
          const totalLength = pathElem.getTotalLength();
          let minDist = Infinity;
          for (let i = 0; i <= samples; i++) {
            const samplePoint = pathElem.getPointAtLength((i / samples) * totalLength);
            const d = distance({ x: samplePoint.x, y: samplePoint.y }, point);
            if (d < minDist) {
              minDist = d;
            }
          }
          return minDist;
        }
      
        const threshold = offsetDist;
      
        // Helper function to reset the token to the start position
        function resetToken() {
          token.style.left = (actualStartPoint.x - 40) + "px";
          token.style.top = (actualStartPoint.y - 40) + "px";
          lastAllowedLeft = parseFloat(token.style.left);
          lastAllowedTop = parseFloat(token.style.top);
        }
      
        token.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          isDragging = true;
          token.style.cursor = "grabbing";
          const rect = token.getBoundingClientRect();
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;
          token.setPointerCapture(e.pointerId);
        });
      
        token.addEventListener("pointermove", (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const containerRect = interactiveLayer.getBoundingClientRect();
          let newLeft = e.clientX - containerRect.left - offsetX;
          let newTop = e.clientY - containerRect.top - offsetY;
      
          const fullMaxLeft = interactiveLayer.clientWidth - token.clientWidth;
          const fullMaxTop = interactiveLayer.clientHeight - token.clientHeight;
          newLeft = Math.max(0, Math.min(newLeft, fullMaxLeft));
          newTop = Math.max(0, Math.min(newTop, fullMaxTop));
      
          const tokenCenter = {
            x: newLeft + token.clientWidth / 2,
            y: newTop + token.clientHeight / 2
          };
          const d = distanceToPath(tokenCenter, mainPath, 150);
          if (d < threshold) {
            lastAllowedLeft = newLeft;
            lastAllowedTop = newTop;
            token.style.left = newLeft + "px";
            token.style.top = newTop + "px";
          } else {
            // In hard mode, play mistake sound and reset token immediately.
            if (hardMode && d >= threshold * 0.95) {
              const errorSound = document.getElementById('error-sound');
              errorSound.currentTime = 0;
              errorSound.play().catch(err => console.warn(err));
              resetToken();
            } else {
              token.style.left = lastAllowedLeft + "px";
              token.style.top = lastAllowedTop + "px";
            }
          }
        });
      
        token.addEventListener("pointerup", (e) => {
          e.preventDefault();
          isDragging = false;
          token.style.cursor = "grab";
          token.releasePointerCapture(e.pointerId);
      
          const tokenRect = token.getBoundingClientRect();
          const tokenCenter = {
            x: tokenRect.left + tokenRect.width / 2,
            y: tokenRect.top + tokenRect.height / 2
          };
          const endRect = endMarker.getBoundingClientRect();
          const endCenter = {
            x: endRect.left + endRect.width / 2,
            y: endRect.top + endRect.height / 2
          };
          const dToEnd = distance(tokenCenter, endCenter);
      
          if (dToEnd < 50) {
            // Successful completion of a trace.
            if (repetitionCount < repetitionTarget - 1) {
              repetitionCount++;
              // Play the reinforcer sound immediately
              showReinforcerSound();
              // Fade out the interactive layer, then generate a new path.
              interactiveLayer.style.opacity = 0;
              setTimeout(() => {
                // Generate a new randomized path (keeping the same repetition count)
                generatePath();
                // Fade in the new path.
                interactiveLayer.style.opacity = 1;
              }, 600); // delay should be slightly longer than the CSS transition duration
            } else {
              // Last repetition reached – proceed to final video.
              showFinalReinforcerVideo();
            }
          }
        });
      
        console.log("Tracing activity started with enhanced options!");
      
        // Helper function to append elements to the interactive layer (z-index: 3)
        function interactiveLayerAppend(parent, child) {
          child.style.position = "absolute";
          parent.appendChild(child);
        }
      }
      // ----------------------------------------------------------------------------
      // END OF GAME-SPECIFIC LOGIC
      // ----------------------------------------------------------------------------
    });
  </script>
</body>
</html>
