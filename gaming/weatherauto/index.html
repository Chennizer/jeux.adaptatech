<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-fr="Jeux météo automatiques" data-en="Automatic Weather Games">Jeux météo automatiques</title>
  <link rel="stylesheet" href="../../css/menu.css">
  <link rel="stylesheet" href="../../css/global.css">
  <link rel="stylesheet" href="../../css/layout.css">
  <link rel="stylesheet" href="../../css/components.css">
  <style>
    :root {
      --weather-accent: #d36135;
      --weather-accent-dark: #b04d29;
      --weather-highlight: #ff4d4d;
    }

    body.weather-menu {
      background-color: #dff3e4;
      color: #294936;
    }

    main[hidden] {
      display: none;
    }

    .hero-minimalist.weather-hero {
      background: #dff3e4;
      padding-bottom: 12px;
    }

    .hero-minimalist.weather-hero h1 {
      margin-bottom: 6px;
    }

    .hero-minimalist.weather-hero p {
      max-width: 720px;
      margin: 0 auto;
    }

    .weather-panel {
      max-width: 1080px;
      margin: 0 auto;
      padding: 0 24px 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .mode-selector {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      background: #ffffff;
      border: 3px solid #623b5a;
      border-radius: 12px;
      padding: 18px 24px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
    }

    .mode-selector button {
      border: none;
      background: var(--weather-accent);
      color: #ffffff;
      font-size: 1.6rem;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: transform 160ms ease, background 160ms ease;
    }

    .mode-selector button:focus-visible {
      outline: 3px solid rgba(211, 97, 53, 0.45);
      outline-offset: 3px;
    }

    @media (hover: hover) and (pointer: fine) {
      .mode-selector button:hover {
        background: var(--weather-accent-dark);
        transform: translateY(-2px);
      }
    }

    .mode-copy {
      text-align: center;
      max-width: 480px;
    }

    .mode-copy h2 {
      margin: 0 0 6px;
      font-size: clamp(1.2rem, 2.6vmin, 1.6rem);
    }

    .mode-copy p {
      margin: 0;
      font-size: clamp(0.95rem, 2.2vmin, 1.1rem);
      color: #3c5c46;
    }

    .mode-hint {
      text-align: center;
      margin: 0;
      color: #3c5c46;
      font-size: clamp(0.9rem, 2vmin, 1rem);
    }

    .tile-container.weather-grid {
      max-width: 1080px;
      margin: 0 auto 40px;
      padding: 0 24px 40px;
    }

    .weather-card {
      all: unset;
      display: block;
      width: 100%;
      max-width: 300px;
      height: 250px;
      border-radius: 12px;
      border: 3px solid #623b5a;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
      overflow: hidden;
      cursor: pointer;
      position: relative;
      transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
      background: #ffffff;
    }

    @media (hover: hover) and (pointer: fine) {
      .weather-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.16);
      }

      .weather-card:hover img {
        transform: scale(1.06);
      }
    }

    .weather-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      transition: transform 260ms ease;
    }

    .tile-title {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 14px 10px;
      background: rgba(0, 0, 0, 0.65);
      color: #dff3e4;
      text-align: center;
    }

    .tile-title h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .tile-title small {
      display: block;
      margin-top: 4px;
      font-size: 0.9rem;
      color: rgba(223, 243, 228, 0.85);
    }

    .weather-card:focus-visible {
      outline: 4px solid rgba(211, 97, 53, 0.35);
      outline-offset: 4px;
    }

    .weather-card.is-selected {
      border-color: var(--weather-highlight);
      box-shadow: 0 0 0 4px rgba(255, 77, 77, 0.35), 0 16px 32px rgba(0, 0, 0, 0.22);
    }

    .game-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      background: #000;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms ease;
    }

    .game-overlay[hidden] {
      display: none;
    }

    .game-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 18px;
      padding: clamp(14px, 3vmin, 26px) clamp(16px, 4vmin, 32px);
      background: linear-gradient(180deg, rgba(0,0,0,0.92) 0%, rgba(0,0,0,0.6) 100%);
      color: #ffffff;
      flex-wrap: wrap;
    }

    .overlay-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }

    .overlay-meta h2 {
      margin: 0;
      font-size: clamp(1.2rem, 2.6vmin, 1.8rem);
    }

    .overlay-meta p {
      margin: 0;
      font-size: clamp(1rem, 2.2vmin, 1.2rem);
      opacity: 0.8;
    }

    .overlay-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .back-button {
      border: none;
      border-radius: 999px;
      padding: 12px 24px;
      background: rgba(255,255,255,0.15);
      color: #ffffff;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      cursor: pointer;
      transition: background 160ms ease, transform 160ms ease;
    }

    .back-button:focus-visible {
      outline: 3px solid rgba(255, 255, 255, 0.5);
      outline-offset: 3px;
    }

    @media (hover: hover) and (pointer: fine) {
      .back-button:hover {
        background: rgba(255,255,255,0.22);
        transform: translateY(-1px);
      }
    }

    .overlay-hint {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.7);
    }

    iframe {
      flex: 1;
      border: none;
      width: 100%;
      background: #000;
    }

    .start-screen {
      position: fixed;
      inset: 0;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 60;
      transition: opacity 320ms ease;
    }

    .start-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-card {
      background: linear-gradient(160deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 24px;
      padding: clamp(32px, 6vw, 60px);
      text-align: center;
      color: #ffffff;
      max-width: min(520px, 92vw);
      box-shadow: 0 24px 60px rgba(0,0,0,0.55);
    }

    .start-card h1 {
      margin: 0 0 clamp(12px, 3vw, 24px);
      font-size: clamp(1.8rem, 4vw, 2.6rem);
    }

    .start-card p {
      margin: 0 0 clamp(24px, 4vw, 36px);
      font-size: clamp(1rem, 2.2vmin, 1.3rem);
      opacity: 0.85;
    }

    #startButton {
      font-size: clamp(1.3rem, 2.6vmin, 1.6rem);
      letter-spacing: 0.2em;
      padding: clamp(14px, 3.2vmin, 18px) clamp(36px, 8vmin, 52px);
      border-radius: 999px;
      border: none;
      color: #000000;
      background: #f2d16b;
      cursor: pointer;
      font-weight: 700;
      text-transform: uppercase;
      transition: transform 160ms ease, box-shadow 160ms ease;
    }

    #startButton:focus-visible {
      outline: 3px solid rgba(242, 209, 107, 0.55);
      outline-offset: 4px;
    }

    @media (hover: hover) and (pointer: fine) {
      #startButton:hover {
        transform: translateY(-2px);
        box-shadow: 0 18px 36px rgba(242, 209, 107, 0.35);
      }
    }

    @media (max-width: 680px) {
      .mode-selector {
        flex-direction: column;
      }

      .mode-selector button {
        width: 52px;
        height: 52px;
        font-size: 1.8rem;
      }
    }
  </style>
</head>
<body class="menu weather-menu">
  <nav class="top-menu">
    <div class="top-menu-title" data-fr="Adaptatech" data-en="Adaptatech">Portail de jeux adaptés</div>
    <ul>
      <li><a href="../../index.html" data-fr="Accueil" data-en="Home">Accueil</a></li>
      <li><a href="../../contact/index.html" data-fr="Contact" data-en="Contact">Contact</a></li>
      <li>
        <a href="#" id="language-toggle" onclick="toggleLanguage(); return false;"></a>
      </li>
    </ul>
  </nav>

  <div class="start-screen" id="startScreen">
    <div class="start-card">
      <h1 data-fr="Jeux météo automatiques" data-en="Automatic weather games">Jeux météo automatiques</h1>
      <p data-fr="Appuie sur START pour lancer en plein écran." data-en="Press START to launch in fullscreen.">Appuie sur START pour lancer en plein écran.</p>
      <button id="startButton" data-fr="START" data-en="START">START</button>
    </div>
  </div>

  <main id="mainContent" hidden>
    <div class="hero-minimalist weather-hero">
      <h1 data-fr="Choisis la météo" data-en="Choose the weather">Choisis la météo</h1>
      <p data-fr="Reste en plein écran et utilise le mode qui te convient pour naviguer dans les jeux." data-en="Stay in fullscreen and use the mode that suits you to browse the games.">Reste en plein écran et utilise le mode qui te convient pour naviguer dans les jeux.</p>
    </div>

    <section class="weather-panel">
      <div class="mode-selector" id="modeSelector" tabindex="0">
        <button id="modePrev" type="button" aria-label="Mode précédent" data-fr-label="Mode précédent" data-en-label="Previous mode">&#8249;</button>
        <div class="mode-copy">
          <h2 id="modeLabel" data-fr="Mode tactile" data-en="Touch mode">Mode tactile</h2>
          <p id="modeDescription" data-fr="Utilise l'écran tactile ou la souris pour choisir un jeu." data-en="Use the touchscreen or mouse to choose a game.">Utilise l'écran tactile ou la souris pour choisir un jeu.</p>
        </div>
        <button id="modeNext" type="button" aria-label="Mode suivant" data-fr-label="Mode suivant" data-en-label="Next mode">&#8250;</button>
      </div>
      <p class="mode-hint" id="modeHint" data-fr="Fais défiler avec la molette ou clique sur les flèches pour changer de mode. En mode choix multiples ou balayage, Entrée avance la sélection et Espace lance le jeu." data-en="Scroll with the wheel or tap the arrows to change modes. In multiple choice or scanning modes, Enter advances the selection and Space starts the game.">Fais défiler avec la molette ou clique sur les flèches pour changer de mode. En mode choix multiples ou balayage, Entrée avance la sélection et Espace lance le jeu.</p>
    </section>

    <div class="tile-container weather-grid" role="list">
      <button class="weather-card" type="button" role="listitem"
        data-index="0"
        data-src="../sunauto/index.html"
        data-title-fr="Soleil"
        data-title-en="Sun"
        data-description-fr="Ambiance lumineuse"
        data-description-en="Warm sunshine"
        aria-label="Soleil - Ambiance lumineuse">
        <img src="../../images/sun.png" alt="Icône de soleil">
        <div class="tile-title">
          <h3 data-fr="Soleil" data-en="Sun">Soleil</h3>
          <small data-fr="Ambiance lumineuse" data-en="Warm sunshine">Ambiance lumineuse</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="1"
        data-src="../cloudauto/index.html"
        data-title-fr="Nuages"
        data-title-en="Clouds"
        data-description-fr="Douce brise"
        data-description-en="Soft breeze"
        aria-label="Nuages - Douce brise">
        <img src="../../images/cloud.png" alt="Icône de nuage">
        <div class="tile-title">
          <h3 data-fr="Nuages" data-en="Clouds">Nuages</h3>
          <small data-fr="Douce brise" data-en="Soft breeze">Douce brise</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="2"
        data-src="../stormauto/index.html"
        data-title-fr="Pluie"
        data-title-en="Rain"
        data-description-fr="Orage relaxant"
        data-description-en="Relaxing storm"
        aria-label="Pluie - Orage relaxant">
        <img src="../../images/rain.png" alt="Icône de pluie">
        <div class="tile-title">
          <h3 data-fr="Pluie" data-en="Rain">Pluie</h3>
          <small data-fr="Orage relaxant" data-en="Relaxing storm">Orage relaxant</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="3"
        data-src="../snowauto/index.html"
        data-title-fr="Neige"
        data-title-en="Snow"
        data-description-fr="Flocons scintillants"
        data-description-en="Shimmering snow"
        aria-label="Neige - Flocons scintillants">
        <img src="../../images/snow.png" alt="Icône de neige">
        <div class="tile-title">
          <h3 data-fr="Neige" data-en="Snow">Neige</h3>
          <small data-fr="Flocons scintillants" data-en="Shimmering snow">Flocons scintillants</small>
        </div>
      </button>
    </div>
  </main>

  <div class="game-overlay" id="gameOverlay" hidden>
    <div class="overlay-bar">
      <div class="overlay-meta">
        <h2 id="overlayTitle" data-fr="" data-en=""></h2>
        <p id="overlayDescription" data-fr="" data-en=""></p>
      </div>
      <div class="overlay-actions">
        <p class="overlay-hint" id="overlayHint" data-fr="Appuie sur Q pour revenir au menu ou sur Échap pour quitter le jeu." data-en="Press Q to return to the menu or Escape to quit the game.">Appuie sur Q pour revenir au menu ou sur Échap pour quitter le jeu.</p>
        <button class="back-button" id="backButton" type="button" data-fr="Retour" data-en="Back">Retour</button>
      </div>
    </div>
    <iframe id="gameFrame" title="Jeu météo automatique" allow="autoplay; fullscreen" allowfullscreen sandbox="allow-scripts allow-same-origin allow-pointer-lock allow-orientation-lock allow-popups" tabindex="-1"></iframe>
  </div>

  <button id="langToggle" class="floating-button lang-toggle" title="Changer la langue / Switch language">EN</button>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const langBtn = document.getElementById('langToggle');
      const siteLang = localStorage.getItem('siteLanguage') || 'en';
      langBtn.textContent = (siteLang === 'fr') ? 'EN' : 'FR';

      langBtn.addEventListener('click', () => {
        toggleLanguage();
        const updatedLang = localStorage.getItem('siteLanguage') || 'en';
        langBtn.textContent = (updatedLang === 'fr') ? 'EN' : 'FR';
      });
    });
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      fetch('../../footer.html')
        .then(response => response.text())
        .then(data => {
          document.body.insertAdjacentHTML('beforeend', data);
        });
    });
  </script>

  <script>
    (function() {
      const startScreen = document.getElementById('startScreen');
      const startButton = document.getElementById('startButton');
      const mainContent = document.getElementById('mainContent');
      const gameOverlay = document.getElementById('gameOverlay');
      const gameFrame = document.getElementById('gameFrame');
      const backButton = document.getElementById('backButton');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayDescription = document.getElementById('overlayDescription');
      const modeSelector = document.getElementById('modeSelector');
      const modePrev = document.getElementById('modePrev');
      const modeNext = document.getElementById('modeNext');
      const modeLabel = document.getElementById('modeLabel');
      const modeDescription = document.getElementById('modeDescription');
      const fsKey = 'weatherAutoFS';
      const cards = Array.from(document.querySelectorAll('.weather-card'));

      const getSiteLanguage = () => (localStorage.getItem('siteLanguage') || 'fr');

      const applyCurrentLanguage = element => {
        if (!element) return;
        const lang = getSiteLanguage();
        const attr = lang === 'fr' ? 'data-fr' : 'data-en';
        const text = element.getAttribute(attr);
        if (text) {
          element.textContent = text;
        }
      };

      const updateModeButtonLabels = () => {
        const lang = getSiteLanguage();
        const prevLabel = modePrev.getAttribute(lang === 'fr' ? 'data-fr-label' : 'data-en-label');
        const nextLabel = modeNext.getAttribute(lang === 'fr' ? 'data-fr-label' : 'data-en-label');
        if (prevLabel) {
          modePrev.setAttribute('aria-label', prevLabel);
        }
        if (nextLabel) {
          modeNext.setAttribute('aria-label', nextLabel);
        }
      };

      const modes = [
        {
          id: 'touch',
          labelFr: 'Mode tactile',
          labelEn: 'Touch mode',
          descriptionFr: "Utilise l'écran tactile ou la souris pour choisir un jeu.",
          descriptionEn: 'Use the touchscreen or mouse to choose a game.'
        },
        {
          id: 'multiple',
          labelFr: 'Mode choix multiples',
          labelEn: 'Multiple choice mode',
          descriptionFr: 'Appuie sur Entrée pour faire défiler la sélection. Appuie sur Espace pour lancer le jeu surligné.',
          descriptionEn: 'Press Enter to move the highlight forward. Press Space to launch the highlighted game.'
        },
        {
          id: 'scan',
          labelFr: 'Mode balayage',
          labelEn: 'Scanning mode',
          descriptionFr: 'La sélection avance automatiquement toutes les 10 secondes. Appuie sur Espace pour lancer le jeu en surbrillance.',
          descriptionEn: 'The selection advances every 10 seconds. Press Space to start the highlighted game.'
        }
      ];

      let modeIndex = 0;
      let highlightIndex = 0;
      let scanTimer = null;
      let lastCard = null;
      let gameActive = false;

      function focusGameFrame() {
        if (!gameActive) return;
        const tryFocus = () => {
          try {
            gameFrame.contentWindow?.focus();
          } catch {}
          if (typeof gameFrame.focus === 'function') {
            try {
              gameFrame.focus({ preventScroll: true });
            } catch {
              gameFrame.focus();
            }
          }
        };
        tryFocus();
        setTimeout(tryFocus, 120);
      }

      function revealMain() {
        startScreen.classList.add('hidden');
        mainContent.hidden = false;
        setTimeout(() => startScreen.remove(), 420);
      }

      async function enterFullscreen() {
        const el = document.documentElement;
        if (document.fullscreenElement === el) return true;
        const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
        if (!req) return false;
        try {
          await req.call(el);
          return true;
        } catch {
          return false;
        }
      }

      function setOverlayLabels(card) {
        overlayTitle.setAttribute('data-fr', card.dataset.titleFr || '');
        overlayTitle.setAttribute('data-en', card.dataset.titleEn || '');
        overlayDescription.setAttribute('data-fr', card.dataset.descriptionFr || '');
        overlayDescription.setAttribute('data-en', card.dataset.descriptionEn || '');
        applyCurrentLanguage(overlayTitle);
        applyCurrentLanguage(overlayDescription);
        if (typeof updateLanguage === 'function') {
          updateLanguage();
        }
      }

      function clearSelection() {
        cards.forEach(card => {
          card.classList.remove('is-selected');
          card.removeAttribute('aria-selected');
        });
      }

      function highlightCard(index) {
        if (!cards.length) return;
        const normalized = ((index % cards.length) + cards.length) % cards.length;
        clearSelection();
        const card = cards[normalized];
        if (card) {
          card.classList.add('is-selected');
          card.setAttribute('aria-selected', 'true');
        }
        highlightIndex = normalized;
      }

      function stopScanTimer() {
        if (scanTimer) {
          clearInterval(scanTimer);
          scanTimer = null;
        }
      }

      function startScanTimer() {
        stopScanTimer();
        scanTimer = setInterval(() => {
          advanceHighlight();
        }, 10000);
      }

      function applyMode(newIndex) {
        modeIndex = ((newIndex % modes.length) + modes.length) % modes.length;
        const mode = modes[modeIndex];
        modeLabel.setAttribute('data-fr', mode.labelFr);
        modeLabel.setAttribute('data-en', mode.labelEn);
        modeDescription.setAttribute('data-fr', mode.descriptionFr);
        modeDescription.setAttribute('data-en', mode.descriptionEn);
        applyCurrentLanguage(modeLabel);
        applyCurrentLanguage(modeDescription);
        updateModeButtonLabels();
        if (typeof updateLanguage === 'function') {
          updateLanguage();
        }

        modeSelector.setAttribute('data-mode', mode.id);
        stopScanTimer();
        clearSelection();

        if (mode.id === 'multiple' || mode.id === 'scan') {
          highlightCard(0);
          if (mode.id === 'scan' && !gameActive) {
            startScanTimer();
          }
        }
      }

      function advanceHighlight() {
        if (!cards.length) return;
        const nextIndex = (highlightIndex + 1) % cards.length;
        highlightCard(nextIndex);
      }

      async function showGame(card) {
        if (!card) return;
        lastCard = card;
        stopScanTimer();
        setOverlayLabels(card);
        const src = card.dataset.src;
        if (src) {
          gameFrame.src = src;
        }
        gameActive = true;
        sessionStorage.setItem(fsKey, '1');
        await enterFullscreen();
        gameOverlay.removeAttribute('hidden');
        requestAnimationFrame(() => {
          gameOverlay.classList.add('visible');
          focusGameFrame();
        });
      }

      function closeGame() {
        if (!gameActive) return;
        gameOverlay.classList.remove('visible');
        setTimeout(() => {
          if (!gameOverlay.classList.contains('visible')) {
            gameActive = false;
            gameOverlay.setAttribute('hidden', '');
            gameFrame.src = 'about:blank';
            const focusTarget = lastCard && mainContent.contains(lastCard) ? lastCard : cards[0];
            if (focusTarget && typeof focusTarget.focus === 'function') {
              try {
                focusTarget.focus({ preventScroll: true });
              } catch {
                focusTarget.focus();
              }
            }
            if (modes[modeIndex].id === 'scan') {
              startScanTimer();
            }
          }
        }, 240);
      }

      function selectHighlightedCard() {
        const card = cards[highlightIndex];
        if (card) {
          showGame(card);
        }
      }

      startButton.addEventListener('click', async () => {
        sessionStorage.setItem(fsKey, '1');
        await enterFullscreen();
        applyMode(modeIndex);
        revealMain();
        setTimeout(() => {
          if (typeof modeSelector.focus === 'function') {
            try {
              modeSelector.focus({ preventScroll: true });
            } catch {
              modeSelector.focus();
            }
          }
        }, 200);
      });

      modePrev.addEventListener('click', () => {
        applyMode(modeIndex - 1);
      });

      modeNext.addEventListener('click', () => {
        applyMode(modeIndex + 1);
      });

      modeSelector.addEventListener('wheel', event => {
        event.preventDefault();
        if (event.deltaY > 0) {
          applyMode(modeIndex + 1);
        } else if (event.deltaY < 0) {
          applyMode(modeIndex - 1);
        }
      }, { passive: false });

      modeSelector.addEventListener('keydown', event => {
        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          applyMode(modeIndex - 1);
        } else if (event.key === 'ArrowRight') {
          event.preventDefault();
          applyMode(modeIndex + 1);
        }
      });

      cards.forEach(card => {
        card.addEventListener('click', () => {
          if (!mainContent.hidden) {
            if (modes[modeIndex].id !== 'touch') {
              highlightIndex = cards.indexOf(card);
              highlightCard(highlightIndex);
            }
            showGame(card);
          }
        });
      });

      backButton.addEventListener('click', () => {
        closeGame();
      });

      document.addEventListener('click', event => {
        const target = event.target;
        if (!target) return;
        if (target.id === 'language-toggle' || target.id === 'langToggle') {
          setTimeout(() => {
            applyCurrentLanguage(modeLabel);
            applyCurrentLanguage(modeDescription);
            updateModeButtonLabels();
          }, 0);
        }
      });

      document.addEventListener('keydown', event => {
        if (!gameOverlay.hasAttribute('hidden')) {
          const key = event.key ? event.key.toLowerCase() : '';
          if (key === 'escape' || key === 'esc') {
            event.preventDefault();
            closeGame();
          } else if (key === 'q') {
            event.preventDefault();
            closeGame();
          }
          return;
        }

        const mode = modes[modeIndex];
        if (mode.id === 'multiple') {
          if (event.key === 'Enter') {
            event.preventDefault();
            advanceHighlight();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            selectHighlightedCard();
          }
        } else if (mode.id === 'scan') {
          if (event.key === 'Enter') {
            event.preventDefault();
            advanceHighlight();
            startScanTimer();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            selectHighlightedCard();
          }
        }
      });

      gameOverlay.addEventListener('click', event => {
        if (event.target === gameOverlay) {
          closeGame();
        }
      });

      gameFrame.addEventListener('load', () => {
        if (!gameActive) return;
        try {
          const frameWindow = gameFrame.contentWindow;
          if (frameWindow) {
            const keyListener = event => {
              if (!gameActive) {
                frameWindow.removeEventListener('keydown', keyListener);
                return;
              }
              const key = event.key ? event.key.toLowerCase() : '';
              if (key === 'escape' || key === 'esc') {
                event.preventDefault();
                closeGame();
              } else if (key === 'q') {
                event.preventDefault();
                closeGame();
              }
            };
            frameWindow.addEventListener('keydown', keyListener);
          }
        } catch {}
        focusGameFrame();
      });

      applyMode(modeIndex);
      updateModeButtonLabels();
    })();
  </script>

  <script src="../../js/translationmain.js"></script>
</body>
</html>
