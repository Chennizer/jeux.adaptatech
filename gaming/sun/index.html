<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title data-fr="Soleil : Jeu Switch" data-en="Sun: Switch Game" data-ja="太陽：スイッチゲーム">Soleil : Jeu Switch</title>

<!-- p5.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>

<!-- Shared overlay/menu styling -->
<link rel="stylesheet" href="../../css/otherswitch.css">

<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#5aa9e6;}
  canvas{display:block;position:fixed;top:0;left:0; z-index:0;}

  /* ===== Landing overlay styling (pill language toggle) ===== */
  :root{
    --c1:#FF595E; --c2:#FF924C; --c3:#FFCA3A; --c4:#8AC926;
    --c5:#1982C4; --c6:#6A4C93; --c7:#B5179E; --c8:#2EC4B6;
    --teal:#04c8bb;
    --pill-bg:#0b0f12;
  }
  *{box-sizing:border-box;}
  body{color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;}

  /* Landing overlay */
  #promptOverlay{
    position:fixed; inset:0; z-index:10000;
    background:#000; display:flex; flex-direction:column;
    align-items:center; justify-content:center; text-align:center; padding:1.25rem;
  }
  #promptOverlay p{font-size:1.2rem; max-width:min(900px,85%); margin:0 0 1.25rem 0; opacity:.95;}
  #modeSelect{display:flex; gap:1rem; margin-bottom:1.5rem; flex-wrap:wrap; justify-content:center;}
  #modeSelect button{
    padding:.8rem 1.1rem; min-width:11rem; border:none; border-radius:10px;
    background:rgba(255,255,255,.1); color:#fff; cursor:pointer; font-size:1rem;
    transition:background .2s ease, transform .05s ease;
  }
  #modeSelect button:hover{background:rgba(255,255,255,.2);}
  #modeSelect button.active{background:#00bfff; color:#000; font-weight:700;}
  #startButton{
    padding:1rem 2rem; font-size:1.25rem; border:none; border-radius:12px;
    background:var(--c5); color:#fff; cursor:pointer;
  }
  #startButton:hover{filter:brightness(1.15);}

  /* Top-right language toggle – pill style */
  #langToggle{
    position:fixed; top:14px; right:14px; z-index:10001;
    display:flex; align-items:center; justify-content:center;
    padding:.35rem .85rem; border-radius:999px; cursor:pointer;
    background:var(--pill-bg); color:var(--teal);
    border:2px solid var(--teal); font-weight:700; font-size:.9rem; letter-spacing:.02em;
    line-height:1; user-select:none;
    box-shadow:0 0 0 0 rgba(4,200,187,0);
    transition:box-shadow .2s ease, transform .04s ease, background .2s ease;
  }
  #langToggle:hover{ box-shadow:0 0 0 3px rgba(4,200,187,.18); }
  #langToggle:active{ transform:translateY(1px); }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>
<body>

<!-- Language toggle (fixed label; hides after Start) -->
<button id="langToggle" title="Changer de langue / Change language">FR / EN</button>

<!-- Landing overlay -->
<div id="promptOverlay">
  <p class="translate"
     data-fr="Choisissez un mode, puis appuyez sur Commencer.<br><small>Espace = rayons · Entrée = rejouer</small>"
     data-en="Select a mode, then press Start.<br><small>Space = rays · Enter = restart</small>"
     data-ja="モードを選んでから開始を押してください。<br><small>スペース＝光線・エンター＝リスタート</small>">
    Choisissez un mode, puis appuyez sur Commencer.<br><small>Espace = rayons · Entrée = rejouer</small>
  </p>
  <div id="modeSelect">
    <button data-mode="normal" class="active translate"
            data-fr="Mode normal (plusieurs clics)" data-en="Normal mode (many presses of the switch)" data-ja="通常モード（複数回押す）">Mode normal</button>
    <button data-mode="rapid" class="translate"
            data-fr="Mode éclair (1 clic)" data-en="Lightning mode (1 press)" data-ja="稲妻モード（1回押す）">Mode éclair (1 clic)</button>
  </div>
  <button id="startButton" class="translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
</div>

<script src="../../js/translationmain.js"></script>
<script>
document.getElementById('langToggle')?.addEventListener('pointerup', toggleLanguage);


/* === AUDIO & ÉTAT ================================================= */
let gameStarted=false, gameOver=false;
const ambiencePath='../../sounds/sun/sunnyday.mp3';
const finishPath  ='../../sounds/sun/fanfare.mp3';
const rayPath     ='../../sounds/sun/sun1.mp3';
let ambience, raySound, finishSound;
let volMusic=.5, volSFX=.5;
let isSFXMuted=false, isMusicMuted=false;

/* === VISUEL ======================================================= */
const MAX_RAYS=8;
let rays=[], rayCount=0;
let sunRadius, innerR, longLen, shortLen, strokeW;
let basePulse=1, sunRot=0;

/* finale pilotée par la durée réelle du morceau */
let finalStage=0;              // 0=off, 1=en cours, 2=done
let finalScale=1;
let warmFlashAlpha=0;
let screenFlashAlpha=0, FLASH_INITIAL=80, FLASH_STEP=FLASH_INITIAL/120;
let finishStartMs=null;
let finishDurMs=6000;          // fallback
let finalProgress=0;           // 0..1

let lastTap=-Infinity, tapDelay=2000;
let rapidMode=false;

/* décor */
let clouds=[], balloon, birds=[];
let balloonImg, birdImg;
let extraBalloons=[];
let balloonsReleased=false;

/* confetti (boostés) */
let confetti=[];
let confettiMidBurstDone=false;
const CONFETTI_COLS=[[255,210,100],[255,177,66],[255,235,150],[255,196,100],[255,225,120]];

/* Buffers */
let skyBuffer;
let haloBuffer;

/* gestion du refresh du ciel (3) */
let lastSkyUpdateFrame = -999;

/* ---------- preload ---------- */
function preload(){
  ambience   = loadSound(ambiencePath);
  raySound   = loadSound(rayPath);
  finishSound= loadSound(finishPath);
  balloonImg = loadImage('../../images/sun/montgolfiere1.png');
  birdImg    = loadImage('../../images/sun/oiseau_vol.png');
}

/* ---------- setup ---------- */
function setup(){
  createCanvas(windowWidth,windowHeight);
  angleMode(RADIANS);
  for(let i=0;i<6;i++)
    clouds.push(new Cloud(random(width),random(30,height/2),
               random(80,250),random(40,120),random(0.5,2)));
  balloon = new Balloon(
    width+random(50,150), random(height/4,height/2-50),
    random(0.5,0.6), 0.25, 'horizontal');
  for(let i=0;i<3;i++) birds.push(new Bird());

  buildSkyBuffer(0);
  computeSizes();
  buildHaloBuffer();

  /* ===== Overlay wiring ===== */
  const modeButtons=[...document.querySelectorAll('#modeSelect button')];
  let selectedMode='normal';
  modeButtons.forEach(btn=>{
    btn.addEventListener('pointerup', ()=>{
      modeButtons.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      selectedMode = btn.dataset.mode;
    });
  });
  document.getElementById('startButton').addEventListener('pointerup', (e)=>{
    e.preventDefault();
    rapidMode = (selectedMode==='rapid');
    startGame();
    document.getElementById('promptOverlay')?.remove();
    const lt=document.getElementById('langToggle'); if(lt) lt.style.display='none';
    document.documentElement.requestFullscreen?.().catch(()=>{});
  });
}

/* ---------- startGame (moved to global) ---------- */
function startGame(){
  gameStarted=true;
  resizeCanvas(windowWidth,windowHeight);
  computeSizes();
  buildSkyBuffer(0);
  buildHaloBuffer();
  if (typeof userStartAudio === 'function') { userStartAudio(); }
  if (ambience){
    ambience.setLoop(true);
    ambience.setVolume(isMusicMuted?0:volMusic);
    ambience.play();
  }
}

/* ---------- responsive sizes ---------- */
function computeSizes(){
  const base=min(width,height)*0.15;
  sunRadius=base;
  innerR   =base*1.2;
  longLen  =base*2.2;
  shortLen =base*2;
  strokeW  =base*0.08;
}

/* ---------- draw ---------- */
function draw(){
  if(!gameStarted){background(0);return;}

  if(finalStage===1){
    if(frameCount - lastSkyUpdateFrame >= 6){
      buildSkyBuffer(finalProgress);
      lastSkyUpdateFrame = frameCount;
    }
  }
  image(skyBuffer, 0, 0);

  birds.forEach(b=>{b.update();b.draw();});
  clouds.forEach(c=>{c.update();c.draw();});

  drawHaloAndVignette();
  drawSun();

  balloon.update(); balloon.draw();
  extraBalloons.forEach(b=>{b.update();b.draw();});

  updateAndDrawConfetti();

  if(warmFlashAlpha>1){
    noStroke(); fill(255,200,80,warmFlashAlpha);
    rect(0,0,width,height);
  }

  basePulse=1+0.05*sin(frameCount*0.03);
  if(rayCount===MAX_RAYS) handleFinalAnim();

  sunRot+=0.003;

  if(screenFlashAlpha>0){
    screenFlashAlpha=max(0,screenFlashAlpha-FLASH_STEP);
    noStroke(); fill(255,180,50,screenFlashAlpha);
    rect(0,0,width,height);
  }

  if (gameOver) {
    setTimeout(()=>{resetScene(); gameOver=false;}, 100);
  }
}

/* ---------- halo + vignette ---------- */
function buildHaloBuffer(){
  const sz = floor(min(width,height)*0.6);
  haloBuffer = createGraphics(sz, sz);
  const g = haloBuffer;
  g.noStroke();
  const cx = sz/2, cy = sz/2, maxR = sz/2;
  for(let i=0;i<80;i++){
    const t = i/79;
    const a = 80*(1-t)*(1-t);
    g.fill(255, 220, 120, a);
    const r = maxR * t;
    g.ellipse(cx, cy, r*2, r*2);
  }
}

function drawHaloAndVignette(){
  const breathe = finalStage===1 ? (0.98 + 0.04 * sin(frameCount*0.03)) : (0.995 + 0.01*sin(frameCount*0.02));
  const tightness = 2.2;
  const s = (sunRadius * tightness) / (haloBuffer.width/2);
  const haloScale = s * breathe * (finalStage===1 ? lerp(1.0, 1.25, easeInOutCubic(constrain(finalProgress,0,1))) : 1.0);

  push();
  translate(width/2, height/2);
  scale(haloScale);
  imageMode(CENTER);
  image(haloBuffer, 0, 0);
  pop();

  const vigStrength = finalStage===1 ? 70 : 30;
  const rings = 10;
  for(let i=0;i<rings;i++){
    const t = i/(rings-1);
    const alpha = vigStrength * (t*t);
    noFill(); stroke(0,0,0, alpha);
    strokeWeight( max(width,height) * 0.02 );
    ellipse(width/2, height/2, width*(1+ t*0.6), height*(1+ t*0.6));
  }
  noStroke();
}

/* ---------- Soleil + rayons ---------- */
function drawSun(){
  push();
  translate(width/2,height/2);
  rotate(sunRot);
  scale(basePulse*(finalStage?finalScale:1));
  noStroke();
  fill(255,180,50);
  ellipse(0,0,sunRadius*2,sunRadius*2);

  stroke(255,210,100);
  strokeWeight(strokeW);
  for(const r of rays){
    const n1 = noise(r.seed, frameCount*0.01);
    const n2 = noise(r.seed+1000, frameCount*0.015);
    const angOff = radians(-3 + 6*n1);
    const lenJit = -3 + 6*n2;
    const a = r.angle + angOff;
    const tgt = r.targetLen + lenJit;

    r.currLen=lerp(r.currLen, tgt, 0.06);
    r.alpha  =lerp(r.alpha,255,0.12);
    stroke(255,210,100, r.alpha);
    line(innerR*cos(a),innerR*sin(a), r.currLen*cos(a),r.currLen*sin(a));
  }
  pop();
}

/* ---------- décor ---------- */
class Cloud{
  constructor(x,y,w,h,s){this.x=x;this.y=y;this.w=w;this.h=h;this.s=s;}
  update(){
    this.x-=this.s;
    if(this.x+this.w<0){
      Object.assign(this,{
        x:width+random(20,100),y:random(30,height/2),
        w:random(80,250),h:random(40,120),s:random(0.5,2)
      });
    }
  }
  draw(){
    noStroke(); fill(255,255,255,180);
    ellipse(this.x,this.y,this.w,this.h);
    ellipse(this.x-this.w*0.4,this.y+10,this.w*0.7,this.h*0.7);
    ellipse(this.x+this.w*0.4,this.y+10,this.w*0.7,this.h*0.7);
  }
}
class Balloon{
  constructor(x,y,v,sc,mode){this.x=x;this.y=y;this.v=v;this.sc=sc;this.mode=mode;}
  switchVertical(){
    this.mode='vertical';
    this.x=random(50,width-50);
    this.y=height+random(40,150);
    this.v=random(1.2,2);
  }
  update(){
    if(finalStage>=1 && this.mode==='horizontal') this.switchVertical();
    if(this.mode==='horizontal'){
      this.x-=this.v;
      if(this.x+balloonImg.width*this.sc<0){
        this.x=width+random(50,150);
        this.y=random(height/4,height/2-50);
        this.v=random(0.5,0.6);
      }
    }else{
      this.y-=this.v;
      if(this.y+balloonImg.height*this.sc<-40){
        this.y=height+random(40,150);
        this.x=random(50,width-50);
        this.v=random(1.2,2);
      }
    }
  }
  draw(){
    push();
    translate(this.x,this.y);
    scale(this.sc);
    imageMode(CENTER);
    image(balloonImg,0,0);
    pop();
  }
}
class Bird{
  constructor(){this.reset();}
  reset(){
    this.sc=0.05;
    this.x=-birdImg.width*this.sc-random(20,100);
    this.y=random(height/6,height/2);
    this.baseV=random(1,2);
    this.phase=random(TWO_PI);
  }
  update(){
    this.x+=this.baseV*(finalStage>=1?2:1);
    this.y+=0.25*sin(frameCount*0.05+this.phase);
    if(this.x>width+40) this.reset();
  }
  draw(){
    push();
    translate(this.x,this.y);
    scale(this.sc);
    imageMode(CENTER);
    image(birdImg,0,0);
    pop();
  }
}

/* ---------- Confetti ---------- */
function spawnConfetti(){
  const n = floor(random(50,80));
  if(confetti.length > 240) confetti.length = 160;
  for(let i=0;i<n;i++){
    const angle = random(TWO_PI);
    const radius = min(width,height)*0.10;
    const x = width/2 + cos(angle)*radius*random(0.15,1);
    const y = height/2 + sin(angle)*radius*random(0.15,1);
    const sp = random(1.8,3.2);
    const vx = (x - width/2) * 0.018 + random(-0.8,0.8);
    const vy = (y - height/2) * 0.018 - sp;
    const col = random(CONFETTI_COLS);
    const rot = random(TWO_PI);
    const rotSp = random(-0.06,0.06);
    const maxLife = floor(random(600,960));
    const size = random(14,28);
    const shape = random([ 'rect', 'tri' ]);
    confetti.push({x,y,vx,vy,ax:0,ay:0.055,col,rot,rotSp,life:maxLife,maxLife,shape,size});
  }
}
function updateAndDrawConfetti(){
  for(let i=confetti.length-1;i>=0;i--){
    const p=confetti[i];
    p.vx*=0.995; p.vy*=0.997;
    p.vx+=p.ax; p.vy+=p.ay; p.x+=p.vx; p.y+=p.vy;
    p.rot+=p.rotSp; p.life-=1;
    const t=constrain(p.life/p.maxLife,0,1);
    const alpha=255*(t*t);
    fill(p.col[0],p.col[1],p.col[2],alpha); noStroke();
    push(); translate(p.x,p.y); rotate(p.rot);
    if(p.shape==='rect'){ rectMode(CENTER); rect(0,0,p.size,p.size*0.6); }
    else{ triangle(-p.size*0.6,p.size*0.5, p.size*0.6,p.size*0.5, 0,-p.size*0.6); }
    pop();
    if(p.life<=0 || p.y>height+80) confetti.splice(i,1);
  }
}

/* ---------- animation finale ---------- */
function handleFinalAnim(){
  if(finalStage===0){
    finalStage=1;
    startFinishSound();
    finishStartMs = millis();
    const dur = (finishSound && finishSound.duration && isFinite(finishSound.duration()))
                ? finishSound.duration()*1000 : null;
    finishDurMs = dur && dur>0 ? dur : 6000;
    finalProgress = 0;
    spawnConfetti();
    confettiMidBurstDone=false;
    if(!balloonsReleased){ releaseExtraBalloons(); balloonsReleased=true; }
  }
  if(finalStage===1){
    const elapsed = millis() - (finishStartMs ?? millis());
    finalProgress = constrain(elapsed / finishDurMs, 0, 1);
    if(!confettiMidBurstDone && finalProgress >= 0.48){ spawnConfetti(); confettiMidBurstDone=true; }
    const growEnd=0.20, shrinkStart=0.80;
    if(finalProgress < growEnd){
      const t = finalProgress / growEnd;
      finalScale = lerp(1.0, 1.6, t);
      warmFlashAlpha = lerp(0, 150, t);
    } else if (finalProgress < shrinkStart){
      finalScale = 1.6;
      const t = (finalProgress - growEnd) / (shrinkStart - growEnd);
      warmFlashAlpha = lerp(150, 0, t);
    } else {
      const t = (finalProgress - shrinkStart) / (1 - shrinkStart);
      finalScale = lerp(1.6, 1.0, t);
      warmFlashAlpha = 0;
    }
    const musicEnded = finishSound && !finishSound.isPlaying();
    if (finalProgress >= 1 || musicEnded){ finalStage = 2; gameOver = true; }
  }
}
function startFinishSound(){
  ambience?.fade(volMusic,0.2);
  finishSound.setVolume(isMusicMuted?0:volMusic);
  finishSound.play();
}

/* ---------- Lâcher de ballons ---------- */
function releaseExtraBalloons(){
  extraBalloons.length = 0;
  const n = floor(random(4,7));
  for(let i=0;i<n;i++){
    const b = new Balloon(random(60,width-60), height + random(40,200), random(1.1,1.9), random(0.18,0.28), 'vertical');
    b.delayStart = millis() + i*random(250,700);
    const baseUpdate = b.update.bind(b);
    b.update = function(){ if(millis() < this.delayStart) return; baseUpdate(); }
    extraBalloons.push(b);
  }
}

/* ---------- interaction ---------- */
function addAllRays(){
  for(let i=0;i<MAX_RAYS;i++){
    rays.push({ angle: i*TWO_PI/MAX_RAYS, currLen: innerR, targetLen: (i%2 ? shortLen : longLen), alpha: 0, seed: random(10000) });
  }
  rayCount=MAX_RAYS; screenFlashAlpha=FLASH_INITIAL;
}
function addSingleRay(){
  const i=rayCount;
  rays.push({ angle: i*TWO_PI/MAX_RAYS, currLen: innerR, targetLen: (i%2 ? shortLen : longLen), alpha: 0, seed: random(10000) });
  rayCount++; screenFlashAlpha=FLASH_INITIAL;
}
function trigger(){
  if(!gameStarted||gameOver||(finalStage>0 && !gameOver)) return;
  if(millis()-lastTap<tapDelay) return;
  lastTap=millis();
  if(rapidMode && rayCount===0){ addAllRays(); }
  else if(!rapidMode && rayCount<MAX_RAYS){ addSingleRay(); }
  if(!isSFXMuted && raySound){
    raySound.setVolume(volSFX);
    raySound.isLoaded()
      ? raySound.play()
      : raySound.once('loaded',()=>{ if(!isSFXMuted) raySound.play(); });
  }
}
function keyPressed(){
  if(key===' '&&gameStarted) trigger();
  if(keyCode===ENTER && gameStarted && (finalStage===0 || gameOver)){ resetScene(); }
}

/* ---------- reset ---------- */
function resetScene(){
  rays=[];rayCount=0;
  finalStage=0;finalScale=1;warmFlashAlpha=0;
  screenFlashAlpha=0;finishStartMs=null;
  finalProgress=0;
  balloonsReleased=false;
  extraBalloons.length=0;
  confetti.length=0;
  confettiMidBurstDone=false;
  buildSkyBuffer(0);
  lastSkyUpdateFrame = -999;
  balloon.mode='horizontal';balloon.v=random(0.5,0.6);
}

/* ---------- Sky buffer ---------- */
function buildSkyBuffer(pWarm){
  if(!skyBuffer || skyBuffer.width!==width || skyBuffer.height!==height){
    skyBuffer = createGraphics(width, height);
  }
  const g = skyBuffer;
  const coldTop = [90,169,230];
  const coldBot = [130,209,240];
  const warmTop = [120,185,235];
  const warmBot = [255,220,160];
  const top = lerpRGB(coldTop, warmTop, easeInOutCubic(constrain(pWarm,0,1)));
  const bot = lerpRGB(coldBot, warmBot, easeInOutCubic(constrain(pWarm,0,1)));

  for (let y = 0; y < height; y++) {
    const t = y / height;
    const c = [
      floor( lerp(top[0], bot[0], t) ),
      floor( lerp(top[1], bot[1], t) ),
      floor( lerp(top[2], bot[2], t) )
    ];
    g.stroke(c[0], c[1], c[2]);
    g.line(0, y, width, y);
  }
}

/* ---------- Resize ---------- */
function windowResized(){
  if(gameStarted){
    resizeCanvas(windowWidth,windowHeight);
    computeSizes();
    buildSkyBuffer(finalStage===1 ? finalProgress : 0);
    buildHaloBuffer();
  }
}

/* ---------- Utils ---------- */
function lerpRGB(a,b,t){ return [ lerp(a[0],b[0],t), lerp(a[1],b[1],t), lerp(a[2],b[2],t) ]; }
function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - pow(-2*x+2,3)/2; }
</script>
</body>
</html>
