<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centered Tag Style Graffiti</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Wrapper for camera shake */
        #scene-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            will-change: transform;
        }

        #wall-canvas, #game-canvas, #fx-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #wall-canvas { z-index: 0; }
        #game-canvas { z-index: 1; }
        #fx-canvas {
            z-index: 2;
            pointer-events: none;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            transition: opacity 0.5s;
        }

        h1 {
            font-size: clamp(30px, 5vw, 80px); 
            color: #FFD700;
            text-shadow: 4px 4px 0px #FF4500, -2px -2px 0 #FFF;
            margin-bottom: 20px;
            font-family: 'Verdana', sans-serif; 
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            transform: skew(-8deg);
            text-align: center; 
        }

        @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap'); 

        h1, input, button {
            font-family: 'Permanent Marker', cursive;
        }

        #mode-toggle,
        #music-toggle {
            display: flex;
            gap: 1.2rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            font-family: sans-serif;
            font-size: 0.9rem;
        }

        #mode-toggle label,
        #music-toggle label {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #music-toggle span {
            font-size: 0.9rem;
            opacity: 0.85;
            margin-right: 6px;
        }

        input[type="text"] {
            font-size: clamp(24px, 3vw, 48px); 
            padding: 15px;
            width: 60%;
            max-width: 500px; 
            text-align: center;
            background: #eee;
            border: 6px solid #000;
            color: #000;
            border-radius: 20px;
            outline: none;
            text-transform: uppercase;
            box-shadow: 5px 5px 0 #888;
        }

        #image-select {
            margin-top: 5px;
            font-size: 1rem;
            padding: 8px 14px;
            border-radius: 16px;
            border: 3px solid #000;
            background: #f4f4f4;
            color: #111;
            box-shadow: 4px 4px 0 #666;
            display: none;
        }

        button {
            margin-top: 25px;
            font-size: clamp(20px, 2.5vw, 40px); 
            padding: 15px 50px;
            background: #00BFFF;
            color: white;
            border: 4px solid white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 900;
            box-shadow: 0 0 20px #00BFFF;
            transition: transform 0.1s;
        }

        button:active { transform: scale(0.95); }
        
        .instruction {
            margin-top: 20px;
            color: #aaa;
            font-size: clamp(12px, 1.2vw, 20px);
            font-family: sans-serif;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="scene-wrapper">
        <canvas id="wall-canvas"></canvas>
        <canvas id="game-canvas"></canvas>
        <canvas id="fx-canvas"></canvas>
    </div>

    <div id="overlay">
        <h1>WILD STYLE TAGS</h1>

        <div id="mode-toggle">
            <label>
                <input type="radio" name="mode" value="text" checked>
                TEXT TAG
            </label>
            <label>
                <input type="radio" name="mode" value="image">
                IMAGE MASK
            </label>
        </div>

        <div id="music-toggle">
            <span>Ambiance:</span>
            <label>
                <input type="radio" name="music" value="punk" checked>
                PUNK ROCK
            </label>
            <label>
                <input type="radio" name="music" value="hiphop">
                HIP HOP
            </label>
        </div>

        <input type="text" id="user-input" placeholder="YOUR TAG" maxlength="15" autocomplete="off"> 

        <select id="image-select">
            <option value="../../images/cvipng/cvi2.png">CVI image 1</option>
            <option value="../../images/cvipng/cviant.png">CVI ants</option>
            <option value="../../images/cvipng/cviboccia.png">CVI boccia</option>
        </select>

        <button id="start-btn">BEGIN</button>
        <p class="instruction">Press SPACE or TAP to draw</p>
    </div>

    <script>
        const gameCanvas = document.getElementById('game-canvas');
        const wallCanvas = document.getElementById('wall-canvas');
        const fxCanvas   = document.getElementById('fx-canvas');
        const ctx  = gameCanvas.getContext('2d');
        const wCtx = wallCanvas.getContext('2d');
        const fxCtx = fxCanvas.getContext('2d');

        const sceneWrapper = document.getElementById('scene-wrapper');

        const overlay = document.getElementById('overlay');
        const inputField = document.getElementById('user-input');
        const startBtn = document.getElementById('start-btn');
        const body = document.body;

        const modeRadios = document.querySelectorAll('input[name="mode"]');
        const imageSelect = document.getElementById('image-select');

        const musicRadios = document.querySelectorAll('input[name="music"]');

        let currentMode = 'text';
        let currentMusicStyle = 'punk';

        modeRadios.forEach(r => {
            r.addEventListener('change', () => {
                currentMode = r.value;
                if (currentMode === 'text') {
                    inputField.style.display = 'block';
                    imageSelect.style.display = 'none';
                } else {
                    inputField.style.display = 'none';
                    imageSelect.style.display = 'block';
                }
            });
        });

        musicRadios.forEach(r => {
            r.addEventListener('change', () => {
                currentMusicStyle = r.value;
            });
        });

        let width, height, audioCtx, sprayNode;
        let copLightsRunning = false;

        // background music (ambiance)
        let musicAudio = null;
        let currentTrackIndex = 0;

        // placeholder playlists: replace with your own file paths
        const punkPlaylist = [
             '../../songs/grafiti/grafitipunkrock1.mp3',
            // '../../audio/punk-track2.mp3'
        ];

        const hipHopPlaylist = [
              '../../songs/grafiti/grafitihiphop1.mp3',
            // '../../audio/hiphop-track2.mp3'
        ];
        
        // --- HIGHLY STYLIZED ALPHABET ---
        const alphabet = {
            'A': [[{x:0.1,y:1.1}, {x:0.5,y:-0.1}, {x:0.9,y:1.1}], [{x:0.2,y:0.6}, {x:0.8,y:0.5}]],
            'B': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.1,y:0}], [{x:0.1,y:0}, {x:0.9,y:0.2}, {x:0.1,y:0.5}], [{x:0.1,y:0.5}, {x:1.0,y:0.8}, {x:0.1,y:1.1}]],
            'C': [[{x:0.9,y:0.2}, {x:0.5,y:-0.1}, {x:0.1,y:0.5}, {x:0.5,y:1.1}, {x:0.9,y:0.8}]],
            'D': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.1,y:0}], [{x:0.1,y:0}, {x:1.0,y:0.5}, {x:0.1,y:1.1}]],
            'E': [[{x:0.9,y:0}, {x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.9,y:1.1}], [{x:0.1,y:0.5}, {x:0.8,y:0.5}]],
            'F': [[{x:0.1,y:1.1}, {x:0.15,y:0}, {x:0.9,y:0}], [{x:0.1,y:0.5}, {x:0.8,y:0.5}]],
            'G': [[{x:0.9,y:0.2}, {x:0.5,y:-0.1}, {x:0.0,y:0.5}, {x:0.5,y:1.1}, {x:0.9,y:0.8}, {x:0.9,y:0.5}, {x:0.6,y:0.5}]],
            'H': [[{x:0.1,y:0}, {x:0.15,y:1.1}], [{x:0.9,y:0}, {x:0.85,y:1.1}], [{x:0.1,y:0.5}, {x:0.9,y:0.5}]],
            'I': [[{x:0.5,y:0}, {x:0.5,y:1.1}], [{x:0.3,y:0}, {x:0.7,y:0}], [{x:0.3,y:1.1}, {x:0.7,y:1.1}]],
            'J': [[{x:0.7,y:0}, {x:0.7,y:0.8}, {x:0.5,y:1.1}, {x:0.2,y:0.9}]],
            'K': [[{x:0.1,y:0}, {x:0.15,y:1.1}], [{x:0.9,y:0}, {x:0.1,y:0.6}, {x:1.0,y:1.1}]],
            'L': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.9,y:1.1}]],
            'M': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.5,y:0.7}, {x:0.9,y:-0.1}, {x:0.9,y:1.1}]],
            'N': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:1.1}, {x:0.9,y:-0.1}]],
            'O': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}]],
            'P': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:0.25}, {x:0.1,y:0.5}]],
            'Q': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}], [{x:0.6,y:0.7}, {x:1.0,y:1.1}]],
            'R': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:0.25}, {x:0.1,y:0.5}, {x:0.9,y:1.1}]],
            'S': [[{x:0.9,y:0.1}, {x:0.1,y:0.1}, {x:0.0,y:0.5}, {x:1.0,y:0.5}, {x:0.9,y:0.9}, {x:0.1,y:0.9}]],
            'T': [[{x:0.5,y:-0.1}, {x:0.5,y:1.1}], [{x:0.1,y:0}, {x:0.9,y:0}]],
            'U': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.85,y:1.1}, {x:0.9,y:0}]],
            'V': [[{x:0.1,y:0}, {x:0.5,y:1.1}, {x:0.9,y:0}]],
            'W': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.5,y:0.6}, {x:0.85,y:1.1}, {x:0.9,y:0}]],
            'X': [[{x:0.1,y:0}, {x:0.9,y:1.1}], [{x:0.9,y:0}, {x:0.1,y:1.1}]],
            'Y': [[{x:0.1,y:0}, {x:0.5,y:0.6}], [{x:0.9,y:0}, {x:0.5,y:0.6}, {x:0.5,y:1.1}]],
            'Z': [[{x:0.1,y:0}, {x:0.9,y:0}, {x:0.1,y:1.1}, {x:0.9,y:1.1}]],
            ' ': [],
            '1': [[{x:0.3,y:0}, {x:0.5,y:0}, {x:0.5,y:1.1}], [{x:0.3,y:1.1}, {x:0.7,y:1.1}]],
            '2': [[{x:0.2,y:0.2}, {x:0.8,y:0.2}, {x:0.8,y:0.5}, {x:0.2,y:1.1}, {x:0.9,y:1.1}]],
            '3': [[{x:0.2,y:0}, {x:0.8,y:0}, {x:0.4,y:0.5}, {x:0.8,y:0.5}, {x:0.8,y:1.1}, {x:0.2,y:1.1}]],
            '4': [[{x:0.8,y:1.1}, {x:0.8,y:0}], [{x:0.8,y:0.6}, {x:0.1,y:0.6}, {x:0.5,y:0}]],
            '5': [[{x:0.8,y:0}, {x:0.2,y:0}, {x:0.2,y:0.4}, {x:0.8,y:0.6}, {x:0.2,y:1.1}]],
            '6': [[{x:0.8,y:0}, {x:0.2,y:0.5}, {x:0.2,y:1.1}, {x:0.8,y:1.1}, {x:0.8,y:0.5}, {x:0.2,y:0.5}]],
            '7': [[{x:0.1,y:0}, {x:0.9,y:0}, {x:0.4,y:1.1}]],
            '8': [[{x:0.5,y:0.5}, {x:0.2,y:0.2}, {x:0.8,y:0.2}, {x:0.5,y:0.5}, {x:0.2,y:0.8}, {x:0.8,y:0.8}, {x:0.5,y:0.5}]],
            '9': [[{x:0.8,y:0.5}, {x:0.2,y:0.5}, {x:0.2,y:0}, {x:0.8,y:0}, {x:0.8,y:1.1}]],
            '0': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}]]
        };

        const colorCombos = [
            { top: '#FF4500', bottom: '#FFD700' }, 
            { top: '#00BFFF', bottom: '#F0F8FF' }, 
            { top: '#FF1493', bottom: '#FFB6C1' }, 
            { top: '#32CD32', bottom: '#ADFF2F' }, 
            { top: '#9400D3', bottom: '#DA70D6' }, 
            { top: '#FF8C00', bottom: '#FFFF00' }  
        ];

        // Text mode state
        let isSpraying = false;
        let targetText = "TAGS"; 
        let textCharIndex = 0; 
        let currentWordRow = 0; 
        let maxWordRows = 3; 

        let currentStrokes = []; 
        let currentStrokeIndex = 0; 
        let currentPointIndex = 0; 
        
        let currentStyle = null;
        let letterDrawOrigin = { x: 0, y: 0 }; 
        let letterHeightScale = 0; 
        let currentWordWidth = 0; 
        let wordStartX = 0; 
        let charSkew = 0; 
        let charScaleFactor = 1;
        let startYOffset = 0; 
        let fixedRowHeight = 0; 

        // Image-mask mode state
        let maskSegments = [[], [], [], []];
        let segmentBounds = [null, null, null, null];
        let currentSegmentIndex = 0;
        let maskBounds = null;
        let maskStyle = colorCombos[0];
        let maskReady = false;
        let maskAnimating = false;

        // --- FULLSCREEN ---
        function enterFullscreen(element) {
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }

        // --- CAMERA SHAKE ---
        function shakeCamera(duration = 1000, magnitude = 12) {
            const start = performance.now();

            function frame(now) {
                const elapsed = now - start;
                const t = Math.min(elapsed / duration, 1);
                const damping = 1 - t;

                const offsetX = (Math.random() * 2 - 1) * magnitude * damping;
                const offsetY = (Math.random() * 2 - 1) * magnitude * damping;

                sceneWrapper.style.transform = `translate(${offsetX}px, ${offsetY}px)`;

                if (t < 1) {
                    requestAnimationFrame(frame);
                } else {
                    sceneWrapper.style.transform = 'translate(0, 0)';
                }
            }

            requestAnimationFrame(frame);
        }

        // --- WALL (clay bricks with texture) ---
        function generateWall() {
            width = window.innerWidth;
            height = window.innerHeight;
            [wallCanvas, gameCanvas, fxCanvas].forEach(c => {
                c.width = width;
                c.height = height;
            });

            fixedRowHeight = Math.min(width, height) * 0.24; 

            const baseLetterHeight = fixedRowHeight * 0.8;
            const approxLetterWidth = baseLetterHeight * 0.75;
            const leftMargin = width * 0.03;
            const rightLimit = width * 0.97;
            const usableWidth = rightLimit - leftMargin;
            const maxCharsPerRow = Math.max(1, Math.floor(usableWidth / approxLetterWidth));

            const totalChars = (targetText || "").length;
            const rowsNeeded = Math.max(1, Math.ceil(totalChars / maxCharsPerRow));

            maxWordRows = rowsNeeded;

            const totalTextHeight = fixedRowHeight * maxWordRows; 
            startYOffset = (height - totalTextHeight) / 2; 

            textCharIndex = 0;
            currentWordRow = 0;
            currentWordWidth = 0;
            wordStartX = 0;
            
            wCtx.fillStyle = '#2b1b17';
            wCtx.fillRect(0, 0, width, height);

            const brickW = 100;
            const brickH = 50;

            for (let y = 0; y < height; y += brickH) {
                const offset = (y / brickH % 2 === 0) ? 0 : brickW / 2;

                for (let x = -brickW; x < width; x += brickW) {
                    const bx = x + offset;
                    const by = y;
                    const bw = brickW - 4;
                    const bh = brickH - 4;

                    let r = 165 + Math.floor(Math.random() * 25);
                    let g = 95  + Math.floor(Math.random() * 20);
                    let b = 70  + Math.floor(Math.random() * 15);

                    const brightnessJitter = (Math.random() - 0.5) * 18;
                    r = Math.max(0, Math.min(255, r + brightnessJitter));
                    g = Math.max(0, Math.min(255, g + brightnessJitter));
                    b = Math.max(0, Math.min(255, b + brightnessJitter));

                    const grad = wCtx.createLinearGradient(bx, by, bx + bw, by + bh);
                    grad.addColorStop(0,   `rgb(${r + 12}, ${g + 8}, ${b + 6})`);
                    grad.addColorStop(0.5, `rgb(${r}, ${g}, ${b})`);
                    grad.addColorStop(1,   `rgb(${r - 14}, ${g - 10}, ${b - 8})`);

                    wCtx.fillStyle = grad;
                    wCtx.fillRect(bx, by, bw, bh);

                    wCtx.fillStyle = 'rgba(40, 25, 20, 0.35)';
                    wCtx.fillRect(bx, by + bh - 2, bw, 2);
                    wCtx.fillRect(bx + bw - 2, by + 2, 2, bh - 4);

                    const pitCount = 4 + Math.floor(Math.random() * 4);
                    for (let i = 0; i < pitCount; i++) {
                        const px = bx + 6 + Math.random() * (bw - 12);
                        const py = by + 6 + Math.random() * (bh - 12);
                        const pitSize = 1 + Math.random() * 2;

                        wCtx.fillStyle = 'rgba(40, 25, 20, 0.45)';
                        wCtx.fillRect(px, py, pitSize, pitSize);
                    }
                }
            }

            const noiseCount = Math.floor((width * height) / 1400);
            for (let i = 0; i < noiseCount; i++) {
                const nx = Math.random() * width;
                const ny = Math.random() * height;
                const size = 1 + Math.random() * 2;

                wCtx.fillStyle = 'rgba(0, 0, 0, 0.12)';
                wCtx.fillRect(nx, ny, size, size);

                if (Math.random() < 0.12) {
                    wCtx.fillStyle = 'rgba(255, 230, 210, 0.10)';
                    wCtx.fillRect(nx, ny, size, size);
                }
            }

            const grad = wCtx.createRadialGradient(
                width / 2, height / 2, height / 3,
                width / 2, height / 2, height
            );
            grad.addColorStop(0, 'rgba(0,0,0,0.12)');
            grad.addColorStop(1, 'rgba(0,0,0,0.80)');
            wCtx.fillStyle = grad;
            wCtx.fillRect(0, 0, width, height);
        }
        window.addEventListener('resize', generateWall);

        // --- AUDIO (effects) ---
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function startSpraySound() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 2; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            noise.loop = true;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            
            const gain = audioCtx.createGain();
            gain.gain.value = 0.15;
            
            noise.connect(filter).connect(gain).connect(audioCtx.destination);
            noise.start();
            sprayNode = { source: noise, gain: gain };
        }

        function stopSpraySound() {
            if (sprayNode) {
                sprayNode.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                sprayNode.source.stop(audioCtx.currentTime + 0.2);
                sprayNode = null;
            }
        }

        function playPopSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.connect(gain).connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        // --- AMBIANCE MUSIC HELPERS ---
        function stopAmbiance() {
            if (musicAudio) {
                musicAudio.pause();
                musicAudio = null;
            }
        }

        function startAmbiance() {
            const playlist = currentMusicStyle === 'hiphop' ? hipHopPlaylist : punkPlaylist;
            if (!playlist || playlist.length === 0) {
                // no tracks configured yet; silent ambiance
                return;
            }

            stopAmbiance();

            currentTrackIndex = 0;
            musicAudio = new Audio(playlist[currentTrackIndex]);
            musicAudio.loop = true; 
            musicAudio.volume = 0.4;

            musicAudio.play().catch(() => {});
        }

        // --- TEXT MODE HELPERS ---
        function calculateLetterPosition() {
            const baseRowHeight = fixedRowHeight; 
            const baseLetterHeight = baseRowHeight * 0.8; 

            letterHeightScale = baseLetterHeight * (1 + (Math.random() - 0.5) * 0.15); 
            const effectiveLetterWidth = letterHeightScale * 0.65; 

            charSkew = (Math.random() - 0.5) * 0.3; 
            charScaleFactor = 1 + (Math.random() - 0.5) * 0.1; 

            if (textCharIndex === 0) { 
                wordStartX = width * 0.03; 
                const verticalOffset = baseRowHeight * 0.1; 
                
                letterDrawOrigin.y = (currentWordRow * baseRowHeight) 
                    + (baseRowHeight - letterHeightScale) / 2 
                    + verticalOffset 
                    + startYOffset;
                
                if (currentWordRow === 0 && letterDrawOrigin.y < height * 0.01) {
                     letterDrawOrigin.y = height * 0.01; 
                }

                letterDrawOrigin.x = wordStartX;
            } else {
                const prevChar = targetText[textCharIndex - 1];
                let prevLetterActualWidth = effectiveLetterWidth * charScaleFactor; 
                if (prevChar === 'I' || prevChar === '1') prevLetterActualWidth *= 0.6; 
                if (prevChar === 'M' || prevChar === 'W') prevLetterActualWidth *= 1.2; 

                const baseGap = effectiveLetterWidth * 0.18;
                const jitter = effectiveLetterWidth * (Math.random() * 0.04 - 0.02);
                letterDrawOrigin.x = letterDrawOrigin.x + prevLetterActualWidth + baseGap + jitter;
                
                const bounceRange = letterHeightScale * 0.1;
                letterDrawOrigin.y += (Math.random() - 0.5) * bounceRange;
                 
                const rowBottomLimit = (currentWordRow + 1) * baseRowHeight - (baseRowHeight * 0.1) + startYOffset; 
                if (letterDrawOrigin.y + letterHeightScale * charScaleFactor > rowBottomLimit) {
                    letterDrawOrigin.y = rowBottomLimit - letterHeightScale * charScaleFactor;
                }
            }
        }

        function getAbsPoint(pt) {
            let x = pt.x * letterHeightScale * charScaleFactor * 0.6 + (pt.y * charSkew * letterHeightScale * 0.45);
            let y = pt.y * letterHeightScale * charScaleFactor;

            return {
                x: letterDrawOrigin.x + x,
                y: letterDrawOrigin.y + y
            };
        }

        function createLetterGradient(topColor, bottomColor) {
            const topY = letterDrawOrigin.y;
            const botY = letterDrawOrigin.y + letterHeightScale * charScaleFactor;
            const grad = ctx.createLinearGradient(0, topY, 0, botY);
            grad.addColorStop(0, topColor);
            grad.addColorStop(1, bottomColor);
            return grad;
        }

        function drawOutline() {
            const outlineThickness = letterHeightScale * 0.08;
            ctx.globalCompositeOperation = 'destination-over';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = outlineThickness;
            ctx.strokeStyle = 'black';

            currentStrokes.forEach(stroke => {
                ctx.beginPath();
                stroke.forEach((pt, i) => {
                    const abs = getAbsPoint(pt);
                    if (i===0) ctx.moveTo(abs.x, abs.y);
                    else ctx.lineTo(abs.x, abs.y);
                });
                ctx.stroke();
            });
            
            ctx.globalCompositeOperation = 'source-over';
        }
        
        function drawDrips() {
            ctx.strokeStyle = currentStyle.bottom; 
            ctx.lineWidth = letterHeightScale * 0.035; 
            ctx.lineCap = 'round';
            ctx.globalAlpha = 0.85;

            currentStrokes.flat().forEach(pt => {
                if (Math.random() > 0.7) { 
                    const abs = getAbsPoint(pt);
                    const dripLength = letterHeightScale * (0.25 + Math.random() * 0.45); 
                    const dripOffset = letterHeightScale * 0.04; 
                    ctx.beginPath();
                    ctx.moveTo(abs.x, abs.y + dripOffset); 
                    ctx.lineTo(abs.x + (Math.random()-0.5)*10, abs.y + dripOffset + dripLength); 
                    ctx.stroke();
                }
            });
            ctx.globalAlpha = 1.0;
        }

        function drawSplatter(x, y, color) {
            const splatterRadius = letterHeightScale * (0.25 + Math.random() * 0.35); 
            const numParticles = 10 + Math.random() * 12; 
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.45;

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * splatterRadius;
                const px = x + Math.cos(angle) * distance;
                const py = y + Math.sin(angle) * distance;
                const radius = 0.8 + Math.random() * 3; 
                ctx.beginPath();
                ctx.arc(px, py, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function sprayBetween(start, end, duration, gradient) {
            return new Promise(resolve => {
                const startTime = performance.now();
                startSpraySound();
                let lastProgress = 0;

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    const bubbleThickness = letterHeightScale * 0.22; 

                    const steps = 5;
                    for (let i = 0; i < steps; i++) {
                        const t = lastProgress + (progress - lastProgress) * (i / steps);
                        const baseX = start.x + (end.x - start.x) * t;
                        const baseY = start.y + (end.y - start.y) * t;

                        const dotCount = 5;
                        for (let j = 0; j < dotCount; j++) {
                            const r = Math.random() * bubbleThickness * 0.5;
                            const angle = Math.random() * Math.PI * 2;
                            const jitterX = (Math.random() - 0.5) * 3;
                            const jitterY = (Math.random() - 0.5) * 3;
                            const px = baseX + Math.cos(angle) * r + jitterX;
                            const py = baseY + Math.sin(angle) * r + jitterY;

                            ctx.fillStyle = gradient;
                            ctx.globalAlpha = 0.25 + Math.random() * 0.25;
                            const radius = 0.7 + Math.random() * (bubbleThickness * 0.07);
                            ctx.beginPath();
                            ctx.arc(px, py, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    ctx.globalAlpha = 0.9;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = bubbleThickness * 0.4;
                    ctx.strokeStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(start.x + (end.x - start.x) * lastProgress,
                               start.y + (end.y - start.y) * lastProgress);
                    ctx.lineTo(start.x + (end.x - start.x) * progress,
                               start.y + (end.y - start.y) * progress);
                    ctx.stroke();

                    ctx.globalAlpha = 1.0;
                    lastProgress = progress;

                    if (progress < 1) requestAnimationFrame(animate);
                    else {
                        stopSpraySound();
                        resolve();
                    }
                }
                requestAnimationFrame(animate);
            });
        }

        // --- COP LIGHTS FX (with reset at end) ---
        function startCopLights() {
            if (copLightsRunning) return;
            copLightsRunning = true;

            const totalFlashes = 6;
            const flashDuration = 700;
            const totalDuration = totalFlashes * flashDuration;

            let startTime = null;

            function frame(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;

                if (elapsed >= totalDuration) {
                    fxCtx.clearRect(0, 0, width, height);
                    copLightsRunning = false;

                    shakeCamera(1000, 12);

                    // reset canvas and text state after the shake
                    setTimeout(() => {
                        ctx.clearRect(0, 0, width, height);
                        generateWall();

                        textCharIndex = 0;
                        currentWordRow = 0;
                        currentWordWidth = 0;
                        wordStartX = 0;
                        letterDrawOrigin.x = 0;
                        letterDrawOrigin.y = 0;
                        currentStrokes = [];
                        currentStrokeIndex = 0;
                        currentPointIndex = 0;
                    }, 1000);

                    return;
                }

                fxCtx.clearRect(0, 0, width, height);

                const flashIndex = Math.floor(elapsed / flashDuration);
                const tInFlash = (elapsed % flashDuration) / flashDuration;

                const isRed = (flashIndex % 2 === 0);

                let intensity = Math.sin(tInFlash * Math.PI);
                intensity = Math.max(0, Math.min(1, intensity));

                const baseAlpha = 0.18;
                const extraAlpha = 0.35;
                const alpha = baseAlpha + extraAlpha * intensity;

                fxCtx.save();
                fxCtx.globalCompositeOperation = 'screen';

                const marginFactor = 0.25;
                const startX = isRed ? -width * marginFactor : width * (1 + marginFactor);
                const endX   = isRed ? width * (1 + marginFactor) : -width * marginFactor;
                const centerX = startX + (endX - startX) * tInFlash;

                const centerY = height * 0.22;
                const radius = Math.max(width, height) * 0.45;

                const colorMain = isRed
                    ? `rgba(255, 60, 60, ${alpha})`
                    : `rgba(60, 120, 255, ${alpha})`;

                const colorSoft = isRed
                    ? `rgba(255, 60, 60, ${alpha * 0.4})`
                    : `rgba(60, 120, 255, ${alpha * 0.4})`;

                const radial = fxCtx.createRadialGradient(
                    centerX, centerY, radius * 0.05,
                    centerX, centerY, radius
                );
                radial.addColorStop(0.0, colorMain);
                radial.addColorStop(0.25, colorMain);
                radial.addColorStop(1.0, 'rgba(0,0,0,0)');
                fxCtx.fillStyle = radial;
                fxCtx.fillRect(0, 0, width, height);

                const horiz = fxCtx.createLinearGradient(0, centerY, width, centerY);
                if (isRed) {
                    horiz.addColorStop(0.0, colorSoft);
                    horiz.addColorStop(0.4, 'rgba(255,60,60,0.06)');
                    horiz.addColorStop(0.7, 'rgba(255,60,60,0.02)');
                    horiz.addColorStop(1.0, 'rgba(0,0,0,0)');
                } else {
                    horiz.addColorStop(0.0, 'rgba(0,0,0,0)');
                    horiz.addColorStop(0.3, 'rgba(60,120,255,0.02)');
                    horiz.addColorStop(0.6, 'rgba(60,120,255,0.06)');
                    horiz.addColorStop(1.0, colorSoft);
                }
                fxCtx.fillStyle = horiz;
                fxCtx.fillRect(0, 0, width, height);

                const vGrad = fxCtx.createLinearGradient(0, 0, 0, height);
                vGrad.addColorStop(0,   'rgba(0, 0, 0, 0.0)');
                vGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.0)');
                vGrad.addColorStop(1.0, 'rgba(0, 0, 0, 0.35)');
                fxCtx.fillStyle = vGrad;
                fxCtx.fillRect(0, 0, width, height);

                fxCtx.restore();

                requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);
        }

        // --- TEXT MODE MAIN ---
        async function trigger() {
            if (copLightsRunning) return;
            if (isSpraying) return;
            isSpraying = true;

            if (currentStrokes.length === 0) {
                const baseLetterHeight = fixedRowHeight * 0.8; 
                let estimatedNextCharWidth = baseLetterHeight * 0.75; 
                let nextChar = targetText[textCharIndex] || '';

                if (nextChar === 'I' || nextChar === '1') estimatedNextCharWidth *= 0.6;
                if (nextChar === 'M' || nextChar === 'W') estimatedNextCharWidth *= 1.2;

                const maxAllowedX = width * 0.97; 

                if (textCharIndex >= targetText.length || (letterDrawOrigin.x + estimatedNextCharWidth) > maxAllowedX) {
                    textCharIndex = 0; 
                    currentWordRow++;
                    letterDrawOrigin.x = wordStartX; 
                }
                
                if (currentWordRow >= maxWordRows) {
                    ctx.fillStyle = '#1a1a1a'; 
                    ctx.globalAlpha = 0.9;
                    ctx.fillRect(0,0,width,height);
                    ctx.globalAlpha = 1.0;
                    currentWordRow = 0;
                    letterDrawOrigin.x = wordStartX; 
                    await new Promise(r => setTimeout(r, 300));
                }

                let char = targetText[textCharIndex];
                let strokes = alphabet[char] || alphabet['?']; 
                
                calculateLetterPosition(); 
                currentStyle = colorCombos[textCharIndex % colorCombos.length]; 

                if (strokes && strokes.length > 0) {
                    currentStrokes = strokes;
                    currentStrokeIndex = 0;
                    currentPointIndex = 0;

                    const p1 = getAbsPoint(currentStrokes[0][0]);
                    const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(p1.x, p1.y, letterHeightScale * 0.16, 0, Math.PI*2);
                    ctx.fill();
                    
                    currentPointIndex = 1;
                    isSpraying = false;
                    return;
                } else {
                    textCharIndex++;
                    letterDrawOrigin.x += fixedRowHeight * 0.7 * 0.5;
                    isSpraying = false;
                    trigger(); 
                    return;
                }
            }

            let currentStrokePoints = currentStrokes[currentStrokeIndex];
            
            if (currentPointIndex < currentStrokePoints.length) {
                const pStart = getAbsPoint(currentStrokePoints[currentPointIndex-1]);
                const pEnd = getAbsPoint(currentStrokePoints[currentPointIndex]);
                const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);
                
                await sprayBetween(pStart, pEnd, 400, grad); 
                currentPointIndex++;
            }

            if (currentPointIndex >= currentStrokePoints.length) {
                currentStrokeIndex++;
                currentPointIndex = 1; 
                
                if (currentStrokeIndex < currentStrokes.length) {
                    const pNewStart = getAbsPoint(currentStrokes[currentStrokeIndex][0]);
                    const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(pNewStart.x, pNewStart.y, letterHeightScale * 0.16, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            if (currentStrokeIndex >= currentStrokes.length) {
                playPopSound();
                drawOutline();
                drawDrips();
                
                const splatX = letterDrawOrigin.x + (letterHeightScale * 0.4 * charScaleFactor);
                const splatY = letterDrawOrigin.y + (letterHeightScale * charScaleFactor);
                drawSplatter(splatX, splatY, currentStyle.bottom);

                currentStrokes = [];
                textCharIndex++;

                if (textCharIndex >= targetText.length) {
                    startCopLights();
                }
            }

            isSpraying = false;
        }

        // --- IMAGE-MASK MODE HELPERS (quarters + diagonal animated pass) ---
        function loadMaskImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const offCanvas = document.createElement('canvas');
                    const offCtx = offCanvas.getContext('2d');
                    offCanvas.width = img.width;
                    offCanvas.height = img.height;
                    offCtx.drawImage(img, 0, 0);

                    const imgData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);

                    let points = [];
                    const step = 2;
                    for (let y = 0; y < imgData.height; y += step) {
                        for (let x = 0; x < imgData.width; x += step) {
                            const idx = (y * imgData.width + x) * 4;
                            const alpha = imgData.data[idx + 3];
                            if (alpha > 50) {
                                points.push({ x, y });
                            }
                        }
                    }

                    const scale = Math.min(width * 0.7 / img.width, height * 0.7 / img.height);
                    const offsetX = (width - img.width * scale) / 2;
                    const offsetY = (height - img.height * scale) / 2;

                    const scaledPoints = points.map(p => ({
                        x: offsetX + p.x * scale,
                        y: offsetY + p.y * scale
                    }));

                    let minY = Infinity, maxY = -Infinity;
                    let minX = Infinity, maxX = -Infinity;
                    scaledPoints.forEach(p => {
                        if (p.y < minY) minY = p.y;
                        if (p.y > maxY) maxY = p.y;
                        if (p.x < minX) minX = p.x;
                        if (p.x > maxX) maxX = p.x;
                    });
                    maskBounds = { minX, maxX, minY, maxY };

                    maskSegments = [[], [], [], []];
                    segmentBounds = [null, null, null, null];

                    const spanX = maxX - minX || 1;
                    const segmentWidth = spanX / 4;

                    scaledPoints.forEach(p => {
                        let seg = Math.floor((p.x - minX) / segmentWidth);
                        if (seg < 0) seg = 0;
                        if (seg > 3) seg = 3;
                        maskSegments[seg].push(p);

                        if (!segmentBounds[seg]) {
                            segmentBounds[seg] = { minX: p.x, maxX: p.x };
                        } else {
                            if (p.x < segmentBounds[seg].minX) segmentBounds[seg].minX = p.x;
                            if (p.x > segmentBounds[seg].maxX) segmentBounds[seg].maxX = p.x;
                        }
                    });

                    for (let i = 0; i < 4; i++) {
                        maskSegments[i].sort((a,b) => a.x - b.x);
                    }

                    currentSegmentIndex = 0;
                    maskStyle = colorCombos[Math.floor(Math.random() * colorCombos.length)];
                    maskReady = true;
                    resolve();
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        function paintMaskPoint(pt, gradient, clusterRadiusBase) {
            const dotsPerPoint = 3;
            for (let d = 0; d < dotsPerPoint; d++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * clusterRadiusBase;
                const px = pt.x + Math.cos(angle) * r;
                const py = pt.y + Math.sin(angle) * r;
                ctx.fillStyle = gradient;
                ctx.globalAlpha = 0.4 + Math.random() * 0.3;
                ctx.beginPath();
                ctx.arc(px, py, clusterRadiusBase * 0.7, 0, Math.PI * 2);
                ctx.fill();
            }

            if (Math.random() < 0.05) {
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = gradient;
                ctx.lineCap = 'round';
                ctx.lineWidth = clusterRadiusBase * 0.5;
                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                const driftX = (Math.random() - 0.5) * clusterRadiusBase * 1.2;
                const dripLength = clusterRadiusBase * (2 + Math.random() * 3);
                ctx.lineTo(pt.x + driftX, pt.y + dripLength);
                ctx.stroke();
            }

            ctx.globalAlpha = 1.0;
        }

        function triggerMask() {
            if (!maskReady) return;
            if (maskAnimating) return;
            if (currentSegmentIndex >= 4) return;

            const seg = maskSegments[currentSegmentIndex];
            if (!seg || seg.length === 0) {
                currentSegmentIndex++;
                if (currentSegmentIndex < 4) triggerMask();
                return;
            }

            const bounds = segmentBounds[currentSegmentIndex];
            if (!bounds) {
                currentSegmentIndex++;
                if (currentSegmentIndex < 4) triggerMask();
                return;
            }

            maskAnimating = true;
            initAudio();
            startSpraySound();

            const duration = 1500;
            const startTime = performance.now();
            const clusterRadiusBase = Math.min(width, height) * 0.004;

            let gradient;
            if (maskBounds) {
                gradient = ctx.createLinearGradient(0, maskBounds.minY, 0, maskBounds.maxY);
            } else {
                gradient = ctx.createLinearGradient(0, 0, 0, height);
            }
            gradient.addColorStop(0, maskStyle.top);
            gradient.addColorStop(1, maskStyle.bottom);

            const baseAngles = [Math.PI/4, 3*Math.PI/4, 5*Math.PI/4, 7*Math.PI/4];
            const baseAngle = baseAngles[Math.floor(Math.random() * baseAngles.length)];
            const angle = baseAngle + (Math.random() - 0.5) * (Math.PI / 6);
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);

            const projArray = seg.map(p => {
                const proj = p.x * dx + p.y * dy;
                return { p, proj };
            });

            let minProj = Infinity, maxProj = -Infinity;
            projArray.forEach(o => {
                if (o.proj < minProj) minProj = o.proj;
                if (o.proj > maxProj) maxProj = o.proj;
            });
            const projSpan = maxProj - minProj || 1;

            projArray.sort((a, b) => a.proj - b.proj);

            function frame(now) {
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const threshold = minProj + projSpan * progress;

                const pointsPerFrame = Math.max(80, Math.floor(projArray.length / 30));
                let paintedThisFrame = 0;

                while (paintedThisFrame < pointsPerFrame && projArray.length > 0) {
                    if (projArray[0].proj > threshold) break;

                    const { p } = projArray.shift();
                    paintMaskPoint(p, gradient, clusterRadiusBase);
                    paintedThisFrame++;
                }

                if (progress < 1 && projArray.length > 0) {
                    requestAnimationFrame(frame);
                } else {
                    while (projArray.length > 0) {
                        const { p } = projArray.shift();
                        paintMaskPoint(p, gradient, clusterRadiusBase);
                    }
                    stopSpraySound();
                    maskAnimating = false;
                    currentSegmentIndex++;
                }
            }

            requestAnimationFrame(frame);
        }

        async function startImageMode() {
            maskReady = false;
            maskAnimating = false;
            currentSegmentIndex = 0;
            initAudio();
            enterFullscreen(body); 
            overlay.style.opacity = 0;
            setTimeout(() => overlay.style.display = 'none', 500);

            generateWall();
            ctx.clearRect(0, 0, width, height);

            const src = imageSelect.value;
            if (!src) return;
            await loadMaskImage(src);
        }

        // --- INIT ---
        generateWall();

        startBtn.addEventListener('click', async () => {
            startAmbiance();
            initAudio();
            enterFullscreen(body); 
            overlay.style.opacity = 0;
            setTimeout(() => overlay.style.display = 'none', 500);

            if (currentMode === 'text') {
                const txt = inputField.value.toUpperCase().trim();
                if (txt.length > 0) {
                    targetText = txt.replace(/[^A-Z0-9 ]/g, '').substring(0, 15); 
                    if (targetText.length === 0) targetText = "TAGS";
                    
                    generateWall(); 
                    ctx.clearRect(0, 0, width, height); 
                    textCharIndex = 0;
                    currentWordRow = 0;
                    currentWordWidth = 0;
                    wordStartX = 0;
                    trigger();
                }
            } else {
                await startImageMode();
            }
        });

        const handleInput = (e) => {
            if (overlay.style.display !== 'none') return;
            if (e.type === 'keydown' && e.code !== 'Space') return;
            if (e.type === 'touchstart') e.preventDefault();

            if (currentMode === 'text') {
                trigger();
            } else {
                triggerMask();
            }
        };

        document.addEventListener('keydown', handleInput);
        document.addEventListener('mousedown', handleInput);
        document.addEventListener('touchstart', handleInput, {passive:false});

        window.addEventListener('beforeunload', stopAmbiance);
    </script>
</body>
</html>
