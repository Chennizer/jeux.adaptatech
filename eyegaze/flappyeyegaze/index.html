<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Flappy-ish â€” Fullscreen + Mario Pipes + Sprite Bird</title>
<style>
  :root { --fg:#e0fbfc; }
  *{ box-sizing:border-box; }
  html,body { margin:0; height:100%; background:#0b1522; color:var(--fg); font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #wrap { position:fixed; inset:0; display:grid; place-items:center; background:radial-gradient(1400px 900px at 50% 20%, #16324f 0%, #0e2034 45%, #0b1522 100%); }
  canvas { width:100vw; height:100vh; display:block; background:#87ceeb; }
  .hud {
    position:absolute; inset:0; pointer-events:none; display:flex; align-items:flex-start; justify-content:space-between; padding:12px 14px;
    font-weight:700; text-shadow:0 2px 0 rgba(0,0,0,.25);
  }
  .badge{ pointer-events:none; background:rgba(0,0,0,.35); padding:.35rem .6rem; border-radius:999px; font-size:14px; }
  #centerOverlay { position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
  .panel {
    pointer-events:auto;
    background:rgba(9,14,22,.78);
    backdrop-filter: blur(8px);
    border:1px solid rgba(255,255,255,.08);
    border-radius:18px;
    padding:18px 18px 14px;
    width:min(92vw, 520px);
    text-align:center;
    box-shadow: 0 20px 60px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.05);
  }
  .title{ font-size:26px; font-weight:800; margin:4px 0 8px; letter-spacing:.2px; }
  .subtitle{ font-size:14px; opacity:.85; margin:0 0 10px; }
  .row{ display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin:10px 0 6px; }
  .chip{
    padding:.45rem .8rem; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); cursor:pointer; user-select:none;
    transition:transform .08s ease, background .2s; font-weight:700; font-size:14px;
  }
  .chip[data-active="true"]{ background:linear-gradient(180deg, #1b2b45, #15243b); border-color:rgba(255,255,255,.2); box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); }
  .cta{
    display:inline-flex; align-items:center; justify-content:center; gap:.55rem;
    padding:.8rem 1.1rem; border:none; border-radius:12px; font-weight:800; letter-spacing:.25px; font-size:15px;
    background:linear-gradient(180deg, #ffd166, #ffb703); color:#1a1a1a; cursor:pointer; margin-top:8px;
    box-shadow:0 8px 24px rgba(255,179,3,.35);
    transition:transform .04s ease;
  }
  .cta:active{ transform:translateY(1px) }
  .hint{ font-size:12px; opacity:.75; margin-top:8px; }
  .footer { position:absolute; bottom:8px; left:0; right:0; display:flex; gap:8px; justify-content:center; pointer-events:none; }
  .kbd{ pointer-events:none; font-size:12px; padding:.2rem .45rem; border:1px solid rgba(255,255,255,.18); border-bottom-width:2px; background:rgba(255,255,255,.06); border-radius:6px; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" aria-label="Flappy style game"></canvas>

  <div class="hud">
    <div class="badge">Score: <span id="score">0</span></div>
    <div class="badge">Best: <span id="best">0</span></div>
  </div>

  <div id="centerOverlay" aria-live="polite">
    <div class="panel" id="menuPanel">
      <div class="title">Flappy-ish</div>
      <div class="subtitle">Move your <b>mouse / finger</b> up & down to fly. Starts in <b>fullscreen</b>.</div>
      <div class="row" role="group" aria-label="Difficulty">
        <div class="chip" data-diff="easy"   data-active="true">Easy</div>
        <div class="chip" data-diff="normal">Normal</div>
        <div class="chip" data-diff="hard">Hard</div>
      </div>
      <button class="cta" id="startBtn">Start</button>
      <div class="hint">Pause: <span class="kbd">P</span> &nbsp; Restart: <span class="kbd">R</span> &nbsp; Start: <span class="kbd">Space/Enter/Click</span></div>
    </div>
  </div>

  <div class="footer">
    <div class="kbd">Sprite bird: up/mid/down frames</div>
  </div>
</div>

<script>
(() => {
  // ======= Canvas sizing (fullscreen) =======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let W = window.innerWidth;
  let H = window.innerHeight;
  let GH = Math.max(60, Math.round(H * 0.12)); // ground height
  let PIPE_W = Math.max(28, Math.round(W * 0.035)); // narrower pipes
  let dpr = 1;

  function fit() {
    W = window.innerWidth; H = window.innerHeight;
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    GH = Math.max(60, Math.round(H * 0.12));
    PIPE_W = Math.max(28, Math.round(W * 0.035)); // keep narrow on resize
    rescaleConfig();
    bird.r = Math.max(10, Math.round(14 * (H / 640)));
    bird.x = Math.round(W * 0.25);
    setTargetY(targetY);
  }
  window.addEventListener('resize', fit, { passive:true });

  // ======= UI elements =======
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const startBtn = document.getElementById('startBtn');
  const menuPanel = document.getElementById('menuPanel');
  const chips = Array.from(document.querySelectorAll('.chip'));

  let difficulty = 'easy';
  chips.forEach(ch => ch.addEventListener('click', () => {
    chips.forEach(c => c.dataset.active = 'false');
    ch.dataset.active = 'true';
    difficulty = ch.dataset.diff;
    rescaleConfig();
  }));

  // ======= Audio (generated) =======
  let AC, masterGain;
  function ensureAudio() {
    if (!AC) {
      AC = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = AC.createGain();
      masterGain.gain.value = 0.2;
      masterGain.connect(AC.destination);
    }
    if (AC.state === 'suspended') AC.resume();
  }
  function beep(freq=600, dur=0.08, type='sine', vol=0.6) {
    if (!AC) return;
    const t0 = AC.currentTime + 0.001;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(masterGain);
    o.start(t0); o.stop(t0 + dur + 0.02);
  }
  function scoreChime(){ beep(850, .07, 'square', .5); setTimeout(()=>beep(1100,.06,'square',.45), 30); }
  function hitSfx(){ beep(200, .18, 'sawtooth', .35); setTimeout(()=>beep(120,.22,'sawtooth',.3), 40); }

  // ======= Helpers =======
  const rand = (a,b)=>a + Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // ======= Game state =======
  const State = { READY:0, PLAYING:1, PAUSED:2, DEAD:3 };
  let state = State.READY;
  let score = 0, best = parseInt(localStorage.getItem('flappy-best')||'0',10);
  bestEl.textContent = best;

  // ======= Difficulty presets (now with fixed speeds per mode) =======
  const presetsBase = {
    easy:   { gap: 240, speed: 1.0,  spawn: 2.2 },  // slow & forgiving
    normal: { gap: 170, speed: 2.4,  spawn: 1.35 }, // moderate
    hard:   { gap: 140, speed: 3.6,  spawn: 1.10 }  // fast & tight
  };
  let cfg = { gap: 220, speed: 3, spawn: 1.4 };

  function rescaleConfig() {
    const base = presetsBase[difficulty];
    cfg = {
      gap:   Math.round(base.gap * (H / 640)), // keep gap responsive to height
      speed: base.speed,                       // DO NOT scale by width
      spawn: base.spawn
    };
  }

  // Bird (mouse-follow control)
  const bird = { x: Math.round(W*0.25), y: Math.round(H*0.45), r: 14, angle: 0, wingPhase: 0 };
  let targetY = bird.y;
  function setTargetY(y){ targetY = clamp(y, bird.r+5, H - GH - bird.r - 5); }

  // ======= Sprite loading (your custom frames) =======
  const SPRITE_BASES = [
    "../../images/flappybird/birdup",
    "../../images/flappybird/birdmid",
    "../../images/flappybird/birddown"
  ];
  const SPRITE_EXTS = [".png", ".webp", ".jpg", ".jpeg"];
  let spriteFrames = [];
  let spriteReady = false;

  function loadWithFallback(base){
    return new Promise(resolve=>{
      let i = 0;
      function tryNext(){
        if (i >= SPRITE_EXTS.length){ resolve(null); return; }
        const src = base + SPRITE_EXTS[i++];
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = tryNext;
        img.src = src;
      }
      tryNext();
    });
  }
  async function preloadSprites(){
    const imgs = await Promise.all(SPRITE_BASES.map(loadWithFallback));
    spriteFrames = imgs.filter(Boolean);
    spriteReady = spriteFrames.length === SPRITE_BASES.length;
  }
  preloadSprites(); // fallback draws vector until ready

  // Pipes
  const pipes = [];
  let pipeTimer = 0;

  // Clouds
  const clouds = [];
  function makeCloud() {
    const y = rand(20, H*0.55);
    const s = rand(0.6, 1.4);
    const w = rand(100, 200)*s;
    const h = rand(24, 42)*s;
    clouds.push({ x: W + w, y, w, h, speed: rand(12, 22)*s });
  }
  for(let i=0;i<8;i++) makeCloud();

  // Ground motion accumulator (subtle)
  let groundOffset = 0;

  // ======= Fullscreen =======
  async function goFullscreen(){
    try{
      if (document.fullscreenElement) return;
      const el = document.documentElement; // full page
      if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen(); // Safari
      setTimeout(()=>window.scrollTo(0,1), 50);
    }catch(e){ /* ignore if blocked */ }
  }

  // ======= Input (start / steer) =======
  function startOrResume(){
    ensureAudio();
    goFullscreen();
    if (state === State.DEAD) { restart(); return; }
    if (state === State.PAUSED) { state = State.PLAYING; hideMenu(); return; }
    if (state === State.READY) { state = State.PLAYING; hideMenu(); }
  }
  function restart(){
    rescaleConfig();
    score = 0; scoreEl.textContent = '0';
    pipes.length = 0; pipeTimer = 0; groundOffset = 0;
    bird.x = Math.round(W*0.25);
    bird.y = Math.round(H*0.45);
    targetY = bird.y;
    bird.angle = 0; bird.wingPhase = 0;
    state = State.READY;
    showMenu('Flappy-ish');
  }

  // UI helpers
  function showMenu(titleText){
    const t = menuPanel.querySelector('.title');
    if (titleText) t.textContent = titleText;
    menuPanel.parentElement.style.display = 'grid';
  }
  function hideMenu(){
    menuPanel.parentElement.style.display = 'none';
  }

  // Events
  window.addEventListener('keydown', e=>{
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'Enter'){ e.preventDefault(); startOrResume(); }
    else if (e.key === 'p' || e.key === 'P'){ 
      if (state === State.PLAYING){ state = State.PAUSED; showMenu('Paused'); }
      else if (state === State.PAUSED){ state = State.PLAYING; hideMenu(); }
    }
    else if (e.key === 'r' || e.key === 'R'){ restart(); }
  });
  window.addEventListener('mousedown', (e)=>{ setTargetY(e.clientY); startOrResume(); });
  window.addEventListener('mousemove', (e)=>{ setTargetY(e.clientY); }, { passive:true });
  window.addEventListener('touchstart', (e)=>{ if (e.touches[0]) { setTargetY(e.touches[0].clientY); startOrResume(); } }, { passive:true });
  window.addEventListener('touchmove', (e)=>{ if (e.touches[0]) setTargetY(e.touches[0].clientY); }, { passive:true });

  startBtn.addEventListener('click', async () => { ensureAudio(); await goFullscreen(); hideMenu(); state = State.PLAYING; });

  // ======= Drawing helpers (procedural assets) =======
  function drawSky() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#78c6ff');
    g.addColorStop(0.6, '#8ed0ff');
    g.addColorStop(1, '#b1e1ff');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }
  function drawSun() {
    ctx.save();
    ctx.globalAlpha = 0.35;
    const cx = W*0.12, cy = H*0.18, r = Math.max(40, Math.min(W,H)*0.05);
    const g = ctx.createRadialGradient(cx,cy,8, cx,cy,r*2.2);
    g.addColorStop(0, 'rgba(255,255,200,.95)');
    g.addColorStop(1, 'rgba(255,255,200,0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(cx,cy,r*2.2,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffe66d';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawCloud(c){
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    const {x,y,w,h} = c;
    roundedCloud(x,y,w,h);
    ctx.restore();
  }
  function roundedCloud(x,y,w,h){
    ctx.beginPath();
    const r = h/2;
    ctx.moveTo(x, y+h);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.quadraticCurveTo(x+w*0.35, y-h*.8, x+w*0.55, y);
    ctx.quadraticCurveTo(x+w-r, y, x+w, y+h);
    ctx.quadraticCurveTo(x+w, y+h*1.2, x+w-r, y+h*1.25);
    ctx.quadraticCurveTo(x+w*.55, y+h*1.6, x+w*.4, y+h*1.25);
    ctx.quadraticCurveTo(x+r, y+h*1.4, x, y+h);
    ctx.closePath(); ctx.fill();
  }

  // ======= Calmer ground (subtle pebbles, slow parallax) =======
  function drawGround() {
    const y0 = H - GH;

    // base grass
    const g = ctx.createLinearGradient(0,y0,0,H);
    g.addColorStop(0,'#3b7f3b'); g.addColorStop(1,'#2c5f2c');
    ctx.fillStyle = g; ctx.fillRect(0,y0, W, GH);

    // top rim for separation
    ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(0, y0, W, 2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0, y0+2, W, 2);

    // subtle moving pebbles (wide spacing, low contrast)
    const step = Math.max(60, Math.round(W * 0.06));
    const offset = groundOffset % step;

    function pebble(cx, cy, w, h, color){
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(cx, cy, w, h, 0, 0, Math.PI*2);
      ctx.fill();
    }

    for (let x = -offset; x < W + step; x += step) {
      pebble(x + 10, y0 + Math.round(GH*0.62), 14, 5, 'rgba(255,255,255,0.08)');
      pebble(x + 36, y0 + Math.round(GH*0.72), 10, 4, 'rgba(0,0,0,0.08)');
      pebble(x + 70, y0 + Math.round(GH*0.58), 8, 3,  'rgba(255,255,255,0.06)');
    }
  }

  // ======= Mario-style pipes (narrower, with caps/rims) =======
  function drawPipe(x, topH, w=PIPE_W, gap=cfg.gap) {
    const bottomY = topH + gap;
    const capH = Math.max(10, Math.round(w * 0.35)); // rim height
    const over = Math.max(6,  Math.round(w * 0.18)); // cap overhang

    const bodyGrad = ctx.createLinearGradient(x,0,x+w,0);
    bodyGrad.addColorStop(0.00, '#096b22');
    bodyGrad.addColorStop(0.25, '#17a23a');
    bodyGrad.addColorStop(0.50, '#29d14f');
    bodyGrad.addColorStop(0.75, '#17a23a');
    bodyGrad.addColorStop(1.00, '#096b22');

    ctx.fillStyle = bodyGrad; ctx.fillRect(x, 0, w, topH);
    ctx.fillStyle = bodyGrad; ctx.fillRect(x, bottomY, w, H-bottomY);

    // body highlights
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    const sheenW = Math.max(2, Math.round(w*0.12));
    const sheenX = x + Math.round(w*0.22);
    ctx.fillRect(sheenX, 0, sheenW, topH);
    ctx.fillRect(sheenX, bottomY, sheenW, H-bottomY);

    // edges
    ctx.fillStyle = 'rgba(0,0,0,0.20)';
    ctx.fillRect(x, 0, 2, topH); ctx.fillRect(x+w-2, 0, 2, topH);
    ctx.fillRect(x, bottomY, 2, H-bottomY); ctx.fillRect(x+w-2, bottomY, 2, H-bottomY);

    // caps
    function drawCap(cx, cy, cw, ch, facingDown){
      const gradCap = ctx.createLinearGradient(cx, cy, cx, cy+ch);
      if (facingDown){ gradCap.addColorStop(0, '#62e86e'); gradCap.addColorStop(1, '#1fbf43'); }
      else           { gradCap.addColorStop(0, '#1fbf43'); gradCap.addColorStop(1, '#62e86e'); }
      ctx.fillStyle = gradCap; ctx.fillRect(cx, cy, cw, ch);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(cx, cy, cw, 2); ctx.fillRect(cx, cy+ch-2, cw, 2);
      ctx.fillStyle = 'rgba(255,255,255,0.10)';
      ctx.fillRect(cx+3, cy+Math.round(ch*0.25), cw-6, 2);
    }
    drawCap(x - over, topH - capH, w + over*2, capH, true);
    drawCap(x - over, bottomY,      w + over*2, capH, false);
  }

  // ======= Bird drawing (sprite first, vector fallback) =======
  function drawBirdSprite(b) {
    // frames: [up, mid, down] â€” cycle: mid, up, mid, down
    const cycle = [1, 0, 1, 2];
    const idx = cycle[Math.floor((b.wingPhase * 1) % 4)];
    const img = spriteFrames[idx] || spriteFrames[1] || spriteFrames[0];

    // scale so sprite height ~= 2 * r (intentional big scale)
    const desiredH = b.r * 6;
    const scale = desiredH / img.naturalHeight;
    const dw = img.naturalWidth * scale;
    const dh = img.naturalHeight * scale;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);
    // (shadow removed)
    ctx.drawImage(img, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  }

  function drawBirdVector(b) {
    // fallback vector bird
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);

    const bodyR = b.r;
    const bodyGrad = ctx.createRadialGradient(0,0, bodyR*0.2, 0,0, bodyR*1.1);
    bodyGrad.addColorStop(0, '#ffd166'); bodyGrad.addColorStop(1, '#f4a261');
    ctx.fillStyle = bodyGrad; ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.beginPath(); ctx.ellipse(0, bodyR*0.2, bodyR*0.9, bodyR*0.7, 0, 0, Math.PI*2); ctx.fill();

    ctx.save();
    const wingA = Math.sin(b.wingPhase)*0.6 - 0.2;
    ctx.rotate(wingA); ctx.translate(-bodyR*0.1, 0);
    ctx.fillStyle = '#f77f00';
    ctx.beginPath(); ctx.ellipse(-bodyR*0.1, 0, bodyR*0.7, bodyR*0.45, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(bodyR*0.35, -bodyR*0.25, bodyR*0.28, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(bodyR*0.45, -bodyR*0.25, bodyR*0.12, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#ff7f00';
    ctx.beginPath(); ctx.moveTo(bodyR*0.9, 0);
    ctx.lineTo(bodyR*1.4, -bodyR*0.1);
    ctx.lineTo(bodyR*0.9, -bodyR*0.25);
    ctx.closePath(); ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawBird(b) {
    if (spriteReady) drawBirdSprite(b);
    else drawBirdVector(b);
  }

  // ======= Collision =======
  function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  // ======= Loop =======
  let last = performance.now();
  fit(); // initial sizing

  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt, now);
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function update(dt, now){
    // wing animation
    bird.wingPhase += (state === State.PLAYING ? 14 : 10)*dt;

    // Background motion (ground parallax slow to reduce dizziness)
    groundOffset += (cfg.speed * 60) * dt * 0.18;

    // Clouds
    for (const c of clouds){ c.x -= c.speed*dt; }
    while (clouds.length && clouds[0].x + clouds[0].w < -10) clouds.shift();
    if (clouds.length < 8 && Math.random() < 0.02) makeCloud();

    if (state === State.PAUSED || state === State.READY || state === State.DEAD){
      if (state === State.READY){
        // idle bob
        bird.y += Math.sin(now*0.004)*0.3;
        bird.angle = Math.sin(now*0.004)*0.05;
      }
      return;
    }

    // PLAYING â€” mouse/finger follow (smooth)
    const followSpeed = 8; // larger = snappier
    const t = clamp(followSpeed * dt, 0, 1);
    const dy = targetY - bird.y;
    bird.y += dy * t;
    bird.angle = clamp(dy * 0.0025, -0.6, 0.6);

    // keep inside bounds
    bird.y = clamp(bird.y, bird.r+5, H - GH - bird.r - 5);

    // Spawn pipes
    pipeTimer -= dt;
    if (pipeTimer <= 0){
      const gap = cfg.gap;
      const margin = 30;
      const minY = margin + 30, maxY = H - margin - 30 - GH;
      const center = rand(minY + gap/2, Math.max(minY + gap/2, maxY - gap/2));
      pipes.push({ x: W + 8, topH: center - gap/2, w: PIPE_W, gap, scored:false });
      if (pipes.length > 12) pipes.shift();
      pipeTimer = cfg.spawn;
    }

    // Move pipes and check scoring
    for (const p of pipes){
      p.x -= (cfg.speed * 60) * dt;
      if (!p.scored && p.x + p.w < bird.x - bird.r){
        p.scored = true;
        score++;
        scoreEl.textContent = score;
        scoreChime();
      }
    }
    while (pipes.length && pipes[0].x + pipes[0].w < -10) pipes.shift();

    // Collisions (caps overhang is visual only; collision uses body width)
    const hitTop = bird.y - bird.r < 0;
    const hitGround = bird.y + bird.r > H - GH;
    let hitPipe = false;
    for (const p of pipes){
      if (circleRectCollide(bird.x, bird.y, bird.r, p.x, 0, p.w, p.topH) ||
          circleRectCollide(bird.x, bird.y, bird.r, p.x, p.topH + p.gap, p.w, H - GH - (p.topH + p.gap))){
        hitPipe = true; break;
      }
    }
    if (hitTop || hitGround || hitPipe){
      if (state !== State.DEAD){
        state = State.DEAD;
        hitSfx();
        if (score > best){ best = score; localStorage.setItem('flappy-best', String(best)); bestEl.textContent = best; }
        setTimeout(()=>{ showMenu('Game Over'); }, 450);
      }
    }
  }

  function draw(){
    drawSky();
    drawSun();

    // Clouds
    for (const c of clouds) drawCloud(c);

    // Pipes
    for (const p of pipes) drawPipe(p.x, p.topH, p.w, p.gap);

    // Bird (sprite or vector)
    drawBird(bird);

    // Ground (now calmer)
    drawGround();

    // READY hint
    if (state === State.READY){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.font = '700 18px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Click / Tap / Space to start â€” will enter fullscreen; steer with mouse/finger', W/2, H*0.62);
      ctx.restore();
    }

    if (state === State.DEAD){
      ctx.save();
      const g = ctx.createRadialGradient(W/2,H/2, 50, W/2,H/2, Math.max(W,H)*0.6);
      g.addColorStop(0, 'rgba(239,71,111,0)');
      g.addColorStop(1, 'rgba(239,71,111,0.25)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }
  }

  // Init
  restart();
})();
</script>
</body>
</html>
