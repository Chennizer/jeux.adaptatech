<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centered Tag Style Graffiti</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #wall-canvas, #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #wall-canvas { z-index: 0; }
        #game-canvas { z-index: 1; }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            transition: opacity 0.5s;
        }

        h1 {
            font-size: clamp(30px, 5vw, 80px); 
            color: #FFD700;
            text-shadow: 4px 4px 0px #FF4500, -2px -2px 0 #FFF;
            margin-bottom: 30px;
            font-family: 'Verdana', sans-serif; 
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            transform: skew(-8deg);
            text-align: center; 
        }

        @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap'); 

        h1, input, button {
            font-family: 'Permanent Marker', cursive;
        }

        input[type="text"] {
            font-size: clamp(24px, 3vw, 48px); 
            padding: 15px;
            width: 60%;
            max-width: 500px; 
            text-align: center;
            background: #eee;
            border: 6px solid #000;
            color: #000;
            border-radius: 20px;
            outline: none;
            text-transform: uppercase;
            box-shadow: 5px 5px 0 #888;
        }

        button {
            margin-top: 30px;
            font-size: clamp(20px, 2.5vw, 40px); 
            padding: 15px 50px;
            background: #00BFFF;
            color: white;
            border: 4px solid white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 900;
            box-shadow: 0 0 20px #00BFFF;
            transition: transform 0.1s;
        }

        button:active { transform: scale(0.95); }
        
        .instruction {
            margin-top: 20px;
            color: #aaa;
            font-size: clamp(12px, 1.2vw, 20px);
            font-family: sans-serif;
            text-align: center;
        }
    </style>
</head>
<body>

    <canvas id="wall-canvas"></canvas>
    <canvas id="game-canvas"></canvas>

    <div id="overlay">
        <h1>WILD STYLE TAGS</h1>
        <input type="text" id="user-input" placeholder="YOUR TAG" maxlength="15" autocomplete="off"> 
        <button id="start-btn">BEGIN</button>
        <p class="instruction">Press SPACE or TAP to draw</p>
    </div>

    <script>
        const gameCanvas = document.getElementById('game-canvas');
        const wallCanvas = document.getElementById('wall-canvas');
        const ctx = gameCanvas.getContext('2d');
        const wCtx = wallCanvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const inputField = document.getElementById('user-input');
        const startBtn = document.getElementById('start-btn');
        const body = document.body;

        let width, height, audioCtx, sprayNode;
        
        // --- HIGHLY STYLIZED ALPHABET (Normalized Coordinates 0-1) ---
        const alphabet = {
            'A': [[{x:0.1,y:1.1}, {x:0.5,y:-0.1}, {x:0.9,y:1.1}], [{x:0.2,y:0.6}, {x:0.8,y:0.5}]],
            'B': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.1,y:0}], [{x:0.1,y:0}, {x:0.9,y:0.2}, {x:0.1,y:0.5}], [{x:0.1,y:0.5}, {x:1.0,y:0.8}, {x:0.1,y:1.1}]],
            'C': [[{x:0.9,y:0.2}, {x:0.5,y:-0.1}, {x:0.1,y:0.5}, {x:0.5,y:1.1}, {x:0.9,y:0.8}]],
            'D': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.1,y:0}], [{x:0.1,y:0}, {x:1.0,y:0.5}, {x:0.1,y:1.1}]],
            'E': [[{x:0.9,y:0}, {x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.9,y:1.1}], [{x:0.1,y:0.5}, {x:0.8,y:0.5}]],
            'F': [[{x:0.1,y:1.1}, {x:0.15,y:0}, {x:0.9,y:0}], [{x:0.1,y:0.5}, {x:0.8,y:0.5}]],
            'G': [[{x:0.9,y:0.2}, {x:0.5,y:-0.1}, {x:0.0,y:0.5}, {x:0.5,y:1.1}, {x:0.9,y:0.8}, {x:0.9,y:0.5}, {x:0.6,y:0.5}]],
            'H': [[{x:0.1,y:0}, {x:0.15,y:1.1}], [{x:0.9,y:0}, {x:0.85,y:1.1}], [{x:0.1,y:0.5}, {x:0.9,y:0.5}]],
            'I': [[{x:0.5,y:0}, {x:0.5,y:1.1}], [{x:0.3,y:0}, {x:0.7,y:0}], [{x:0.3,y:1.1}, {x:0.7,y:1.1}]],
            'J': [[{x:0.7,y:0}, {x:0.7,y:0.8}, {x:0.5,y:1.1}, {x:0.2,y:0.9}]],
            'K': [[{x:0.1,y:0}, {x:0.15,y:1.1}], [{x:0.9,y:0}, {x:0.1,y:0.6}, {x:1.0,y:1.1}]],
            'L': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.9,y:1.1}]],
            'M': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.5,y:0.7}, {x:0.9,y:-0.1}, {x:0.9,y:1.1}]],
            'N': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:1.1}, {x:0.9,y:-0.1}]],
            'O': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}]],
            'P': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:0.25}, {x:0.1,y:0.5}]],
            'Q': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}], [{x:0.6,y:0.7}, {x:1.0,y:1.1}]],
            'R': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:0.25}, {x:0.1,y:0.5}, {x:0.9,y:1.1}]],
            'S': [[{x:0.9,y:0.1}, {x:0.1,y:0.1}, {x:0.0,y:0.5}, {x:1.0,y:0.5}, {x:0.9,y:0.9}, {x:0.1,y:0.9}]],
            'T': [[{x:0.5,y:-0.1}, {x:0.5,y:1.1}], [{x:0.1,y:0}, {x:0.9,y:0}]],
            'U': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.85,y:1.1}, {x:0.9,y:0}]],
            'V': [[{x:0.1,y:0}, {x:0.5,y:1.1}, {x:0.9,y:0}]],
            'W': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.5,y:0.6}, {x:0.85,y:1.1}, {x:0.9,y:0}]],
            'X': [[{x:0.1,y:0}, {x:0.9,y:1.1}], [{x:0.9,y:0}, {x:0.1,y:1.1}]],
            'Y': [[{x:0.1,y:0}, {x:0.5,y:0.6}], [{x:0.9,y:0}, {x:0.5,y:0.6}, {x:0.5,y:1.1}]],
            'Z': [[{x:0.1,y:0}, {x:0.9,y:0}, {x:0.1,y:1.1}, {x:0.9,y:1.1}]],
            ' ': [],
            '1': [[{x:0.3,y:0}, {x:0.5,y:0}, {x:0.5,y:1.1}], [{x:0.3,y:1.1}, {x:0.7,y:1.1}]],
            '2': [[{x:0.2,y:0.2}, {x:0.8,y:0.2}, {x:0.8,y:0.5}, {x:0.2,y:1.1}, {x:0.9,y:1.1}]],
            '3': [[{x:0.2,y:0}, {x:0.8,y:0}, {x:0.4,y:0.5}, {x:0.8,y:0.5}, {x:0.8,y:1.1}, {x:0.2,y:1.1}]],
            '4': [[{x:0.8,y:1.1}, {x:0.8,y:0}], [{x:0.8,y:0.6}, {x:0.1,y:0.6}, {x:0.5,y:0}]],
            '5': [[{x:0.8,y:0}, {x:0.2,y:0}, {x:0.2,y:0.4}, {x:0.8,y:0.6}, {x:0.2,y:1.1}]],
            '6': [[{x:0.8,y:0}, {x:0.2,y:0.5}, {x:0.2,y:1.1}, {x:0.8,y:1.1}, {x:0.8,y:0.5}, {x:0.2,y:0.5}]],
            '7': [[{x:0.1,y:0}, {x:0.9,y:0}, {x:0.4,y:1.1}]],
            '8': [[{x:0.5,y:0.5}, {x:0.2,y:0.2}, {x:0.8,y:0.2}, {x:0.5,y:0.5}, {x:0.2,y:0.8}, {x:0.8,y:0.8}, {x:0.5,y:0.5}]],
            '9': [[{x:0.8,y:0.5}, {x:0.2,y:0.5}, {x:0.2,y:0}, {x:0.8,y:0}, {x:0.8,y:1.1}]],
            '0': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}]]
        };

        const colorCombos = [
            { top: '#FF4500', bottom: '#FFD700' }, 
            { top: '#00BFFF', bottom: '#F0F8FF' }, 
            { top: '#FF1493', bottom: '#FFB6C1' }, 
            { top: '#32CD32', bottom: '#ADFF2F' }, 
            { top: '#9400D3', bottom: '#DA70D6' }, 
            { top: '#FF8C00', bottom: '#FFFF00' }  
        ];

        // Game Logic Variables
        let isSpraying = false;
        let targetText = "TAGS"; 
        let textCharIndex = 0; 
        let currentWordRow = 0; 
        let maxWordRows = 3; 

        let currentStrokes = []; 
        let currentStrokeIndex = 0; 
        let currentPointIndex = 0; 
        
        let currentStyle = null;
        let letterDrawOrigin = { x: 0, y: 0 }; 
        let letterHeightScale = 0; 
        let currentWordWidth = 0; 
        let wordStartX = 0; 
        let charSkew = 0; 
        let charScaleFactor = 1;
        let startYOffset = 0; // Vertical offset for centering
        let fixedRowHeight = 0; // New fixed size based on percentage

        // --- FULLSCREEN LOGIC ---
        function enterFullscreen(element) {
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }

        // --- WALL GENERATOR ---
        function generateWall() {
    width = window.innerWidth;
    height = window.innerHeight;
    [wallCanvas, gameCanvas].forEach(c => { c.width = width; c.height = height; });

    fixedRowHeight = Math.min(width, height) * 0.24; 

    // estimate width per char including gap
    const baseLetterHeight = fixedRowHeight * 0.8;
    const approxLetterWidth = baseLetterHeight * 0.75;
    const leftMargin = width * 0.03;
    const rightLimit = width * 0.97;
    const usableWidth = rightLimit - leftMargin;
    const maxCharsPerRow = Math.max(1, Math.floor(usableWidth / approxLetterWidth));

    const totalChars = (targetText || "").length;
    const rowsNeeded = Math.max(1, Math.ceil(totalChars / maxCharsPerRow));

    maxWordRows = rowsNeeded;

    const totalTextHeight = fixedRowHeight * maxWordRows; 
    startYOffset = (height - totalTextHeight) / 2; 

    // Reset state
    textCharIndex = 0;
    currentWordRow = 0;
    currentWordWidth = 0;
    wordStartX = 0;

    // BASE WALL COLOR â€“ dark earthy brown instead of near-black
    wCtx.fillStyle = '#2b1b17';
    wCtx.fillRect(0, 0, width, height);

    const brickW = 100;
    const brickH = 50;

    // CLAY / NATURAL BRICK COLORS
    for (let y = 0; y < height; y += brickH) {
        const offset = (y / brickH % 2 === 0) ? 0 : brickW / 2;
        for (let x = -brickW; x < width; x += brickW) {
            // warm orange-brown with slight variation per brick
            let r = 165 + Math.floor(Math.random() * 30); // 165-195
            let g = 95  + Math.floor(Math.random() * 25); // 95-120
            let b = 70  + Math.floor(Math.random() * 20); // 70-90
            wCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            wCtx.fillRect(x + offset, y, brickW - 4, brickH - 4);
        }
    }

    // Softer vignette so bricks stay visible
    const grad = wCtx.createRadialGradient(
        width / 2, height / 2, height / 3,
        width / 2, height / 2, height
    );
    grad.addColorStop(0, 'rgba(0,0,0,0.15)');
    grad.addColorStop(1, 'rgba(0,0,0,0.85)');
    wCtx.fillStyle = grad;
    wCtx.fillRect(0, 0, width, height);
}

        window.addEventListener('resize', generateWall);

        // --- AUDIO ENGINE ---
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function startSpraySound() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 2; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            noise.loop = true;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            
            const gain = audioCtx.createGain();
            gain.gain.value = 0.15;
            
            noise.connect(filter).connect(gain).connect(audioCtx.destination);
            noise.start();
            sprayNode = { source: noise, gain: gain };
        }

        function stopSpraySound() {
            if (sprayNode) {
                sprayNode.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                sprayNode.source.stop(audioCtx.currentTime + 0.2);
                sprayNode = null;
            }
        }

        function playPopSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.connect(gain).connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        // --- DRAWING UTILS ---
        function calculateLetterPosition() {
            const baseRowHeight = fixedRowHeight; 
            const baseLetterHeight = baseRowHeight * 0.8; 

            letterHeightScale = baseLetterHeight * (1 + (Math.random() - 0.5) * 0.15); 
            const effectiveLetterWidth = letterHeightScale * 0.65; 

            charSkew = (Math.random() - 0.5) * 0.3; 
            charScaleFactor = 1 + (Math.random() - 0.5) * 0.1; 

            if (textCharIndex === 0) { 
                wordStartX = width * 0.03; 
                const verticalOffset = baseRowHeight * 0.1; 
                
                letterDrawOrigin.y = (currentWordRow * baseRowHeight) 
                    + (baseRowHeight - letterHeightScale) / 2 
                    + verticalOffset 
                    + startYOffset;
                
                if (currentWordRow === 0 && letterDrawOrigin.y < height * 0.01) {
                     letterDrawOrigin.y = height * 0.01; 
                }

                letterDrawOrigin.x = wordStartX;
            } else {
                const prevChar = targetText[textCharIndex - 1];
                let prevLetterActualWidth = effectiveLetterWidth * charScaleFactor; 
                if (prevChar === 'I' || prevChar === '1') prevLetterActualWidth *= 0.6; 
                if (prevChar === 'M' || prevChar === 'W') prevLetterActualWidth *= 1.2; 

                // Positive gap between letters instead of overlap
                const baseGap = effectiveLetterWidth * 0.18;      // main spacing
                const jitter = effectiveLetterWidth * (Math.random() * 0.04 - 0.02); // small random variation
                letterDrawOrigin.x = letterDrawOrigin.x + prevLetterActualWidth + baseGap + jitter;
                
                const bounceRange = letterHeightScale * 0.1;
                letterDrawOrigin.y += (Math.random() - 0.5) * bounceRange;
                 
                const rowBottomLimit = (currentWordRow + 1) * baseRowHeight - (baseRowHeight * 0.1) + startYOffset; 
                if (letterDrawOrigin.y + letterHeightScale * charScaleFactor > rowBottomLimit) {
                    letterDrawOrigin.y = rowBottomLimit - letterHeightScale * charScaleFactor;
                }
            }
        }

        function getAbsPoint(pt) {
            let x = pt.x * letterHeightScale * charScaleFactor * 0.6 + (pt.y * charSkew * letterHeightScale * 0.45);
            let y = pt.y * letterHeightScale * charScaleFactor;

            return {
                x: letterDrawOrigin.x + x,
                y: letterDrawOrigin.y + y
            };
        }

        function createLetterGradient(topColor, bottomColor) {
            const topY = letterDrawOrigin.y;
            const botY = letterDrawOrigin.y + letterHeightScale * charScaleFactor;
            const grad = ctx.createLinearGradient(0, topY, 0, botY);
            grad.addColorStop(0, topColor);
            grad.addColorStop(1, bottomColor);
            return grad;
        }

        // --- ANIMATION ENGINE ---
        function drawOutline() {
            const outlineThickness = letterHeightScale * 0.08;
            ctx.globalCompositeOperation = 'destination-over';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = outlineThickness;
            ctx.strokeStyle = 'black';

            currentStrokes.forEach(stroke => {
                ctx.beginPath();
                stroke.forEach((pt, i) => {
                    const abs = getAbsPoint(pt);
                    if (i===0) ctx.moveTo(abs.x, abs.y);
                    else ctx.lineTo(abs.x, abs.y);
                });
                ctx.stroke();
            });
            
            ctx.globalCompositeOperation = 'source-over';
        }
        
        function drawDrips() {
            ctx.strokeStyle = currentStyle.bottom; 
            ctx.lineWidth = letterHeightScale * 0.035; 
            ctx.lineCap = 'round';
            ctx.globalAlpha = 0.85;

            currentStrokes.flat().forEach(pt => {
                if (Math.random() > 0.7) { 
                    const abs = getAbsPoint(pt);
                    const dripLength = letterHeightScale * (0.25 + Math.random() * 0.45); 
                    const dripOffset = letterHeightScale * 0.04; 
                    ctx.beginPath();
                    ctx.moveTo(abs.x, abs.y + dripOffset); 
                    ctx.lineTo(abs.x + (Math.random()-0.5)*10, abs.y + dripOffset + dripLength); 
                    ctx.stroke();
                }
            });
            ctx.globalAlpha = 1.0;
        }

        function drawSplatter(x, y, color) {
            const splatterRadius = letterHeightScale * (0.25 + Math.random() * 0.35); 
            const numParticles = 10 + Math.random() * 12; 
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.45;

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * splatterRadius;
                const px = x + Math.cos(angle) * distance;
                const py = y + Math.sin(angle) * distance;
                const radius = 0.8 + Math.random() * 3; 
                ctx.beginPath();
                ctx.arc(px, py, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        // Softer spray: fewer, smaller dots
        function sprayBetween(start, end, duration, gradient) {
            return new Promise(resolve => {
                const startTime = performance.now();
                startSpraySound();
                let lastProgress = 0;

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    const bubbleThickness = letterHeightScale * 0.22; 

                    const steps = 5;
                    for (let i = 0; i < steps; i++) {
                        const t = lastProgress + (progress - lastProgress) * (i / steps);
                        const baseX = start.x + (end.x - start.x) * t;
                        const baseY = start.y + (end.y - start.y) * t;

                        const dotCount = 5;
                        for (let j = 0; j < dotCount; j++) {
                            const r = Math.random() * bubbleThickness * 0.5;
                            const angle = Math.random() * Math.PI * 2;
                            const jitterX = (Math.random() - 0.5) * 3;
                            const jitterY = (Math.random() - 0.5) * 3;
                            const px = baseX + Math.cos(angle) * r + jitterX;
                            const py = baseY + Math.sin(angle) * r + jitterY;

                            ctx.fillStyle = gradient;
                            ctx.globalAlpha = 0.25 + Math.random() * 0.25;
                            const radius = 0.7 + Math.random() * (bubbleThickness * 0.07);
                            ctx.beginPath();
                            ctx.arc(px, py, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Thin core stroke
                    ctx.globalAlpha = 0.9;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = bubbleThickness * 0.4;
                    ctx.strokeStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(start.x + (end.x - start.x) * lastProgress,
                               start.y + (end.y - start.y) * lastProgress);
                    ctx.lineTo(start.x + (end.x - start.x) * progress,
                               start.y + (end.y - start.y) * progress);
                    ctx.stroke();

                    ctx.globalAlpha = 1.0;
                    lastProgress = progress;

                    if (progress < 1) requestAnimationFrame(animate);
                    else {
                        stopSpraySound();
                        resolve();
                    }
                }
                requestAnimationFrame(animate);
            });
        }

        // --- MAIN GAME LOOP ---
        async function trigger() {
            if (isSpraying) return;
            isSpraying = true;

            // --- A. START A NEW LETTER ---
            if (currentStrokes.length === 0) {
                const baseLetterHeight = fixedRowHeight * 0.8; 
                let estimatedNextCharWidth = baseLetterHeight * 0.75; // include spacing
                let nextChar = targetText[textCharIndex] || '';

                if (nextChar === 'I' || nextChar === '1') estimatedNextCharWidth *= 0.6;
                if (nextChar === 'M' || nextChar === 'W') estimatedNextCharWidth *= 1.2;

                const maxAllowedX = width * 0.97; 

                if (textCharIndex >= targetText.length || (letterDrawOrigin.x + estimatedNextCharWidth) > maxAllowedX) {
                    textCharIndex = 0; 
                    currentWordRow++;
                    letterDrawOrigin.x = wordStartX; 
                }
                
                if (currentWordRow >= maxWordRows) {
                    ctx.fillStyle = '#1a1a1a'; 
                    ctx.globalAlpha = 0.9;
                    ctx.fillRect(0,0,width,height);
                    ctx.globalAlpha = 1.0;
                    currentWordRow = 0;
                    letterDrawOrigin.x = wordStartX; 
                    await new Promise(r => setTimeout(r, 300));
                }

                let char = targetText[textCharIndex];
                let strokes = alphabet[char] || alphabet['?']; 
                
                calculateLetterPosition(); 
                currentStyle = colorCombos[textCharIndex % colorCombos.length]; 

                if (strokes && strokes.length > 0) {
                    currentStrokes = strokes;
                    currentStrokeIndex = 0;
                    currentPointIndex = 0;

                    const p1 = getAbsPoint(currentStrokes[0][0]);
                    const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(p1.x, p1.y, letterHeightScale * 0.16, 0, Math.PI*2);
                    ctx.fill();
                    
                    currentPointIndex = 1;
                    isSpraying = false;
                    return;
                } else {
                    textCharIndex++;
                    letterDrawOrigin.x += fixedRowHeight * 0.7 * 0.5;
                    isSpraying = false;
                    trigger(); 
                    return;
                }
            }

            // --- B. CONTINUE DRAWING ---
            let currentStrokePoints = currentStrokes[currentStrokeIndex];
            
            if (currentPointIndex < currentStrokePoints.length) {
                const pStart = getAbsPoint(currentStrokePoints[currentPointIndex-1]);
                const pEnd = getAbsPoint(currentStrokePoints[currentPointIndex]);
                const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);
                
                await sprayBetween(pStart, pEnd, 400, grad); 
                currentPointIndex++;
            }

            // --- C. END OF STROKE ---
            if (currentPointIndex >= currentStrokePoints.length) {
                currentStrokeIndex++;
                currentPointIndex = 1; 
                
                if (currentStrokeIndex < currentStrokes.length) {
                    const pNewStart = getAbsPoint(currentStrokes[currentStrokeIndex][0]);
                    const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(pNewStart.x, pNewStart.y, letterHeightScale * 0.16, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // --- D. END OF LETTER ---
            if (currentStrokeIndex >= currentStrokes.length) {
                playPopSound();
                drawOutline();
                drawDrips();
                
                const splatX = letterDrawOrigin.x + (letterHeightScale * 0.4 * charScaleFactor);
                const splatY = letterDrawOrigin.y + (letterHeightScale * charScaleFactor);
                drawSplatter(splatX, splatY, currentStyle.bottom);

                currentStrokes = [];
                textCharIndex++;
            }

            isSpraying = false;
        }

        // --- INIT ---
        generateWall();

        startBtn.addEventListener('click', () => {
            const txt = inputField.value.toUpperCase().trim();
            if (txt.length > 0) {
                targetText = txt.replace(/[^A-Z0-9 ]/g, '').substring(0, 15); 
                if (targetText.length === 0) targetText = "TAGS";

                initAudio();
                enterFullscreen(body); 
                overlay.style.opacity = 0;
                setTimeout(() => overlay.style.display = 'none', 500);
                
                generateWall(); 
                ctx.clearRect(0, 0, width, height); 
                textCharIndex = 0;
                currentWordRow = 0;
                currentWordWidth = 0;
                wordStartX = 0;
                trigger();
            }
        });

        const handleInput = (e) => {
            if (overlay.style.display !== 'none') return;
            if(e.type === 'keydown' && e.code !== 'Space') return;
            if(e.type === 'touchstart') e.preventDefault();
            trigger();
        };

        document.addEventListener('keydown', handleInput);
        document.addEventListener('mousedown', handleInput);
        document.addEventListener('touchstart', handleInput, {passive: false});

    </script>
</body>
</html>
