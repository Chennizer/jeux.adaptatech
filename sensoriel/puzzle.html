<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../../images/binou.png">
  <link rel="stylesheet" href="../../css/ipadteachh.css">
  <link rel="stylesheet" href="../../css/control-panel.css">
  <title>2×2 Puzzle with Bold Border and No Scrolling</title>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    .puzzle-container {
      width: calc(100vw - 60px);
      height: calc(100vh - 60px);
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 40px;
      padding: 20px;
      flex-wrap: wrap;
      overflow: hidden;
      position: relative;
    }
    #piecesArea {
      position: relative;
      width: 350px;
      height: 350px;
      background: #ddd;
      border: 2px solid #999;
      border-radius: 8px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 20px;
      overflow: hidden;
      max-width: 90%;
      max-height: 90%;
    }
    #puzzleArea {
      width: 268px;
      height: 268px;
      background: #fff;
      border: 4px solid #000;
      border-radius: 8px;
      display: grid;
      grid-template-columns: repeat(2, 130px);
      grid-template-rows: repeat(2, 130px);
      gap: 0;
      box-sizing: border-box;
      position: relative;
      max-width: 90%;
      max-height: 90%;
    }
    #toggleReferenceContainer {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      text-align: center;
    }
    .slot {
      width: 130px;
      height: 130px;
      background: #e2e2e2;
      border: 1px solid #ccc;
      position: relative;
      overflow: hidden; 
      box-sizing: border-box;
    }
    .draggable-piece {
      width: 130px;
      height: 130px;
      cursor: grab;
      border: 2px solid transparent;
      border-radius: 4px;
      object-fit: cover;  
      position: absolute;
      touch-action: none;
      user-select: none;
      transition: opacity 0.2s;
    }
    .draggable-piece.active {
      opacity: 0.8;
      cursor: grabbing;
      z-index: 1000;
    }
    #hiddenCanvas {
      display: none;
    }
    h1 {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 1.5rem;
      color: #333;
      z-index: 10;
    }
    .highlight {
      outline: 3px dashed #00aaff; 
      outline-offset: -5px;
      background-color: rgba(0, 170, 255, 0.1);
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: #fefefe;
      padding: 20px;
      border-radius: 8px;
      position: relative;
      max-width: 90%;
      max-height: 90%;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .modal.flex {
      display: flex;
    }
    @media (max-width: 800px) {
      #piecesArea {
        width: 300px;
        height: 300px;
      }
      #puzzleArea {
        width: 268px;
        height: 268px;
      }
      .puzzle-container {
        gap: 20px;
        padding: 10px;
      }
    }
    @media (max-width: 600px) {
      #piecesArea {
        width: 250px;
        height: 250px;
      }
      #puzzleArea {
        width: 218px;
        height: 218px;
      }
      .draggable-piece {
        width: 100px;
        height: 100px;
      }
      h1 {
        font-size: 1.2rem;
      }
    }
    #reinforcerOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255,255,255,0.8);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 1001;
    }
    #reinforcerButton {
      display: none;
      width: 100px;
      height: 100px;
      background: url('../../images/smiley.png') no-repeat center center;
      background-size: cover;
      border: none;
      cursor: pointer;
      z-index: 1002;
    }
    #reinforcerVideo {
      display: none;
      max-width: 80%;
      max-height: 80%;
    }
    #videoOverlayCover {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0);
      z-index: 1003;
    }
  </style>
</head>
<body>

  <h1>Casse-tête</h1>

  <!-- Container for Puzzle and Pieces -->
  <div class="puzzle-container">
    <div id="piecesArea"></div>
    <div id="puzzleArea"></div>
  </div>

  <!-- Reference Button -->
  <div id="toggleReferenceContainer">
    <button id="toggleReference" class="button">Show Reference</button>
  </div>

  <!-- Reference Modal -->
  <div id="referenceModal" class="modal">
    <div class="modal-content">
      <img class="modal-image" src="../../images/toupieetbinou.png" alt="Completed Puzzle Model">
    </div>
  </div>

  <!-- Reinforcer Overlay -->
  <div id="reinforcerOverlay">
    <button
      id="reinforcerButton"
      aria-label="Jouer la vidéo de renforcement"
    ></button>
    <video
      id="reinforcerVideo"
      playsinline
      webkit-playsinline
      disablepictureinpicture
      controlslist="nodownload noremoteplayback"
    ></video>
    <div id="videoOverlayCover"></div>
  </div>

  <canvas id="hiddenCanvas"></canvas>

  <script>
    // Define ROWS, COLS, PIECE_SIZE GLOBALLY so they are accessible in all functions
    const ROWS       = 2;
    const COLS       = 2;
    const PIECE_SIZE = 130;

    document.addEventListener('DOMContentLoaded', () => {
      const gameIdentifier = 'puzzle';
      const selections = JSON.parse(localStorage.getItem('gameSelections'));
      let currentGameIndex = parseInt(localStorage.getItem('currentGameIndex'), 10);

      // If no game selections stored, or invalid data, redirect to main page
      if (!selections || !selections.gameOrder || isNaN(currentGameIndex)) {
        alert("Game selections not found. Redirecting to selection page.");
        window.location.href = "main.html";
        return;
      }

      // If this page is not the correct next game, redirect
      if (selections.gameOrder[currentGameIndex] !== gameIdentifier) {
        alert("This is not your current game. Redirecting to the correct game.");
        window.location.href = selections.gameOrder[currentGameIndex] + ".html";
        return;
      }

      // Determine puzzle image from the user's media selection
      const mediaOption = selections.mediaOption || "";
      let imageSrc;
      switch(mediaOption) {
        case "moana":
          imageSrc = "../../images/moana-background.jpg";
          break;
        case "monde":
          imageSrc = "../../images/worldmap.jpg";
          break;
        case "nature":
          imageSrc = "../../images/nature-background.png";
          break;
        default:
          imageSrc = "../../images/toupieetbinou.png";
      }

      // Update reference modal image to match the media option
      const referenceImage = document.querySelector('.modal-image');
      referenceImage.src = imageSrc;

      // Start puzzle
      initializePuzzleGame(imageSrc);
    });

    function initializePuzzleGame(puzzleImagePath) {
      puzzlePieces = [];
      const hiddenCanvas = document.getElementById('hiddenCanvas');
      const piecesArea   = document.getElementById('piecesArea');
      const puzzleArea   = document.getElementById('puzzleArea');
      const ctx          = hiddenCanvas.getContext('2d');

      const puzzleImage = new Image();
      puzzleImage.src = puzzleImagePath;
      puzzleImage.onload = () => {
        puzzleArea.innerHTML  = "";
        piecesArea.innerHTML  = "";
        puzzlePieces = [];

        hiddenCanvas.width  = puzzleImage.width;
        hiddenCanvas.height = puzzleImage.height;
        ctx.drawImage(puzzleImage, 0, 0);

        const sourcePieceWidth  = puzzleImage.width  / COLS;
        const sourcePieceHeight = puzzleImage.height / ROWS;

        let pieceIndex = 0;
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            const pieceCanvas = document.createElement('canvas');
            pieceCanvas.width  = sourcePieceWidth;
            pieceCanvas.height = sourcePieceHeight;
            const pieceCtx = pieceCanvas.getContext('2d');
            pieceCtx.drawImage(
              puzzleImage,
              col * sourcePieceWidth,
              row * sourcePieceHeight,
              sourcePieceWidth,
              sourcePieceHeight,
              0,
              0,
              sourcePieceWidth,
              sourcePieceHeight
            );
            const pieceDataURL = pieceCanvas.toDataURL();
            puzzlePieces.push({
              index: pieceIndex,
              row,
              col,
              img: pieceDataURL
            });
            pieceIndex++;
          }
        }

        // Create puzzle slots
        for (let i = 0; i < puzzlePieces.length; i++) {
          const slot = document.createElement('div');
          slot.classList.add('slot');
          slot.dataset.index = i;
          slot.addEventListener('dragover', allowDrop);
          slot.addEventListener('drop', onDrop);
          slot.addEventListener('dragenter', onDragEnter);
          slot.addEventListener('dragleave', onDragLeave);
          puzzleArea.appendChild(slot);
        }

        // Allow dropping back to piecesArea
        piecesArea.addEventListener('dragover', allowDrop);
        piecesArea.addEventListener('drop', onDropLeft);
        piecesArea.addEventListener('dragenter', onDragEnter);
        piecesArea.addEventListener('dragleave', onDragLeave);

        // Shuffle and place puzzle pieces in piecesArea
        shuffleArray(puzzlePieces);
        puzzlePieces.forEach(piece => {
          const imgEl = document.createElement('img');
          imgEl.src = piece.img;
          imgEl.classList.add('draggable-piece');
          imgEl.draggable = true;
          imgEl.dataset.index = piece.index;
          imgEl.style.width  = PIECE_SIZE + "px";
          imgEl.style.height = PIECE_SIZE + "px";
          imgEl.addEventListener('dragstart', onDragStart);
          imgEl.addEventListener('dragend',   onDragEnd);

          placePieceRandomlyInGrid(imgEl, piecesArea.clientWidth, piecesArea.clientHeight);
          piecesArea.appendChild(imgEl);

          // Touch events
          imgEl.addEventListener('touchstart', touchStartHandler, { passive: false });
          imgEl.addEventListener('touchmove',  touchMoveHandler,  { passive: false });
          imgEl.addEventListener('touchend',   touchEndHandler);
        });
      };

      puzzleImage.onerror = (err) => {
        console.error("Puzzle image failed to load:", err);
      };
    }

    /**
     * Place piece randomly in #piecesArea
     */
    function placePieceRandomlyInGrid(pieceEl, containerW, containerH) {
      const totalCells = ROWS * COLS;
      const randomCell = Math.floor(Math.random() * totalCells);

      const cellWidth  = containerW / COLS;
      const cellHeight = containerH / ROWS;
      const maxOffsetX = cellWidth  - PIECE_SIZE - 10;
      const maxOffsetY = cellHeight - PIECE_SIZE - 10;

      const offsetX = Math.floor(Math.random() * Math.max(1, maxOffsetX));
      const offsetY = Math.floor(Math.random() * Math.max(1, maxOffsetY));

      const cellRow = Math.floor(randomCell / COLS);
      const cellCol = randomCell % COLS;

      pieceEl.style.left = (cellCol * cellWidth + offsetX) + 'px';
      pieceEl.style.top  = (cellRow * cellHeight + offsetY) + 'px';
    }

    /**
     * Drag & Drop handlers
     */
    function onDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.index);
      e.target.classList.add('active');
      const originalParent = e.target.parentElement;
      e.target.dataset.originalParent = originalParent.id || originalParent.className;
      if (originalParent.classList.contains('slot')) {
        e.target.dataset.originalSlot = originalParent.dataset.index;
      } else {
        e.target.dataset.originalSlot = 'piecesArea';
      }
    }
    function onDragEnd(e) {
      e.target.classList.remove('active');
    }
    function allowDrop(e) {
      e.preventDefault();
    }
    function onDragEnter(e) {
      e.currentTarget.classList.add('highlight');
    }
    function onDragLeave(e) {
      e.currentTarget.classList.remove('highlight');
    }

    // Dropping onto puzzle slots
    function onDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('highlight');

      const pieceIndex = e.dataTransfer.getData('text/plain');
      const slot = e.currentTarget;
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);
      if (!draggedImg) return;

      const originalParentId = draggedImg.dataset.originalParent;
      const originalSlot     = draggedImg.dataset.originalSlot;
      const existingPiece    = slot.querySelector('img');

      if (existingPiece) {
        if (originalParentId === 'piecesArea') {
          // Move existing piece back to #piecesArea
          document.getElementById('piecesArea').appendChild(existingPiece);
          existingPiece.style.position = 'absolute';
          existingPiece.style.width  = PIECE_SIZE + "px";
          existingPiece.style.height = PIECE_SIZE + "px";
          placePieceRandomlyInGrid(existingPiece, 350, 350);
        } else {
          // If original container was another slot
          const originalSlotElement = document.querySelector(`.slot[data-index='${originalSlot}']`);
          if (originalSlotElement) {
            originalSlotElement.innerHTML = '';
            originalSlotElement.appendChild(existingPiece);
            existingPiece.style.position = 'absolute';
            existingPiece.style.left = '0';
            existingPiece.style.top  = '0';
            existingPiece.style.width  = '100%';
            existingPiece.style.height = '100%';
          }
        }
      }

      slot.innerHTML = '';
      slot.appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.left = '0';
      draggedImg.style.top  = '0';
      draggedImg.style.width  = '100%';
      draggedImg.style.height = '100%';

      draggedImg.dataset.originalParent = slot.classList.contains('slot') ? slot.className : slot.id;
      draggedImg.dataset.originalSlot   = slot.dataset.index;
      checkPuzzleCompletion();
    }

    // Dropping back into #piecesArea
    function onDropLeft(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('highlight');
      const pieceIndex = e.dataTransfer.getData('text/plain');
      const draggedImg = document.querySelector(`.draggable-piece[data-index='${pieceIndex}']`);
      if (!draggedImg) return;

      const originalParentId = draggedImg.dataset.originalParent;
      const originalSlot     = draggedImg.dataset.originalSlot;

      if (originalParentId !== 'piecesArea') {
        const originalSlotElement = document.querySelector(`.slot[data-index='${originalSlot}']`);
        if (originalSlotElement) {
          originalSlotElement.innerHTML = "";
        }
      }
      document.getElementById('piecesArea').appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.width  = PIECE_SIZE + "px";
      draggedImg.style.height = PIECE_SIZE + "px";
      placePieceRandomlyInGrid(draggedImg, 350, 350);

      draggedImg.dataset.originalParent = 'piecesArea';
      draggedImg.dataset.originalSlot   = 'piecesArea';
    }

    // Shuffle array in-place
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Check puzzle completion
    function checkPuzzleCompletion() {
      let correct = 0;
      const slots = document.querySelectorAll('.slot');
      slots.forEach(slot => {
        const slotIndex = slot.dataset.index;
        const pieceImg  = slot.querySelector('img');
        if (pieceImg && pieceImg.dataset.index === slotIndex) {
          correct++;
        }
      });
      if (correct === ROWS * COLS) {
        showReinforcerPrompt();
      }
    }

    /**
     * Show reinforcer overlay
     */
    function showReinforcerPrompt() {
      const reinforcerOverlay = document.getElementById('reinforcerOverlay');
      const reinforcerButton  = document.getElementById('reinforcerButton');
      const reinforcerVideo   = document.getElementById('reinforcerVideo');
      reinforcerOverlay.style.display = 'flex';
      reinforcerButton.style.display  = 'block';
      reinforcerVideo.src = getReinforcerVideoSource();
      reinforcerVideo.removeAttribute('controls');
      reinforcerVideo.controls = false;
    }

    function getReinforcerVideoSource() {
      const selections = JSON.parse(localStorage.getItem("gameSelections")) || {};
      const mediaOption = selections.mediaOption || "";
      switch(mediaOption) {
        case "moana":
          return "../../videos/africa.mp4";
        case "space":
          return "../../videos/space-reinforcer.mp4";
        case "nature":
          return "../../videos/nature-reinforcer.mp4";
        default:
          return "../../videos/toupieetbinouecole.mp4";
      }
    }

    // Reinforcer button click => play video => next game
    const reinforcerButton = document.getElementById('reinforcerButton');
    const reinforcerVideo  = document.getElementById('reinforcerVideo');
    const videoOverlayCover= document.getElementById('videoOverlayCover');

    reinforcerButton.addEventListener('click', () => {
      reinforcerButton.style.display = 'none';
      reinforcerOverlay.style.background = '#000';
      reinforcerVideo.style.display = 'block';
      videoOverlayCover.style.display = 'block';
      reinforcerVideo.controls = false;
      reinforcerVideo.play().catch(err => {
        console.warn('Video play failed:', err);
      });
      reinforcerVideo.addEventListener('ended', () => {
        navigateToNextGame();
      }, { once: true });
    });

    // After reinforcer finishes, move to the next game or completion page
    function navigateToNextGame() {
      const selections = JSON.parse(localStorage.getItem('gameSelections'));
      let currentGameIndex = parseInt(localStorage.getItem('currentGameIndex'), 10);
      currentGameIndex++;
      localStorage.setItem('currentGameIndex', currentGameIndex);
      if (currentGameIndex < selections.gameOrder.length) {
        window.location.href = selections.gameOrder[currentGameIndex] + ".html";
      } else {
        window.location.href = "completion.html";
      }
    }

    /**
     * Touch handling for mobile
     */
    let touchData = {
      dragging: false,
      element: null,
      originalParent: null,
      originalSlot: null,
      originalPosition: { left: 0, top: 0 },
      offsetX: 0,
      offsetY: 0
    };

    function touchStartHandler(e) {
      e.preventDefault();
      const touch = e.touches[0];
      touchData.dragging = true;
      touchData.element  = e.target;
      touchData.originalParent = e.target.parentElement;
      if (e.target.parentElement.classList.contains('slot')) {
        touchData.originalSlot = e.target.parentElement.dataset.index;
      } else {
        touchData.originalSlot = 'piecesArea';
      }
      e.target.classList.add('active');
      const rect = e.target.getBoundingClientRect();
      touchData.offsetX = touch.clientX - rect.left;
      touchData.offsetY = touch.clientY - rect.top;
      touchData.originalPosition.left = rect.left;
      touchData.originalPosition.top  = rect.top;
      e.target.style.zIndex = 1000;
      e.target.style.position = 'fixed';
      e.target.style.left = (touch.clientX - touchData.offsetX) + 'px';
      e.target.style.top  = (touch.clientY - touchData.offsetY) + 'px';
    }

    function touchMoveHandler(e) {
      if (!touchData.dragging) return;
      e.preventDefault();
      const touch = e.touches[0];
      touchData.element.style.left = (touch.clientX - touchData.offsetX) + 'px';
      touchData.element.style.top  = (touch.clientY - touchData.offsetY) + 'px';
    }

    function touchEndHandler(e) {
      if (!touchData.dragging) return;
      touchData.dragging = false;
      touchData.element.classList.remove('active');
      const touch = e.changedTouches[0];
      touchData.element.style.pointerEvents = 'none';
      const dropTarget = getDropTarget(touch.clientX, touch.clientY);
      touchData.element.style.pointerEvents = '';
      if (dropTarget) {
        if (dropTarget.classList.contains('slot')) {
          onDropTouch(touch.clientX, touch.clientY, dropTarget, touchData.element);
        } else if (dropTarget.id === 'piecesArea') {
          onDropLeftTouch(touch.clientX, touch.clientY, touchData.element);
        } else {
          resetTouchElementPosition(touchData.element);
        }
      } else {
        resetTouchElementPosition(touchData.element);
      }
      touchData.element.style.zIndex = '';
      touchData.element.style.position = 'absolute';
      touchData.element = null;
    }

    function onDropTouch(clientX, clientY, slotEl, draggedImg) {
      const existingPiece = slotEl.querySelector('img');
      const originalParentId = touchData.originalParent.id || touchData.originalParent.className;
      const originalSlot = touchData.originalSlot;
      const piecesArea = document.getElementById('piecesArea');

      if (existingPiece) {
        if (originalParentId === 'piecesArea') {
          piecesArea.appendChild(existingPiece);
          existingPiece.style.position = 'absolute';
          existingPiece.style.width  = '130px';
          existingPiece.style.height = '130px';
          placePieceRandomlyInGrid(existingPiece, piecesArea.clientWidth, piecesArea.clientHeight);
        } else {
          const originalSlotElement = document.querySelector(`.slot[data-index='${originalSlot}']`);
          if (originalSlotElement) {
            originalSlotElement.innerHTML = '';
            originalSlotElement.appendChild(existingPiece);
            existingPiece.style.position = 'absolute';
            existingPiece.style.left = '0';
            existingPiece.style.top  = '0';
            existingPiece.style.width  = '100%';
            existingPiece.style.height = '100%';
          }
        }
      }
      slotEl.innerHTML = '';
      slotEl.appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.left = '0';
      draggedImg.style.top  = '0';
      draggedImg.style.width  = '100%';
      draggedImg.style.height = '100%';
      draggedImg.dataset.originalParent = slotEl.classList.contains('slot') ? slotEl.className : slotEl.id;
      draggedImg.dataset.originalSlot = slotEl.dataset.index;

      checkPuzzleCompletion();
    }

    function onDropLeftTouch(clientX, clientY, draggedImg) {
      const oldParent = draggedImg.parentElement;
      if (oldParent && oldParent.classList.contains('slot')) {
        oldParent.innerHTML = "";
      }
      const piecesArea = document.getElementById('piecesArea');
      piecesArea.appendChild(draggedImg);
      draggedImg.style.position = 'absolute';
      draggedImg.style.width  = '130px';
      draggedImg.style.height = '130px';
      placePieceRandomlyInGrid(draggedImg, piecesArea.clientWidth, piecesArea.clientHeight);
      draggedImg.dataset.originalParent = 'piecesArea';
      draggedImg.dataset.originalSlot   = 'piecesArea';
    }

    function resetTouchElementPosition(pieceEl) {
      const piecesArea = document.getElementById('piecesArea');
      if (pieceEl.parentElement.id === 'piecesArea') {
        placePieceRandomlyInGrid(pieceEl, piecesArea.clientWidth, piecesArea.clientHeight);
      }
    }

    function getDropTarget(x, y) {
      const elem = document.elementFromPoint(x, y);
      if (!elem) return null;
      return elem.closest('.slot') || (elem.id === 'piecesArea' ? elem : null);
    }

    /**
     * REFERENCE MODAL LOGIC
     * Ensure the button opens the modal properly
     */
    const referenceModal = document.getElementById('referenceModal');
    const toggleReferenceBtn = document.getElementById('toggleReference');

    function openModal() {
      referenceModal.classList.add('flex');
      document.documentElement.style.overflow = 'hidden';
      setTimeout(() => {
        document.addEventListener('click', closeModalOnInteraction);
        document.addEventListener('touchend', closeModalOnInteraction);
      }, 0);
    }
    function closeModal() {
      referenceModal.classList.remove('flex');
      document.documentElement.style.overflow = '';
      document.removeEventListener('click', closeModalOnInteraction);
      document.removeEventListener('touchend', closeModalOnInteraction);
    }
    function closeModalOnInteraction(event) {
      if (event.target !== toggleReferenceBtn) {
        closeModal();
      }
    }

    toggleReferenceBtn.addEventListener('click', openModal);
    toggleReferenceBtn.addEventListener('touchend', openModal);

    referenceModal.addEventListener('click', (event) => {
      if (event.target === referenceModal) {
        closeModal();
      }
    });

    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        closeModal();
      }
    });
  </script>
</body>
</html>
