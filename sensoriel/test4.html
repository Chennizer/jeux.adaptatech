<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../../images/binou.png">
  <link rel="stylesheet" href="../../css/ipadteachh.css">
  <title>Base Game</title>
  <!-- Load shared themes file -->
  <script src="../../js/themes.js"></script>
  <style>
    /* 1) Reset and full-screen usage */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
  
    .game-container {
      width: 90vw;
      height: 90vh;
      max-width: 1200px;
      max-height: 800px;
      display: flex;
      position: relative;
      border-radius: 15px;
      background-color: #fff;
      overflow: hidden;
    }
  
    #game-content {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
    }
  
    @keyframes pulse {
      0%   { transform: scale(1); }
      50%  { transform: scale(1.35); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
  <!-- Activity overlay (shows the game index) -->
  <div id="activityNumberOverlay">
    <div class="number-text"></div>
  </div>
  
  <!-- Main game container -->
  <div class="game-container">
    <div id="game-content"></div>
  </div>
  
  <!-- Reinforcer overlay (common for all games) -->
  <div id="reinforcerOverlay">
    <button id="reinforcerButton" aria-label="Voir la vidéo de renforcement"></button>
    <video id="reinforcerVideo"
           playsinline
           webkit-playsinline
           disablepictureinpicture
           controlslist="nodownload noremoteplayback"
           preload="auto">
      <source id="reinforcerVideoSource" src="" type="video/mp4">
      Votre navigateur ne supporte pas la balise vidéo.
    </video>
    <div id="videoOverlayCover"></div>
  </div>
  
  <!-- Audio elements for error, reinforcer, and final reward sounds -->
  <audio id="error-sound" src="" preload="auto"></audio>
  <audio id="word-reward-sound" src="" preload="auto"></audio>
  <audio id="final-reward-sound" src="" preload="auto"></audio>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Retrieve game selections and theme info from localStorage
      const selections = JSON.parse(localStorage.getItem('gameSelections')) || {};
      const mediaOption = selections.mediaOption || "";
      const themeData = (window.themes && window.themes[mediaOption])
                        ? window.themes[mediaOption]
                        : window.themes["default"] || {};
      
      // Set audio element sources
      document.getElementById('error-sound').src =
        themeData.errorSound || "../../sounds/error.mp3";
      document.getElementById('word-reward-sound').src =
        themeData.reinforcerSound || "../../sounds/rooster.mp3";
      document.getElementById('final-reward-sound').src =
        themeData.finalRewardSound || "../../sounds/victory.mp3";
      
      // Choose a random reinforcer video from theme
      const reinforcerVideoSource = document.getElementById('reinforcerVideoSource');
      if (themeData.reinforcerVideos && themeData.reinforcerVideos.length > 0) {
        reinforcerVideoSource.src = themeData.reinforcerVideos[
          Math.floor(Math.random() * themeData.reinforcerVideos.length)
        ];
      } else {
        reinforcerVideoSource.src = "../../videos/africa.mp4";
      }
      const reinforcerVideo = document.getElementById('reinforcerVideo');
      reinforcerVideo.load();
      
      // Show the overlay with the game index
      let overallGameIndex = parseInt(localStorage.getItem('currentGameIndex'), 10);
      if (isNaN(overallGameIndex)) {
        alert("Game selections not found. Redirecting to main page.");
        window.location.href = "main.html";
        return;
      }
      const activityOverlay = document.getElementById('activityNumberOverlay');
      const numberTextEl = activityOverlay.querySelector('.number-text');
      numberTextEl.textContent = (overallGameIndex + 1).toString();
      activityOverlay.style.display = 'flex';
      
      // Hide overlay and start game on click/touch
      function hideOverlayAndStart() {
        if (themeData.startSound) {
          let sfx = new Audio(themeData.startSound);
          sfx.play().catch(err => console.warn('Sound play error:', err));
        }
        activityOverlay.style.display = 'none';
        document.removeEventListener('click', hideOverlayAndStart);
        document.removeEventListener('touchend', hideOverlayAndStart);
        startGame();
      }
      document.addEventListener('click', hideOverlayAndStart);
      document.addEventListener('touchend', hideOverlayAndStart);
      
      /* Generic function to navigate to the next game. */
      function navigateToNextGame() {
        const selections = JSON.parse(localStorage.getItem('gameSelections'));
        let currentGameIndex = parseInt(localStorage.getItem('currentGameIndex'), 10);
        currentGameIndex++;
        localStorage.setItem('currentGameIndex', currentGameIndex);
        if (currentGameIndex < selections.gameOrder.length) {
          window.location.href =
            selections.gameOrder[currentGameIndex] + ".html";
        } else {
          window.location.href = "completion.html";
        }
      }
      
      /* Show a short reinforcer sound between words (2s delay). */
      function showReinforcerSound() {
        setTimeout(() => {
          const wordRewardSound = document.getElementById('word-reward-sound');
          wordRewardSound.currentTime = 0;
          wordRewardSound.play().catch(error => {
            console.error('Error playing reinforcer sound:', error);
          });
        }, 2000);
      }
      
      /* Show final reinforcer overlay (video button). */
      function showFinalReinforcerVideo() {
        const finalRewardSound = document.getElementById('final-reward-sound');
        finalRewardSound.currentTime = 0;
        finalRewardSound.play().catch(error => {
          console.error('Error playing final reward sound:', error);
        });
        const reinforcerOverlay = document.getElementById('reinforcerOverlay');
        reinforcerOverlay.style.display = 'flex';
        reinforcerVideo.style.display = 'none';
        document.getElementById('videoOverlayCover').style.display = 'none';
      }
      
      /* Reinforcer button triggers the actual video. */
      const reinforcerButton = document.getElementById('reinforcerButton');
      reinforcerButton.addEventListener('click', function() {
        reinforcerButton.style.display = 'none';
        const reinforcerOverlay = document.getElementById('reinforcerOverlay');
        reinforcerOverlay.style.background = '#000';
        reinforcerVideo.style.display = 'block';
        document.getElementById('videoOverlayCover').style.display = 'block';
        reinforcerVideo.play().catch(err => {
          console.warn('Video play failed:', err);
          hideReinforcer();
        });
      });
      // On video end, go to next game
      reinforcerVideo.addEventListener('ended', function() {
        navigateToNextGame();
      }, { once: true });
      
      function hideReinforcer() {
        const reinforcerOverlay = document.getElementById('reinforcerOverlay');
        reinforcerOverlay.style.display = 'none';
        reinforcerButton.style.display = 'flex';
        reinforcerVideo.style.display = 'none';
        reinforcerVideo.pause();
        reinforcerVideo.currentTime = 0;
        document.getElementById('videoOverlayCover').style.display = 'none';
        reinforcerOverlay.style.background = 'rgba(0,0,0,0.8)';
      }
      
      // ----------------------------------------------------------------------------
      // SLIDE TOKEN ALONG A RANDOMIZED SVG LABYRINTH WITH RANDOMIZATION
      // ----------------------------------------------------------------------------
      window.startGame = function() {
        const gameContent = document.getElementById('game-content');
        gameContent.innerHTML = '';
      
        // Create a container that fills the whole game area
        const pathContainer = document.createElement('div');
        pathContainer.style.position = 'relative';
        pathContainer.style.width = '100%';
        pathContainer.style.height = '100%';
        pathContainer.style.backgroundColor = 'transparent';
        pathContainer.style.border = 'none';
        pathContainer.style.overflow = 'hidden';
        gameContent.appendChild(pathContainer);
      
        // Create an SVG element to hold the labyrinth path
        const svgNS = "http://www.w3.org/2000/svg";
        const svgElem = document.createElementNS(svgNS, "svg");
        svgElem.setAttribute("width", "100%");
        svgElem.setAttribute("height", "100%");
        svgElem.style.position = "absolute";
        svgElem.style.top = "0";
        svgElem.style.left = "0";
        svgElem.style.pointerEvents = "none";
        pathContainer.appendChild(svgElem);
      
        // Get container dimensions
        const containerWidth = pathContainer.clientWidth;
        const containerHeight = pathContainer.clientHeight;
      
        // Generate 4 key points with more randomness for a curvy, interesting path
        const startPoint = {
          x: containerWidth * 0.1,
          y: containerHeight * (0.2 + Math.random() * 0.6)
        };
        const midPoint1 = {
          x: containerWidth * 0.3 + Math.random() * (containerWidth * 0.1),
          y: containerHeight * (0.1 + Math.random() * 0.8)
        };
        const midPoint2 = {
          x: containerWidth * 0.6 + Math.random() * (containerWidth * 0.1),
          y: containerHeight * (0.1 + Math.random() * 0.8)
        };
        const endPoint = {
          x: containerWidth * 0.9,
          y: containerHeight * (0.2 + Math.random() * 0.6)
        };
      
        // Generate random control points for a multi-segment cubic Bezier curve.
        // Increase random offsets for more curviness.
        const cp1 = {
          x: startPoint.x + (midPoint1.x - startPoint.x) * 0.3 + (Math.random() - 0.5) * 150,
          y: startPoint.y + (midPoint1.y - startPoint.y) * 0.3 + (Math.random() - 0.5) * 150
        };
        const cp2 = {
          x: startPoint.x + (midPoint1.x - startPoint.x) * 0.7 + (Math.random() - 0.5) * 150,
          y: startPoint.y + (midPoint1.y - startPoint.y) * 0.7 + (Math.random() - 0.5) * 150
        };
        const cp3 = {
          x: midPoint1.x + (midPoint2.x - midPoint1.x) * 0.7 + (Math.random() - 0.5) * 150,
          y: midPoint1.y + (midPoint2.y - midPoint1.y) * 0.7 + (Math.random() - 0.5) * 150
        };
        const cp4 = {
          x: midPoint2.x + (endPoint.x - midPoint2.x) * 0.7 + (Math.random() - 0.5) * 150,
          y: midPoint2.y + (endPoint.y - midPoint2.y) * 0.7 + (Math.random() - 0.5) * 150
        };
      
        // Build the SVG path data using a multi-segment cubic Bezier curve.
        const pathData = `M ${startPoint.x},${startPoint.y} C ${cp1.x},${cp1.y} ${cp2.x},${cp2.y} ${midPoint1.x},${midPoint1.y} S ${cp3.x},${cp3.y} ${midPoint2.x},${midPoint2.y} S ${cp4.x},${cp4.y} ${endPoint.x},${endPoint.y}`;
      
        const pathElem = document.createElementNS(svgNS, "path");
        pathElem.setAttribute("d", pathData);
        pathElem.setAttribute("stroke", "black");
        pathElem.setAttribute("stroke-width", "10");
        pathElem.setAttribute("fill", "none");
        svgElem.appendChild(pathElem);
      
        // Draw start and end markers using the same key points.
        function createMarker(point, text, bgColor) {
          const marker = document.createElement("div");
          marker.style.position = "absolute";
          marker.style.left = (point.x - 30) + "px";
          marker.style.top = (point.y - 30) + "px";
          marker.style.width = "60px";
          marker.style.height = "60px";
          marker.style.backgroundColor = bgColor;
          marker.style.borderRadius = "50%";
          marker.style.border = "3px solid #444";
          marker.style.display = "flex";
          marker.style.justifyContent = "center";
          marker.style.alignItems = "center";
          marker.textContent = text;
          marker.style.fontWeight = "bold";
          return marker;
        }
      
        const startMarker = createMarker(startPoint, "Start", "#8be");
        const endMarker = createMarker(endPoint, "End", "#cfc");
        pathContainer.appendChild(startMarker);
        pathContainer.appendChild(endMarker);
      
        // ---- Draggable Token Setup ----
        const token = document.createElement("img");
        token.src =
          (themeData.transparentPNGs && themeData.transparentPNGs.length > 0)
            ? themeData.transparentPNGs[Math.floor(Math.random() * themeData.transparentPNGs.length)]
            : "../../images/fallback.png";
        token.style.position = "absolute";
        token.style.width = "80px";
        token.style.height = "80px";
        token.style.objectFit = "contain";
        token.style.cursor = "grab";
        token.style.touchAction = "none";
        token.style.userSelect = "none";
        token.style.webkitUserSelect = "none";
        token.draggable = false;
        // Position token at the start (centered)
        token.style.left = (startPoint.x - 40) + "px";
        token.style.top = (startPoint.y - 40) + "px";
        pathContainer.appendChild(token);
      
        // Save last allowed position (initialize to starting position)
        let lastAllowedLeft = parseFloat(token.style.left);
        let lastAllowedTop = parseFloat(token.style.top);
      
        // Variables for dragging
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;
      
        // Helper: Euclidean distance
        function distance(p1, p2) {
          return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }
      
        // Helper: compute minimum distance from a point to the SVG path by sampling points
        function distanceToPath(point, pathElem, samples = 50) {
          const totalLength = pathElem.getTotalLength();
          let minDist = Infinity;
          for (let i = 0; i <= samples; i++) {
            const samplePoint = pathElem.getPointAtLength((i / samples) * totalLength);
            const d = distance({ x: samplePoint.x, y: samplePoint.y }, point);
            if (d < minDist) {
              minDist = d;
            }
          }
          return minDist;
        }
      
        // Set threshold distance (in pixels) for token to be considered "on the path"
        const threshold = 20;
      
        token.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          isDragging = true;
          token.style.cursor = "grabbing";
          const rect = token.getBoundingClientRect();
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;
          token.setPointerCapture(e.pointerId);
        });
      
        token.addEventListener("pointermove", (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const containerRect = pathContainer.getBoundingClientRect();
          let newLeft = e.clientX - containerRect.left - offsetX;
          let newTop = e.clientY - containerRect.top - offsetY;
      
          // Clamp to container bounds
          const fullMaxLeft = pathContainer.clientWidth - token.clientWidth;
          const fullMaxTop = pathContainer.clientHeight - token.clientHeight;
          newLeft = Math.max(0, Math.min(newLeft, fullMaxLeft));
          newTop = Math.max(0, Math.min(newTop, fullMaxTop));
      
          // Compute token center
          const tokenCenter = {
            x: newLeft + token.clientWidth / 2,
            y: newTop + token.clientHeight / 2
          };
      
          const d = distanceToPath(tokenCenter, pathElem);
          if (d < threshold) {
            lastAllowedLeft = newLeft;
            lastAllowedTop = newTop;
            token.style.left = newLeft + "px";
            token.style.top = newTop + "px";
          } else {
            token.style.left = lastAllowedLeft + "px";
            token.style.top = lastAllowedTop + "px";
          }
        });
      
        token.addEventListener("pointerup", (e) => {
          e.preventDefault();
          isDragging = false;
          token.style.cursor = "grab";
          token.releasePointerCapture(e.pointerId);
      
          // Compute token center
          const tokenRect = token.getBoundingClientRect();
          const tokenCenter = {
            x: tokenRect.left + tokenRect.width / 2,
            y: tokenRect.top + tokenRect.height / 2
          };
          // Use the end marker's position for collision detection
          const endRect = endMarker.getBoundingClientRect();
          const endCenter = {
            x: endRect.left + endRect.width / 2,
            y: endRect.top + endRect.height / 2
          };
          const dToEnd = distance(tokenCenter, endCenter);
      
          if (dToEnd < 50) {
            showFinalReinforcerVideo();
          } else {
            // Optionally play error sound here.
            // document.getElementById('error-sound').play();
          }
        });
      
        console.log("Slide the Token game started with a randomized SVG labyrinth with added randomization!");
      };
      // ----------------------------------------------------------------------------
      // END OF GAME-SPECIFIC LOGIC
      // ----------------------------------------------------------------------------
    });
  </script>
</body>
</html>
