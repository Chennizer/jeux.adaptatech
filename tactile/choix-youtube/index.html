<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title class="translate" data-fr="Choix multiple tactile (YouTube)" data-en="Touch Multiple Choice (YouTube)" data-ja="タッチ式複数選択（YouTube）">Choix multiple tactile</title>
  <link rel="stylesheet" href="../../css/choix.css">
  <style>
    /* Preserve tactile-friendly sizing rules */
    #tile-container.flashcard-mode .tile {
      width: 90vh !important;
      height: 90vh !important;
    }
    #tile-container.this-or-that-mode .tile {
      width: 60vh !important;
      height: 60vh !important;
    }
    #tile-container.grid-2x2 {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr);
      gap: 10vh;
      justify-items: center;
      align-items: center;
    }
    #tile-container.this-or-that-mode {
      gap: 30vh !important;
    }
    #tile-container.inputs-frozen .tile,
    .tile.youtube-playing {
      pointer-events: none;
    }
  </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
<body>
  <!-- Main Options (Game Setup) -->
  <div id="game-options" class="modal" style="display: flex;">
    <div id="control-panel-options">
      <div id="options-title-bar">
          <h2 id="options-main-title" class="translate" data-fr="Activité de choix multiple (tactile)" data-en="Multiple Choice Activity (touchscreen)" data-ja="タッチ対応の複数選択アクティビティ">Activité de choix multiple</h2>
      </div>
      <div id="mode-divider"></div>
      <div id="options-inline-container">
        <!-- LEFT COLUMN: Time Limit + Resume Video -->
        <div id="advanced-options-section">
          <div class="advanced-options-container">
            <div class="option-item">
              <label for="enable-time-limit" class="teal-label">
                <input type="checkbox" id="enable-time-limit">
                <span class="translate" data-fr="Temps limite" data-en="Time Limit" data-ja="時間制限">Temps limite</span>
              </label>
            </div>
            <div id="time-limit-container" class="option-item" style="display: none;">
              <label for="time-limit-seconds" class="duration-label">
                <span class="translate" data-fr="Durée (sec):" data-en="Duration (sec):" data-ja="時間（秒）：">Durée (sec):</span>
              </label>
              <input type="number" id="time-limit-seconds" min="1" value="30" class="styled-input-small">
            </div>
            <div id="resume-video-container" class="option-item" style="display: none;">
              <label for="enable-resume-video" class="teal-label">
                <input type="checkbox" id="enable-resume-video">
                  <span class="translate" data-fr="Reprendre la vidéo" data-en="Resume Video" data-ja="動画を再開">Reprendre la vidéo</span>
              </label>
            </div>
          </div>
        </div>
        <!-- CENTER COLUMN: Tile slider -->
        <div id="game-options-controls">
          <div class="option-item" id="tile-slider-container">
            <label for="tile-count" class="control-label">
                <span class="translate" data-fr="Nombre de tuiles:" data-en="Number of Tiles:" data-ja="タイル数：">Nombre de tuiles:</span>
              <span id="tile-count-value" class="slider-value no-translate">3</span>
            </label>
            <input type="range" id="tile-count" min="1" max="6" value="3" class="styled-slider">
          </div>
        </div>
        <!-- RIGHT COLUMN: Documentation links -->
        <div id="links-column">
            <a href="../../documentation/choix tactile/index.html" target="_blank" class="doc-link translate"
               data-fr="Instructions" data-en="Instructions" data-ja="操作説明">Instructions</a>
            <a href="../../documentation/pédagogie choix et scan/index.html" target="_blank" class="doc-link translate"
               data-fr="Pédagogie" data-en="Pedagogy" data-ja="指導法">Pédagogie</a>
        </div>
      </div>
      <div id="mode-divider"></div>
        <button id="choose-tiles-button" class="button translate"
                data-fr="Choix des tuiles" data-en="Tile Selection" data-ja="タイルを選ぶ">Choix des tuiles</button>
    </div>
  </div>

  <!-- Tile Picker (Step 2) -->
  <div id="tile-picker-modal" class="modal" style="display: none;">
    <div id="control-panel-options">
      <div id="control-panel-title-wrapper">
          <h2 id="control-panel-title" class="translate" data-fr="Choisir les tuiles" data-en="Choose the Tiles" data-ja="タイルを選択">
            Choisir les tuiles
          </h2>
        </div>
        <div id="control-panel-instructions" style="margin-top:10px;">
          <span class="translate" data-fr="Choisir" data-en="Choose" data-ja="選ぶ">Choisir</span>
          <span id="tile-count-display" class="no-translate"></span>
          <span class="translate" data-fr="tuiles." data-en="tiles." data-ja="枚のタイル。">tuiles.</span>
        </div>
      <div id="tile-picker-grid"></div>
      <div id="yt-import-controls">
        <div id="yt-input-row">
          <div class="actions-row">
            <input id="add-video-url-input" type="text" placeholder="URL" class="control-panel-input">
              <button id="add-video-url-button" class="button" data-fr="Ajouter URL" data-en="Add URL" data-ja="URLを追加">Ajouter URL</button>
          </div>
          <div class="actions-row">
            <input id="yt-playlist-url-input" type="text" placeholder="URL de playlist (ex. https://www.youtube.com/playlist?list=...)" class="control-panel-input">
              <button id="yt-playlist-import-button" class="button" data-fr="Importer" data-en="Import" data-ja="インポート">Importer</button>
          </div>
        </div>
        <div class="actions-row">
            <button id="clear-videos-button" class="button translate" data-fr="Tout effacer" data-en="Clear All" data-ja="すべて削除">Tout effacer</button>
            <button id="start-game-button" class="button translate" data-fr="Commencer" data-en="Start" data-ja="開始" disabled>Commencer</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Game Container (Chosen Tiles) -->
  <div id="tile-container" style="display: none;"></div>

  <!-- Video Container -->
  <div id="video-container" style="display: none;">
    <video id="video-player" autoplay>
      <source id="video-source" type="video/mp4" />
        <span class="translate" data-fr="Votre navigateur ne supporte pas la vidéo." data-en="Your browser does not support video." data-ja="お使いのブラウザは動画に対応していません。">
        Votre navigateur ne supporte pas la vidéo.
      </span>
    </video>
    <div id="youtube-player" style="display:none;width:100%;height:100%;pointer-events:none;"></div>
  </div>

  <script>window.populateTilePickerGrid = function(){};</script>
  <script>
    (function() {
      const state = window.youtubeState || {
        apiReady: false,
        player: null,
        pendingLoad: null,
        readyCallbacks: []
      };

      function flushReadyCallbacks() {
        if (!state.readyCallbacks.length) return;
        const callbacks = state.readyCallbacks.slice();
        state.readyCallbacks.length = 0;
        callbacks.forEach(cb => {
          try {
            cb();
          } catch (err) {
            console.error('YouTube ready callback failed', err);
          }
        });
      }

      window.youtubeState = state;

      window.onYouTubeIframeAPIReady = () => {
        state.apiReady = true;
        flushReadyCallbacks();
      };

      if (window.YT && window.YT.Player) {
        state.apiReady = true;
        flushReadyCallbacks();
      }
    })();
  </script>
  <script src="https://www.youtube.com/iframe_api"></script>
  <script src="../../js/config.js"></script>
  <script src="../../js/customYoutubeChoices.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // mediaChoices is populated via customYoutubeChoices.js
      const gameOptionsModal = document.getElementById('game-options');
      const tilePickerModal  = document.getElementById('tile-picker-modal');
      const tileContainer    = document.getElementById('tile-container');
      const videoContainer   = document.getElementById('video-container');
      const videoPlayer      = document.getElementById('video-player');
      const videoSource      = document.getElementById('video-source');
      const youtubeDiv       = document.getElementById('youtube-player');

      const tileCountInput   = document.getElementById('tile-count');
      const tileCountValue   = document.getElementById('tile-count-value');
      const chooseTilesButton = document.getElementById('choose-tiles-button');
      const tilePickerGrid    = document.getElementById('tile-picker-grid');
      const tileCountDisplay  = document.getElementById('tile-count-display');
      const startGameButton   = document.getElementById('start-game-button');

      const enableTimeLimitCheckbox   = document.getElementById('enable-time-limit');
      const timeLimitContainer        = document.getElementById('time-limit-container');
      const timeLimitInput            = document.getElementById('time-limit-seconds');
      const resumeVideoContainer      = document.getElementById('resume-video-container');
      const enableResumeVideoCheckbox = document.getElementById('enable-resume-video');

      let desiredTileCount = parseInt(tileCountInput.value, 10) || 3;
      let selectedTileIndices = [];
      let videoPlaying = false;
      let videoTimeLimitTimeout = null;
      let videoResumePositions = {};
      let currentVideoUrl = null;
      let loadingDiv = null;
      let activeTile = null;

      let inactivityTimer = null;
      function clearInactivityTimer() {
        if (inactivityTimer) {
          clearTimeout(inactivityTimer);
          inactivityTimer = null;
        }
      }
      function startInactivityTimer() {
        clearInactivityTimer();
        inactivityTimer = setTimeout(() => {}, 30000);
      }
      function resetInactivityTimer() {
        if (!videoPlaying) {
          startInactivityTimer();
        }
      }

      const youtubeState = window.youtubeState;

      function queueYoutubeReady(fn) {
        if (youtubeState.apiReady) {
          fn();
        } else {
          youtubeState.readyCallbacks.push(fn);
        }
      }

      function isYouTubeUrl(url) {
        return /^(https?:\/\/)?(www\.|m\.)?((youtube\.com\/)|(youtu\.be\/))/.test(url);
      }

      function getYouTubeId(url) {
        try {
          const u = new URL(url);
          if (u.hostname.includes('youtu.be')) {
            return u.pathname.slice(1);
          }
          const id = u.searchParams.get('v');
          if (id) return id;
          const match = url.match(/\/embed\/([a-zA-Z0-9_-]+)/);
          return match ? match[1] : null;
        } catch {
          return null;
        }
      }

      tileCountInput.addEventListener('input', () => {
        tileCountValue.textContent = tileCountInput.value;
      });

      enableTimeLimitCheckbox.addEventListener('change', () => {
        const show = enableTimeLimitCheckbox.checked;
        timeLimitContainer.style.display = show ? 'block' : 'none';
        resumeVideoContainer.style.display = show ? 'block' : 'none';
      });

      chooseTilesButton.addEventListener('click', () => {
        desiredTileCount = parseInt(tileCountInput.value, 10) || 3;
        tileCountDisplay.textContent = desiredTileCount;
        selectedTileIndices = [];
        updateStartButtonState();
        gameOptionsModal.style.display = 'none';
        tilePickerModal.style.display = 'flex';
        populateTilePickerGrid();
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen().catch(() => {});
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        }
      });

      function populateTilePickerGridInternal() {
        tilePickerGrid.innerHTML = '';
        if (!mediaChoices || !mediaChoices.length) {
          const emptyMessage = document.createElement('p');
          emptyMessage.classList.add('translate');
          emptyMessage.dataset.fr = "Ajoutez des vidéos YouTube à l'aide des champs ci-dessous.";
          emptyMessage.dataset.en = "Add YouTube videos using the fields below.";
          emptyMessage.textContent = emptyMessage.dataset.fr;
          tilePickerGrid.appendChild(emptyMessage);
          startGameButton.disabled = true;
          return;
        }

        selectedTileIndices = selectedTileIndices.filter(idx => idx < mediaChoices.length);

        const grid = document.createElement('div');
        grid.style.display = 'flex';
        grid.style.flexWrap = 'wrap';
        grid.style.gap = '10px';

        mediaChoices.forEach((choice, idx) => {
          const tileOption = document.createElement('div');
          tileOption.classList.add('tile');
          tileOption.setAttribute('data-index', idx);
          tileOption.style.backgroundImage = `url(${choice.image})`;
          if (selectedTileIndices.includes(idx)) {
            tileOption.classList.add('selected');
          }
          const caption = document.createElement('div');
          caption.classList.add('caption');
          caption.textContent = choice.name;
          tileOption.appendChild(caption);
          tileOption.addEventListener('click', () => {
            resetInactivityTimer();
            if (selectedTileIndices.includes(idx)) {
              selectedTileIndices = selectedTileIndices.filter(i => i !== idx);
            } else if (selectedTileIndices.length < desiredTileCount) {
              selectedTileIndices.push(idx);
            }
            updateStartButtonState();
            populateTilePickerGridInternal();
          });
          grid.appendChild(tileOption);
        });

        tilePickerGrid.appendChild(grid);
        updateStartButtonState();
      }

      function updateStartButtonState() {
        startGameButton.disabled = (selectedTileIndices.length !== desiredTileCount);
      }

      window.populateTilePickerGrid = () => {
        if (!tilePickerGrid) return;
        populateTilePickerGridInternal();
      };

      startGameButton.addEventListener('click', () => {
        const videos = selectedTileIndices.map(i => mediaChoices[i].video);
        showLoadingScreen()
          .then(() => preloadVideos(videos))
          .then(() => {
            hideLoadingScreen();
            tilePickerModal.style.display = 'none';
            renderChosenTiles();
            tileContainer.style.display = 'flex';
          });
      });

      function renderChosenTiles() {
        tileContainer.innerHTML = '';
        const chosen = selectedTileIndices.map(i => mediaChoices[i]);
        tileContainer.classList.remove('flashcard-mode', 'this-or-that-mode', 'grid-2x2', 'two-tiles', 'tile-count-3', 'tile-count-5', 'tile-count-6');
        if (chosen.length === 1) {
          tileContainer.classList.add('flashcard-mode');
        } else if (chosen.length === 2) {
          tileContainer.classList.add('this-or-that-mode', 'two-tiles');
        } else if (chosen.length === 4) {
          tileContainer.classList.add('grid-2x2');
        } else {
          tileContainer.classList.add(`tile-count-${chosen.length}`);
        }

        chosen.forEach(choice => {
          const tile = document.createElement('div');
          tile.classList.add('tile');
          tile.style.backgroundImage = `url(${choice.image})`;
          const caption = document.createElement('div');
          caption.classList.add('caption');
          caption.textContent = choice.name;
          tile.appendChild(caption);
          tile.addEventListener('click', () => {
            playVideo(choice.video, tile);
          });
          tileContainer.appendChild(tile);
        });
      }

      function createOrLoadYoutube(videoId, startSeconds) {
        if (!youtubeState.apiReady) {
          youtubeState.pendingLoad = { videoId, startSeconds };
          queueYoutubeReady(() => {
            const pending = youtubeState.pendingLoad;
            youtubeState.pendingLoad = null;
            if (pending) {
              createOrLoadYoutube(pending.videoId, pending.startSeconds);
            }
          });
          return;
        }
        youtubeState.pendingLoad = null;
        if (youtubeState.player) {
          youtubeState.player.loadVideoById({ videoId, startSeconds });
          youtubeState.player.playVideo();
        } else {
          youtubeState.player = new YT.Player('youtube-player', {
            videoId,
            playerVars: { autoplay: 1, controls: 0, playsinline: 1 },
            events: {
              onReady: event => {
                if (startSeconds) {
                  event.target.seekTo(startSeconds, true);
                }
                event.target.playVideo();
              },
              onStateChange: event => {
                if (event.data === YT.PlayerState.ENDED) {
                  if (currentVideoUrl) {
                    delete videoResumePositions[currentVideoUrl];
                  }
                  videoPlaying = false;
                  resetToTileScreen();
                }
              },
              onError: () => {
                resetToTileScreen();
              }
            }
          });
        }
      }

      function playVideo(videoUrl, tile) {
        videoPlaying = true;
        currentVideoUrl = videoUrl;
        if (activeTile) {
          activeTile.classList.remove('youtube-playing');
        }
        activeTile = tile || null;
        if (activeTile) {
          activeTile.classList.add('youtube-playing');
        }
        tileContainer.classList.add('inputs-frozen');
        tileContainer.style.display = 'none';
        tilePickerModal.style.display = 'none';
        gameOptionsModal.style.display = 'none';
        videoContainer.style.display = 'flex';
        resetInactivityTimer();

        const isYoutubeVideo = isYouTubeUrl(videoUrl);
        if (isYoutubeVideo) {
          videoPlayer.pause();
          videoPlayer.currentTime = 0;
          videoPlayer.style.display = 'none';
          youtubeDiv.style.display = 'block';
          const videoId = getYouTubeId(videoUrl);
          const resumeTime = (enableResumeVideoCheckbox.checked && videoResumePositions[videoUrl]) ? videoResumePositions[videoUrl] : 0;
          if (videoId) {
            createOrLoadYoutube(videoId, resumeTime);
          }
        } else {
          youtubeDiv.style.display = 'none';
          videoPlayer.style.display = 'block';
          videoSource.src = videoUrl;
          videoPlayer.removeAttribute('controls');
          videoPlayer.load();
          videoPlayer.onloadedmetadata = () => {
            if (enableResumeVideoCheckbox.checked && videoResumePositions[videoUrl]) {
              videoPlayer.currentTime = videoResumePositions[videoUrl];
            }
            videoPlayer.play();
          };
        }

        if (videoContainer.requestFullscreen) {
          videoContainer.requestFullscreen().catch(() => {});
        } else if (videoContainer.webkitRequestFullscreen) {
          videoContainer.webkitRequestFullscreen();
        }
        if (isYoutubeVideo && youtubeState.player && typeof youtubeState.player.playVideo === 'function') {
          youtubeState.player.playVideo();
        }

        if (enableTimeLimitCheckbox.checked) {
          const limit = parseInt(timeLimitInput.value, 10) || 60;
          if (videoTimeLimitTimeout) clearTimeout(videoTimeLimitTimeout);
          videoTimeLimitTimeout = setTimeout(() => {
            if (!videoPlaying) return;
            if (isYouTubeUrl(videoUrl)) {
              if (enableResumeVideoCheckbox.checked && youtubeState.player && typeof youtubeState.player.getCurrentTime === 'function') {
                videoResumePositions[videoUrl] = youtubeState.player.getCurrentTime();
              } else {
                delete videoResumePositions[videoUrl];
              }
              if (youtubeState.player) {
                youtubeState.player.pauseVideo();
              }
            } else {
              if (enableResumeVideoCheckbox.checked) {
                videoResumePositions[videoUrl] = videoPlayer.currentTime;
              } else {
                delete videoResumePositions[videoUrl];
              }
              videoPlayer.pause();
            }
            resetToTileScreen();
          }, limit * 1000);
        }
      }

      videoPlayer.addEventListener('ended', () => {
        if (currentVideoUrl) {
          delete videoResumePositions[currentVideoUrl];
        }
        videoPlaying = false;
        resetToTileScreen();
      });

      function resetToTileScreen() {
        if (videoTimeLimitTimeout) {
          clearTimeout(videoTimeLimitTimeout);
          videoTimeLimitTimeout = null;
        }
        if (isYouTubeUrl(currentVideoUrl)) {
          if (youtubeState.player) {
            youtubeState.player.stopVideo();
          }
        } else {
          videoPlayer.pause();
          videoPlayer.currentTime = 0;
        }
        videoPlaying = false;
        currentVideoUrl = null;
        if (activeTile) {
          activeTile.classList.remove('youtube-playing');
          activeTile = null;
        }
        tileContainer.classList.remove('inputs-frozen');
        videoContainer.style.display = 'none';
        tileContainer.style.display = 'flex';
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(() => {});
        } else if (document.webkitFullscreenElement) {
          document.webkitExitFullscreen();
        }
      }

      function showLoadingScreen() {
        return new Promise(resolve => {
          loadingDiv = document.createElement('div');
          loadingDiv.id = 'loading-screen';
          Object.assign(loadingDiv.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100vw',
            height: '100vh',
            backgroundColor: 'rgba(0,0,0,0.8)',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            color: '#fff',
            fontSize: '24px',
            zIndex: '9999'
          });
          const indicator = document.createElement('div');
          indicator.id = 'loading-indicator';
          indicator.textContent = 'Chargement... (0/0)';
          loadingDiv.appendChild(indicator);
          document.body.appendChild(loadingDiv);
          setTimeout(() => resolve(), 100);
        });
      }

      function hideLoadingScreen() {
        if (loadingDiv) {
          document.body.removeChild(loadingDiv);
          loadingDiv = null;
        }
      }

      function preloadVideos(videoUrls) {
        const localUrls = videoUrls.filter(url => !isYouTubeUrl(url));
        if (!localUrls.length) {
          return Promise.resolve();
        }
        return new Promise(resolve => {
          let loadedCount = 0;
          const totalCount = localUrls.length;
          const indicator = document.getElementById('loading-indicator');
          Promise.all(localUrls.map(url => new Promise(res => {
            const tempVid = document.createElement('video');
            tempVid.preload = 'auto';
            tempVid.src = url;
            tempVid.addEventListener('canplaythrough', () => {
              loadedCount++;
              if (indicator) {
                indicator.textContent = `Chargement... (${loadedCount}/${totalCount})`;
              }
              res();
            });
            tempVid.addEventListener('error', () => {
              loadedCount++;
              if (indicator) {
                indicator.textContent = `Chargement... (${loadedCount}/${totalCount})`;
              }
              res();
            });
          }))).then(() => resolve());
        });
      }

      populateTilePickerGrid();
      startInactivityTimer();
    });
  </script>
  <script src="../../js/translationonly.js"></script>
</body>
</html>
