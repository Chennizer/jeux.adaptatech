<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title
    data-fr="Olympiques d'hiver — Zamboni (Jeu switch)"
    data-en="Winter Olympics — Zamboni (Switch Game)"
    data-ja="冬季オリンピック — ザンボーニ（スイッチゲーム）"
  >Olympiques d'hiver — Zamboni (Jeu switch)</title>

  <link rel="stylesheet" href="../../css/otherswitch.css" />
  <script src="../../js/translationmain.js"></script>

  <style>
    :root{
      --bg-top:#061a2b;
      --bg-bottom:#0b2f4d;
      --ice:#dff4ff;
      --ice-dull:#cfe7f5;
      --clean:#f4fdff;
      --line:#e53935;
      --line-blue:#1e88e5;
      --accent:#ffd54f;
      --accent-2:#ffb300;
      --text:#ffffff;
    }
    *{box-sizing:border-box;}
    html,body{margin:0;height:100%;overflow:hidden;background:#04111f;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;}

    body{
      background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));
    }

    canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
      z-index:1;
    }

    .hud{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:5;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      padding:clamp(10px,2vh,18px) clamp(12px,2vw,28px);
    }

    .hud-top{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:6px;
      max-width:min(70vw,900px);
      text-shadow:0 2px 10px rgba(0,0,0,.35);
    }

    .brand h1{
      margin:0;
      font-size:clamp(1.1rem,2.4vw,1.6rem);
      letter-spacing:.02em;
    }

    .brand p{
      margin:0;
      font-size:clamp(.92rem,2vw,1.05rem);
      opacity:.95;
    }

    .scoreboard{
      pointer-events:none;
      background:rgba(6,18,32,.55);
      border:2px solid rgba(255,255,255,.2);
      border-radius:14px;
      padding:10px 14px;
      min-width:clamp(140px,18vw,210px);
      box-shadow:0 8px 20px rgba(0,0,0,.25);
      backdrop-filter:blur(4px);
    }

    .scoreboard-title{
      font-size:.8rem;
      text-transform:uppercase;
      letter-spacing:.08em;
      opacity:.8;
      margin-bottom:6px;
    }

    .scoreboard-value{
      font-size:clamp(1.2rem,2.6vw,1.7rem);
      font-weight:800;
      color:var(--accent);
    }

    .scoreboard-sub{
      margin-top:2px;
      font-size:.9rem;
      opacity:.9;
    }

    .hud-bottom{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-width:min(92vw,980px);
      text-shadow:0 2px 8px rgba(0,0,0,.35);
    }

    .progress-shell{
      width:min(520px,92vw);
      height:18px;
      border-radius:999px;
      background:rgba(255,255,255,.18);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.25);
      box-shadow:inset 0 0 0 1px rgba(0,0,0,.12);
    }

    .progress-fill{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,var(--accent),var(--accent-2));
      transition:width 200ms ease;
    }

    /* Overlay */
    #promptOverlay{
      position:fixed;
      inset:0;
      z-index:10;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:16px;
      padding:24px;
      background:radial-gradient(circle at 20% 20%,rgba(255,255,255,.08),transparent 55%), rgba(2,10,20,.92);
    }

    #promptOverlay h2{
      margin:0;
      font-size:clamp(1.5rem,4vw,2.4rem);
      letter-spacing:.02em;
    }

    #promptOverlay p{
      margin:0;
      max-width:min(900px,92vw);
      font-size:clamp(1.05rem,2.6vw,1.25rem);
      line-height:1.5;
      opacity:.98;
    }

    #modeSelect{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:center;
    }

    #modeSelect button{
      pointer-events:auto;
      border:none;
      border-radius:12px;
      padding:12px 18px;
      min-width:220px;
      font-size:1rem;
      cursor:pointer;
      background:rgba(255,255,255,.12);
      color:var(--text);
      transition:transform 80ms ease, background 150ms ease, box-shadow 150ms ease;
      box-shadow:0 6px 18px rgba(0,0,0,.25);
    }

    #modeSelect button:hover,
    #modeSelect button:focus-visible{
      background:rgba(255,255,255,.2);
      outline:none;
      box-shadow:0 0 0 3px rgba(255,213,79,.35);
    }

    #modeSelect button.active{
      background:linear-gradient(135deg,var(--accent),var(--accent-2));
      color:#1b1400;
      font-weight:800;
    }

    #startButton{
      pointer-events:auto;
      border:none;
      border-radius:14px;
      padding:14px 28px;
      font-size:1.2rem;
      font-weight:800;
      cursor:pointer;
      color:#1b1400;
      background:linear-gradient(135deg,var(--accent),var(--accent-2));
      box-shadow:0 10px 26px rgba(0,0,0,.35);
      transition:transform 90ms ease, filter 150ms ease;
    }

    #startButton:hover,
    #startButton:focus-visible{filter:brightness(1.05);outline:none;}
    #startButton:active{transform:translateY(1px) scale(.995);}

    #langToggle{
      position:fixed;
      top:14px;
      right:14px;
      z-index:11;
      padding:.45rem .95rem;
      border-radius:999px;
      border:2px solid #2ee6d6;
      background:#04131d;
      color:#2ee6d6;
      font-weight:800;
      letter-spacing:.02em;
      cursor:pointer;
      box-shadow:0 0 0 0 rgba(46,230,214,0);
      transition:box-shadow 150ms ease, transform 80ms ease;
    }

    #langToggle:hover,
    #langToggle:focus-visible{outline:none;box-shadow:0 0 0 4px rgba(46,230,214,.2);}
    #langToggle:active{transform:translateY(1px);}

    @media (max-width:720px){
      .hud-top{flex-direction:column;align-items:flex-start;}
      .scoreboard{min-width:unset;width:min(260px,92vw);}
    }
  </style>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-B45TJG4GBJ');
  </script>
</head>
<body>
  <button id="langToggle" title="Changer la langue / Change language">FR / EN</button>

  <div id="promptOverlay">
    <h2 class="translate"
        data-fr="Patinoire olympique : Zamboni"
        data-en="Olympic rink: Zamboni"
        data-ja="オリンピックリンク：ザンボーニ">
      Patinoire olympique : Zamboni
    </h2>
    <p class="translate"
       data-fr="Appuyez sur votre switch (ou la barre d'espace) pour avancer et lisser la glace. Nettoyez toute la patinoire pour lancer la cérémonie !"
       data-en="Press your switch (or the space bar) to move forward and smooth the ice. Clean the entire rink to start the ceremony!"
       data-ja="スイッチ（またはスペースキー）を押して前進し、氷を整えましょう。リンク全体をきれいにするとセレモニーが始まります！">
      Appuyez sur votre switch (ou la barre d'espace) pour avancer et lisser la glace. Nettoyez toute la patinoire pour lancer la cérémonie !
    </p>

    <div id="modeSelect">
      <button data-mode="parade" class="active translate"
              data-fr="Parade (relax)"
              data-en="Parade (relax)"
              data-ja="パレード（ゆったり）">Parade (relax)</button>
      <button data-mode="ceremony" class="translate"
              data-fr="Cérémonie (plus rapide)"
              data-en="Ceremony (faster)"
              data-ja="セレモニー（少し速い）">Cérémonie (plus rapide)</button>
    </div>

    <button id="startButton" class="translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
  </div>

  <canvas id="rink"></canvas>

  <div class="hud" aria-hidden="true">
    <div class="hud-top">
      <div class="brand">
        <h1 class="translate"
            data-fr="Jeux d'hiver — Entretien de la glace"
            data-en="Winter Games — Ice maintenance"
            data-ja="冬のゲーム — 製氷車">
          Jeux d'hiver — Entretien de la glace
        </h1>
        <p class="translate"
           data-fr="Chaque pression fait avancer la Zamboni et fait briller la glace."
           data-en="Each press moves the Zamboni forward and makes the ice shine."
           data-ja="押すたびにザンボーニが進み、氷が輝きます。">
          Chaque pression fait avancer la Zamboni et fait briller la glace.
        </p>
      </div>

      <div class="scoreboard">
        <div class="scoreboard-title translate" data-fr="Score olympique" data-en="Olympic score" data-ja="オリンピックスコア">Score olympique</div>
        <div class="scoreboard-value"><span id="scoreValue">0</span>%</div>
        <div class="scoreboard-sub translate" id="scoreSub"
             data-fr="Glace lissée"
             data-en="Ice smoothed"
             data-ja="整氷率">Glace lissée</div>
      </div>
    </div>

    <div class="hud-bottom">
      <div class="progress-shell"><div class="progress-fill" id="progressFill"></div></div>
      <div class="translate"
           data-fr="Astuce : gardez un rythme régulier. Entrée = recommencer."
           data-en="Tip: keep a steady rhythm. Enter = restart."
           data-ja="ヒント：一定のリズムで。Enterでリスタート。">
        Astuce : gardez un rythme régulier. Entrée = recommencer.
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('rink');
    const ctx = canvas.getContext('2d');

    const overlay = document.getElementById('promptOverlay');
    const startButton = document.getElementById('startButton');
    const modeButtons = Array.from(document.querySelectorAll('#modeSelect button'));

    const scoreValue = document.getElementById('scoreValue');
    const progressFill = document.getElementById('progressFill');
    const scoreSub = document.getElementById('scoreSub');

    const langToggle = document.getElementById('langToggle');
    langToggle.addEventListener('pointerup', () => {
      toggleLanguage();
      updateModeButtonLabels();
      updateHUDCopy();
    });

    document.addEventListener('DOMContentLoaded', () => {
      updateLanguage();
      updateModeButtonLabels();
      updateHUDCopy();
    });

    const state = {
      started:false,
      finished:false,
      mode:'parade',
      presses:0,
      smoothing:0,
      targetSmoothing:0,
      dwellCooldown:0,
      celebrationTime:0,
    };

    const grid = {
      cols:28,
      rows:16,
      cells:[],
      cleaned:0,
      total:0,
    };

    const zamboni = {
      col:1,
      row:1,
      dir:1,
      movesPerPress:1,
      trailRadius:1,
    };

    const arena = {
      flags:[
        '#ef5350','#42a5f5','#66bb6a','#ffee58','#ab47bc','#ffa726','#26c6da','#ec407a'
      ],
      flagPhase:0,
      glow:0,
    };

    function resize(){
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      buildGrid();
      draw();
    }

    window.addEventListener('resize', resize);

    function buildGrid(){
      const {cols,rows} = grid;
      grid.cells = new Array(cols*rows).fill(0);
      grid.cleaned = 0;
      grid.total = cols*rows;
      zamboni.col = 1;
      zamboni.row = 1;
      zamboni.dir = 1;
      cleanAround(zamboni.col, zamboni.row, 2);
    }

    function idx(c,r){ return r*grid.cols + c; }

    function cleanCell(c,r){
      if(c < 0 || r < 0 || c >= grid.cols || r >= grid.rows) return;
      const i = idx(c,r);
      if(grid.cells[i] < 1){
        grid.cells[i] = 1;
        grid.cleaned += 1;
      }
    }

    function cleanAround(c,r,rad=zamboni.trailRadius){
      for(let rr = r-rad; rr <= r+rad; rr++){
        for(let cc = c-rad; cc <= c+rad; cc++){
          cleanCell(cc,rr);
        }
      }
      syncProgress();
    }

    function syncProgress(){
      const pct = Math.min(100, Math.round((grid.cleaned / grid.total) * 100));
      scoreValue.textContent = pct;
      progressFill.style.width = pct + '%';
      state.targetSmoothing = pct / 100;
      if(!state.finished && pct >= 100){
        triggerCelebration();
      }
    }

    function setMode(mode){
      state.mode = mode;
      const parade = mode === 'parade';
      zamboni.movesPerPress = parade ? 1 : 2;
      zamboni.trailRadius = parade ? 1 : 2;
      state.dwellCooldown = parade ? 0 : 80;
      modeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.mode === mode));
      updateModeButtonLabels();
    }

    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => setMode(btn.dataset.mode));
    });

    startButton.addEventListener('click', () => {
      state.started = true;
      overlay.style.display = 'none';
      langToggle.style.display = 'none';
      canvas.focus?.();
    });

    function handlePress(){
      if(!state.started || state.finished) return;
      const now = performance.now();
      if(state.dwellCooldown && now - state.presses < state.dwellCooldown) return;

      state.presses = now;
      advanceZamboni();
      arena.glow = Math.min(1, arena.glow + 0.18);
    }

    function advanceZamboni(){
      for(let step = 0; step < zamboni.movesPerPress; step++){
        zamboni.col += zamboni.dir;
        if(zamboni.col >= grid.cols - 2){
          zamboni.col = grid.cols - 2;
          zamboni.row = Math.min(grid.rows - 2, zamboni.row + 2);
          zamboni.dir = -1;
        }else if(zamboni.col <= 1){
          zamboni.col = 1;
          zamboni.row = Math.min(grid.rows - 2, zamboni.row + 2);
          zamboni.dir = 1;
        }

        if(zamboni.row >= grid.rows - 1){
          zamboni.row = 1;
        }

        cleanAround(zamboni.col, zamboni.row);
      }
    }

    function triggerCelebration(){
      state.finished = true;
      state.celebrationTime = performance.now();
      scoreSub.dataset.fr = 'Patinoire prête !';
      scoreSub.dataset.en = 'Rink ready!';
      scoreSub.dataset.ja = 'リンク完成！';
      updateHUDCopy();
    }

    function restart(){
      state.started = false;
      state.finished = false;
      state.smoothing = 0;
      state.targetSmoothing = 0;
      arena.glow = 0;
      overlay.style.display = 'flex';
      langToggle.style.display = 'block';
      buildGrid();
      syncProgress();
      updateHUDCopy();
    }

    function onKey(e){
      if(e.code === 'Space'){
        e.preventDefault();
        handlePress();
      }
      if(e.code === 'Enter'){
        e.preventDefault();
        restart();
      }
    }
    window.addEventListener('keydown', onKey, {passive:false});

    window.addEventListener('pointerdown', handlePress);

    function updateModeButtonLabels(){
      modeButtons.forEach(btn => {
        const lang = document.documentElement.lang || 'fr';
        const key = lang === 'en' ? 'en' : (lang === 'ja' ? 'ja' : 'fr');
        btn.textContent = btn.dataset[key];
      });
    }

    function updateHUDCopy(){
      updateLanguage();
      if(state.finished){
        updateLanguage();
      }
    }

    function drawArenaFrame(bounds){
      const {x,y,w,h} = bounds;
      const board = Math.min(w,h) * 0.06;
      ctx.save();
      ctx.translate(x,y);

      const outerRadius = 26;
      roundRect(ctx,0,0,w,h,outerRadius);
      ctx.fillStyle = '#f7fbff';
      ctx.fill();

      roundRect(ctx,board,board,w-board*2,h-board*2,20);
      ctx.fillStyle = '#ffffff';
      ctx.fill();

      ctx.lineWidth = board*0.35;
      ctx.strokeStyle = '#c62828';
      roundRect(ctx,board*0.5,board*0.5,w-board,h-board,24);
      ctx.stroke();

      ctx.restore();
    }

    function drawRink(bounds){
      const {x,y,w,h} = bounds;
      const pad = Math.min(w,h) * 0.06;
      const inner = {x:x+pad,y:y+pad,w:w-pad*2,h:h-pad*2};

      const cellW = inner.w / grid.cols;
      const cellH = inner.h / grid.rows;

      // Ice base
      const iceGrad = ctx.createLinearGradient(inner.x, inner.y, inner.x, inner.y + inner.h);
      iceGrad.addColorStop(0, '#eefbff');
      iceGrad.addColorStop(1, '#d7f1ff');
      ctx.fillStyle = iceGrad;
      roundRect(ctx, inner.x, inner.y, inner.w, inner.h, 18);
      ctx.fill();

      // Uncleaned overlay
      ctx.save();
      roundRect(ctx, inner.x, inner.y, inner.w, inner.h, 18);
      ctx.clip();
      for(let r=0;r<grid.rows;r++){
        for(let c=0;c<grid.cols;c++){
          const clean = grid.cells[idx(c,r)];
          if(clean >= 1) continue;
          const cx = inner.x + c*cellW;
          const cy = inner.y + r*cellH;
          ctx.fillStyle = (c+r)%2===0 ? 'rgba(195,224,240,0.42)' : 'rgba(186,217,236,0.38)';
          ctx.fillRect(cx,cy,cellW+0.6,cellH+0.6);
        }
      }
      ctx.restore();

      // Hockey lines
      const centerX = inner.x + inner.w/2;
      const centerY = inner.y + inner.h/2;
      ctx.save();
      roundRect(ctx, inner.x, inner.y, inner.w, inner.h, 18);
      ctx.clip();

      ctx.lineWidth = Math.max(2, inner.w * 0.004);
      ctx.strokeStyle = 'rgba(229,57,53,0.9)';
      ctx.beginPath();
      ctx.moveTo(centerX, inner.y);
      ctx.lineTo(centerX, inner.y + inner.h);
      ctx.stroke();

      ctx.strokeStyle = 'rgba(30,136,229,0.85)';
      const blueOffset = inner.w * 0.22;
      ctx.beginPath();
      ctx.moveTo(centerX - blueOffset, inner.y);
      ctx.lineTo(centerX - blueOffset, inner.y + inner.h);
      ctx.moveTo(centerX + blueOffset, inner.y);
      ctx.lineTo(centerX + blueOffset, inner.y + inner.h);
      ctx.stroke();

      // Faceoff circle
      ctx.strokeStyle = 'rgba(229,57,53,0.85)';
      ctx.lineWidth = Math.max(2, inner.w * 0.005);
      ctx.beginPath();
      ctx.arc(centerX, centerY, inner.w * 0.09, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      drawZamboni(inner, cellW, cellH);
      drawShine(inner);
    }

    function drawZamboni(inner, cellW, cellH){
      const zx = inner.x + zamboni.col*cellW;
      const zy = inner.y + zamboni.row*cellH;
      const w = cellW * 2.4;
      const h = cellH * 1.5;

      ctx.save();
      ctx.translate(zx, zy);

      // shadow
      ctx.fillStyle = 'rgba(0,0,0,.18)';
      ctx.beginPath();
      ctx.ellipse(w*0.5, h*0.95, w*0.55, h*0.35, 0, 0, Math.PI*2);
      ctx.fill();

      // body
      const dir = zamboni.dir;
      ctx.scale(dir,1);
      const offsetX = dir === 1 ? 0 : -w;
      ctx.translate(offsetX,0);

      ctx.fillStyle = '#ffca28';
      roundRect(ctx, 0, h*0.05, w, h*0.7, 10);
      ctx.fill();

      ctx.fillStyle = '#455a64';
      roundRect(ctx, w*0.18, -h*0.05, w*0.42, h*0.38, 8);
      ctx.fill();

      ctx.fillStyle = '#90caf9';
      roundRect(ctx, w*0.24, 0, w*0.3, h*0.22, 6);
      ctx.fill();

      ctx.fillStyle = '#263238';
      ctx.beginPath();
      ctx.arc(w*0.22, h*0.78, h*0.22, 0, Math.PI*2);
      ctx.arc(w*0.78, h*0.78, h*0.22, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = '#eceff1';
      ctx.fillRect(w*0.02, h*0.55, w*0.96, h*0.12);

      ctx.restore();
    }

    function drawShine(inner){
      state.smoothing += (state.targetSmoothing - state.smoothing) * 0.06;
      const alpha = 0.18 + state.smoothing * 0.32 + arena.glow * 0.18;
      arena.glow *= 0.94;

      ctx.save();
      roundRect(ctx, inner.x, inner.y, inner.w, inner.h, 18);
      ctx.clip();

      const grad = ctx.createLinearGradient(inner.x, inner.y, inner.x + inner.w, inner.y + inner.h);
      grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
      grad.addColorStop(0.5, `rgba(255,255,255,${alpha*0.35})`);
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(inner.x, inner.y, inner.w, inner.h);

      // celebration sweep
      if(state.finished){
        const t = (performance.now() - state.celebrationTime) / 1000;
        const sweepX = inner.x + ((t * 180) % (inner.w + 200)) - 100;
        const sweep = ctx.createLinearGradient(sweepX, inner.y, sweepX + 160, inner.y);
        sweep.addColorStop(0, 'rgba(255,255,255,0)');
        sweep.addColorStop(0.5, 'rgba(255,255,255,0.5)');
        sweep.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = sweep;
        ctx.fillRect(inner.x, inner.y, inner.w, inner.h);
      }

      ctx.restore();
    }

    function drawCrowd(bounds){
      const {x,y,w} = bounds;
      const crowdY = y - 40;
      const rows = 3;
      const dotsPerRow = Math.max(18, Math.floor(w / 40));
      ctx.save();
      for(let r=0;r<rows;r++){
        const yy = crowdY - r*18;
        for(let i=0;i<dotsPerRow;i++){
          const xx = x + (i + (r%2)*0.5) * (w / dotsPerRow);
          const hue = 180 + ((i*17 + r*23) % 120);
          ctx.fillStyle = `hsla(${hue},80%,70%,${0.18 + r*0.05})`;
          ctx.beginPath();
          ctx.arc(xx, yy, 4 - r*0.6, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
    }

    function drawFlags(bounds){
      const {x,y,w} = bounds;
      const flagTop = y - 120;
      const flagCount = 8;
      const gap = w / (flagCount + 1);
      arena.flagPhase += 0.02;
      ctx.save();
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(255,255,255,0.55)';
      for(let i=0;i<flagCount;i++){
        const fx = x + gap*(i+1);
        const sway = Math.sin(arena.flagPhase + i*0.7) * 6;
        ctx.beginPath();
        ctx.moveTo(fx, flagTop);
        ctx.lineTo(fx, flagTop + 60);
        ctx.stroke();

        ctx.fillStyle = arena.flags[i % arena.flags.length];
        ctx.beginPath();
        ctx.moveTo(fx, flagTop + 6);
        ctx.quadraticCurveTo(fx + 28 + sway, flagTop + 18, fx, flagTop + 34);
        ctx.lineTo(fx, flagTop + 6);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawSpotlights(bounds){
      const {x,y,w,h} = bounds;
      const t = performance.now() * 0.001;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      for(let i=0;i<3;i++){
        const phase = t * (0.6 + i*0.2);
        const sx = x + (i+1) * (w/4);
        const sweep = Math.sin(phase) * (w*0.2);
        const grad = ctx.createLinearGradient(sx + sweep, y - 180, sx - sweep, y + h*0.3);
        grad.addColorStop(0, 'rgba(255,255,255,0.22)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(sx - 40, y - 180);
        ctx.lineTo(sx + 40, y - 180);
        ctx.lineTo(sx + 200 + sweep, y + h*0.35);
        ctx.lineTo(sx - 200 + sweep, y + h*0.35);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    function drawPodium(bounds){
      if(!state.finished) return;
      const {x,y,w,h} = bounds;
      const baseY = y + h + 26;
      const blockW = Math.min(120, w*0.16);
      const gap = blockW * 0.25;
      const centerX = x + w/2;

      ctx.save();
      ctx.translate(centerX, baseY);
      const pulse = 1 + Math.sin(performance.now()*0.006)*0.04;
      ctx.scale(pulse,pulse);

      const colors = ['#c0c0c0','#ffd54f','#cd7f32'];
      const heights = [54,74,44];
      const order = [-1,0,1];
      order.forEach((pos,idx) => {
        const bx = pos*(blockW+gap) - blockW/2;
        const bh = heights[idx];
        ctx.fillStyle = colors[idx];
        roundRect(ctx,bx,-bh,blockW,bh,8);
        ctx.fill();
      });
      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function draw(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      ctx.clearRect(0,0,vw,vh);

      const rinkW = Math.min(vw*0.9, 1200);
      const rinkH = Math.min(vh*0.68, 680);
      const rinkX = (vw - rinkW)/2;
      const rinkY = Math.max(120, (vh - rinkH)/2 - 20);
      const bounds = {x:rinkX,y:rinkY,w:rinkW,h:rinkH};

      drawSpotlights(bounds);
      drawFlags(bounds);
      drawCrowd(bounds);
      drawArenaFrame(bounds);
      drawRink(bounds);
      drawPodium(bounds);

      requestAnimationFrame(draw);
    }

    resize();
    syncProgress();
    draw();
  </script>
</body>
</html>
