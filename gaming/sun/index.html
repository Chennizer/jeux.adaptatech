<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Soleil : Jeu Switch</title>
<!-- p5.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>
<link rel="stylesheet" href="../../css/otherswitch.css">
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#5aa9e6;}
  canvas{display:block;position:fixed;top:0;left:0;}
  #modeOverlay{
    position:fixed;inset:0;display:flex;flex-direction:column;
    align-items:center;justify-content:center;gap:24px;
    background:#000;color:#fff;z-index:10000;}
  #modeOverlay button{
    padding:10px 24px;font-size:18px;border:none;border-radius:6px;
    cursor:pointer;background:#ffd250;color:#000;}
  #modeOverlay button:hover{background:#ffb930;}
  #settings-icon{
    position:fixed;top:16px;right:16px;width:40px;height:40px;
    border-radius:50%;background:#000;color:#fff;font-size:22px;
    display:flex;align-items:center;justify-content:center;visibility:hidden;
    cursor:pointer;z-index:9999;
  }
  #menu{z-index:10000;display:none;}
  #menu.show{display:block;}
</style>
</head>
<body>
<!-- ────────── Choix du mode ────────── -->
<div id="modeOverlay">
  <h2>Choisis ton mode&nbsp;:</h2>
  <button id="btnNormal">Mode normal</button>
  <button id="btnRapid">Mode éclair (1 clic)</button>
  <p style="font-size:14px;opacity:.8;">
    Espace pour les rayons · Entrée pour rejouer
  </p>
</div>

<!-- icône réglages + menu -->
<div id="settings-icon" title="Settings">⚙️</div>
<div id="menu">
  <h2>Options</h2>
  <h3>Musique &amp; son</h3>
  <label class="inline"><span>Désactiver la musique</span>
    <input type="checkbox" id="muteMusic"></label><br>
  <label><span>Volume musique :</span> <span id="musicVolVal">50</span><br>
    <input type="range" id="musicVol" min="0" max="100" value="50"></label><br>
  <label class="inline"><span>Désactiver les effets</span>
    <input type="checkbox" id="muteSFX"></label><br>
  <label><span>Volume effets :</span> <span id="sfxVolVal">50</span><br>
    <input type="range" id="sfxVol" min="0" max="100" value="50"></label>
  <h3>Délai entre appuis (ms)</h3>
  <label><span>Délai :</span> <span id="tapDelayVal">2000</span><br>
    <input type="range" id="tapDelaySlider" min="500" max="5000" value="2000"></label>
</div>

<script>
/* === AUDIO & ÉTAT ================================================= */
let gameStarted=false, gameOver=false;
const ambiencePath='../../sounds/sun/sunnyday.mp3';
const finishPath  ='../../sounds/sun/fanfare.mp3';
const rayPath     ='../../sounds/sun/sun1.mp3';
let ambience, raySound, finishSound;
let volMusic=.5, volSFX=.5;
let isSFXMuted=false, isMusicMuted=false;

/* === VISUEL ======================================================= */
const MAX_RAYS=8;
let rays=[], rayCount=0;
let sunRadius, innerR, longLen, shortLen, strokeW;
let basePulse=1, sunRot=0;

/* finale pilotée par la durée réelle du morceau */
let finalStage=0;              // 0=off, 1=en cours, 2=done
let finalScale=1;
let warmFlashAlpha=0;
let screenFlashAlpha=0, FLASH_INITIAL=80, FLASH_STEP=FLASH_INITIAL/120;
let finishStartMs=null;
let finishDurMs=6000;          // fallback
let finalProgress=0;           // 0..1

let lastTap=-Infinity, tapDelay=2000;
let rapidMode=false;

/* décor */
let clouds=[], balloon, birds=[];
let balloonImg, birdImg;
let extraBalloons=[];          // ballons supplémentaires (finale)
let balloonsReleased=false;

/* confetti (boostés) */
let confetti=[];
let confettiMidBurstDone=false; // burst supplémentaire à ~50%
const CONFETTI_COLS=[[255,210,100],[255,177,66],[255,235,150],[255,196,100],[255,225,120]];

/* Buffers */
let skyBuffer;                 // ciel
let haloBuffer;                // halo autour du soleil

/* gestion du refresh du ciel (3) */
let lastSkyUpdateFrame = -999;

/* ---------- preload ---------- */
function preload(){
  ambience   = loadSound(ambiencePath);
  raySound   = loadSound(rayPath);
  finishSound= loadSound(finishPath);
  balloonImg = loadImage('../../images/sun/montgolfiere1.png');
  birdImg    = loadImage('../../images/sun/oiseau_vol.png');
}

/* ---------- setup ---------- */
function setup(){
  createCanvas(windowWidth,windowHeight);
  angleMode(RADIANS);
  for(let i=0;i<6;i++)
    clouds.push(new Cloud(random(width),random(30,height/2),
               random(80,250),random(40,120),random(0.5,2)));
  balloon = new Balloon(
    width+random(50,150), random(height/4,height/2-50),
    random(0.5,0.6), 0.25, 'horizontal');
  for(let i=0;i<3;i++) birds.push(new Bird());

  buildSkyBuffer(0);           // ciel initial (froid)
  computeSizes();
  buildHaloBuffer();           // halo pré-calculé (compact)
}

/* ---------- responsive sizes ---------- */
function computeSizes(){
  const base=min(width,height)*0.15;
  sunRadius=base;
  innerR   =base*1.2;
  longLen  =base*2.2;
  shortLen =base*2;
  strokeW  =base*0.08;
}

/* ---------- draw ---------- */
function draw(){
  if(!gameStarted){background(0);return;}

  // (3) Warm sky drift
  if(finalStage===1){
    if(frameCount - lastSkyUpdateFrame >= 6){
      buildSkyBuffer(finalProgress);
      lastSkyUpdateFrame = frameCount;
    }
  }
  image(skyBuffer, 0, 0);

  // éléments derrière le soleil
  birds.forEach(b=>{b.update();b.draw();});
  clouds.forEach(c=>{c.update();c.draw();});

  // halo + vignette (1)
  drawHaloAndVignette();

  // soleil et rayons (2)
  drawSun();

  // >>> Ballons devant le soleil <<<
  balloon.update(); balloon.draw();
  extraBalloons.forEach(b=>{b.update();b.draw();});

  // confetti (7) — boostés
  updateAndDrawConfetti();

  if(warmFlashAlpha>1){
    noStroke(); fill(255,200,80,warmFlashAlpha);
    rect(0,0,width,height);
  }

  basePulse=1+0.05*sin(frameCount*0.03);
  if(rayCount===MAX_RAYS) handleFinalAnim();

  sunRot+=0.003;

  if(screenFlashAlpha>0){
    screenFlashAlpha=max(0,screenFlashAlpha-FLASH_STEP);
    noStroke(); fill(255,180,50,screenFlashAlpha);
    rect(0,0,width,height);
  }

  if (gameOver) {
    setTimeout(()=>{resetScene(); gameOver=false;}, 100);
  }
}

/* ---------- halo + vignette ---------- */
function buildHaloBuffer(){
  const sz = floor(min(width,height)*0.6); // compact
  haloBuffer = createGraphics(sz, sz);
  const g = haloBuffer;
  g.noStroke();
  const cx = sz/2, cy = sz/2, maxR = sz/2;
  for(let i=0;i<80;i++){
    const t = i/79;
    const a = 80*(1-t)*(1-t);
    g.fill(255, 220, 120, a);
    const r = maxR * t;
    g.ellipse(cx, cy, r*2, r*2);
  }
}

function drawHaloAndVignette(){
  const breathe = finalStage===1 ? (0.98 + 0.04 * sin(frameCount*0.03)) : (0.995 + 0.01*sin(frameCount*0.02));
  const tightness = 2.2;
  const s = (sunRadius * tightness) / (haloBuffer.width/2);
  const haloScale = s * breathe * (finalStage===1 ? lerp(1.0, 1.25, easeInOutCubic(constrain(finalProgress,0,1))) : 1.0);

  push();
  translate(width/2, height/2);
  scale(haloScale);
  imageMode(CENTER);
  image(haloBuffer, 0, 0);
  pop();

  // Vignette douce
  const vigStrength = finalStage===1 ? 70 : 30;
  const rings = 10;
  for(let i=0;i<rings;i++){
    const t = i/(rings-1);
    const alpha = vigStrength * (t*t);
    noFill(); stroke(0,0,0, alpha);
    strokeWeight( max(width,height) * 0.02 );
    ellipse(width/2, height/2, width*(1+ t*0.6), height*(1+ t*0.6));
  }
  noStroke();
}

/* ---------- Soleil + rayons + shimmer ---------- */
function drawSun(){
  push();
  translate(width/2,height/2);
  rotate(sunRot);
  scale(basePulse*(finalStage?finalScale:1));
  noStroke();
  fill(255,180,50);
  ellipse(0,0,sunRadius*2,sunRadius*2);

  stroke(255,210,100);
  strokeWeight(strokeW);
  for(const r of rays){
    const n1 = noise(r.seed, frameCount*0.01);
    const n2 = noise(r.seed+1000, frameCount*0.015);
    const angOff = radians(-3 + 6*n1);           // ±3°
    const lenJit = -3 + 6*n2;                    // ±3 px
    const a = r.angle + angOff;
    const tgt = r.targetLen + lenJit;

    r.currLen=lerp(r.currLen, tgt, 0.06);
    r.alpha  =lerp(r.alpha,255,0.12);
    stroke(255,210,100, r.alpha);
    line(innerR*cos(a),innerR*sin(a), r.currLen*cos(a),r.currLen*sin(a));
  }
  pop();
}

/* ---------- décor ---------- */
class Cloud{
  constructor(x,y,w,h,s){this.x=x;this.y=y;this.w=w;this.h=h;this.s=s;}
  update(){
    this.x-=this.s;
    if(this.x+this.w<0){
      Object.assign(this,{
        x:width+random(20,100),y:random(30,height/2),
        w:random(80,250),h:random(40,120),s:random(0.5,2)
      });
    }
  }
  draw(){
    noStroke(); fill(255,255,255,180);
    ellipse(this.x,this.y,this.w,this.h);
    ellipse(this.x-this.w*0.4,this.y+10,this.w*0.7,this.h*0.7);
    ellipse(this.x+this.w*0.4,this.y+10,this.w*0.7,this.h*0.7);
  }
}
class Balloon{
  constructor(x,y,v,sc,mode){this.x=x;this.y=y;this.v=v;this.sc=sc;this.mode=mode;}
  switchVertical(){
    this.mode='vertical';
    this.x=random(50,width-50);
    this.y=height+random(40,150);
    this.v=random(1.2,2);
  }
  update(){
    if(finalStage>=1 && this.mode==='horizontal') this.switchVertical();
    if(this.mode==='horizontal'){
      this.x-=this.v;
      if(this.x+balloonImg.width*this.sc<0){
        this.x=width+random(50,150);
        this.y=random(height/4,height/2-50);
        this.v=random(0.5,0.6);
      }
    }else{
      this.y-=this.v;
      if(this.y+balloonImg.height*this.sc<-40){
        this.y=height+random(40,150);
        this.x=random(50,width-50);
        this.v=random(1.2,2);
      }
    }
  }
  draw(){
    push();
    translate(this.x,this.y);
    scale(this.sc);
    imageMode(CENTER);
    image(balloonImg,0,0);
    pop();
  }
}
class Bird{
  constructor(){this.reset();}
  reset(){
    this.sc=0.05;
    this.x=-birdImg.width*this.sc-random(20,100);
    this.y=random(height/6,height/2);
    this.baseV=random(1,2);
    this.phase=random(TWO_PI);
  }
  update(){
    this.x+=this.baseV*(finalStage>=1?2:1);
    this.y+=0.25*sin(frameCount*0.05+this.phase);
    if(this.x>width+40) this.reset();
  }
  draw(){
    push();
    translate(this.x,this.y);
    scale(this.sc);
    imageMode(CENTER);
    image(birdImg,0,0);
    pop();
  }
}

/* ---------- Confetti (PLUS APPARENTS) ---------- */
function spawnConfetti(){
  // Beaucoup plus: 50–80 pièces
  const n = floor(random(50,80));
  // Reset si trop de confetti en cours (sécurité perf)
  if(confetti.length > 240) confetti.length = 160;

  for(let i=0;i<n;i++){
    const angle = random(TWO_PI);
    const radius = min(width,height)*0.10; // burst un peu plus large
    const x = width/2 + cos(angle)*radius*random(0.15,1);
    const y = height/2 + sin(angle)*radius*random(0.15,1);

    // vitesse initiale plus marquée mais douce
    const sp = random(1.8,3.2);
    const vx = (x - width/2) * 0.018 + random(-0.8,0.8);
    const vy = (y - height/2) * 0.018 - sp;

    const col = random(CONFETTI_COLS);
    const rot = random(TWO_PI);
    const rotSp = random(-0.06,0.06);

    // Durée PLUS LONGUE: 600–960 frames (~10–16s à 60fps)
    const maxLife = floor(random(600,960));

    // Plus gros: 14–28 px
    const size = random(14,28);

    const shape = random([ 'rect', 'tri' ]);

    confetti.push({
      x, y, vx, vy,
      ax: 0, ay: 0.055,    // gravité douce (plus petit => reste plus longtemps)
      col, rot, rotSp,
      life: maxLife, maxLife,
      shape, size
    });
  }
}

function updateAndDrawConfetti(){
  if(confetti.length===0) return;

  for(let i=confetti.length-1;i>=0;i--){
    const p = confetti[i];
    // physique
    p.vx += p.ax; p.vy += p.ay;
    p.x  += p.vx; p.y  += p.vy;
    // friction légère (conserve la dérive)
    p.vx *= 0.995; 
    p.vy *= 0.997;
    p.rot += p.rotSp;
    p.life -= 1;

    // Alpha: plein au début, baisse lentement (courbe ease)
    const t = constrain(p.life / p.maxLife, 0, 1);
    const alpha = 255 * (t*t); // ralentit la disparition

    fill(p.col[0], p.col[1], p.col[2], alpha);
    noStroke();
    push(); translate(p.x, p.y); rotate(p.rot);
    if(p.shape==='rect'){
      rectMode(CENTER);
      rect(0,0,p.size, p.size*0.6);
    }else{
      triangle(-p.size*0.6, p.size*0.5, p.size*0.6, p.size*0.5, 0, -p.size*0.6);
    }
    pop();

    // nettoyage
    if(p.life<=0 || p.y>height+80) confetti.splice(i,1);
  }
}

/* ---------- animation finale (durée = durée du morceau) ---------- */
function handleFinalAnim(){
  // démarrage
  if(finalStage===0){
    finalStage=1;
    startFinishSound();
    finishStartMs = millis();
    const dur = (finishSound && finishSound.duration && isFinite(finishSound.duration()))
                ? finishSound.duration()*1000 : null;
    finishDurMs = dur && dur>0 ? dur : 6000;
    finalProgress = 0;

    // confetti + lâcher de ballons
    spawnConfetti();
    confettiMidBurstDone=false;
    if(!balloonsReleased){
      releaseExtraBalloons();
      balloonsReleased=true;
    }
  }

  if(finalStage===1){
    // progression 0..1 pendant toute la durée du morceau
    const elapsed = millis() - (finishStartMs ?? millis());
    finalProgress = constrain(elapsed / finishDurMs, 0, 1);

    // Burst supplémentaire à mi-parcours pour "encore plus visible"
    if(!confettiMidBurstDone && finalProgress >= 0.48){
      spawnConfetti();
      confettiMidBurstDone = true;
    }

    // Phases : 0–0.2 agrandit, 0.2–0.8 maintient, 0.8–1.0 rétrécit
    const growEnd=0.20, shrinkStart=0.80;

    if(finalProgress < growEnd){
      const t = finalProgress / growEnd;
      finalScale = lerp(1.0, 1.6, t);
      warmFlashAlpha = lerp(0, 150, t);
    } else if (finalProgress < shrinkStart){
      finalScale = 1.6;
      const t = (finalProgress - growEnd) / (shrinkStart - growEnd);
      warmFlashAlpha = lerp(150, 0, t);
    } else {
      const t = (finalProgress - shrinkStart) / (1 - shrinkStart);
      finalScale = lerp(1.6, 1.0, t);
      warmFlashAlpha = 0;
    }

    const musicEnded = finishSound && !finishSound.isPlaying();
    if (finalProgress >= 1 || musicEnded){
      finalStage = 2;
      gameOver = true;
    }
  }
}

function startFinishSound(){
  ambience?.fade(volMusic,0.2); // atténue l'ambiance
  finishSound.setVolume(isMusicMuted?0:volMusic);
  finishSound.play();
}

/* ---------- Lâcher de ballons (finale) ---------- */
function releaseExtraBalloons(){
  extraBalloons.length = 0;
  const n = floor(random(4,7));
  for(let i=0;i<n;i++){
    const b = new Balloon(random(60,width-60), height + random(40,200), random(1.1,1.9), random(0.18,0.28), 'vertical');
    b.delayStart = millis() + i*random(250,700);
    const baseUpdate = b.update.bind(b);
    b.update = function(){
      if(millis() < this.delayStart) return;
      baseUpdate();
    }
    extraBalloons.push(b);
  }
}

/* ---------- interaction ---------- */
function addAllRays(){
  for(let i=0;i<MAX_RAYS;i++){
    rays.push({
      angle: i*TWO_PI/MAX_RAYS,
      currLen: innerR,
      targetLen: (i%2 ? shortLen : longLen),
      alpha: 0,
      seed: random(10000)         // shimmer seed
    });
  }
  rayCount=MAX_RAYS;
  screenFlashAlpha=FLASH_INITIAL;
}
function addSingleRay(){
  const i=rayCount;
  rays.push({
    angle: i*TWO_PI/MAX_RAYS,
    currLen: innerR,
    targetLen: (i%2 ? shortLen : longLen),
    alpha: 0,
    seed: random(10000)           // shimmer seed
  });
  rayCount++;
  screenFlashAlpha=FLASH_INITIAL;
}
function trigger(){
  if(!gameStarted||gameOver||(finalStage>0 && !gameOver)) return;
  if(millis()-lastTap<tapDelay) return;
  lastTap=millis();
  if(rapidMode && rayCount===0){
    addAllRays();
  }else if(!rapidMode && rayCount<MAX_RAYS){
    addSingleRay();
  }
  if(!isSFXMuted && raySound){
    raySound.setVolume(volSFX);
    raySound.isLoaded()
      ? raySound.play()
      : raySound.once('loaded',()=>{ if(!isSFXMuted) raySound.play(); });
  }
}
function keyPressed(){
  if(key===' '&&gameStarted) trigger();
  if(keyCode===ENTER && gameStarted && (finalStage===0 || gameOver)){
    resetScene();
  }
}

/* ---------- reset ---------- */
function resetScene(){
  rays=[];rayCount=0;
  finalStage=0;finalScale=1;warmFlashAlpha=0;
  screenFlashAlpha=0;finishStartMs=null;
  finalProgress=0;
  balloonsReleased=false;
  extraBalloons.length=0;
  confetti.length=0;
  confettiMidBurstDone=false;

  buildSkyBuffer(0);
  lastSkyUpdateFrame = -999;

  balloon.mode='horizontal';balloon.v=random(0.5,0.6);
}

/* ---------- UI : options et menu ---------- */
window.addEventListener('load',()=>{
  const ov=document.getElementById('modeOverlay'),
        btnN=document.getElementById('btnNormal'),
        btnR=document.getElementById('btnRapid');
  btnN.onclick=()=>{rapidMode=false;startGame();};
  btnR.onclick=()=>{rapidMode=true; startGame();};

  const ico=document.getElementById('settings-icon'),
        menu=document.getElementById('menu'),
        muteM=document.getElementById('muteMusic'),
        volM=document.getElementById('musicVol'),
        valM=document.getElementById('musicVolVal'),
        muteS=document.getElementById('muteSFX'),
        volS=document.getElementById('sfxVol'),
        valS=document.getElementById('sfxVolVal'),
        slider=document.getElementById('tapDelaySlider'),
        valT=document.getElementById('tapDelayVal');

  slider.oninput=e=>{tapDelay=e.target.value;valT.textContent=e.target.value;};

  volM.oninput=e=>{
    volMusic=e.target.value/100; valM.textContent=e.target.value;
    if(!isMusicMuted) ambience?.setVolume(volMusic);
    finishSound.setVolume(isMusicMuted?0:volMusic);
  };
  volS.oninput=e=>{
    volSFX=e.target.value/100; valS.textContent=e.target.value;
    raySound.setVolume(isSFXMuted?0:volSFX);
  };
  muteM.onchange=e=>{
    isMusicMuted=e.target.checked;
    ambience?.setVolume(isMusicMuted?0:volMusic);
    finishSound.setVolume(isMusicMuted?0:volMusic);
  };
  muteS.onchange=e=>{
    isSFXMuted=e.target.checked;
    raySound.setVolume(isSFXMuted?0:volSFX);
  };

  function startGame(){
    ov.remove();
    gameStarted=true;
    ico.style.visibility='visible';
    (document.documentElement.requestFullscreen||
     document.documentElement.webkitRequestFullscreen)?.call(document.documentElement);
    resizeCanvas(windowWidth,windowHeight);
    computeSizes();
    buildSkyBuffer(0);   // ciel base
    buildHaloBuffer();   // halo recalé si dimension change
    ambience.setLoop(true);
    ambience.setVolume(isMusicMuted?0:volMusic);
    ambience.play();
  }

  ico.onclick=()=>{if(gameStarted) menu.classList.toggle('show');};
  document.onclick=e=>{
    if(!menu.contains(e.target)&&!ico.contains(e.target)) menu.classList.remove('show');};
});

/* ---------- Sky buffer (3) ---------- */
function buildSkyBuffer(pWarm){
  // pWarm : 0 = froid; 1 = chaud
  if(!skyBuffer || skyBuffer.width!==width || skyBuffer.height!==height){
    skyBuffer = createGraphics(width, height);
  }
  const g = skyBuffer;
  const coldTop = [90,169,230];
  const coldBot = [130,209,240];
  const warmTop = [120,185,235];
  const warmBot = [255,220,160];
  const top = lerpRGB(coldTop, warmTop, easeInOutCubic(constrain(pWarm,0,1)));
  const bot = lerpRGB(coldBot, warmBot, easeInOutCubic(constrain(pWarm,0,1)));

  for (let y = 0; y < height; y++) {
    const t = y / height;
    const c = [
      floor( lerp(top[0], bot[0], t) ),
      floor( lerp(top[1], bot[1], t) ),
      floor( lerp(top[2], bot[2], t) )
    ];
    g.stroke(c[0], c[1], c[2]);
    g.line(0, y, width, y);
  }
}

/* ---------- Resize ---------- */
function windowResized(){
  if(gameStarted){
    resizeCanvas(windowWidth,windowHeight);
    computeSizes();
    buildSkyBuffer(finalStage===1 ? finalProgress : 0);
    buildHaloBuffer();
  }
}

/* ---------- Utils ---------- */
function lerpRGB(a,b,t){ return [ lerp(a[0],b[0],t), lerp(a[1],b[1],t), lerp(a[2],b[2],t) ]; }
function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - pow(-2*x+2,3)/2; }
</script>

    <script src="../../js/home-button.js" defer></script>
</body>
</html>
