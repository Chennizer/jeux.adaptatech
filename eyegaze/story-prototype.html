<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Story Prototype — Cherry Blossom, Meditation, Lamp</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Helvetica Neue", Arial, system-ui, sans-serif;
    }
    html, body {
      margin: 0;
      height: 100%;
    }
    body {
      background: #030712;
      color: #f9fafb;
    }
    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    .page {
      position: absolute;
      inset: 0;
      display: none;
    }
    .page.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 40px;
      padding: clamp(24px, 6vw, 80px);
      text-align: center;
    }
    .landing-page {
      background: radial-gradient(circle at top, rgba(56,189,248,0.25), transparent 60%),
                  radial-gradient(circle at bottom, rgba(190,242,100,0.12), transparent 70%),
                  #030712;
    }
    .landing-page h1 {
      margin: 0;
      font-size: clamp(32px, 6vw, 56px);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    .landing-page p {
      max-width: min(720px, 90vw);
      line-height: 1.7;
      font-size: clamp(18px, 3vw, 24px);
      color: rgba(226, 232, 240, 0.9);
    }
    .start-button {
      position: relative;
      padding: 16px 32px;
      border-radius: 999px;
      border: 2px solid rgba(191, 219, 254, 0.6);
      background: rgba(59, 130, 246, 0.3);
      color: #f8fafc;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      box-shadow: 0 12px 40px rgba(15, 23, 42, 0.35);
      overflow: hidden;
      isolation: isolate;
    }
    .start-button:hover,
    .start-button:focus-visible {
      transform: translateY(-2px);
      border-color: rgba(248, 250, 252, 0.85);
      box-shadow: 0 16px 50px rgba(59, 130, 246, 0.35);
      outline: none;
    }
    .story-page {
      background: radial-gradient(circle at top, rgba(14,116,144,0.25), transparent 60%),
                  radial-gradient(circle at bottom, rgba(190,242,100,0.12), transparent 70%),
                  #030712;
    }
    .story-page h1 {
      margin: 0;
      font-size: clamp(28px, 5vw, 48px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .story-page p {
      max-width: min(720px, 90vw);
      line-height: 1.6;
      font-size: clamp(18px, 2.8vw, 24px);
    }
    .gaze-target {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 14px 24px;
      border-radius: 999px;
      border: 2px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.65);
      color: #e2e8f0;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.3s ease, background 0.3s ease;
      overflow: hidden;
      isolation: isolate;
    }
    .gaze-target:hover,
    .gaze-target:focus-visible,
    .gaze-target.progress {
      border-color: rgba(248, 250, 252, 0.85);
      background: rgba(59, 130, 246, 0.35);
    }
    .dwell-overlay {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 120%;
      height: 120%;
      transform: translate(-50%, -50%) scale(0.08);
      transform-origin: center;
      border-radius: inherit;
      pointer-events: none;
      background: rgba(220, 38, 38, 0.55);
      opacity: 0;
    }
    .dwell-overlay.animate {
      animation: dwellFill var(--dwell-duration, 1500ms) linear forwards;
    }
    @keyframes dwellFill {
      from {
        transform: translate(-50%, -50%) scale(0.08);
        opacity: 0.2;
      }
      to {
        transform: translate(-50%, -50%) scale(1.02);
        opacity: 0.75;
      }
    }
    .page.game-page {
      background: #000;
      padding: 0;
    }
    .game-frame {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
      background: #000;
    }
  </style>
</head>
<body>
  <div id="app">
    <section class="page landing-page active" data-index="0">
      <h1>Samurai Journey</h1>
      <p>
        Begin an interactive tale guided by your gaze. Press start to enter fullscreen and follow the
        warrior through moments of story and play.
      </p>
      <button id="startStory" class="start-button" type="button">Start the Story</button>
    </section>

    <section class="page story-page" data-index="1">
      <h1>Samurai Dawn</h1>
      <p>
        The young warrior arrives at the cherry grove to begin a journey of focus and harmony.
        Follow the story by resting your gaze on the glowing sigil below. The tale will unfold
        between moments of play.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Focus to Continue</div>
    </section>

    <section class="page story-page" data-index="2">
      <h1>Whispers in the Wind</h1>
      <p>
        Petals spiral through the air as a playful spirit challenges the warrior to slice blossoms
        carried by the breeze. Prepare to enter the first training.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Enter the Grove</div>
    </section>

    <section class="page game-page" data-index="3" data-game="cherry">
      <iframe title="Cherry Blossom Game" class="game-frame" allowfullscreen></iframe>
    </section>

    <section class="page story-page" data-index="4">
      <h1>Breath of the Mountain</h1>
      <p>
        With the challenge complete, the warrior rests beside a moonlit lake. Slow breaths and a
        guiding light call for quiet concentration before the next path.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Begin Meditation</div>
    </section>

    <section class="page game-page" data-index="5" data-game="meditation">
      <iframe title="Meditation Game" class="game-frame" allowfullscreen></iframe>
    </section>

    <section class="page story-page" data-index="6">
      <h1>Lanterns Ascend</h1>
      <p>
        Enlightened by calm, the warrior must now send lanterns skyward to guide wandering spirits.
        A final game of patience awaits among the stars.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Release the Light</div>
    </section>

    <section class="page game-page" data-index="7" data-game="lamp">
      <iframe title="Lantern Game" class="game-frame" allowfullscreen></iframe>
    </section>

    <section class="page story-page" data-index="8">
      <h1>Journey Complete</h1>
      <p>
        The night sky glows with quiet lanterns. The warrior bows in gratitude, ready for whatever
        tale will come next.
      </p>
      <div class="gaze-target" data-next data-dwell="1500" tabindex="0">Restart Story</div>
    </section>
  </div>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const pages = Array.from(document.querySelectorAll('.page'));
      let currentIndex = 0;
      let gameTimeoutId = null;

      function clearGameTimer() {
        if (gameTimeoutId) {
          clearTimeout(gameTimeoutId);
          gameTimeoutId = null;
        }
      }

      function showPage(index) {
        if (index < 0 || index >= pages.length) return;
        if (index === currentIndex) return;
        clearGameTimer();
        const previousPage = pages[currentIndex];
        if (previousPage) {
          previousPage.classList.remove('active');
          if (previousPage.dataset.game) {
            stopGame(previousPage);
          }
        }
        currentIndex = index;
        const page = pages[currentIndex];
        if (!page) return;
        page.classList.add('active');
        if (page.dataset.game) {
          loadGame(page.dataset.game, page);
          gameTimeoutId = window.setTimeout(() => {
            if (pages[currentIndex] === page) {
              nextPage();
            }
          }, 30000);
        }
      }

      function nextPage() {
        const nextIndex = (currentIndex + 1) % pages.length;
        showPage(nextIndex);
      }

      function createDwellOverlay(target, dwell) {
        const existing = target.querySelectorAll('.dwell-overlay');
        existing.forEach((el) => el.remove());
        const overlay = document.createElement('div');
        overlay.className = 'dwell-overlay';
        overlay.style.setProperty('--dwell-duration', `${dwell}ms`);
        target.appendChild(overlay);
        requestAnimationFrame(() => overlay.classList.add('animate'));
        return overlay;
      }

      function clearDwellOverlay(target) {
        target.querySelectorAll('.dwell-overlay').forEach((el) => el.remove());
      }

      const startButton = document.getElementById('startStory');
      if (startButton) {
        const beginStory = async () => {
          await requestAppFullscreen();
          showPage(1);
        };
        startButton.addEventListener('click', (event) => {
          event.preventDefault();
          beginStory();
        });
        startButton.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            beginStory();
          }
        });
        startButton.addEventListener('pointerenter', () => {
          createDwellOverlay(startButton, 1200);
        });
        startButton.addEventListener('pointerleave', () => {
          clearDwellOverlay(startButton);
        });
      }

      const gazeTargets = document.querySelectorAll('[data-next]');
      gazeTargets.forEach((target) => {
        const dwell = Number(target.dataset.dwell || 1800);
        let timer = null;
        const trigger = () => {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          target.classList.remove('progress');
          clearDwellOverlay(target);
          nextPage();
        };
        target.addEventListener('pointerenter', () => {
          if (timer) return;
          target.classList.add('progress');
          createDwellOverlay(target, dwell);
          timer = setTimeout(trigger, dwell);
        });
        target.addEventListener('pointerleave', () => {
          if (!timer) return;
          clearTimeout(timer);
          timer = null;
          target.classList.remove('progress');
          clearDwellOverlay(target);
        });
        target.addEventListener('click', trigger);
        target.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            trigger();
          }
        });
      });

      async function requestAppFullscreen() {
        if (document.fullscreenElement) return;
        const root = document.documentElement;
        const method = root.requestFullscreen || root.webkitRequestFullscreen || root.msRequestFullscreen;
        if (method) {
          try {
            await method.call(root);
          } catch (error) {
            /* ignore failures */
          }
        }
      }

      const templateCache = {};
      function loadTemplate(id) {
        if (!templateCache[id]) {
          const tpl = document.getElementById(id);
          templateCache[id] = tpl ? tpl.innerHTML.trim() : '';
        }
        return templateCache[id];
      }

      const loadedGames = new Set();

      function autoStartGameFrame(iframe, attempt = 0) {
        if (!iframe) return;
        const win = iframe.contentWindow;
        const doc = win?.document;
        if (!doc || !win) return;

        const startOverlay = doc.getElementById('startOverlay');
        if (startOverlay) {
          startOverlay.style.display = 'none';
        }

        const storyApi = win.storyGameApi;
        if (storyApi && typeof storyApi.start === 'function') {
          try {
            const maybePromise = storyApi.start();
            if (maybePromise && typeof maybePromise.then === 'function') {
              maybePromise.catch(() => {});
            }
            return;
          } catch (error) {
            /* ignore and fall back */
          }
        }

        const autoFns = ['startExperience', 'startGame'];
        for (const name of autoFns) {
          const fn = win[name];
          if (typeof fn === 'function') {
            try {
              fn.call(win);
              return;
            } catch (error) {
              /* ignore individual game errors */
            }
          }
        }

        const startBtn = doc.getElementById('startBtn');
        if (startBtn && typeof startBtn.click === 'function') {
          startBtn.click();
        }

        if (attempt < 5) {
          window.setTimeout(() => autoStartGameFrame(iframe, attempt + 1), 200);
        }
      }

      function stopGame(page) {
        const iframe = page?.querySelector('iframe');
        if (!iframe) return;
        try {
          const win = iframe.contentWindow;
          if (!win) return;
          const api = win.storyGameApi;
          if (api && typeof api.stop === 'function') {
            try {
              const maybePromise = api.stop();
              if (maybePromise && typeof maybePromise.then === 'function') {
                maybePromise.catch(() => {});
              }
            } catch (error) {
              /* ignore stop errors */
            }
          } else {
            const stopFns = ['stopExperience', 'stopGame', 'pauseGame'];
            for (const name of stopFns) {
              const fn = win[name];
              if (typeof fn === 'function') {
                try {
                  fn.call(win);
                } catch (error) {
                  /* ignore */
                }
              }
            }
          }

          const doc = win.document;
          if (doc) {
            doc.querySelectorAll('audio').forEach((audioEl) => {
              try {
                audioEl.pause();
                audioEl.currentTime = 0;
              } catch (error) {
                /* ignore audio cleanup failures */
              }
            });
          }
        } catch (error) {
          /* ignore cross-frame issues */
        }
      }

      function loadGame(key, page) {
        const iframe = page.querySelector('iframe');
        const note = page.querySelector('.loading-note');
        if (!iframe) return;

        const handleLoaded = () => {
          if (note) {
            try {
              note.remove();
            } catch (error) {
              /* ignore */
            }
          }
          window.requestAnimationFrame(() => autoStartGameFrame(iframe));
        };

        if (!loadedGames.has(key)) {
          let templateId = '';
          if (key === 'cherry') templateId = 'tpl-cherryblossom';
          else if (key === 'meditation') templateId = 'tpl-meditation';
          else if (key === 'lamp') templateId = 'tpl-lamp';
          if (!templateId) return;
          const html = loadTemplate(templateId);
          if (!html) return;
          iframe.addEventListener('load', handleLoaded, { once: true });
          iframe.srcdoc = html;
          loadedGames.add(key);
        } else {
          handleLoaded();
        }
      }
    });
  </script>

  <template id="tpl-cherryblossom">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cherry Blossom Cut — Tornado Swirl (Fly-Off) Intro</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    #game {
      display: block;
      width: 100vw; height: 100vh;
      cursor: crosshair;          /* fallback if custom cursor is not ready */
      background: #000;
    }
    #startOverlay {
      position: fixed; inset: 0;
      background: #000;
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="startOverlay" aria-hidden="true"></div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       CONFIG
    ======================= */
    const IMG_SRC = "../../images/samurai/cherryblossom.png";       // petal image
    const BG_SRC  = "../../images/samurai/cherryblossombg.png";     // background image
    const SLASH_SOUND = "../../sounds/blade.mp3";
    const KATANA_SRC  = "../../images/samurai/katana.png";
    const SONG_SRC    = "../../songs/samurai/cherryblossomsong2.mp3"; // bg song
    const KATANA_DRAW_SRC = "../../sounds/katana.mp3";               // sword drawing SFX

    // Cursor limits and hotspot (in ORIGINAL image pixels)
    const CURSOR_MAX_PX = 124;
    const HOTSPOT_ORIG = { x: 12, y: 28 };

    // Play (normal game) settings
    const SPAWN_EVERY_MS   = 1400;
    const FALL_SPEED_MIN   = 40;
    const FALL_SPEED_MAX   = 95;
    const BLOSSOM_SIZE_MIN = 72 * 3;
    const BLOSSOM_SIZE_MAX = 138 * 3;
    const HOVER_CUT_RADIUS = 52;
    const SHARD_SPREAD_SPEED = 190;
    const SHARD_ROT_SPEED    = 1.2;
    const SHARD_FADE_TIME    = 0.85;
    const MAX_FALLING        = 5;

    // Intro (tornado swirl) settings — fly-off
    const INTRO_DURATION_MS = 5000;     // 5s total
    const SWIRL_PETALS      = 50;       // keep it smooth
    const SWIRL_SIZE_MIN    = 40;
    const SWIRL_SIZE_MAX    = 100;
    const SWIRL_RAD_MIN     = 20;       // starting radius
    const SWIRL_RAD_MAX     = 220;
    const SWIRL_DR_MIN      = 16;       // baseline radial expansion (px/s)
    const SWIRL_DR_MAX      = 42;
    const SWIRL_DA_MIN      = 2.2;      // angular vel (rad/s)
    const SWIRL_DA_MAX      = 4.2;
    const SWIRL_SPIN_MIN    = -1.6;     // self-rotation (rad/s)
    const SWIRL_SPIN_MAX    =  1.6;
    const SWIRL_CENTER_DRIFT_Y = 12;    // gentle downward drift (px/s)

    // Strong outward burst controls
    const BURST_START_T     = 0.60;     // fraction of intro when burst begins
    const BURST_MAX_OUT_PX  = 1800;     // additional outward speed at peak (px/s)
    const BURST_SPINUP_MUL  = 1.6;      // multiplies angular velocity during burst
    const FINAL_BLAST_MS    = 350;      // last ms window for a final kick
    const FINAL_BLAST_OUT   = 2200;     // extra outward speed (px/s) in last window

    // Off-screen margin for culling
    const OFF_MARGIN = 320;

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    let resizeRAF = 0;
    window.addEventListener('resize', () => {
      cancelAnimationFrame(resizeRAF);
      resizeRAF = requestAnimationFrame(() => {
        W = canvas.width  = window.innerWidth;
        H = canvas.height = window.innerHeight;
      });
    });

    // Assets
    const img = new Image(); img.src = IMG_SRC;
    const bgImg = new Image(); bgImg.src = BG_SRC;

    // Audio
    const slashAudio = new Audio(SLASH_SOUND);
    slashAudio.volume = 0.6;
    function playSlash() {
      const s = slashAudio.cloneNode(true);
      s.volume = slashAudio.volume;
      s.play().catch(()=>{});
    }

    // Background music
    const bgSong = new Audio(SONG_SRC);
    bgSong.volume = 0.75;   // 75%
    bgSong.loop = true;

    // Katana draw SFX (for the moment the sword cursor appears)
    const katanaDraw = new Audio(KATANA_DRAW_SRC);
    katanaDraw.volume = 0.9;

    // Pointer / cursor flip
    const pointer = { x: -9999, y: -9999, prevX: -9999, inside: false };
    const MOVE_THRESH = 2;
    let cursorOrient = 'left';

    canvas.addEventListener('pointermove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top)  * (canvas.height / rect.height);
      const dx = (pointer.prevX === -9999) ? 0 : (x - pointer.prevX);

      pointer.x = x; pointer.y = y; pointer.inside = true;

      if (gameState === 'play' && katanaReady && katanaRevealed) {
        if (dx > MOVE_THRESH && cursorOrient !== 'right') { cursorOrient = 'right'; applyKatanaCursor(); }
        else if (dx < -MOVE_THRESH && cursorOrient !== 'left') { cursorOrient = 'left'; applyKatanaCursor(); }
      }
      pointer.prevX = x;
    });
    canvas.addEventListener('pointerleave', () => pointer.inside = false);

    const blossoms = [];
    const shards = [];
    const rand = (a, b) => a + Math.random() * (b - a);
    const nowSec = () => performance.now()/1000;

    /* =======================
       KATANA CURSOR
    ======================= */
    let katanaReady = false;
    let katanaLeft = null;   // {url, hx, hy}
    let katanaRight = null;  // {url, hx, hy}
    let katanaRevealed = false; // becomes true once we show the katana cursor + play SFX

    const katanaImg = new Image();
    katanaImg.onload = () => {
      const iw = katanaImg.width, ih = katanaImg.height;
      const scale = Math.min(1, CURSOR_MAX_PX / Math.max(iw, ih));
      const dw = Math.round(iw * scale);
      const dh = Math.round(ih * scale);

      const leftCanvas = document.createElement('canvas');
      leftCanvas.width = dw; leftCanvas.height = dh;
      const lctx = leftCanvas.getContext('2d');
      lctx.imageSmoothingEnabled = true;
      lctx.drawImage(katanaImg, 0, 0, dw, dh);

      const rightCanvas = document.createElement('canvas');
      rightCanvas.width = dw; rightCanvas.height = dh;
      const rctx = rightCanvas.getContext('2d');
      rctx.imageSmoothingEnabled = true;
      rctx.translate(dw, 0); rctx.scale(-1, 1);
      rctx.drawImage(katanaImg, 0, 0, dw, dh);

      const hxLeft  = Math.max(0, Math.min(dw - 1, Math.round(HOTSPOT_ORIG.x * scale)));
      const hyLeft  = Math.max(0, Math.min(dh - 1, Math.round(HOTSPOT_ORIG.y * scale)));
      const hxRight = (dw - 1) - hxLeft;
      const hyRight = hyLeft;

      katanaLeft  = { url: leftCanvas.toDataURL('image/png'),  hx: hxLeft,  hy: hyLeft };
      katanaRight = { url: rightCanvas.toDataURL('image/png'), hx: hxRight, hy: hyRight };
      katanaReady = true;

      // If we are already in play and haven't revealed yet, do it now
      if (gameState === 'play' && !katanaRevealed) {
        revealKatanaCursorWithSfx();
      }
    };
    katanaImg.onerror = () => { katanaReady = false; };
    katanaImg.src = KATANA_SRC;

    function applyKatanaCursor() {
      if (!katanaReady) return;
      const k = (cursorOrient === 'right') ? katanaRight : katanaLeft;
      canvas.style.cursor = `url("${k.url}") ${k.hx} ${k.hy}, crosshair`;
    }

    function revealKatanaCursorWithSfx() {
      if (!katanaReady) return; // will be retried via onload above
      applyKatanaCursor();
      katanaRevealed = true;
      // Play the katana drawing sound when the sword appears
      try { katanaDraw.currentTime = 0; katanaDraw.play(); } catch(e) {}
    }

    /* =======================
       HUD: SLICE COUNTER
    ======================= */
    let sliceCount = 0;
    function drawHUD() {
      const pad = Math.max(12, Math.min(20, Math.floor(W * 0.01 + H * 0.01)));
      const iconSize = Math.max(24, Math.min(36, Math.floor((W + H) * 0.02)));
      const textSize = Math.max(18, Math.min(28, Math.floor((W + H) * 0.018)));

      const xRight = W - pad;
      const yTop = pad + iconSize * 0.1;

      ctx.save();
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.font = `700 ${textSize}px ui-rounded, ui-sans-serif, system-ui, Segoe UI, Roboto, Arial`;
      ctx.fillStyle = '#d40000';
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 2;

      // Number
      ctx.fillText(`${sliceCount}`, xRight, yTop + iconSize * 0.5);

      // Icon left of the number
      if (img.complete && img.naturalWidth > 0) {
        const iconX = xRight - ctx.measureText(`${sliceCount}`).width - 10 - iconSize;
        const iconY = pad;
        ctx.shadowColor = 'rgba(0,0,0,0.18)';
        ctx.drawImage(img, iconX, iconY, iconSize, iconSize);
      }
      ctx.restore();
    }

    /* =======================
       GAME ENTITIES
    ======================= */
    function spawnBlossom() {
      if (!img.complete) return;
      const size = rand(BLOSSOM_SIZE_MIN, BLOSSOM_SIZE_MAX);
      const aspect = img.width / img.height || 1;
      const w = aspect >= 1 ? size*aspect : size;
      const h = aspect >= 1 ? size : size/aspect;
      blossoms.push({
        x: rand(w * 0.5, W - w * 0.5),
        y: -h - rand(0, 100),
        w, h,
        angle: rand(-Math.PI, Math.PI),
        rot: rand(-0.5, 0.5),
        vy: rand(FALL_SPEED_MIN, FALL_SPEED_MAX),
        vx: rand(-12, 12),
        cut: false
      });
    }

    function cutBlossom(b) {
      playSlash();
      sliceCount++;

      const leftRect  = { sx: 0, sy: 0, sw: img.width/2, sh: img.height };
      const rightRect = { sx: img.width/2, sy: 0, sw: img.width/2, sh: img.height };
      const tw = b.w, th = b.h, tBorn = nowSec();
      shards.push({clip:leftRect,x:b.x-tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx:-SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot:-SHARD_ROT_SPEED,born:tBorn,life:SHARD_FADE_TIME});
      shards.push({clip:rightRect,x:b.x+tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx: SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot: SHARD_ROT_SPEED,born:tBorn,life: SHARD_FADE_TIME});
      b.cut = true;
    }

    /* =======================
       INTRO: TORNADO SWIRL (FLY-OFF)
    ======================= */
    let gameState = 'idle';  // 'idle' | 'intro' | 'play'
    let introStartMs = 0;
    let started = false;
    let rafId = 0;

    let swirlCenter = { x: 0, y: 0 };
    let swirlPetals = []; // {r,a,w,h,spin,dr,da,angle,done}

    function smoothstep01(t){ return t*t*(3-2*t); } // 0..1 -> smooth 0..1

    function initSwirl() {
      swirlCenter.x = W * 0.5;
      swirlCenter.y = H * 0.55;
      swirlPetals = [];

      for (let i = 0; i < SWIRL_PETALS; i++) {
        const r  = rand(SWIRL_RAD_MIN, SWIRL_RAD_MAX);
        const a  = rand(0, Math.PI * 2);
        const size = rand(SWIRL_SIZE_MIN, SWIRL_SIZE_MAX);
        const aspect = (img.width || 1) / (img.height || 1);
        const w = aspect >= 1 ? size*aspect : size;
        const h = aspect >= 1 ? size : size/aspect;

        swirlPetals.push({
          r, a, w, h,
          spin: rand(SWIRL_SPIN_MIN, SWIRL_SPIN_MAX),              // self-rotation
          dr:   rand(SWIRL_DR_MIN, SWIRL_DR_MAX),                  // base radial expansion
          da:   rand(SWIRL_DA_MIN, SWIRL_DA_MAX) * (Math.random()<0.5?-1:1), // angular velocity
          angle: rand(-Math.PI, Math.PI),
          done: false
        });
      }
    }

    function updateSwirl(dt, t01) {
      // gentle vertical drift of the whole column
      swirlCenter.y += SWIRL_CENTER_DRIFT_Y * dt;

      // ramped burst strength 0..1 after BURST_START_T
      const burstPhase = Math.max(0, (t01 - BURST_START_T) / (1 - BURST_START_T));
      const burst = smoothstep01(burstPhase); // smooth ramp-up

      // final blast window
      const remainingMs = INTRO_DURATION_MS * (1 - t01);
      const finalBlast = remainingMs <= FINAL_BLAST_MS ? (1 - remainingMs / FINAL_BLAST_MS) : 0;

      for (const p of swirlPetals) {
        if (p.done) continue;

        // spin-up during burst (tighter/twitchier swirl)
        const daNow = p.da * (1 + (BURST_SPINUP_MUL - 1) * burst);

        // strong outward push during burst + final blast
        const outward = p.dr + (BURST_MAX_OUT_PX * burst) + (FINAL_BLAST_OUT * finalBlast);

        // integrate polar motion
        p.a     += daNow * dt;     // orbit
        p.r     += outward * dt;   // spiral out faster and then explode
        p.angle += p.spin * dt;    // petal self-rotation

        // compute position for off-screen test
        const x = swirlCenter.x + Math.cos(p.a) * p.r;
        const y = swirlCenter.y + Math.sin(p.a) * p.r;

        if (x < -OFF_MARGIN || x > W + OFF_MARGIN || y < -OFF_MARGIN || y > H + OFF_MARGIN) {
          p.done = true; // out of view; stop drawing
        }
      }
    }

    function drawSwirl() {
      drawBackgroundImage();
      for (const p of swirlPetals) {
        if (p.done) continue;
        const x = swirlCenter.x + Math.cos(p.a) * p.r;
        const y = swirlCenter.y + Math.sin(p.a) * p.r;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(p.angle);
        ctx.drawImage(img, -p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      // HUD during intro (shows 0)
      drawHUD();
    }

    /* =======================
       GAME LOOP STATE
    ======================= */
    let lastT = performance.now(), spawnTimer = 0;

    function tick(tMs) {
      if (!started) {
        rafId = 0;
        return;
      }
      const dt = Math.min(0.033, (tMs - lastT) / 1000);
      lastT = tMs;

      if (gameState === 'intro') {
        const elapsed = tMs - introStartMs;
        const t01 = Math.min(1, Math.max(0, elapsed / INTRO_DURATION_MS));
        updateSwirl(dt, t01);
        drawSwirl();

        if (elapsed >= INTRO_DURATION_MS) {
          gameState = 'play';

          // Reveal sword cursor + SFX if ready, or as soon as it becomes ready
          if (katanaReady) revealKatanaCursorWithSfx();

          spawnTimer = SPAWN_EVERY_MS + 1; // seed first blossom soon
        }
      } else if (gameState === 'play') {
        spawnTimer += dt * 1000;
        if (spawnTimer > SPAWN_EVERY_MS && blossoms.length < MAX_FALLING) {
          spawnTimer = 0;
          spawnBlossom();
        }
        updateBlossoms(dt);
        updateShards(dt);
        render();
      }

      rafId = requestAnimationFrame(tick);
    }

    /* =======================
       BACKGROUND IMAGE (cover)
    ======================= */
    function drawBackgroundImage() {
      if (bgImg.complete && bgImg.naturalWidth > 0) {
        const iw = bgImg.width, ih = bgImg.height;
        const scale = Math.max(W / iw, H / ih); // cover
        const dw = iw * scale, dh = ih * scale;
        const dx = (W - dw) * 0.5;
        const dy = (H - dh) * 0.5;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(bgImg, dx, dy, dw, dh);
      } else {
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, W, H);
      }
    }

    /* =======================
       PLAY RENDER/UPDATE
    ======================= */
    function updateBlossoms(dt) {
      for (let i = blossoms.length-1; i>=0; i--) {
        const b = blossoms[i];
        b.y += b.vy * dt;
        b.x += b.vx * dt;
        b.angle += b.rot * dt;
        const dx = pointer.x - b.x, dy = pointer.y - b.y;
        if (pointer.inside && !b.cut && dx*dx+dy*dy<=HOVER_CUT_RADIUS*HOVER_CUT_RADIUS) cutBlossom(b);
        if (b.cut || b.y - b.h/2 > H+40) blossoms.splice(i, 1);
      }
    }

    function updateShards(dt) {
      const t = nowSec();
      for (let i = shards.length-1; i>=0; i--) {
        const s = shards[i];
        s.x += s.vx * dt; s.y += s.vy * dt; s.vy += 420*dt; s.angle += s.rot * dt;
        if (t - s.born > s.life) shards.splice(i, 1);
      }
    }

    function render() {
      drawBackgroundImage();
      // Whole blossoms
      for (const b of blossoms) {
        ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle);
        ctx.drawImage(img,-b.w/2,-b.h/2,b.w,b.h); ctx.restore();
      }
      // Shards
      const t = nowSec();
      for (const s of shards) {
        const alpha = Math.max(0,1-(t-s.born)/s.life);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.translate(s.x,s.y); ctx.rotate(s.angle);
        ctx.drawImage(img,s.clip.sx,s.clip.sy,s.clip.sw,s.clip.sh,-s.w/2,-s.h/2,s.w,s.h);
        ctx.restore();
      }
      // HUD over everything
      drawHUD();
    }

    /* ===== FULLSCREEN START ===== */
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    async function enterFullscreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    }

    function scheduleTick() {
      if (!started || rafId) return;
      const begin = () => {
        if (!started) return;
        lastT = performance.now();
        rafId = requestAnimationFrame(tick);
      };

      if (img.complete && bgImg.complete) {
        begin();
        return;
      }

      let pending = 0;
      const tryStart = () => {
        if (--pending <= 0) begin();
      };
      if (!img.complete)  { pending++; img.onload  = tryStart; }
      if (!bgImg.complete){ pending++; bgImg.onload = tryStart; }
      if (pending === 0) begin();
    }

    function resetGameState() {
      gameState = 'idle';
      introStartMs = 0;
      swirlPetals = [];
      blossoms.length = 0;
      shards.length = 0;
      katanaRevealed = false;
      pointer.x = pointer.y = pointer.prevX = -9999;
      pointer.inside = false;
      cursorOrient = 'left';
    }

    async function startExperience(options = {}) {
      if (started) return;

      if (options.requestFullscreen) {
        try { await enterFullscreen(); } catch (e) {}
      }

      started = true;
      resetGameState();
      if (startOverlay) startOverlay.style.display = 'none';
      canvas.style.cursor = 'none';

      try { bgSong.currentTime = 0; await bgSong.play(); } catch (e) {}
      try { katanaDraw.currentTime = 0; katanaDraw.pause(); } catch (e) {}

      gameState = 'intro';
      introStartMs = performance.now();
      initSwirl();

      scheduleTick();
    }

    function stopExperience() {
      if (!started) return;
      started = false;
      cancelAnimationFrame(rafId);
      rafId = 0;
      resetGameState();
      canvas.style.cursor = 'default';
      try { bgSong.pause(); bgSong.currentTime = 0; } catch (e) {}
      try { slashAudio.pause(); slashAudio.currentTime = 0; } catch (e) {}
      try { katanaDraw.pause(); katanaDraw.currentTime = 0; } catch (e) {}
    }

    if (startBtn) {
      startBtn.addEventListener('click', () => {
        startExperience({ requestFullscreen: true });
      });
    } else {
      window.requestAnimationFrame(() => startExperience());
    }

    window.startExperience = (options) => startExperience(options);
    window.stopExperience = stopExperience;
    window.storyGameApi = { start: startExperience, stop: stopExperience };

  })();
  </script>
</body>
</html>
  </template>

  <template id="tpl-meditation">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Samurai Focus — Moon Meditation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #f8fafc;
      font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
    }
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #000;
      cursor: none;
    }
    #startOverlay {
      position: fixed;
      inset: 0;
      background: #000;
      pointer-events: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="startOverlay" aria-hidden="true"></div>
  <canvas id="game"></canvas>
  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    let width = 0;
    let height = 0;
    let running = false;
    let rafId = 0;
    let lastTime = 0;

    const pointer = { x: 0, y: 0, inside: false };

    const DWELL_MS = 1600;
    const DECAY_RATE = 0.45;
    const RESPAWN_DELAY = 1600;
    const LAUNCH_DURATION = 1100;
    const ORB_RADIUS = { min: 72, max: 108 };
    const ORB_BUFFER = 56;

    const moon = { x: 0, y: 0, r: 130 };

    const particles = [];
    const MAX_PARTICLES = 48;

    let orb = null;
    let launchPath = null;
    let respawnAt = 0;

    const overlay = document.getElementById('startOverlay');
    const backgroundImg = new Image();
    backgroundImg.src = '../../images/samurai/lampbg.png';

    function makeAudio(src, { loop = false, volume = 0.5 } = {}) {
      const audio = new Audio(src);
      audio.loop = loop;
      audio.volume = volume;
      audio.preload = 'auto';
      return audio;
    }

    const ambience = makeAudio('../../sounds/samurai/lamplit2.mp3', { loop: true, volume: 0.32 });
    const music = makeAudio('../../sounds/samurai/lamplit1.mp3', { loop: true, volume: 0.28 });
    const sfxRelease = makeAudio('../../sounds/samurai/energyball.mp3', { volume: 0.6 });
    const sfxImpact = makeAudio('../../sounds/samurai/spacerockexplosion1.mp3', { volume: 0.6 });

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      moon.x = width * 0.78;
      moon.y = height * 0.26;
      moon.r = Math.min(width, height) * 0.14;
    }
    window.addEventListener('resize', resize);

    function randomBetween(min, max) {
      return min + Math.random() * (max - min);
    }

    function spawnOrb(initial = false) {
      const spawnX = randomBetween(width * 0.25, width * 0.75);
      const spawnY = randomBetween(height * 0.58, height * 0.78);
      const radius = randomBetween(ORB_RADIUS.min, ORB_RADIUS.max);
      orb = {
        x: spawnX,
        y: spawnY,
        radius,
        charge: initial ? 0 : Math.random() * 0.1,
        wobble: Math.random() * Math.PI * 2,
      };
      launchPath = null;
    }

    function beginLaunch() {
      if (!orb) return;
      launchPath = {
        start: performance.now(),
        duration: LAUNCH_DURATION,
        from: { x: orb.x, y: orb.y, r: orb.radius },
        ctrl: {
          x: orb.x + (moon.x - orb.x) * 0.45,
          y: Math.min(orb.y, moon.y) - height * 0.22,
        },
        to: { x: moon.x, y: moon.y, r: Math.max(32, moon.r * 0.18) },
        trail: [],
      };
      try { sfxRelease.currentTime = 0; sfxRelease.play().catch(() => {}); } catch (error) {}
      orb = null;
    }

    function spawnParticles(x, y) {
      const count = 24;
      for (let i = 0; i < count && particles.length < MAX_PARTICLES; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const speed = randomBetween(90, 220);
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: randomBetween(0.6, 1.1),
          maxLife: randomBetween(0.6, 1.1),
          size: randomBetween(6, 18),
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i -= 1) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 40 * dt;
      }
    }

    function easeInOut(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    function updateOrb(dt) {
      if (orb) {
        orb.wobble += dt * 1.6;
        const wobbleX = Math.sin(orb.wobble) * 4;
        const wobbleY = Math.cos(orb.wobble * 0.7) * 3;
        orb.renderX = orb.x + wobbleX;
        orb.renderY = orb.y + wobbleY;

        if (pointer.inside) {
          const dx = pointer.x - orb.renderX;
          const dy = pointer.y - orb.renderY;
          const dist = Math.hypot(dx, dy);
          if (dist <= orb.radius + ORB_BUFFER) {
            orb.charge = Math.min(1, orb.charge + (dt * 1000) / DWELL_MS);
          } else {
            orb.charge = Math.max(0, orb.charge - dt * DECAY_RATE);
          }
        } else {
          orb.charge = Math.max(0, orb.charge - dt * DECAY_RATE);
        }

        if (orb.charge >= 1) {
          beginLaunch();
        }
      }

      if (launchPath) {
        const t = Math.min(1, (performance.now() - launchPath.start) / launchPath.duration);
        const eased = easeInOut(t);
        const u = 1 - eased;
        const from = launchPath.from;
        const ctrl = launchPath.ctrl;
        const to = launchPath.to;
        const x = u * u * from.x + 2 * u * eased * ctrl.x + eased * eased * to.x;
        const y = u * u * from.y + 2 * u * eased * ctrl.y + eased * eased * to.y;
        const r = from.r + (to.r - from.r) * eased;

        launchPath.trail.push({ x, y, r, alpha: 1 });
        if (launchPath.trail.length > 14) launchPath.trail.shift();
        for (const seg of launchPath.trail) seg.alpha *= 0.86;

        launchPath.position = { x, y, r };

        if (t >= 1) {
          try { sfxImpact.currentTime = 0; sfxImpact.play().catch(() => {}); } catch (error) {}
          spawnParticles(moon.x, moon.y);
          launchPath = null;
          respawnAt = performance.now() + RESPAWN_DELAY;
        }
      } else if (!orb && (!respawnAt || performance.now() >= respawnAt)) {
        spawnOrb();
        respawnAt = 0;
      }
    }

    function update(dt) {
      updateOrb(dt);
      updateParticles(dt);
    }

    function drawBackground() {
      if (backgroundImg.complete && backgroundImg.naturalWidth > 0) {
        const imgAspect = backgroundImg.naturalWidth / backgroundImg.naturalHeight;
        const canvasAspect = width / height || 1;
        let drawWidth = width;
        let drawHeight = height;
        if (canvasAspect > imgAspect) {
          drawHeight = width / imgAspect;
        } else {
          drawWidth = height * imgAspect;
        }
        const dx = (width - drawWidth) / 2;
        const dy = (height - drawHeight) / 2;
        ctx.drawImage(backgroundImg, dx, dy, drawWidth, drawHeight);
      } else {
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#040b19');
        gradient.addColorStop(0.45, '#091a2f');
        gradient.addColorStop(1, '#041218');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      }

      const veil = ctx.createLinearGradient(0, 0, 0, height);
      veil.addColorStop(0, 'rgba(4, 12, 24, 0.2)');
      veil.addColorStop(0.4, 'rgba(4, 8, 18, 0.15)');
      veil.addColorStop(1, 'rgba(4, 8, 18, 0.45)');
      ctx.fillStyle = veil;
      ctx.fillRect(0, 0, width, height);
    }

    function drawMoon() {
      ctx.save();
      ctx.shadowColor = 'rgba(180, 220, 255, 0.35)';
      ctx.shadowBlur = moon.r * 0.9;
      ctx.fillStyle = '#f4f5ff';
      ctx.beginPath();
      ctx.arc(moon.x, moon.y, moon.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      const halo = ctx.createRadialGradient(moon.x, moon.y, moon.r * 0.4, moon.x, moon.y, moon.r * 1.6);
      halo.addColorStop(0, 'rgba(255,255,255,0.45)');
      halo.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = halo;
      ctx.beginPath();
      ctx.arc(moon.x, moon.y, moon.r * 1.6, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawOrb() {
      if (orb) {
        const x = orb.renderX ?? orb.x;
        const y = orb.renderY ?? orb.y;
        const radius = orb.radius * (0.8 + orb.charge * 0.3);
        const gradient = ctx.createRadialGradient(x, y, radius * 0.2, x, y, radius);
        gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
        gradient.addColorStop(0.45, 'rgba(120,220,220,0.75)');
        gradient.addColorStop(1, 'rgba(20,130,150,0.0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        if (orb.charge > 0.05) {
          const ring = ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 1.2);
          ring.addColorStop(0, 'rgba(140,230,225,0.35)');
          ring.addColorStop(1, 'rgba(140,230,225,0)');
          ctx.fillStyle = ring;
          ctx.beginPath();
          ctx.arc(x, y, radius * 1.2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (launchPath) {
        const { position, trail } = launchPath;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const seg of trail) {
          if (seg.alpha <= 0.02) continue;
          const grad = ctx.createRadialGradient(seg.x, seg.y, seg.r * 0.2, seg.x, seg.y, seg.r);
          grad.addColorStop(0, `rgba(255,255,255,${0.45 * seg.alpha})`);
          grad.addColorStop(1, 'rgba(120,220,220,0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(seg.x, seg.y, seg.r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();

        if (position) {
          const grad = ctx.createRadialGradient(position.x, position.y, position.r * 0.25, position.x, position.y, position.r);
          grad.addColorStop(0, 'rgba(255,255,255,0.9)');
          grad.addColorStop(1, 'rgba(90,200,210,0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(position.x, position.y, position.r, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawParticles() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const p of particles) {
        const alpha = Math.max(0, Math.min(1, p.life / p.maxLife));
        ctx.fillStyle = `rgba(255,240,200,${0.6 * alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawPointer() {
      if (!pointer.inside) return;
      const radius = 18;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const grad = ctx.createRadialGradient(pointer.x, pointer.y, radius * 0.2, pointer.x, pointer.y, radius);
      grad.addColorStop(0, 'rgba(255,255,255,0.8)');
      grad.addColorStop(1, 'rgba(255,80,80,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(pointer.x, pointer.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function render() {
      drawBackground();
      drawMoon();
      drawParticles();
      drawOrb();
      drawPointer();
    }

    function loop(now) {
      if (!running) {
        rafId = 0;
        return;
      }
      if (!lastTime) lastTime = now;
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;
      update(dt);
      render();
      rafId = requestAnimationFrame(loop);
    }

    function updatePointerFromEvent(event) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      pointer.x = (event.clientX - rect.left) * scaleX;
      pointer.y = (event.clientY - rect.top) * scaleY;
    }

    canvas.addEventListener('pointerenter', (event) => {
      pointer.inside = true;
      updatePointerFromEvent(event);
    });
    canvas.addEventListener('pointermove', (event) => {
      pointer.inside = true;
      updatePointerFromEvent(event);
    });
    canvas.addEventListener('pointerleave', () => {
      pointer.inside = false;
    });
    canvas.addEventListener('pointerdown', (event) => {
      event.preventDefault();
    });

    function startExperience() {
      if (running) return;
      running = true;
      resize();
      spawnOrb(true);
      if (overlay) overlay.style.display = 'none';
      lastTime = performance.now();
      try { ambience.currentTime = 0; ambience.play().catch(() => {}); } catch (error) {}
      try { music.currentTime = 0; music.play().catch(() => {}); } catch (error) {}
      rafId = requestAnimationFrame(loop);
    }

    function stopExperience() {
      running = false;
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = 0;
      }
      if (overlay) overlay.style.display = '';
      [ambience, music, sfxRelease, sfxImpact].forEach((audio) => {
        try {
          audio.pause();
          audio.currentTime = 0;
        } catch (error) {}
      });
      orb = null;
      launchPath = null;
      respawnAt = 0;
      particles.length = 0;
    }

    window.addEventListener('blur', () => {
      if (!running) return;
      pointer.inside = false;
    });

    window.startExperience = startExperience;
    window.stopExperience = stopExperience;
    window.storyGameApi = { start: startExperience, stop: stopExperience };
  })();
  </script>
</body>
</html>
  </template>

  <template id="tpl-lamp">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sky Lanterns — Dual Lamps + Scattered + Colored Fireflies + BG Lanterns + Shooting Star + Ropes</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { display: flex; }
    #layout { display: flex; width: 100vw; height: 100vh; background: #000; overflow: hidden; }
    #modePanel {
      width: 20vw; min-width: 180px; max-width: 320px; background: #050505;
      border-right: 1px solid rgba(255,255,255,0.04); box-shadow: 10px 0 26px rgba(0,0,0,0.55);
      display: flex; align-items: center; justify-content: center;
      padding: clamp(32px, 5vh, 72px) clamp(16px, 1.8vw, 32px); position: relative; z-index: 12;
    }
    #modePanel .panel-ornaments { position: absolute; inset: 0; pointer-events: none; }
    #modePanel .panel-ornaments img { position: absolute; width: clamp(110px, 14vw, 160px); opacity: 0.18; filter: blur(0.2px) drop-shadow(0 6px 10px rgba(0,0,0,0.55)); }
    #modePanel .panel-ornaments .branch-corner { bottom: clamp(18px, 6vh, 32px); left: clamp(12px, 2vw, 28px); transform: rotate(-12deg); }

    #playArea { flex: 1; position: relative; height: 100vh; background: #000; overflow: hidden; z-index: 20; }
    #game { display: block; width: 100%; height: 100%; background: #000; position: relative; }

    #startOverlay { position: absolute; inset: 0; background: #000; z-index: 30; pointer-events: none; }

    #modeSelector {
      display: flex; flex-direction: column; gap: clamp(24px, 5vh, 48px); width: 100%; align-items: center;
      pointer-events: none; color: #f8eacb; font-size: 16px; text-transform: uppercase; letter-spacing: 0.08em;
    }
    .mode-tile {
      position: relative; width: clamp(120px, 16vw, 220px); aspect-ratio: 1; border-radius: 24px;
      background: rgba(18,18,22,0.92); border: 1px solid rgba(255,255,255,0.08);
      display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto;
      transition: transform 0.22s ease, border-color 0.22s ease, box-shadow 0.22s ease; box-shadow: 0 12px 26px rgba(0,0,0,0.5);
    }
    .mode-tile img { width: 68%; height: 68%; object-fit: contain; filter: drop-shadow(0 6px 10px rgba(0,0,0,0.55)); pointer-events: none; user-select: none; }
    .mode-tile .label {
      position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%);
      font-size: 13px; letter-spacing: 0.12em; color: rgba(255,240,200,0.75); text-shadow: 0 2px 6px rgba(0,0,0,0.6); pointer-events: none;
    }
    .mode-tile.active { border-color: rgba(255,210,120,0.5); box-shadow: 0 16px 36px rgba(255,180,60,0.24); }
    .mode-tile.hovering { transform: translateY(-6px); border-color: rgba(255,120,120,0.65); }
    .mode-tile .progress {
      position: absolute; top: 50%; left: 50%; width: 0; height: 0; opacity: 0; transform: translate(-50%, -50%);
      border-radius: 20px; pointer-events: none; background: rgba(220,20,20,0.55);
      transition: width 0.08s linear, height 0.08s linear, opacity 0.12s ease;
    }
    .mode-tile.hovering .progress { opacity: 0.75; }
  </style>
</head>
<body>
  <div id="layout">
    <aside id="modePanel">
      <div class="panel-ornaments" aria-hidden="true">
        <img src="../../images/samurai/cherryblossom.png" alt="" class="branch-corner" />
      </div>
      <div id="modeSelector" role="group" aria-label="Interaction mode">
        <div class="mode-tile active" data-mode="chi" aria-pressed="true" role="button">
          <img src="../../images/samurai/transparentchi.png" alt="Chi mode" />
          <div class="progress"></div>
          <span class="label">Chi</span>
        </div>
        <div class="mode-tile" data-mode="katana" aria-pressed="false" role="button">
          <img src="../../images/samurai/katana.png" alt="Katana mode" />
          <div class="progress"></div>
          <span class="label">Katana</span>
        </div>
      </div>
    </aside>
    <div id="playArea">
      <div id="startOverlay" aria-hidden="true"></div>
      <canvas id="game"></canvas>
    </div>
  </div>

  <script>
  (() => {
    /* =======================
       TUNABLES
    ======================= */
    const BG_SRC      = "../../images/samurai/lampbg.png";

    // Two lamp variants
    const CLOSED1_SRC = "../../images/samurai/closedlamp1.png";
    const LIT1_SRC    = "../../images/samurai/litlamp1.png";
    const CLOSED2_SRC = "../../images/samurai/closedlamp2.png";
    const LIT2_SRC    = "../../images/samurai/litlamp2.png";

    const LANTERN_COUNT   = 5;
    const LAMP_H_MIN      = 180;
    const LAMP_H_MAX      = 300;
    const HOVER_RADIUS    = 60;

    const ASCEND_SPEED_MIN = 60;
    const ASCEND_SPEED_MAX = 100;
    const DRIFT_X_MIN      = 20;
    const DRIFT_X_MAX      = 30;
    const SWAY_FREQ_MIN    = 0.6;
    const SWAY_FREQ_MAX    = 1.2;
    const SWAY_AMP_MIN     = 12;
    const SWAY_AMP_MAX     = 28;

    // Scattering along bottom — raised baseline (rope stop)
    const SIDE_PAD_H   = 24;
    const BOTTOM_PAD_V = 140;  // rope-limited rest height
    const SEP_EXTRA    = 40;

    // Stars
    const STAR_DENSITY_PER_MPX = 55;
    const STAR_MIN_SIZE = 0.8, STAR_MAX_SIZE = 2.0;
    const STAR_MIN_AMP  = 0.25, STAR_MAX_AMP = 0.55;
    const STAR_MIN_FREQ = 0.30, STAR_MAX_FREQ = 0.95; // Hz
    const STAR_BASE_MIN = 0.06, STAR_BASE_MAX = 0.14;
    const STAR_HALO_CORE = 0.35;
    const STAR_HALO_RING = 0.10;

    // Fireflies (soft, colored)
    const FIREFLY_COUNT = 22;
    const FIREFLY_Y_MIN_FRAC = 0.68, FIREFLY_Y_MAX_FRAC = 0.92;
    const FIREFLY_SPEED = 12;
    const FIREFLY_PULSE_MIN = 0.6, FIREFLY_PULSE_MAX = 1.2;
    const FIREFLY_SIZE_MIN = 1.8, FIREFLY_SIZE_MAX = 3.2;
    const FIREFLY_COLORS = [
      { core: '255,230,140', halo: '255,230,140' },
      { core: '185,255,185', halo: '185,255,185' },
      { core: '255,185,185', halo: '255,185,185' },
      { core: '185,220,255', halo: '185,220,255' },
    ];

    // Idle motion
    const IDLE_BOB_AMP_CLOSED = 2.2;
    const IDLE_BOB_AMP_LIT    = 3.6;
    const IDLE_BOB_FREQ_MIN   = 0.2;
    const IDLE_BOB_FREQ_MAX   = 0.35;
    const IDLE_ROT_AMP        = 0.015;

    // Constant lamp glow
    const GLOW_BASE_ALPHA = 0.22;
    const GLOW_RADIUS_MULT = 1.25;

    const HOVER_COOLDOWN_MS = 250;

    // Distant background lanterns
    const BG_LANTERN_COUNT = 10;
    const BG_LANTERN_SIZE_MIN = 14, BG_LANTERN_SIZE_MAX = 26; // px
    const BG_LANTERN_SPEED_MIN = 10, BG_LANTERN_SPEED_MAX = 22; // px/s
    const BG_LANTERN_HALO_ALPHA = 0.10;
    const BG_LANTERN_CORE_ALPHA = 0.20;

    // Shooting star
    const SHOOTING_STAR_MIN_INTERVAL = 18; // seconds
    const SHOOTING_STAR_MAX_INTERVAL = 45;
    const SHOOTING_STAR_SPEED_MIN = 600, SHOOTING_STAR_SPEED_MAX = 900; // px/s
    const SHOOTING_STAR_LEN_MIN = 120, SHOOTING_STAR_LEN_MAX = 200; // px
    const SHOOTING_STAR_LIFE = 1.2; // seconds

    // === ROPE (tethers) ===
    const ROPE_COLOR_RGB = '210,180,140';
    const ROPE_ALPHA     = 0.85;
    const ROPE_WIDTH     = 4.0;    // thicker rope
    const ROPE_SAG_MAX   = 120;
    const ROPE_SAG_RATIO = 0.36;
    const ROPE_SNAP_LIFE = 0.6;
    const ROPE_ATTACH_FROM_BOTTOM_FRAC = 0.10;
    const ROPE_ANCHOR_BOTTOM_OFFSET    = 0;

    // Katana must hit rope
    const ROPE_HIT_RADIUS = 12; // px distance from rope to register a cut

    // Dwell + audio
    const LAMP_DWELL_MS = 1000;  // hover to light (Chi)
    const LIFT_DURATION = 2.0;   // seconds to rise to rope-limited position

    const MODE_DWELL_MS = 500;

    const KATANA_CURSOR_SRC = "../../images/samurai/katana.png";
    const KATANA_CURSOR_MAX_PX = 124;
    const KATANA_CURSOR_HOTSPOT = { x: 12, y: 28 };
    const KATANA_MOVE_THRESHOLD = 2;

    const POINTER_EDGE_GRACE = 22;

    // ▼ UPDATED: use the exact same Chi image as the tile
    const CHI_POINTER_SRC = "../../images/samurai/transparentchi.png";
    const CHI_POINTER_BASE = 96;
    const CHI_POINTER_MAX = 118;
    const CHI_POINTER_BREATH = 0.05;
    const CHI_POINTER_BREATH_FREQ = 0.8;

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const initialRect = canvas.getBoundingClientRect();
    let W = canvas.width  = initialRect.width  || window.innerWidth;
    let H = canvas.height = initialRect.height || window.innerHeight;

    function resize() {
      const rect = canvas.getBoundingClientRect();
      const displayW = rect.width  || W;
      const displayH = rect.height || H;
      W = canvas.width  = displayW;
      H = canvas.height = displayH;
      rebuildStars();
      rebuildFireflies();
      rebuildBgLanterns();
      // keep rope anchors at bottom & inside margins and recompute rest/ground positions
      for (const l of lanterns) {
        if (!l.anchor) continue;
        l.anchor.y = H - ROPE_ANCHOR_BOTTOM_OFFSET;
        l.anchor.x = Math.max(SIDE_PAD_H, Math.min(W - SIDE_PAD_H, l.anchor.x));
        l.restY  = H - BOTTOM_PAD_V - l.h * 0.5;
        l.groundY = H - l.h * 0.5 + 2;
        if (l.state === 'closed') l.y = l.groundY; // keep closed lamps at ground after resize
      }
    }
    window.addEventListener('resize', resize);

    const bgImg  = new Image(); bgImg.src  = BG_SRC;

    const imgClosed1 = new Image(); imgClosed1.src = CLOSED1_SRC;
    const imgLit1    = new Image(); imgLit1.src    = LIT1_SRC;
    const imgClosed2 = new Image(); imgClosed2.src = CLOSED2_SRC;
    const imgLit2    = new Image(); imgLit2.src    = LIT2_SRC;

    function getClosedImg(type){ return type===1 ? imgClosed1 : imgClosed2; }
    function getLitImg(type){    return type===1 ? imgLit1    : imgLit2; }

    const modeSelector = document.getElementById('modeSelector');
    const modeTileNodes = Array.from(modeSelector.querySelectorAll('.mode-tile'));
    const modeTiles = modeTileNodes.map(el => ({
      el,
      mode: el.dataset.mode,
      progressEl: el.querySelector('.progress'),
      dwellStart: 0
    }));
    let hoveredTile = null;
    let currentMode = 'chi';

    function refreshModeTiles() {
      for (const tile of modeTiles) {
        const active = tile.mode === currentMode;
        tile.el.classList.toggle('active', active);
        tile.el.setAttribute('aria-pressed', active ? 'true' : 'false');
      }
    }

    const pointer = { x: -9999, y: -9999, inside: false, prevX: -9999 };
    let cursorOrient = 'left';

    function applyCurrentCursor() { canvas.style.cursor = 'none'; }

    function updatePointerFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const displayW = rect.width || 1;
      const displayH = rect.height || 1;
      const scaleX = displayW ? W / displayW : 1;
      const scaleY = displayH ? H / displayH : 1;
      const relX = e.clientX - rect.left;
      const relY = e.clientY - rect.top;

      const clampedX = Math.max(0, Math.min(displayW, relX));
      const clampedY = Math.max(0, Math.min(displayH, relY));
      pointer.x = clampedX * scaleX;
      pointer.y = clampedY * scaleY;

      const insideNow =
        relX >= -POINTER_EDGE_GRACE && relX <= displayW + POINTER_EDGE_GRACE &&
        relY >= -POINTER_EDGE_GRACE && relY <= displayH + POINTER_EDGE_GRACE;

      if (currentMode === 'katana' && pointer.prevX !== -9999 && insideNow) {
        const dx = pointer.x - pointer.prevX;
        if (Math.abs(dx) > KATANA_MOVE_THRESHOLD) {
          const wantOrient = dx > 0 ? 'right' : 'left';
          if (wantOrient !== cursorOrient) {
            cursorOrient = wantOrient;
            applyCurrentCursor();
          }
        }
      }

      pointer.prevX = insideNow ? pointer.x : -9999;
      pointer.inside = insideNow;
    }
    window.addEventListener('pointermove', updatePointerFromEvent, { passive: true });

    function setTileProgress(tile, progress) {
      if (!tile.progressEl) return;
      const clamped = Math.max(0, Math.min(1, progress));
      const pct = (clamped * 100).toFixed(1) + '%';
      if (clamped <= 0) {
        tile.progressEl.style.width = '0%';
        tile.progressEl.style.height = '0%';
        tile.progressEl.style.opacity = '';
        return;
      }
      tile.progressEl.style.width = pct;
      tile.progressEl.style.height = pct;
    }

    function clearTileProgress(tile) {
      tile.dwellStart = 0;
      tile.el.classList.remove('hovering');
      if (tile.progressEl) {
        tile.progressEl.style.width = '0%';
        tile.progressEl.style.height = '0%';
        tile.progressEl.style.opacity = '';
      }
    }

    /* ========= Mode switch + slice SFX ========= */
    const KATANA_DRAW_SRC  = "../../sounds/katana.mp3";
    const CHI_SELECT_SRC   = "../../sounds/samurai/energyball.mp3";
    const KATANA_SLICE_SRC = "../../sounds/blade.mp3"; // <-- NEW: rope cut slice

    const sfxKatanaDraw  = new Audio(KATANA_DRAW_SRC);  sfxKatanaDraw.volume  = 0.9; sfxKatanaDraw.preload  = "auto";
    const sfxChiSelect   = new Audio(CHI_SELECT_SRC);   sfxChiSelect.volume   = 0.7; sfxChiSelect.preload   = "auto";
    const sfxKatanaSlice = new Audio(KATANA_SLICE_SRC); sfxKatanaSlice.volume = 0.9; sfxKatanaSlice.preload = "auto";

    function playSfx(a){ try{ const n=a.cloneNode(true); n.volume=a.volume; n.play().catch(()=>{});}catch(_){} }
    /* ========================================== */

    function setMode(mode) {
      if (mode === currentMode) { applyCurrentCursor(); return; }
      currentMode = mode;

      // Play the requested sounds on mode change
      if (mode === 'katana') playSfx(sfxKatanaDraw);
      else if (mode === 'chi') playSfx(sfxChiSelect);

      refreshModeTiles();
      applyCurrentCursor();
    }

    function updateModeHover() {
      if (!hoveredTile) return;
      const tile = hoveredTile;
      if (!tile.dwellStart) tile.dwellStart = performance.now();
      const elapsed = performance.now() - tile.dwellStart;
      const progress = Math.min(1, elapsed / MODE_DWELL_MS);
      setTileProgress(tile, progress);
      if (progress >= 1) {
        clearTileProgress(tile);
        hoveredTile = null;
        setMode(tile.mode);
      }
    }

    for (const tile of modeTiles) {
      tile.el.addEventListener('pointerenter', () => {
        if (hoveredTile && hoveredTile !== tile) clearTileProgress(hoveredTile);
        hoveredTile = tile;
        tile.dwellStart = performance.now();
        tile.el.classList.add('hovering');
        setTileProgress(tile, 0.02);
      });
      tile.el.addEventListener('pointerleave', () => {
        if (hoveredTile === tile) hoveredTile = null;
        clearTileProgress(tile);
      });
    }

    const katanaCursor = { left: null, right: null };
    let katanaCursorReady = false;
    const katanaCursorImg = new Image();
    katanaCursorImg.src = KATANA_CURSOR_SRC;
    katanaCursorImg.onload = () => {
      const iw = katanaCursorImg.width;
      const ih = katanaCursorImg.height;
      if (!iw || !ih) return;
      const scale = Math.min(1, KATANA_CURSOR_MAX_PX / Math.max(iw, ih));
      const dw = Math.round(iw * scale);
      const dh = Math.round(ih * scale);

      const makeCanvas = flipX => {
        const c = document.createElement('canvas');
        c.width = dw; c.height = dh;
        const cctx = c.getContext('2d');
        cctx.imageSmoothingEnabled = true;
        if (flipX) { cctx.translate(dw, 0); cctx.scale(-1, 1); }
        cctx.drawImage(katanaCursorImg, 0, 0, dw, dh);
        return c;
      };

      const hx = Math.max(0, Math.min(dw - 1, Math.round(KATANA_CURSOR_HOTSPOT.x * scale)));
      const hy = Math.max(0, Math.min(dh - 1, Math.round(KATANA_CURSOR_HOTSPOT.y * scale)));

      katanaCursor.left = { canvas: makeCanvas(false), hx, hy };
      katanaCursor.right = { canvas: makeCanvas(true), hx: (dw - 1) - hx, hy };
      katanaCursorReady = true;
      if (currentMode === 'katana') applyCurrentCursor();
    };

    const chiPointerImg = new Image();
    chiPointerImg.src = CHI_POINTER_SRC;

    refreshModeTiles();
    applyCurrentCursor();

    const rand = (a, b) => a + Math.random() * (b - a);
    const clamp01 = v => Math.max(0, Math.min(1, v));
    const nowMs = () => performance.now();
    const nowSec = () => performance.now()/1000;

    /* =======================
       AUDIO (lamp lit)
    ======================= */
    const lampLitSounds = [1,2,3].map(i => {
      const a = new Audio(`../../sounds/samurai/lamplit${i}.mp3`);
      a.preload = 'auto';
      a.volume = 0.8;
      return a;
    });
    function playRandomLampLit() {
      const base = lampLitSounds[Math.floor(Math.random() * lampLitSounds.length)];
      if (!base) return;
      const a = base.cloneNode(true);
      a.volume = base.volume;
      a.play().catch(() => {});
    }

    /* =======================
       LANTERNS (foreground)
    ======================= */
    const lanterns = [];

    function chooseScatteredX(w) {
      const minX = SIDE_PAD_H + w * 0.5;
      const maxX = W - SIDE_PAD_H - w * 0.5;
      const tries = 24;
      for (let t = 0; t < tries; t++) {
        const x = rand(minX, maxX);
        let ok = true;
        for (const l of lanterns) {
          const minSep = (w + l.w) * 0.5 + SEP_EXTRA;
          if (Math.abs(x - l.x) < minSep) { ok = false; break; }
        }
        if (ok) return x;
      }
      return rand(minX, maxX);
    }

    function spawnLanternBottom() {
      const type = Math.random() < 0.5 ? 1 : 2;
      const closedImg = getClosedImg(type);

      const dispH = rand(LAMP_H_MIN, LAMP_H_MAX);
      const iw = closedImg.naturalWidth  || 1;
      const ih = closedImg.naturalHeight || 1;
      const aspect = iw / ih;
      const dispW = dispH * aspect;

      const x = chooseScatteredX(dispW);

      // Rest (rope-limited) position and ground position
      const restY   = H - BOTTOM_PAD_V - dispH * 0.5; // where the rope stops it
      const groundY = H - dispH * 0.5 + 2;           // at the floor

      const born = nowMs();

      lanterns.push({
        type, x, y: groundY, w: dispW, h: dispH,
        state: "closed",
        lastHover: 0,
        ascendVy: rand(ASCEND_SPEED_MIN, ASCEND_SPEED_MAX),
        driftBase: Math.random() < 0.5 ? -1 : 1,
        driftSpeed: rand(DRIFT_X_MIN, DRIFT_X_MAX),
        swayFreq: rand(SWAY_FREQ_MIN, SWAY_FREQ_MAX),
        swayAmp: rand(SWAY_AMP_MIN, SWAY_AMP_MAX),
        bobFreq: rand(IDLE_BOB_FREQ_MIN, IDLE_BOB_FREQ_MAX),
        bobPhase: Math.random() * Math.PI * 2,
        born,
        dwellStartChi: 0,
        anchor: { x: x + rand(-30,30), y: H - ROPE_ANCHOR_BOTTOM_OFFSET },
        snap: null,
        _ropeHovered: false,

        // lift animation data
        restY, groundY, liftT0: 0, liftDur: LIFT_DURATION
      });
    }

    function ensureCount() { while (lanterns.length < LANTERN_COUNT) spawnLanternBottom(); }
    function resetOne(i) { lanterns.splice(i, 1); ensureCount(); }

    function isHovering(l) {
      const dx = pointer.x - l.x;
      const dy = pointer.y - l.y;
      return (dx*dx + dy*dy) <= (HOVER_RADIUS * HOVER_RADIUS);
    }

    /* ---------- Rope math helpers ---------- */
    function quadBezierPoint(p0, p1, p2, t) {
      const it = 1 - t;
      return { x: it*it*p0.x + 2*it*t*p1.x + t*t*p2.x, y: it*it*p0.y + 2*it*t*p1.y + t*t*p2.y };
    }
    function pointSegDist(px, py, ax, ay, bx, by) {
      const vx = bx - ax, vy = by - ay;
      const wx = px - ax, wy = py - ay;
      const c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.hypot(px - ax, py - ay);
      const c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.hypot(px - bx, py - by);
      const t = c1 / c2;
      const ix = ax + t*vx, iy = ay + t*vy;
      return Math.hypot(px - ix, py - iy);
    }
    function ropePoints(l, t) {
      const p0 = { x: l.anchor.x, y: l.anchor.y };
      const p2 = { x: l.x, y: l.y + l.h * (0.5 - ROPE_ATTACH_FROM_BOTTOM_FRAC) };
      const len = Math.hypot(p2.x - p0.x, p2.y - p0.y);
      const sag = Math.min(ROPE_SAG_MAX, len * ROPE_SAG_RATIO);
      const sway = Math.sin((t + l.bobPhase) * 2 * Math.PI * l.bobFreq) * 4;
      const p1 = { x: (p0.x + p2.x)/2 + sway * 0.6, y: (p0.y + p2.y)/2 + sag + sway * 0.2 };
      return { p0, p1, p2 };
    }
    function ropeHitTest(l, tSec) {
      const { p0, p1, p2 } = ropePoints(l, tSec);
      const minX = Math.min(p0.x, p1.x, p2.x) - ROPE_HIT_RADIUS;
      const maxX = Math.max(p0.x, p1.x, p2.x) + ROPE_HIT_RADIUS;
      const minY = Math.min(p0.y, p1.y, p2.y) - ROPE_HIT_RADIUS;
      const maxY = Math.max(p0.y, p1.y, p2.y) + ROPE_HIT_RADIUS;
      if (pointer.x < minX || pointer.x > maxX || pointer.y < minY || pointer.y > maxY) return false;
      const STEPS = 24;
      let prev = quadBezierPoint(p0, p1, p2, 0);
      for (let i = 1; i <= STEPS; i++) {
        const tt = i / STEPS;
        const cur = quadBezierPoint(p0, p1, p2, tt);
        const d = pointSegDist(pointer.x, pointer.y, prev.x, prev.y, cur.x, cur.y);
        if (d <= ROPE_HIT_RADIUS) return true;
        prev = cur;
      }
      return false;
    }
    // Closest point on rope to pointer (sampled)
    function ropeClosestPoint(l, tSec) {
      const { p0, p1, p2 } = ropePoints(l, tSec);
      const STEPS = 48;
      let best = { d: Infinity, pt: {x: p0.x, y: p0.y} };
      let prev = quadBezierPoint(p0, p1, p2, 0);
      for (let i = 1; i <= STEPS; i++) {
        const tt = i / STEPS;
        const cur = quadBezierPoint(p0, p1, p2, tt);
        const d = pointSegDist(pointer.x, pointer.y, prev.x, prev.y, cur.x, cur.y);
        if (d < best.d) {
          best = d < pointSegDist(pointer.x, pointer.y, cur.x, cur.y, prev.x, prev.y)
            ? { d, pt: prev } : { d, pt: cur };
        }
        prev = cur;
      }
      return best.pt;
    }

    function easeOutCubic(u) { const t = 1 - Math.max(0, Math.min(1, u)); return 1 - t*t*t; }

    function handleHoverActions(l) {
      const t = nowMs();
      if (currentMode === 'chi') {
        if (l.state !== 'closed' && l.state !== 'lifting') { l.dwellStartChi = 0; return; }
        if (!pointer.inside || !isHovering(l)) { l.dwellStartChi = 0; return; }

        if (!l.dwellStartChi) l.dwellStartChi = t;
        const elapsed = t - l.dwellStartChi;

        // When dwell completes: start lifting animation (if not already lifting)
        if (elapsed >= LAMP_DWELL_MS && (t - l.lastHover) >= HOVER_COOLDOWN_MS) {
          l.lastHover = t;
          l.dwellStartChi = 0;
          if (l.state !== 'lifting' && l.y > l.restY + 1) {
            l.state = 'lifting';
            l.liftT0 = nowSec();
            playRandomLampLit();
          }
        }
      } else if (currentMode === 'katana') {
        l.dwellStartChi = 0; // no dwell in katana; reset any progress fill
        if (l.state !== 'lit') return;                 // can cut only after it has finished lifting
        if (t - l.lastHover < HOVER_COOLDOWN_MS) return;

        const tSec = performance.now()/1000;
        const overRope = ropeHitTest(l, tSec);
        l._ropeHovered = !!overRope;
        if (!overRope) return;

        // === Freeze rope geometry at the cut moment ===
        const frozen = ropePoints(l, tSec);               // snapshot of curve
        const breakPt = ropeClosestPoint(l, tSec);        // point on snapshot nearest pointer

        l.lastHover = t;
        l.state = 'ascend';
        l.ascendVy = rand(ASCEND_SPEED_MIN, ASCEND_SPEED_MAX);
        l.snap = {
          t0: nowSec(),
          life: ROPE_SNAP_LIFE,
          breakPt,
          frozen   // {p0,p1,p2} frozen at cut time
        };

        // ▼ NEW: play slice SFX right when the rope is cut
        playSfx(sfxKatanaSlice);
      }
    }

    /* =======================
       AMBIENT: STARS & FIREFLIES
    ======================= */
    let stars = [];
    function rebuildStars() {
      const areaMPx = (W * H) / 1_000_000;
      const count = Math.max(40, Math.round(STAR_DENSITY_PER_MPX * areaMPx));
      stars = Array.from({length: count}, () => ({
        x: Math.random() * W,
        y: Math.random() * H * 0.9,
        r: rand(STAR_MIN_SIZE, STAR_MAX_SIZE),
        base: rand(STAR_BASE_MIN, STAR_BASE_MAX),
        amp:  rand(STAR_MIN_AMP, STAR_MAX_AMP),
        freq: rand(STAR_MIN_FREQ, STAR_MAX_FREQ),
        phase: Math.random() * Math.PI * 2
      }));
    }

    let fireflies = [];
    function rebuildFireflies() {
      fireflies = Array.from({length: FIREFLY_COUNT}, () => {
        const color = FIREFLY_COLORS[Math.floor(Math.random() * FIREFLY_COLORS.length)];
        return {
          x: Math.random() * W,
          y: rand(H * FIREFLY_Y_MIN_FRAC, H * FIREFLY_Y_MAX_FRAC),
          dir: Math.random() * Math.PI * 2,
          speed: FIREFLY_SPEED * rand(0.8, 1.25),
          pulseF: rand(FIREFLY_PULSE_MIN, FIREFLY_PULSE_MAX),
          phase: Math.random() * Math.PI * 2,
          size: rand(FIREFLY_SIZE_MIN, FIREFLY_SIZE_MAX),
          color
        };
      });
    }

    function updateAmbient(dt) {
      for (const f of fireflies) {
        f.dir += (Math.random() - 0.5) * 0.15 * dt;
        f.x += Math.cos(f.dir) * f.speed * dt;
        f.y += Math.sin(f.dir) * f.speed * dt * 0.5;

        if (f.x < -20) f.x = W + 20;
        if (f.x > W + 20) f.x = -20;
        if (f.y < H * FIREFLY_Y_MIN_FRAC) f.y = H * FIREFLY_Y_MIN_FRAC + 4;
        if (f.y > H * FIREFLY_Y_MAX_FRAC) f.y = H * FIREFLY_Y_MAX_FRAC - 4;
      }
    }

    function drawGlow(x, y, r, alpha, rgb="255,210,120") {
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0, `rgba(${rgb},${alpha})`);
      g.addColorStop(1, `rgba(${rgb},0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawChiPointer() {
      if (currentMode !== 'chi' || !pointer.inside) return;
      const ready = chiPointerImg && chiPointerImg.complete && chiPointerImg.naturalWidth > 0;
      const t = performance.now() / 1000;
      const breathe = 1 + CHI_POINTER_BREATH * Math.sin(t * 2 * Math.PI * CHI_POINTER_BREATH_FREQ);
      const size = Math.min(CHI_POINTER_MAX, CHI_POINTER_BASE * breathe);
      const x = pointer.x, y = pointer.y;

      const glowR = size * 0.75;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(x, y, 0, x, y, glowR);
      g.addColorStop(0, 'rgba(180,255,255,0.35)');
      g.addColorStop(1, 'rgba(140,200,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x, y, glowR, 0, Math.PI * 2); ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.imageSmoothingQuality = 'high';
      if (ready) ctx.drawImage(chiPointerImg, x - size/2, y - size/2, size, size);
      else { ctx.fillStyle = '#cfefff'; ctx.beginPath(); ctx.arc(x, y, Math.max(6, size * 0.12), 0, Math.PI * 2); ctx.fill(); }
      ctx.restore();
    }

    function drawKatanaPointer() {
      if (currentMode !== 'katana' || !pointer.inside) return;
      const data = cursorOrient === 'right' ? katanaCursor.right : katanaCursor.left;
      const ready = katanaCursorReady && data && data.canvas;
      const hx = data ? data.hx : 0, hy = data ? data.hy : 0;
      const drawX = pointer.x - hx, drawY = pointer.y - hy;

      ctx.save();
      ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
      if (ready) ctx.drawImage(data.canvas, drawX, drawY, data.canvas.width, data.canvas.height);
      else {
        ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pointer.x - 18, pointer.y - 18); ctx.lineTo(pointer.x + 22, pointer.y + 22);
        ctx.moveTo(pointer.x + 22, pointer.y - 18); ctx.lineTo(pointer.x - 18, pointer.y + 22);
        ctx.stroke();
      }
      ctx.restore();
    }

    function renderStars(t) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const s of stars) {
        const p = 0.5 + 0.5 * Math.sin(s.phase + t * 2 * Math.PI * s.freq);
        const a = Math.min(1, s.base + s.amp * p);
        const r = s.r * (0.8 + 0.6 * p);

        const R = r * 3.2;
        const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, R);
        g.addColorStop(0.0, `rgba(255,240,200,${a * STAR_HALO_CORE})`);
        g.addColorStop(1.0, `rgba(255,240,200,${a * STAR_HALO_RING})`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(s.x, s.y, R, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = Math.max(0.18, a);
        ctx.beginPath(); ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgb(255,240,210)'; ctx.fill();
      }
      ctx.restore();
    }

    /* =======================
       BACKGROUND LANTERNS
    ======================= */
    let bgLanterns = [];
    function rebuildBgLanterns() { bgLanterns = []; for (let i = 0; i < BG_LANTERN_COUNT; i++) spawnBgLantern(true); }
    function spawnBgLantern(initial=false) {
      const type = Math.random() < 0.5 ? 1 : 2;
      const size = rand(BG_LANTERN_SIZE_MIN, BG_LANTERN_SIZE_MAX);
      const x = Math.random() * W;
      const y = initial ? rand(H * 0.15, H - 60) : H - 40 - size;
      const vy = rand(BG_LANTERN_SPEED_MIN, BG_LANTERN_SPEED_MAX);
      const swayFreq = rand(0.1, 0.25);
      const swayAmp = rand(4, 9);
      const phase = Math.random() * Math.PI * 2;
      bgLanterns.push({ type, x, y, size, vy, swayFreq, swayAmp, phase });
    }
    function updateBgLanterns(dt) {
      const t = performance.now() / 1000;
      for (let i = bgLanterns.length - 1; i >= 0; i--) {
        const b = bgLanterns[i];
        b.y -= b.vy * dt;
        b.x += Math.sin(t * 2 * Math.PI * b.swayFreq + b.phase) * b.swayAmp * dt;
        if (b.y + b.size < -20) { bgLanterns.splice(i, 1); spawnBgLantern(false); }
      }
    }
    function renderBgLanterns() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const b of bgLanterns) {
        drawGlow(b.x, b.y, b.size * 2.6, BG_LANTERN_HALO_ALPHA);
        ctx.globalAlpha = BG_LANTERN_CORE_ALPHA;
        const img = getLitImg(b.type);
        ctx.drawImage(img, b.x - b.size/2, b.y - b.size/2, b.size, b.size);
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }

    /* =======================
       SHOOTING STAR
    ======================= */
    let activeShootingStar = null;
    let nextStarTime = 0;
    function scheduleShootingStar() {
      nextStarTime = performance.now() / 1000 + rand(SHOOTING_STAR_MIN_INTERVAL, SHOOTING_STAR_MAX_INTERVAL);
    }
    function maybeSpawnShootingStar() {
      const t = performance.now() / 1000;
      if (activeShootingStar || t < nextStarTime) return;
      const y = rand(H * 0.05, H * 0.35);
      const dir = Math.random() < 0.5 ? 1 : -1;
      const x = dir > 0 ? -60 : W + 60;
      activeShootingStar = {
        x, y,
        vx: dir * rand(SHOOTING_STAR_SPEED_MIN, SHOOTING_STAR_SPEED_MAX),
        len: rand(SHOOTING_STAR_LEN_MIN, SHOOTING_STAR_LEN_MAX),
        age: 0, life: SHOOTING_STAR_LIFE, dir
      };
    }
    function updateShootingStar(dt) {
      if (!activeShootingStar) return;
      const s = activeShootingStar;
      s.x += s.vx * dt;
      s.age += dt;
      if (s.age > s.life || s.x < -200 || s.x > W + 200) {
        activeShootingStar = null;
        scheduleShootingStar();
      }
    }
    function renderShootingStar() {
      if (!activeShootingStar) return;
      const s = activeShootingStar;
      const a = Math.max(0, 1 - s.age / s.life);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.65 * a;
      ctx.beginPath(); ctx.arc(s.x, s.y, 1.8, 0, Math.PI * 2); ctx.fillStyle = 'rgb(255,240,210)'; ctx.fill();
      const x2 = s.x - s.dir * s.len;
      const y2 = s.y + 0.25 * s.len;
      const grad = ctx.createLinearGradient(x2, y2, s.x, s.y);
      grad.addColorStop(0, 'rgba(255,240,210,0)');
      grad.addColorStop(1, 'rgba(255,240,210,0.6)');
      ctx.strokeStyle = grad; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x2, y2); ctx.lineTo(s.x, s.y); ctx.stroke();
      ctx.restore();
    }

    /* =======================
       ROPES
    ======================= */
    function drawIntactRope(l, t) {
      const { p0, p1, p2 } = ropePoints(l, t);
      ctx.save();
      ctx.lineWidth = ROPE_WIDTH; ctx.lineCap = 'round';
      ctx.strokeStyle = `rgba(${ROPE_COLOR_RGB},${ROPE_ALPHA})`;
      ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y); ctx.stroke();

      if (l._ropeHovered && currentMode === 'katana') {
        ctx.strokeStyle = 'rgba(255,230,160,0.9)';
        ctx.lineWidth = ROPE_WIDTH + 1.5;
        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawSnappingRope(l, t) {
      if (!l.snap) return;
      const age = t - l.snap.t0;
      const p = Math.min(1, age / l.snap.life); // 0→1
      const frozen = l.snap.frozen || ropePoints(l, t); // fallback, but frozen is expected
      const { p0, p1, p2 } = frozen;
      const B = l.snap.breakPt || { x: (p0.x + p2.x)/2, y: (p0.y + p2.y)/2 };

      // endpoints retreat towards their anchors along the FROZEN curve direction
      const topEnd = { x: p2.x + (B.x - p2.x) * (1 - p), y: p2.y + (B.y - p2.y) * (1 - p) };
      const botEnd = { x: p0.x + (B.x - p0.x) * (1 - p), y: p0.y + (B.y - p0.y) * (1 - p) };

      // slight recoil offsets
      const recoil = (1 - p) * 6;
      const topOff = { x: 0, y: -recoil };
      const botOff = { x: 0, y: recoil * 0.6 };

      ctx.save();
      ctx.lineWidth = ROPE_WIDTH; ctx.lineCap = 'round';
      ctx.strokeStyle = `rgba(${ROPE_COLOR_RGB},${ROPE_ALPHA * (1 - p)})`;

      // top piece (near lantern)
      ctx.beginPath();
      ctx.moveTo(p2.x, p2.y);
      ctx.lineTo(topEnd.x + topOff.x, topEnd.y + topOff.y);
      ctx.stroke();

      // bottom piece (near anchor)
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(botEnd.x + botOff.x, botEnd.y + botOff.y);
      ctx.stroke();
      ctx.restore();

      if (p >= 1) l.snap = null; // done
    }

function drawRopes(t) {
  for (const l of lanterns) {
    // Lantern is flying away. Show snap animation while it lives; otherwise, no rope.
    if (l.state === 'ascend') {
      if (l.snap) drawSnappingRope(l, t);
      continue; // <-- prevent drawing an intact rope after snap ends
    }

    // Rope should be visible only while the lantern is still tethered
    // (closed at ground, lifting to rest, or sitting lit at rest).
    if (l.state === 'closed' || l.state === 'lifting' || l.state === 'lit') {
      drawIntactRope(l, t);
    }
  }
}

    /* =======================
       INTERNAL FILL (progress inside lantern)
    ======================= */
    function renderLampFillInside(l) {
      if (l.state !== 'closed' || !l.dwellStartChi) return;
      const elapsed = performance.now() - l.dwellStartChi;
      const p = clamp01(elapsed / LAMP_DWELL_MS);

      if (!l._fillC) l._fillC = document.createElement('canvas');
      const oc = l._fillC;
      const w = Math.max(2, Math.round(l.w));
      const h = Math.max(2, Math.round(l.h));
      if (oc.width !== w || oc.height !== h) { oc.width = w; oc.height = h; }
      const octx = oc.getContext('2d');
      octx.clearRect(0, 0, w, h);

      const fillH = Math.max(1, Math.floor(h * p));
      const y0 = h - fillH;
      const grad = octx.createLinearGradient(0, h, 0, y0);
      grad.addColorStop(0.00, 'rgba(255,220,140,0.95)');
      grad.addColorStop(0.60, 'rgba(255,205,120,0.65)');
      grad.addColorStop(1.00, 'rgba(255,180,100,0.35)');

      octx.globalCompositeOperation = 'source-over';
      octx.fillStyle = grad;
      octx.fillRect(0, y0, w, fillH);

      octx.globalCompositeOperation = 'destination-in';
      const closedImg = getClosedImg(l.type);
      octx.drawImage(closedImg, 0, 0, w, h);

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.drawImage(oc, -l.w/2, -l.h/2, l.w, l.h);
      ctx.restore();
    }

    /* =======================
       LOOP
    ======================= */
    let lastT = performance.now();
    let started = false;

    function drawBackgroundImage() {
      if (bgImg.complete && bgImg.naturalWidth > 0) {
        const iw = bgImg.width, ih = bgImg.height;
        const scale = Math.max(W / iw, H / ih); // cover
        const dw = iw * scale, dh = ih * scale;
        const dx = (W - dw) * 0.5;
        const dy = (H - dh) * 0.5;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(bgImg, dx, dy, dw, dh);
      } else {
        ctx.fillStyle = "#001028";
        ctx.fillRect(0, 0, W, H);
      }
    }

    function update(dt) {
      updateModeHover();

      // ambient
      updateAmbient(dt);
      updateBgLanterns(dt);
      maybeSpawnShootingStar();
      updateShootingStar(dt);

      const tSec = performance.now()/1000;

      // foreground lanterns
      for (let i = lanterns.length - 1; i >= 0; i--) {
        const l = lanterns[i];

        // Track rope hover for visual feedback in katana mode (only when lit)
        l._ropeHovered = (currentMode === 'katana' && l.state === 'lit' && pointer.inside) ? ropeHitTest(l, tSec) : false;

        if (pointer.inside && (isHovering(l) || l._ropeHovered)) {
          handleHoverActions(l);
        } else {
          if (l.state === 'closed') l.dwellStartChi = 0;
        }

        // Clamp X inside play area at all times
        const minX = SIDE_PAD_H + l.w * 0.5;
        const maxX = W - SIDE_PAD_H - l.w * 0.5;

        if (l.state === "ascend") {
          // free-ascend into the sky after the cut
          const t = (performance.now() - l.born) / 1000;
          const sway = Math.sin(2 * Math.PI * l.swayFreq * t) * l.swayAmp;
          l.y -= l.ascendVy * dt;
          l.x += l.driftBase * l.driftSpeed * dt + sway * dt * 0.6;
          l.x = Math.max(minX, Math.min(maxX, l.x));
          if (l.y + l.h * 0.5 < -30) { resetOne(i); continue; }
        } else if (l.state === 'lifting') {
          // animate from groundY -> restY over LIFT_DURATION
          const p = easeOutCubic((nowSec() - l.liftT0) / l.liftDur);
          const prevY = l.y;
          l.y = l.groundY + (l.restY - l.groundY) * Math.min(1, p);
          const sway = Math.sin((nowSec() - l.liftT0) * 2 * Math.PI * l.swayFreq) * 0.25;
          l.x += sway;
          l.x = Math.max(minX, Math.min(maxX, l.x));
          if (l.y <= l.restY + 0.5 || (l.y === prevY && p >= 1)) {
            l.y = l.restY;
            l.state = 'lit';
          }
        } else if (l.state === 'lit') {
          const dy = l.restY - l.y;
          if (Math.abs(dy) > 0.5) l.y += Math.sign(dy) * Math.min(120 * dt, Math.abs(dy));
          l.x = Math.max(minX, Math.min(maxX, l.x));
        } else { // 'closed' at ground
          l.y = l.groundY;
          l.x = Math.max(minX, Math.min(maxX, l.x));
        }
      }
    }

    function render() {
      const t = performance.now() / 1000;

      drawBackgroundImage();
      renderStars(t);
      renderShootingStar();
      renderBgLanterns();

      // Ropes behind lamps
      drawRopes(t);

      // Constant glow for lit/ascending lamps
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const l of lanterns) {
        if (l.state === "lit" || l.state === "ascend" || l.state === "lifting") {
          drawGlow(l.x, l.y, l.h * GLOW_RADIUS_MULT, GLOW_BASE_ALPHA);
        }
      }
      ctx.restore();

      // Foreground lamps
      for (const l of lanterns) {
        const bobAmp = (l.state === "lit" || l.state === "ascend" || l.state === "lifting")
          ? IDLE_BOB_AMP_LIT : IDLE_BOB_AMP_CLOSED;
        const yOff = Math.sin(l.bobPhase + t * 2 * Math.PI * l.bobFreq) * bobAmp;
        const rot  = Math.sin(l.bobPhase * 0.7 + t * 2 * Math.PI * l.bobFreq * 0.8) * IDLE_ROT_AMP;

        const img = (l.state === "closed") ? getClosedImg(l.type) : getLitImg(l.type);

        ctx.save();
        ctx.translate(l.x, l.y + yOff);
        ctx.rotate(rot);

        // draw lantern image first
        ctx.drawImage(img, -l.w/2, -l.h/2, l.w, l.h);

        // if closed and dwelling, overlay the internal fill
        if (l.state === 'closed' && l.dwellStartChi) {
          renderLampFillInside(l);
        }

        ctx.restore();
      }

      // Fireflies on top
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const f of fireflies) {
        const a = 0.12 + 0.18 * (0.5 + 0.5 * Math.sin(f.phase + t * 2 * Math.PI * f.pulseF));
        const haloR = f.size * 4.5;
        const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, haloR);
        g.addColorStop(0, `rgba(${f.color.halo},${a})`);
        g.addColorStop(1, `rgba(${f.color.halo},0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(f.x, f.y, haloR, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${f.color.core})`; ctx.fill();
      }
      ctx.restore();

      drawChiPointer();
      drawKatanaPointer();
    }

    function tick(tMs) {
      if (!started) {
        rafId = 0;
        return;
      }
      const dt = Math.min(0.033, (tMs - lastT) / 1000);
      lastT = tMs;

      ensureCount();
      update(dt);
      render();

      rafId = requestAnimationFrame(tick);
    }

    /* ===== FULLSCREEN START ===== */
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    async function enterFullscreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    }

    function scheduleTick() {
      if (!started || rafId) return;
      const begin = () => {
        if (!started) return;
        lastT = performance.now();
        rafId = requestAnimationFrame(tick);
      };

      const imgs = [bgImg, imgClosed1, imgLit1, imgClosed2, imgLit2, chiPointerImg, katanaCursorImg];
      if (imgs.every(im => im.complete)) {
        begin();
        return;
      }

      let pending = 0;
      const tryStart = () => {
        if (--pending <= 0) begin();
      };
      imgs.forEach(im => { if (!im.complete) { pending++; im.onload = tryStart; } });
      if (pending === 0) begin();
    }

    function resetGameState() {
      lanterns.length = 0;
      hoveredTile = null;
      modeTiles.forEach(clearTileProgress);
      currentMode = 'chi';
      refreshModeTiles();
      cursorOrient = 'left';
      applyCurrentCursor();
      pointer.x = pointer.y = -9999;
      pointer.prevX = -9999;
      pointer.inside = false;
      stars = [];
      fireflies = [];
      bgLanterns = [];
      activeShootingStar = null;
      nextStarTime = 0;
    }

    function rebuildWorld() {
      ensureCount();
      rebuildStars();
      rebuildFireflies();
      rebuildBgLanterns();
      scheduleShootingStar();
    }

    function quietAudio() {
      [sfxKatanaDraw, sfxChiSelect, sfxKatanaSlice, ...lampLitSounds].forEach(a => {
        try { a.pause(); a.currentTime = 0; } catch (e) {}
      });
    }

    async function startExperience(options = {}) {
      if (started) return;
      if (options.requestFullscreen) {
        try { await enterFullscreen(); } catch (e) {}
      }

      resetGameState();
      quietAudio();
      started = true;
      if (startOverlay) startOverlay.style.display = 'none';
      canvas.style.cursor = 'none';

      resize();
      rebuildWorld();
      scheduleTick();
    }

    function stopExperience() {
      if (!started) return;
      started = false;
      cancelAnimationFrame(rafId);
      rafId = 0;
      quietAudio();
      resetGameState();
      canvas.style.cursor = 'default';
    }

    if (startBtn) {
      startBtn.addEventListener('click', () => {
        startExperience({ requestFullscreen: true });
      });
    } else {
      window.requestAnimationFrame(() => startExperience());
    }

    window.startExperience = (options) => startExperience(options);
    window.stopExperience = stopExperience;
    window.storyGameApi = { start: startExperience, stop: stopExperience };
  })();
  </script>
</body>
</html>
  </template>
</body>
</html>
