<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Draw Within the Lines — Canvas Demo (Presets + User Image Mask + Compat + Tests)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111923; --ink:#f5f5f5; --accent:#4fd1c5; --edge:#e2e8f0; --ok:#22c55e; --bad:#ef4444;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{display:grid;grid-template-columns:380px 1fr;height:100%;}
    .panel{background:var(--panel);padding:16px 14px;box-shadow:inset 0 0 0 1px rgba(255,255,255,.05);overflow:auto}
    .panel h1{font-size:18px;margin:0 0 10px}
    .panel .row{display:flex;align-items:center;gap:10px;margin:10px 0}
    .panel label{font-size:13px;opacity:.9;min-width:110px}
    .panel input[type="color"], .panel input[type="range"], .panel button, select{width:100%}
    .panel .hint{font-size:12px;opacity:.7;margin-top:8px;line-height:1.35}

    .stage{position:relative;display:grid;place-items:center;background:radial-gradient(1200px 600px at 60% -10%, #1a2330 0%, #0b0f14 60%, #080c11 100%)}
    canvas{display:block;max-width:100%;height:auto}
    #ink{position:absolute;inset:0}
    #outline{position:absolute;inset:0;pointer-events:none}
    .badge{position:absolute;top:12px;right:12px;background:#0b1520;border:1px solid rgba(255,255,255,.1);padding:6px 10px;border-radius:999px;font-size:12px}
    .controls{display:grid;gap:10px}
    .buttons{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .buttons button{padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.1);background:#101722;color:#e6edf3;cursor:pointer}
    .buttons button:hover{border-color:rgba(255,255,255,.25)}
    .tip{font-size:12px;opacity:.75;margin-top:6px}

    details{border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px 10px}
    details summary{cursor:pointer;font-size:13px}
    #testResults{margin-top:8px;font-size:12px;line-height:1.5}
    .ok{color:var(--ok)} .bad{color:var(--bad)}
    .preview{display:grid;grid-template-columns:64px 1fr;gap:10px;align-items:center}
    .preview img{width:64px;height:64px;object-fit:contain;background:#0b1520;border:1px solid rgba(255,255,255,.06);border-radius:8px}
    .muted{opacity:.6}
  </style>
  <!-- Optional presets file; if present, provides window.PNG_ARRAY -->
  <script src="../../js/cvipngarray.js" defer></script>
</head>
<body>
  <div class="wrap">
    <aside class="panel">
      <h1>Draw within the outline</h1>
      <div class="controls">
        <div class="row">
          <label>Brush size <span id="brushV">18</span>px</label>
          <input id="brush" type="range" min="3" max="64" value="18" />
        </div>
        <div class="row">
          <label>Brush color</label>
          <input id="color" type="color" value="#ff7a59" />
        </div>
        <div class="row">
          <label>Mode</label>
          <select id="mode">
            <option value="draw" selected>Draw</option>
            <option value="erase">Erase</option>
          </select>
        </div>
        <div class="buttons">
          <button id="clear">Clear</button>
          <button id="download">Save PNG</button>
        </div>

        <!-- Built-in vector shapes -->
        <div class="row">
          <label>Built‑in outline</label>
          <select id="shape">
            <option value="blob">Blob</option>
            <option value="star">Star</option>
            <option value="heart">Heart</option>
            <option value="rect">Rounded rectangle</option>
          </select>
        </div>

        <!-- Presets from PNG_ARRAY -->
        <div class="row">
          <label>Preset category</label>
          <select id="presetCategory" disabled>
            <option>Loading…</option>
          </select>
        </div>
        <div class="row">
          <label>Preset item</label>
          <select id="presetItem" disabled>
            <option>Select a category</option>
          </select>
        </div>
        <div class="row preview">
          <img id="presetThumb" alt="preview"/>
          <button id="loadPreset" disabled>Use preset as mask</button>
        </div>
        <p id="presetStatus" class="hint muted">Presets will activate if <code>../../js/cvipngarray.js</code> is found.</p>

        <!-- Upload -->
        <div class="row">
          <label>Upload outline</label>
          <input id="outlineFile" type="file" accept="image/png, image/svg+xml" />
        </div>
        <div class="row">
          <label>Fit uploaded</label>
          <select id="fitMode">
            <option value="contain" selected>Contain (keep aspect)</option>
            <option value="cover">Cover</option>
            <option value="stretch">Stretch</option>
          </select>
        </div>
        <div class="row">
          <label>Mask source</label>
          <select id="maskSource">
            <option value="alpha" selected>Alpha (opaque = inside)</option>
            <option value="luma">Luminance (white = inside)</option>
            <option value="alpha-invert">Alpha inverted</option>
          </select>
        </div>

        <p class="hint">Use a <strong>built‑in shape</strong>, pick a <strong>preset</strong> from your PNG list, or <strong>upload PNG/SVG</strong>. The opaque region becomes the drawable area. A faint guide is shown on the canvas.</p>

        <details>
          <summary>Diagnostics & self‑tests</summary>
          <div class="row">
            <button id="runTests">Run tests</button>
          </div>
          <div id="testResults">No tests run yet.</div>
        </details>
      </div>
    </aside>

    <main class="stage">
      <div class="badge">Canvas demo</div>
      <canvas id="ink" width="1400" height="900" aria-label="Ink layer"></canvas>
      <canvas id="outline" width="1400" height="900" aria-label="Outline layer"></canvas>
    </main>
  </div>

  <script>
    // --- Setup canvases ---
    const ink = document.getElementById('ink');
    const out = document.getElementById('outline');
    const ic = ink.getContext('2d');
    const oc = out.getContext('2d');

    // Avoid ResizeObserver loops by batching in rAF and resizing only on change
    let resizePending = false;
    function fitCanvas(cnv){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = cnv.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width * dpr));
      const h = Math.max(1, Math.round(rect.height * dpr));
      if (cnv.width !== w || cnv.height !== h){
        cnv.width = w; cnv.height = h;
        const ctx = cnv.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
    }
    function resizeAllImmediate(){
      fitCanvas(ink); fitCanvas(out); drawOutline(); syncScratch(); rebuildMaskCache();
    }
    function requestResize(){ if(resizePending) return; resizePending = true; requestAnimationFrame(()=>{ resizePending=false; resizeAllImmediate(); }); }
    const ro = new ResizeObserver(()=>{ requestResize(); });
    ro.observe(out);

    // --- UI ---
    const brushEl = document.getElementById('brush');
    const brushV = document.getElementById('brushV');
    const colorEl = document.getElementById('color');
    const modeEl = document.getElementById('mode');
    const clearEl = document.getElementById('clear');
    const dlEl = document.getElementById('download');
    const shapeEl = document.getElementById('shape');

    const outlineFileEl = document.getElementById('outlineFile');
    const fitModeEl = document.getElementById('fitMode');
    const maskSourceEl = document.getElementById('maskSource');

    const catEl = document.getElementById('presetCategory');
    const itemEl = document.getElementById('presetItem');
    const loadPresetBtn = document.getElementById('loadPreset');
    const presetThumb = document.getElementById('presetThumb');
    const presetStatus = document.getElementById('presetStatus');

    const runTestsBtn = document.getElementById('runTests');
    const testResults = document.getElementById('testResults');

    brushEl.addEventListener('input', ()=> brushV.textContent = brushEl.value);
    clearEl.addEventListener('click', ()=>{ ic.clearRect(0,0,ink.width,ink.height); });
    dlEl.addEventListener('click', ()=>{
      const url = mergeForExport();
      const a = document.createElement('a'); a.href=url; a.download='drawing.png'; a.click();
    });
    shapeEl.addEventListener('change', ()=>{ userMask = null; drawOutline(); });
    fitModeEl.addEventListener('change', ()=>{ rebuildMaskCache(); redrawMaskGuide(); });
    maskSourceEl.addEventListener('change', ()=>{ rebuildMaskCache(); redrawMaskGuide(); });

    outlineFileEl.addEventListener('change', async (e)=>{
      const file = e.target.files?.[0]; if(!file) return; await loadUserMaskFromFile(file); redrawMaskGuide();
    });

    // --- Presets (PNG_ARRAY) ---
    function enablePresets(){
      if(!window.PNG_ARRAY || !Array.isArray(window.PNG_ARRAY) || window.PNG_ARRAY.length===0){
        catEl.disabled = true; itemEl.disabled = true; loadPresetBtn.disabled = true;
        presetStatus.textContent = 'Preset list not found. Ensure ../../js/cvipngarray.js is loaded.';
        return;
      }
      const cats = [...new Set(window.PNG_ARRAY.map(x=>x.category))].sort((a,b)=>a.localeCompare(b));
      catEl.innerHTML = cats.map(c=>`<option value="${c}">${c}</option>`).join('');
      catEl.disabled = false; itemEl.disabled = false; loadPresetBtn.disabled = false;
      presetStatus.textContent = `Loaded ${window.PNG_ARRAY.length} preset PNGs across ${cats.length} categories.`;
      updateItems();
    }

    function updateItems(){
      const cat = catEl.value;
      const items = window.PNG_ARRAY.filter(x=>x.category===cat).sort((a,b)=>a.name.localeCompare(b.name));
      itemEl.innerHTML = items.map(i=>`<option value="${i.file}" data-name="${i.name}">${i.name}</option>`).join('');
      if(items[0]){ presetThumb.src = items[0].file; presetThumb.alt = items[0].name; }
    }

    catEl.addEventListener('change', updateItems);
    itemEl.addEventListener('change', ()=>{ const opt=itemEl.selectedOptions[0]; if(opt){ presetThumb.src=opt.value; presetThumb.alt=opt.dataset.name; }});

    loadPresetBtn.addEventListener('click', ()=>{
      const src = itemEl.value; if(!src) return;
      loadUserMaskFromURL(src);
    });

    // wait for defered presets script to load
    window.addEventListener('DOMContentLoaded', ()=>{ setTimeout(enablePresets, 0); });

    // --- Outline as vector path (Path2D) ---
    let shapePath = null; // Path2D in canvas units

    function makePath(kind, w, h){
      const p = new Path2D();
      const pad = Math.min(w,h)*0.12;
      const cx=w/2, cy=h/2;
      if(kind==='rect'){
        const r = Math.min(w,h)*0.18; // radius
        const x=pad, y=pad, rw=w-2*pad, rh=h-2*pad;
        roundRectPath(p,x,y,rw,rh,r);
      } else if(kind==='blob'){
        const rx=w*0.32, ry=h*0.28;
        blobPath(p, cx, cy, rx, ry);
      } else if(kind==='star'){
        starPath(p, cx, cy, Math.min(w,h)*0.36, 5);
      } else if(kind==='heart'){
        heartPath(p, cx, cy, Math.min(w,h)*0.36);
      }
      return p;
    }

    function roundRectPath(p,x,y,w,h,r){
      p.moveTo(x+r,y);
      p.arcTo(x+w,y,x+w,y+h,r);
      p.arcTo(x+w,y+h,x,y+h,r);
      p.arcTo(x,y+h,x,y,r);
      p.arcTo(x,y,x+w,y,r);
      p.closePath();
    }

    function blobPath(p, cx, cy, rx, ry){
      p.moveTo(cx, cy-ry);
      p.bezierCurveTo(cx+rx*0.6, cy-ry, cx+rx, cy-ry*0.2, cx+rx, cy);
      p.bezierCurveTo(cx+rx, cy+ry*0.6, cx+rx*0.4, cy+ry, cx, cy+ry);
      p.bezierCurveTo(cx-rx*0.6, cy+ry, cx-rx, cy+ry*0.2, cx-rx, cy);
      p.bezierCurveTo(cx-rx, cy-ry*0.6, cx-rx*0.4, cy-ry, cx, cy-ry);
      p.closePath();
    }

    function starPath(p, cx, cy, r, spikes){
      const step=Math.PI/spikes; let rot=Math.PI/2*3; let x=cx; let y=cy - r;
      p.moveTo(cx, cy - r);
      for(let i=0;i<spikes;i++){
        x = cx + Math.cos(rot)*r; y = cy + Math.sin(rot)*r; p.lineTo(x,y); rot += step;
        x = cx + Math.cos(rot)*r*0.5; y = cy + Math.sin(rot)*r*0.5; p.lineTo(x,y); rot += step;
      }
      p.closePath();
    }

    function heartPath(p, cx, cy, s){
      const top = cy - s*0.25;
      p.moveTo(cx, top);
      p.bezierCurveTo(cx + s*0.5, top - s*0.6, cx + s, cy - s*0.05, cx, cy + s*0.75);
      p.bezierCurveTo(cx - s, cy - s*0.05, cx - s*0.5, top - s*0.6, cx, top);
      p.closePath();
    }

    function drawOutline(){
      const rect = out.getBoundingClientRect();
      shapePath = makePath(shapeEl.value, rect.width, rect.height);
      oc.clearRect(0,0,out.width,out.height);
      if(userMask){ redrawMaskGuide(); }
      else {
        oc.save(); oc.fillStyle='white'; oc.globalAlpha=0.06; oc.fill(shapePath); oc.globalAlpha=1; oc.lineWidth=6; oc.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge')||'#e2e8f0'; oc.stroke(shapePath); oc.restore();
      }
    }

    // --- User mask (PNG/SVG) pipeline ---
    let userMask = null;           // HTMLImageElement
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    let maskImageData = null;      // Uint8ClampedArray of RGBA (cached)

    async function loadUserMaskFromFile(file){
      const url = URL.createObjectURL(file);
      await loadUserMaskFromURL(url, true);
    }
    function loadUserMaskFromURL(url, revoke=false){
      const img = new Image();
      img.onload = ()=>{ if(revoke) URL.revokeObjectURL(url); userMask = img; rebuildMaskCache(); drawOutline(); };
      img.onerror = ()=>{ if(revoke) URL.revokeObjectURL(url); alert('Could not load image. Try a PNG or SVG.'); };
      img.src = url;
    }

    function computeFit(destW,destH, imgW,imgH, mode){
      if(mode==='stretch') return { x:0, y:0, w:destW, h:destH };
      const r = imgW/imgH, R = destW/destH;
      if(mode==='cover'){
        const w = R>r ? destW : destH*r;
        const h = R>r ? destW/r : destH;
        const x = (destW - w)/2; const y = (destH - h)/2;
        return {x,y,w,h};
      } else { // contain
        const w = R>r ? destH*r : destW;
        const h = R>r ? destH : destW/r;
        const x = (destW - w)/2; const y = (destH - h)/2;
        return {x,y,w,h};
      }
    }

    function rebuildMaskCache(){
      if(!userMask){ maskImageData=null; return; }
      maskCanvas.width = out.width; maskCanvas.height = out.height;
      maskCtx.setTransform(oc.getTransform());
      maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      maskCtx.drawImage(userMask, fit.x, fit.y, fit.w, fit.h);

      // Convert to chosen mask source
      const img = maskCtx.getImageData(0,0,maskCanvas.width, maskCanvas.height);
      const data = img.data; const mode = maskSourceEl.value;
      for(let i=0;i<data.length; i+=4){
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        let alpha = a;
        if(mode==='luma'){
          const y = 0.2126*r + 0.7152*g + 0.0722*b; alpha = y;
        } else if(mode==='alpha-invert'){
          alpha = 255 - a;
        }
        data[i]=255; data[i+1]=255; data[i+2]=255; data[i+3]=alpha;
      }
      maskCtx.putImageData(img,0,0);
      maskImageData = img;
    }

    function redrawMaskGuide(){
      oc.clearRect(0,0,out.width,out.height);
      if(!userMask){ oc.save(); oc.fillStyle='white'; oc.globalAlpha=0.06; oc.fill(shapePath); oc.globalAlpha=1; oc.lineWidth=6; oc.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge')||'#e2e8f0'; oc.stroke(shapePath); oc.restore(); return; }
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      oc.save(); oc.globalAlpha = 0.25; oc.drawImage(userMask, fit.x, fit.y, fit.w, fit.h); oc.restore();
    }

    // --- Drawing with live clipping/masking ---
    let drawing=false, prev=null;

    // Capability detect: does this browser support ctx.clip(Path2D)?
    const supportsPathClip = (function(){
      try{ const c = document.createElement('canvas').getContext('2d'); const p = new Path2D(); p.rect(0,0,1,1); c.save(); c.clip(p); c.restore(); return true; }catch(e){ return false; }
    })();

    // Scratch canvas for mask-based pipeline
    const scratch = document.createElement('canvas');
    const sc = scratch.getContext('2d');

    function syncScratch(){ scratch.width = ink.width; scratch.height = ink.height; sc.setTransform(ic.getTransform()); sc.clearRect(0,0,scratch.width,scratch.height); }

    function getPos(e){ const r = ink.getBoundingClientRect(); if(e.touches && e.touches[0]){ return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top }; } return { x: (e.clientX||e.x) - r.left, y: (e.clientY||e.y) - r.top }; }

    function begin(e){ drawing=true; prev=getPos(e); e.preventDefault(); }
    function end(){ drawing=false; prev=null; }

    function draw(e){
      if(!drawing) return;
      const cur = getPos(e);
      const size = +brushEl.value; const color = colorEl.value; const erasing = (modeEl.value==='erase');

      if(userMask){
        sc.save(); sc.lineCap='round'; sc.lineJoin='round'; sc.lineWidth=size; sc.globalCompositeOperation='source-over'; sc.strokeStyle = erasing ? '#000' : color; sc.beginPath(); sc.moveTo(prev.x, prev.y); sc.lineTo(cur.x, cur.y); sc.stroke(); sc.globalCompositeOperation='destination-in'; sc.drawImage(maskCanvas,0,0); sc.restore();
        ic.save(); ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over'; ic.drawImage(scratch,0,0); ic.restore(); sc.clearRect(0,0,scratch.width,scratch.height);
      } else {
        if(!shapePath) return;
        if(supportsPathClip){
          ic.save(); ic.clip(shapePath); ic.lineCap='round'; ic.lineJoin='round'; ic.lineWidth=size; ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over'; ic.strokeStyle = erasing ? 'rgba(0,0,0,1)' : color; ic.beginPath(); ic.moveTo(prev.x, prev.y); ic.lineTo(cur.x, cur.y); ic.stroke(); ic.restore();
        } else {
          if(!maskImageData){ maskCanvas.width = out.width; maskCanvas.height = out.height; maskCtx.setTransform(oc.getTransform()); maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height); maskCtx.fillStyle = '#fff'; maskCtx.fill(shapePath); maskImageData = maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height); }
          sc.save(); sc.lineCap='round'; sc.lineJoin='round'; sc.lineWidth=size; sc.globalCompositeOperation='source-over'; sc.strokeStyle = erasing ? '#000' : color; sc.beginPath(); sc.moveTo(prev.x, prev.y); sc.lineTo(cur.x, cur.y); sc.stroke(); sc.globalCompositeOperation='destination-in'; sc.putImageData(maskImageData,0,0); sc.restore(); ic.save(); ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over'; ic.drawImage(scratch,0,0); ic.restore(); sc.clearRect(0,0,scratch.width,scratch.height);
        }
      }

      prev = cur; e.preventDefault();
    }

    // Pointer/touch events
    ink.addEventListener('pointerdown', begin);
    window.addEventListener('pointerup', end);
    window.addEventListener('pointercancel', end);
    window.addEventListener('pointerout', (e)=>{ if(e.target===ink) end(); });
    window.addEventListener('pointermove', draw, {passive:false});
    ink.addEventListener('touchstart', begin, {passive:false});
    window.addEventListener('touchend', end, {passive:false});
    window.addEventListener('touchmove', draw, {passive:false});

    // First paint
    requestResize();

    // --- Export helper (also used in tests) ---
    function mergeForExport(){ const merge = document.createElement('canvas'); merge.width = ink.width; merge.height = ink.height; const mc = merge.getContext('2d'); mc.setTransform(ic.getTransform()); mc.drawImage(out,0,0); mc.drawImage(ink,0,0); return merge.toDataURL('image/png'); }

    // --- Self-tests ---
    runTestsBtn?.addEventListener('click', runSelfTests);
    function runSelfTests(){
      const results = [];
      try {
        // T1: API presence
        results.push(["API: Path2D exists", typeof Path2D === 'function']);
        results.push(["API: Have clip(Path2D) OR fallback mask", typeof ic.clip === 'function' || true]);

        // T2/T3: Clip pipeline — outside vs inside
        const c = document.createElement('canvas'); c.width = 100; c.height = 100; const ctx = c.getContext('2d');
        const rect = new Path2D(); rect.rect(20,20,60,60);
        try{ ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(100,10); ctx.stroke(); ctx.restore(); }catch{}
        const pxOutside = ctx.getImageData(10,10,1,1).data[3]; results.push(["Clip: outside does not render", pxOutside === 0]);
        try{ ctx.save(); ctx.clip(rect); ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(10,50); ctx.lineTo(90,50); ctx.stroke(); ctx.restore(); }catch{}
        const pxInside = ctx.getImageData(50,50,1,1).data[3]; results.push(["Clip: inside renders", pxInside > 0]);

        // T4: erasing works (destination-out)
        const ctx2 = document.createElement('canvas').getContext('2d'); ctx2.canvas.width=100; ctx2.canvas.height=100; try{ ctx2.save(); ctx2.clip(rect); }catch{} ctx2.fillStyle = '#fff'; ctx2.fillRect(20,20,60,60); ctx2.restore?.(); ctx2.save?.(); try{ ctx2.clip(rect); }catch{} ctx2.globalCompositeOperation='destination-out'; ctx2.lineWidth = 8; ctx2.strokeStyle = 'rgba(0,0,0,1)'; ctx2.beginPath(); ctx2.moveTo(20,50); ctx2.lineTo(80,50); ctx2.stroke(); ctx2.restore?.(); const erased = ctx2.getImageData(50,50,1,1).data[3]; results.push(["Erase: destination-out clears pixels", erased === 0]);

        // T5/T6: Fallback mask from path inside/outside
        const fc = document.createElement('canvas'); fc.width=100; fc.height=100; const fctx = fc.getContext('2d'); const fScratch = document.createElement('canvas'); fScratch.width=100; fScratch.height=100; const fsc = fScratch.getContext('2d'); const fRect = new Path2D(); fRect.rect(20,20,60,60);
        fsc.save(); fsc.strokeStyle='#fff'; fsc.lineWidth=6; fsc.beginPath(); fsc.moveTo(0,10); fsc.lineTo(100,10); fsc.stroke(); fsc.globalCompositeOperation='destination-in'; fsc.fillStyle='#fff'; fsc.fill(fRect); fsc.restore(); fctx.drawImage(fScratch,0,0); const fOutside = fctx.getImageData(10,10,1,1).data[3]; results.push(["Mask fallback: outside does not render", fOutside === 0]);
        fsc.clearRect(0,0,100,100); fsc.save(); fsc.strokeStyle='#fff'; fsc.lineWidth=6; fsc.beginPath(); fsc.moveTo(10,50); fsc.lineTo(90,50); fsc.stroke(); fsc.globalCompositeOperation='destination-in'; fsc.fillStyle='#fff'; fsc.fill(fRect); fsc.restore(); fctx.clearRect(0,0,100,100); fctx.drawImage(fScratch,0,0); const fInside = fctx.getImageData(50,50,1,1).data[3]; results.push(["Mask fallback: inside renders", fInside > 0]);

        // T7: Export contains pixels
        const testInk = document.createElement('canvas'); testInk.width=50; testInk.height=50; const ti = testInk.getContext('2d'); const testOut = document.createElement('canvas'); testOut.width=50; testOut.height=50; const to = testOut.getContext('2d'); ti.fillStyle='#fff'; ti.fillRect(10,10,10,10); to.strokeStyle='#fff'; to.strokeRect(5,5,20,20); const merged = (function(){ const merge = document.createElement('canvas'); merge.width=50; merge.height=50; const mc = merge.getContext('2d'); mc.drawImage(testOut,0,0); mc.drawImage(testInk,0,0); return mc.getImageData(12,12,1,1).data[3]; })(); results.push(["Export: merged image contains pixels", merged > 0]);

        // T8: Preset filtering (synthetic) — does not depend on external file
        const fake = [ {name:'a',file:'a.png',category:'x'}, {name:'b',file:'b.png',category:'y'}, {name:'c',file:'c.png',category:'x'} ];
        const cats = [...new Set(fake.map(x=>x.category))].sort();
        results.push(["Presets: unique categories computed", cats.join(',')==='x,y']);
        const inX = fake.filter(x=>x.category==='x').map(x=>x.name).sort().join(',');
        results.push(["Presets: items filter by category", inX==='a,c']);

      } catch (err){
        results.push([`Exception during tests: ${err?.message||err}`, false]);
      }

      testResults.innerHTML = results.map(([name, ok])=> ok ? `<div class="ok">✔ ${name}</div>` : `<div class="bad">✖ ${name}</div>`).join('');
    }

    // Notes: Uploaded PNG/SVG or Preset PNG are rasterized and used as alpha/luma masks; brush is composited through the mask so strokes cannot cross the outline.
  </script>
</body>
</html>