<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gentle Bees</title>
  <style>
    :root {
      --sky: #f0f7ff;
      --meadow: #e5f6e0;
      --sun: #ffd166;
      --text: #0f172a;
      --muted: #4b5563;
      --accent: #f59e0b;
      --button: #f97316;
      --button-dark: #ea580c;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Atkinson Hyperlegible", "Segoe UI", system-ui, sans-serif;
      background: linear-gradient(180deg, var(--sky) 0%, #eaf7ff 35%, var(--meadow) 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.25rem clamp(1rem, 3vw, 2rem);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(15, 23, 42, 0.06);
      box-shadow: 0 4px 18px rgba(15, 23, 42, 0.05);
      z-index: 10;
    }

    header h1 {
      font-size: clamp(1.2rem, 3vw, 1.6rem);
      font-weight: 700;
      letter-spacing: 0.01em;
    }

    header p {
      color: var(--muted);
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      max-width: 720px;
      line-height: 1.5;
    }

    main {
      position: relative;
      flex: 1;
      display: flex;
      align-items: stretch;
      justify-content: center;
      overflow: hidden;
    }

    #scene {
      flex: 1;
      width: 100%;
      height: 100%;
      display: block;
    }

    .instruction-card {
      position: absolute;
      top: clamp(0.75rem, 3vw, 1.5rem);
      right: clamp(0.75rem, 3vw, 1.5rem);
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(15, 23, 42, 0.05);
      border-radius: 16px;
      padding: 1rem 1.25rem;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.12);
      width: min(280px, 40vw);
      backdrop-filter: blur(8px);
    }

    .instruction-card h2 {
      font-size: 1rem;
      margin-bottom: 0.4rem;
      color: var(--text);
      letter-spacing: 0.01em;
    }

    .instruction-card p {
      color: var(--muted);
      line-height: 1.45;
      font-size: 0.95rem;
    }

    .action-area {
      position: absolute;
      left: 50%;
      bottom: clamp(1rem, 4vw, 2rem);
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      text-align: center;
      z-index: 5;
    }

    .action-button {
      border: none;
      border-radius: 999px;
      padding: clamp(0.9rem, 3vw, 1.2rem) clamp(2rem, 5vw, 3rem);
      background: linear-gradient(135deg, var(--button) 0%, var(--button-dark) 100%);
      color: white;
      font-size: clamp(1.1rem, 3vw, 1.4rem);
      font-weight: 700;
      box-shadow: 0 16px 40px rgba(234, 88, 12, 0.3);
      cursor: pointer;
      transition: transform 150ms ease, box-shadow 150ms ease;
      letter-spacing: 0.01em;
    }

    .action-button:active,
    .action-button:focus-visible {
      outline: none;
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 10px 25px rgba(234, 88, 12, 0.25);
    }

    .action-hint {
      color: var(--muted);
      font-size: 0.95rem;
      padding: 0 0.5rem;
    }

    @media (max-width: 640px) {
      .instruction-card {
        position: static;
        width: auto;
        margin: 1rem;
      }

      main {
        padding-bottom: 8rem;
      }

      .action-area {
        bottom: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Gentle Bees</h1>
    <p>
      A calm cause-and-effect activity: press the big button (or SPACE) to send the bees to the
      flowers. Each return grows the honeycomb filling the left side of the meadow, with warm glow
      and gentle chimes to link action and outcome.
    </p>
  </header>

  <main>
    <canvas id="scene" aria-label="Bee meadow" role="img"></canvas>

    <div class="instruction-card" aria-live="polite">
      <h2>How it works</h2>
      <p>
        Press once. Bees fly out, gather nectar, and light up the hive with a warm honey glow while
        new honeycombs rise on the left. Pause, then press again whenever you want a new burst.
      </p>
    </div>

    <div class="action-area">
      <button class="action-button" id="sendButton" aria-describedby="hint">
        Send the bees
      </button>
      <div class="action-hint" id="hint">You can also press SPACE</div>
    </div>
  </main>

  <script>
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");
    const button = document.getElementById("sendButton");

    const bees = [];
    const pollenBursts = [];
    const honeyCells = [];
    const honeyGrid = [];
    let builtCells = 0;

    function resizeCanvas() {
      const { width, height } = canvas.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      canvas.width = width * ratio;
      canvas.height = height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      setupHoneyGrid(true);
    }

    const resizeObserver = new ResizeObserver(resizeCanvas);
    resizeObserver.observe(canvas);
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const chime = audioCtx.createOscillator();
    const chimeGain = audioCtx.createGain();
    chime.type = "sine";
    chime.frequency.value = 660;
    chimeGain.gain.value = 0;
    chime.connect(chimeGain).connect(audioCtx.destination);
    chime.start();

    function playChime() {
      audioCtx.resume();
      const now = audioCtx.currentTime;
      chimeGain.gain.cancelScheduledValues(now);
      chimeGain.gain.setValueAtTime(0, now);
      chimeGain.gain.linearRampToValueAtTime(0.2, now + 0.05);
      chimeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
    }

    function hiveCenter() {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      return { x: w * 0.28, y: h * 0.55 };
    }

    function createBees(count) {
      bees.length = 0;
      for (let i = 0; i < count; i++) {
        bees.push({
          x: 0,
          y: 0,
          angle: Math.random() * Math.PI * 2,
          progress: 0,
          target: null,
          delay: Math.random() * 0.4,
        });
      }
      resetBees();
    }

    function resetBees() {
      const { x, y } = hiveCenter();
      bees.forEach((b) => {
        b.x = x + (Math.random() - 0.5) * 12;
        b.y = y + (Math.random() - 0.5) * 12;
        b.progress = 0;
        b.target = null;
      });
    }

    function setupHoneyCells() {
      honeyCells.length = 0;
      const { x, y } = hiveCenter();
      const radius = (Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1)) * 0.04;
      for (let r = -1; r <= 1; r++) {
        for (let c = -1; c <= 1; c++) {
          if (Math.abs(r) + Math.abs(c) <= 1) {
            honeyCells.push({
              x: x + c * radius * 1.8,
              y: y + r * radius * 1.6,
              fill: 0.2,
            });
          }
        }
      }
    }

    function setupHoneyGrid(keepProgress = false) {
      const previousRatio = keepProgress && honeyGrid.length > 0 ? builtCells / honeyGrid.length : 0.08;
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      const areaWidth = w * 0.5;
      const radius = Math.min(w, h) * 0.035;
      const horiz = radius * 1.8;
      const vert = radius * 1.55;
      const margin = radius * 1.2;

      honeyGrid.length = 0;
      let row = 0;
      for (let y = margin; y <= h - margin; y += vert) {
        const offset = row % 2 === 0 ? 0 : horiz * 0.5;
        for (let x = margin + offset; x <= areaWidth - margin; x += horiz) {
          honeyGrid.push({ x, y, fill: 0.15 + Math.random() * 0.05 });
        }
        row++;
      }

      const baseRatio = Math.max(previousRatio, 0.08);
      builtCells = Math.min(honeyGrid.length, Math.max(4, Math.round(honeyGrid.length * baseRatio)));
    }

    function createFlowers() {
      const positions = [];
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      const baseX = w * 0.65;
      const spread = Math.min(w, h) * 0.18;
      for (let i = 0; i < 5; i++) {
        const offsetY = (i - 2) * (spread / 3);
        positions.push({
          x: baseX + (Math.random() - 0.3) * spread,
          y: h * 0.5 + offsetY + (Math.random() - 0.5) * 30,
          sway: Math.random() * Math.PI * 2,
        });
      }
      return positions;
    }

    let flowers = createFlowers();

    function drawBackground(t) {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);

      const skyGrad = ctx.createLinearGradient(0, 0, 0, h);
      skyGrad.addColorStop(0, "#eaf6ff");
      skyGrad.addColorStop(1, "#f7fbff");
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, w, h);

      ctx.fillStyle = "#d6f0d4";
      ctx.beginPath();
      ctx.ellipse(w * 0.1, h * 0.2, 60, 18, -0.2, 0, Math.PI * 2);
      ctx.fill();

      const hillGrad = ctx.createLinearGradient(0, h * 0.6, 0, h);
      hillGrad.addColorStop(0, "#c9e9c4");
      hillGrad.addColorStop(1, "#a8d9a8");
      ctx.fillStyle = hillGrad;
      ctx.beginPath();
      ctx.moveTo(0, h * 0.55);
      ctx.quadraticCurveTo(w * 0.35, h * 0.45, w * 0.6, h * 0.6);
      ctx.quadraticCurveTo(w * 0.8, h * 0.7, w, h * 0.62);
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      const sunX = w * 0.15;
      const sunY = h * 0.18;
      const sunR = Math.min(w, h) * 0.08;
      const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
      sunGrad.addColorStop(0, "rgba(255,209,102,0.8)");
      sunGrad.addColorStop(1, "rgba(255,209,102,0)");
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (let i = 0; i < 6; i++) {
        const cx = w * 0.35 + i * 30;
        const cy = h * 0.15 + Math.sin(t * 0.0005 + i) * 6;
        ctx.beginPath();
        ctx.ellipse(cx, cy, 28, 16, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = "#84cc16";
      for (let i = 0; i < 10; i++) {
        const x = (w / 10) * i + (Math.sin(t * 0.001 + i) * 10);
        const y = h * 0.7 + (Math.sin(t * 0.0015 + i) * 6);
        ctx.beginPath();
        ctx.ellipse(x, y, 24, 8, 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawHoneyField(t) {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      const areaWidth = w * 0.5;

      const honeyGrad = ctx.createLinearGradient(0, 0, areaWidth, 0);
      honeyGrad.addColorStop(0, "rgba(255, 251, 235, 0.8)");
      honeyGrad.addColorStop(1, "rgba(255, 247, 209, 0.5)");
      ctx.fillStyle = honeyGrad;
      ctx.fillRect(0, 0, areaWidth, h);

      const radius = Math.min(w, h) * 0.035;
      const wobble = Math.sin(t * 0.002) * 0.08;

      function drawHex(x, y, r) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const ang = Math.PI / 3 * i + Math.PI / 6 + wobble;
          const px = x + Math.cos(ang) * r;
          const py = y + Math.sin(ang) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
      }

      honeyGrid.forEach((cell, idx) => {
        const built = idx < builtCells;
        if (built) {
          cell.fill = Math.max(0.25, cell.fill * 0.985);
        }
        const alpha = built ? 0.18 + cell.fill * 0.55 : 0.06;
        ctx.fillStyle = `rgba(250, 204, 21, ${alpha})`;
        drawHex(cell.x, cell.y, radius);
        ctx.fill();

        if (built) {
          ctx.strokeStyle = "rgba(245, 158, 11, 0.5)";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });

      ctx.globalAlpha = 1;
    }

    function drawHive(t) {
      const { x, y } = hiveCenter();
      const baseR = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) * 0.08;

      const glow = ctx.createRadialGradient(x, y, baseR * 0.1, x, y, baseR * 1.4);
      glow.addColorStop(0, "rgba(250, 204, 21, 0.35)");
      glow.addColorStop(1, "rgba(250, 204, 21, 0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(x, y, baseR * 1.4, 0, Math.PI * 2);
      ctx.fill();

      for (let i = 0; i < 5; i++) {
        const r = baseR * (0.55 + i * 0.08);
        const wobble = Math.sin(t * 0.002 + i) * 1.5;
        ctx.fillStyle = `hsl(39, 85%, ${68 - i * 5}% )`;
        ctx.beginPath();
        ctx.ellipse(x, y + wobble, r * 0.85, r * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      honeyCells.forEach((cell, idx) => {
        const fill = cell.fill;
        const col = idx % 2 === 0 ? "#fef08a" : "#fde047";
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.ellipse(cell.x, cell.y, baseR * 0.26, baseR * 0.22, 0, 0, Math.PI * 2);
        ctx.globalAlpha = 0.3 + fill * 0.7;
        ctx.fill();
        ctx.globalAlpha = 1;
        cell.fill = Math.max(0.2, cell.fill * 0.97);
      });
    }

    function drawFlowers(t) {
      const petalColors = ["#f97316", "#ec4899", "#22c55e", "#06b6d4", "#eab308"];
      flowers.forEach((f, i) => {
        const sway = Math.sin(t * 0.002 + f.sway) * 6;
        const stemH = 110;
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate((sway * Math.PI) / 180);

        ctx.strokeStyle = "#15803d";
        ctx.lineWidth = 6;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(12, stemH * 0.4, 0, stemH);
        ctx.stroke();

        const petalCount = 8;
        const petalR = 28;
        for (let p = 0; p < petalCount; p++) {
          const a = (Math.PI * 2 * p) / petalCount;
          const px = Math.cos(a) * petalR;
          const py = Math.sin(a) * petalR;
          ctx.beginPath();
          ctx.fillStyle = petalColors[(i + p) % petalColors.length];
          ctx.ellipse(px, py, 18, 10, a, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      });
    }

    function drawBee(bee, t) {
      ctx.save();
      ctx.translate(bee.x, bee.y);
      ctx.rotate(bee.angle);
      const wobble = Math.sin(t * 0.005 + bee.x * 0.05) * 0.1;
      ctx.rotate(wobble);

      ctx.globalAlpha = 0.8;
      ctx.fillStyle = "rgba(255, 209, 102, 0.25)";
      ctx.beginPath();
      ctx.arc(-12, 0, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#facc15";
      ctx.beginPath();
      ctx.ellipse(0, 0, 16, 10, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#0f172a";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-4, -10);
      ctx.lineTo(-4, 10);
      ctx.moveTo(6, -9);
      ctx.lineTo(6, 9);
      ctx.stroke();

      ctx.fillStyle = "#0f172a";
      ctx.beginPath();
      ctx.arc(12, 0, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(191, 219, 254, 0.9)";
      ctx.beginPath();
      ctx.ellipse(-4, -10, 10, 6, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-4, 10, 10, 6, 0.3, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawPollen(t) {
      for (let i = pollenBursts.length - 1; i >= 0; i--) {
        const p = pollenBursts[i];
        p.life -= 0.016;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        if (p.life <= 0) {
          pollenBursts.splice(i, 1);
          continue;
        }
        const alpha = Math.max(0, p.life / p.maxLife);
        ctx.fillStyle = `rgba(250, 204, 21, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2 + (1 - alpha) * 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function activateBees() {
      playChime();
      flowers = createFlowers();
      const { x, y } = hiveCenter();
      bees.forEach((bee, i) => {
        const flower = flowers[i % flowers.length];
        const ctrl = { x: (x + flower.x) / 2, y: (y + flower.y) / 2 - 60 };
        bee.target = { flower, ctrl };
        bee.progress = 0;
        bee.delay = Math.random() * 0.25;
      });
      honeyCells.forEach((cell) => {
        cell.fill = 0.15;
      });
    }

    function updateBees(dt) {
      bees.forEach((bee) => {
        if (!bee.target) return;
        if (bee.delay > 0) {
          bee.delay -= dt;
          return;
        }
        bee.progress = Math.min(1, bee.progress + dt * 0.4);
        const { x: hx, y: hy } = hiveCenter();
        const { flower, ctrl } = bee.target;
        const t = bee.progress;
        const inv = 1 - t;
        bee.x = inv * inv * hx + 2 * inv * t * ctrl.x + t * t * flower.x;
        bee.y = inv * inv * hy + 2 * inv * t * ctrl.y + t * t * flower.y;
        const dx = flower.x - bee.x;
        const dy = flower.y - bee.y;
        bee.angle = Math.atan2(dy, dx);

        if (t >= 1) {
          bee.target = { flower, ctrl, returning: true };
          bee.progress = 0;
          bee.delay = 0.1;
          spawnPollen(flower.x, flower.y, true);
        }
      });

      bees.forEach((bee) => {
        if (!bee.target || !bee.target.returning) return;
        if (bee.delay > 0) {
          bee.delay -= dt;
          return;
        }
        bee.progress = Math.min(1, bee.progress + dt * 0.45);
        const { x: hx, y: hy } = hiveCenter();
        const { flower, ctrl } = bee.target;
        const t = bee.progress;
        const inv = 1 - t;
        bee.x = inv * inv * flower.x + 2 * inv * t * ctrl.x + t * t * hx;
        bee.y = inv * inv * flower.y + 2 * inv * t * ctrl.y + t * t * hy;
        const dx = hx - bee.x;
        const dy = hy - bee.y;
        bee.angle = Math.atan2(dy, dx);

        if (t >= 1) {
          bee.target = null;
          bee.progress = 0;
          bee.delay = Math.random() * 0.8;
          feedHive();
          spawnPollen(hx, hy, false);
        }
      });
    }

    function feedHive() {
      if (honeyGrid.length > 0) {
        if (builtCells < honeyGrid.length) {
          honeyGrid[builtCells].fill = 1;
          builtCells++;
        } else {
          const cell = honeyGrid[Math.floor(Math.random() * honeyGrid.length)];
          cell.fill = Math.min(1, cell.fill + 0.35);
        }
      }

      if (honeyCells.length > 0) {
        const hiveCell = honeyCells[Math.floor(Math.random() * honeyCells.length)];
        hiveCell.fill = Math.min(1, hiveCell.fill + 0.35);
      }
    }

    function spawnPollen(x, y, bright) {
      for (let i = 0; i < 14; i++) {
        const ang = (Math.PI * 2 * i) / 14 + Math.random() * 0.3;
        const speed = bright ? 1.8 : 1.2;
        pollenBursts.push({
          x,
          y,
          vx: Math.cos(ang) * speed,
          vy: Math.sin(ang) * speed,
          life: 1,
          maxLife: 1,
        });
      }
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      drawBackground(now);
      drawHoneyField(now);
      updateBees(dt);
      drawHive(now);
      drawFlowers(now);
      bees.forEach((bee) => drawBee(bee, now));
      drawPollen(now);
      requestAnimationFrame(loop);
    }

    function handleAction() {
      activateBees();
    }

    button.addEventListener("click", handleAction);
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        handleAction();
      }
    });

    createBees(8);
    setupHoneyCells();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
