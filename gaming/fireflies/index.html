<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title
    class="translate"
    data-fr="Lucioles magiques : jeu switch"
    data-en="Firefly Magic: switch game">
    Lucioles magiques : jeu switch
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../css/otherswitch.css" />
  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <style>
    :root {
      color-scheme: dark;
    }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #02030a;
      font-family: "Poppins", "Segoe UI", sans-serif;
    }

    body.playing,
    body.playing * {
      cursor: none !important;
    }

    canvas#fireflyCanvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: none;
      background: #02030a;
      z-index: 0;
    }

    #game-options {
      transition: opacity 0.35s ease;
    }

    #game-options.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #options-title-bar {
      text-align: center;
      color: #ffffff;
      margin-bottom: 16px;
    }

    #options-main-title {
      margin: 0;
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    #langToggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 99999;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 2px solid #009688;
      background: #ffffff;
      color: #009688;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
    }

    body.playing #langToggle {
      display: none !important;
    }
  </style>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-B45TJG4GBJ');
  </script>
</head>
<body>
  <canvas id="fireflyCanvas" aria-hidden="true"></canvas>

  <button id="langToggle" type="button" title="Changer la langue / Switch language">EN</button>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title" class="translate"
          data-fr="Lucioles magiques"
          data-en="Firefly Magic">
        Lucioles magiques
      </h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="soundToggle" checked>
              <span class="translate"
                    data-fr="Son"
                    data-en="Sound">Son</span>
            </label>
          </div>

          <div class="option-item">
            <label for="soundLevel" class="teal-label label-block">
              <span class="translate"
                    data-fr="Niveau sonore :"
                    data-en="Sound level:">Niveau sonore :</span>
              <span id="soundLevelValue" class="value-badge">60</span>
            </label>
            <input type="range" id="soundLevel" class="styled-slider" min="0" max="100" value="60">
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="effectSelect" class="teal-label label-block translate"
                   data-fr="Type d'effet"
                   data-en="Effect type">Type d'effet</label>
            <select id="effectSelect" class="styled-select">
              <option value="swirl" class="translate" data-fr="Tourbillon" data-en="Swirl">Tourbillon</option>
              <option value="cascade" class="translate" data-fr="Cascade" data-en="Cascade">Cascade</option>
              <option value="aurora" class="translate" data-fr="Aurore" data-en="Aurora">Aurore</option>
              <option value="mix" class="translate" data-fr="Mélange" data-en="Mix">Mélange</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="lightIntensity" class="teal-label label-block">
              <span class="translate"
                    data-fr="Intensité lumineuse :"
                    data-en="Light intensity:">Intensité lumineuse :</span>
              <span id="lightIntensityValue" class="value-badge">45</span>
            </label>
            <input type="range" id="lightIntensity" class="styled-slider" min="0" max="100" value="45">
          </div>

          <div class="option-item">
            <label for="sizeLevel" class="teal-label label-block">
              <span class="translate"
                    data-fr="Taille des lucioles :"
                    data-en="Firefly size:">Taille des lucioles :</span>
              <span id="sizeLevelValue" class="value-badge">50</span>
            </label>
            <input type="range" id="sizeLevel" class="styled-slider" min="20" max="100" value="50">
          </div>
        </div>
      </div>

      <button id="startButton" class="button translate"
              data-fr="Commencer"
              data-en="Start">Commencer</button>
    </div>
  </div>

  <script src="../../js/translationmain.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const langBtn = document.getElementById('langToggle');
      if (langBtn) {
        const siteLang = localStorage.getItem('siteLanguage') || 'en';
        langBtn.textContent = (siteLang === 'fr') ? 'EN' : 'FR';
        langBtn.addEventListener('click', () => {
          if (typeof toggleLanguage === 'function') {
            toggleLanguage();
          }
          const updated = localStorage.getItem('siteLanguage') || 'en';
          langBtn.textContent = (updated === 'fr') ? 'EN' : 'FR';
        });
      }

      const canvas = document.getElementById('fireflyCanvas');
      const ctx = canvas.getContext('2d', { alpha: false });

      const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
      const lerp = (a, b, t) => a + (b - a) * t;

      let W = 0;
      let H = 0;

      const settings = {
        size: 0.5,
        trail: 0.12,
        lightIntensity: 0.45
      };

      let pulseBoost = 0;
      let pulseFlash = 0;
      let lastFrame = 0;
      let running = false;
      let animationId = null;
      let lastBurstTime = 0;
      let baseMotion = 0;

      const burstFocus = { x: 0, y: 0 };

      const gameOptions = document.getElementById('game-options');
      const startButton = document.getElementById('startButton');
      const soundToggle = document.getElementById('soundToggle');
      const soundLevel = document.getElementById('soundLevel');
      const soundLevelValue = document.getElementById('soundLevelValue');
      const effectSelect = document.getElementById('effectSelect');
      const lightIntensity = document.getElementById('lightIntensity');
      const lightIntensityValue = document.getElementById('lightIntensityValue');
      const sizeLevel = document.getElementById('sizeLevel');
      const sizeLevelValue = document.getElementById('sizeLevelValue');

      const music = new Audio('../../songs/space/spacebest1.mp3');

      const BURST_DURATION = 3.8;
      const BURST_VARIANTS = ['swirl', 'cascade', 'aurora'];
      const EFFECT_VARIANTS = {
        swirl: ['swirl'],
        cascade: ['cascade'],
        aurora: ['aurora'],
        mix: BURST_VARIANTS
      };
      let burstTimer = 0;
      let burstVariant = 'swirl';
      let swirlDir = 1;
      let burstWaveOffset = 0;
      music.loop = true;
      music.volume = 0.6;
      let musicWanted = true;
      let sfxLevel = 0.6;

      if (soundToggle) {
        musicWanted = soundToggle.checked;
      }

      function setSoundLevelUI(value) {
        if (!Number.isFinite(value)) return;
        const val = Math.round(clamp(value, 0, 100));
        if (soundLevelValue) {
          soundLevelValue.textContent = String(val);
        }
        if (soundLevel && soundLevel.value !== String(val)) {
          soundLevel.value = String(val);
        }
        const normalized = val / 100;
        sfxLevel = normalized;
        music.volume = Math.min(1, normalized * 0.85);
      }

      if (soundLevel) {
        setSoundLevelUI(Number(soundLevel.value || 60));
      }
      if (lightIntensity) {
        setLightLevelUI(Number(lightIntensity.value || 45));
      }
      if (sizeLevel) {
        setSizeLevelUI(Number(sizeLevel.value || 50));
      }
      applySoundPreference();

      soundLevel?.addEventListener('input', (ev) => {
        setSoundLevelUI(Number(ev.target.value));
      });

      soundToggle?.addEventListener('change', () => {
        applySoundPreference();
      });

      lightIntensity?.addEventListener('input', (ev) => {
        setLightLevelUI(Number(ev.target.value));
      });

      sizeLevel?.addEventListener('input', (ev) => {
        setSizeLevelUI(Number(ev.target.value));
      });

      function setLightLevelUI(value) {
        if (!Number.isFinite(value)) return;
        const val = Math.round(clamp(value, 0, 100));
        if (lightIntensityValue) {
          lightIntensityValue.textContent = String(val);
        }
        if (lightIntensity && lightIntensity.value !== String(val)) {
          lightIntensity.value = String(val);
        }
        settings.lightIntensity = clamp(val / 100, 0, 1);
      }

      let sizeUpdateHandle = null;
      function setSizeLevelUI(value) {
        if (!Number.isFinite(value)) return;
        const val = Math.round(clamp(value, 20, 100));
        if (sizeLevelValue) {
          sizeLevelValue.textContent = String(val);
        }
        if (sizeLevel && sizeLevel.value !== String(val)) {
          sizeLevel.value = String(val);
        }
        settings.size = clamp(val / 100, 0.2, 1.0);
        if (sizeUpdateHandle) {
          clearTimeout(sizeUpdateHandle);
        }
        sizeUpdateHandle = setTimeout(() => {
          sizeUpdateHandle = null;
          if (W > 0 && H > 0) {
            firefliesInit();
          }
        }, 120);
      }

      function applySoundPreference() {
        if (soundToggle) {
          musicWanted = soundToggle.checked;
          if (soundLevel) {
            soundLevel.disabled = !musicWanted;
          }
        }

        if (!musicWanted) {
          music.pause();
        } else if (running) {
          const playPromise = music.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(() => {});
          }
        }
      }

      let audioCtx = null;
      function ensureAudioCtx() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
      }

      function resumeAudioCtx() {
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(() => {});
        }
      }

      function playPing(freq = 600) {
        if (!running || !musicWanted || sfxLevel <= 0.001) return;
        const ac = ensureAudioCtx();
        resumeAudioCtx();
        const now = ac.currentTime;
        const osc = ac.createOscillator();
        const gain = ac.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(Math.max(0.02, 0.12 * sfxLevel), now + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
        osc.connect(gain).connect(ac.destination);
        osc.start(now);
        osc.stop(now + 0.6);
      }

      function mapIntensity() {
        const timerBoost = burstTimer > 0
          ? Math.pow(clamp(burstTimer / BURST_DURATION, 0, 1), 1.2) * 0.35
          : 0;
        return clamp(baseMotion + pulseBoost + timerBoost, 0, 1);
      }

      function sizeNorm() {
        return clamp(settings.size, 0, 1);
      }

      function mapTrail() {
        return clamp(settings.trail, 0.02, 0.35);
      }

      function clearToBg(hard = false) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        if (hard) {
          ctx.fillStyle = '#02030a';
          ctx.fillRect(0, 0, W, H);
        } else {
          const fade = mapTrail();
          ctx.fillStyle = `rgba(2, 4, 16, ${fade})`;
          ctx.fillRect(0, 0, W, H);
        }
      }

      const FIREFLIES = { list: [], t: 0 };
      const FIREFLY_NEIGHBORS = { a: [], b: [] };
      const FIREFLY_SPRITE_SIZE = 256;
      const FIREFLY_SPRITES = new Map();

      function getFireflySprite(hue) {
        const quant = ((Math.round(hue / 12) * 12) % 360 + 360) % 360;
        const key = `${quant}`;
        let sprite = FIREFLY_SPRITES.get(key);
        if (!sprite) {
          const canvasSprite = document.createElement('canvas');
          canvasSprite.width = canvasSprite.height = FIREFLY_SPRITE_SIZE;
          const gctx = canvasSprite.getContext('2d');
          const cx = FIREFLY_SPRITE_SIZE / 2;

          const bloom = gctx.createRadialGradient(cx, cx, cx * 0.1, cx, cx, cx * 0.95);
          bloom.addColorStop(0.0, `hsla(${quant}, 100%, 70%, 1)`);
          bloom.addColorStop(0.55, `hsla(${(quant + 16) % 360}, 95%, 55%, 0.65)`);
          bloom.addColorStop(1.0, `hsla(${(quant + 56) % 360}, 85%, 45%, 0)`);
          gctx.fillStyle = bloom;
          gctx.fillRect(0, 0, FIREFLY_SPRITE_SIZE, FIREFLY_SPRITE_SIZE);

          const highlight = gctx.createRadialGradient(cx * 0.68, cx * 0.68, cx * 0.06, cx * 0.68, cx * 0.68, cx * 0.28);
          highlight.addColorStop(0.0, `hsla(${(quant + 36) % 360}, 100%, 90%, 0.75)`);
          highlight.addColorStop(1.0, `hsla(${(quant + 36) % 360}, 100%, 90%, 0)`);
          gctx.fillStyle = highlight;
          gctx.fillRect(0, 0, FIREFLY_SPRITE_SIZE, FIREFLY_SPRITE_SIZE);

          sprite = { canvas: canvasSprite, radius: FIREFLY_SPRITE_SIZE / 2 };
          FIREFLY_SPRITES.set(key, sprite);
        }
        return sprite;
      }

      function firefliesInit() {
        FIREFLIES.list.length = 0;
        const sN = sizeNorm();
        const area = W * H;
        const density = clamp(Math.sqrt(area / (1280 * 720)), 0.6, 1.25);
        const n = Math.floor(clamp(90 * density + 110 * sN, 90, 200));
        const spread = Math.hypot(W, H) * 0.58;
        const neighborA = FIREFLY_NEIGHBORS.a;
        const neighborB = FIREFLY_NEIGHBORS.b;
        neighborA.length = n;
        neighborB.length = n;

        for (let i = 0; i < n; i++) {
          const z = 0.58 + Math.random() * 0.82;
          const invZ = 1 / z;
          const ang = Math.random() * Math.PI * 2;
          const rad = Math.sqrt(Math.random()) * spread;
          const cx = W * 0.5 + Math.cos(ang) * rad;
          const cy = H * 0.5 + Math.sin(ang) * rad;

          FIREFLIES.list.push({
            x: cx,
            y: cy,
            px: cx,
            py: cy,
            vx: (Math.random() - 0.5) * 0.25,
            vy: (Math.random() - 0.5) * 0.25,
            z,
            invZ,
            hue: 170 + Math.random() * 80,
            glow: 0.2 + Math.random() * 0.4,
            phase: Math.random() * Math.PI * 2,
          });
        }

        const shortOffset = Math.min(n - 1, 13);
        const longOffset = Math.min(n - 1, Math.max(shortOffset + 1, Math.round(n * 0.24)));
        for (let i = 0; i < n; i++) {
          neighborA[i] = (i + shortOffset) % n;
          neighborB[i] = (i + longOffset) % n;
        }
      }

      function flyWrap(f) {
        const pad = 80;
        let wrapped = false;
        if (f.x < -pad) { f.x = W + pad; wrapped = true; }
        if (f.x > W + pad) { f.x = -pad; wrapped = true; }
        if (f.y < -pad) { f.y = H + pad; wrapped = true; }
        if (f.y > H + pad) { f.y = -pad; wrapped = true; }
        if (wrapped) { f.px = f.x; f.py = f.y; }
        return wrapped;
      }

      function drawFirefly(f, coreR, bloomR, alphaCore, alphaBloom) {
        const sprite = getFireflySprite(f.hue);
        if (alphaBloom > 0.001) {
          drawGlowSprite(sprite, f.x, f.y, bloomR, alphaBloom, 'screen');
        }

        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 1;
        ctx.fillStyle = `hsla(${f.hue | 0}, 100%, 68%, ${alphaCore})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, coreR, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = 'screen';
        ctx.strokeStyle = `hsla(${(f.hue + 36) | 0}, 100%, 88%, ${0.55 * alphaCore})`;
        ctx.lineWidth = Math.max(0.7, coreR * 0.3);
        ctx.beginPath();
        ctx.arc(f.x - coreR * 0.32, f.y - coreR * 0.32, coreR * 0.30, 0, Math.PI * 2);
        ctx.stroke();
      }

      function drawGlowSprite(sprite, x, y, radius, alpha, composite = 'screen') {
        if (!sprite || alpha <= 0.001) return;
        ctx.save();
        ctx.globalCompositeOperation = composite;
        ctx.globalAlpha = alpha;
        const scale = radius / sprite.radius;
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.drawImage(sprite.canvas, -sprite.radius, -sprite.radius);
        ctx.restore();
      }

      function renderFireflies(dt, intensity) {
        const baseActivity = clamp(intensity, 0, 1);
        const sN = sizeNorm();
        FIREFLIES.t += dt;

        clearToBg(false);

        const burstPhase = burstTimer > 0 ? clamp(burstTimer / BURST_DURATION, 0, 1) : 0;
        const burstEase = burstPhase > 0 ? Math.pow(burstPhase, 0.75) : 0;
        const motionActivity = clamp(baseActivity + burstEase * 0.6, 0, 1);
        const baseVisual = clamp(baseActivity + burstEase * 0.85, 0, 1);
        const lightScale = 0.4 + settings.lightIntensity * 1.0;
        const visualActivity = clamp(baseVisual * lightScale, 0, 1.35);

        const wanderBase = lerp(0, 0.24, motionActivity);
        const attractK = lerp(0, 32, motionActivity);
        const repelK = lerp(0, 24, motionActivity);
        const maxSpeed = lerp(0, 32, motionActivity);
        const dampBase = lerp(0.88, 0.975, motionActivity);
        const damp = Math.pow(dampBase, dt * 60);
        const velScale = dt * lerp(0, 34, motionActivity);

        const pullR = 220 + 360 * sN;
        const pullR2 = pullR * pullR;
        const nearRange = 180 + 240 * sN;
        const nearRange2 = nearRange * nearRange;
        const repelR = 160 + 240 * sN;
        const repelR2 = repelR * repelR;
        const hopXLimit = W * 0.42;
        const hopYLimit = H * 0.42;

        const neighborsA = FIREFLY_NEIGHBORS.a;
        const neighborsB = FIREFLY_NEIGHBORS.b;

        const swirlStrength = 28 * burstEase;
        const radialStrength = 18 * burstEase;
        const waveStrength = 15 * burstEase;
        const jitterStrength = 0.6 * burstEase;
        const burstProgress = burstPhase > 0 ? 1 - burstPhase : 0;
        const glowBoost = 0.45 * burstEase * lightScale;
        const brightness = 0.6 + settings.lightIntensity * 0.9;

        const N = FIREFLIES.list.length;
        for (let i = 0; i < N; i++) {
          const f = FIREFLIES.list[i];
          f.px = f.x;
          f.py = f.y;

          let near = 0;
          const invZ = f.invZ;

          const dx = burstFocus.x - f.x;
          const dy = burstFocus.y - f.y;
          const dist2 = dx * dx + dy * dy;
          let dist = 0;

          if (dist2 < nearRange2) {
            dist = Math.sqrt(dist2);
            near = clamp(1 - dist / nearRange, 0, 1) * motionActivity;
          } else if (dist2 < pullR2) {
            dist = Math.sqrt(dist2);
          }
          if (!dist && dist2 > 0) {
            dist = Math.sqrt(dist2);
          }

          const wanderLocal = wanderBase * (1 + 0.7 * (1 - near));
          f.vx += (Math.random() - 0.5) * wanderLocal * invZ;
          f.vy += (Math.random() - 0.5) * wanderLocal * invZ;

          if (motionActivity > 0.0005 && dist2 < pullR2 && dist > 0) {
            const t = 1 - dist / pullR;
            const pull = attractK * (0.25 + 0.75 * t) * dt * invZ / 320;
            f.vx += dx * pull;
            f.vy += dy * pull;
          }

          if (repelK > 0 && motionActivity > 0.0001) {
            const idxA = neighborsA[i];
            const idxB = neighborsB[i];

            const gA = FIREFLIES.list[idxA];
            if (gA && gA !== f) {
              const rx = f.x - gA.x;
              const ry = f.y - gA.y;
              const rd2 = rx * rx + ry * ry + 0.0001;
              if (rd2 < repelR2) {
                const inv = 1 / Math.sqrt(rd2);
                const repelScale = (repelK * (1 - rd2 / repelR2)) * dt * invZ / 120;
                f.vx += rx * inv * repelScale;
                f.vy += ry * inv * repelScale;
              }
            }

            const gB = FIREFLIES.list[idxB];
            if (gB && gB !== f) {
              const rx = f.x - gB.x;
              const ry = f.y - gB.y;
              const rd2 = rx * rx + ry * ry + 0.0001;
              if (rd2 < repelR2) {
                const inv = 1 / Math.sqrt(rd2);
                const repelScale = (repelK * (1 - rd2 / repelR2)) * dt * invZ / 120;
                f.vx += rx * inv * repelScale;
                f.vy += ry * inv * repelScale;
              }
            }
          }

          if (burstEase > 0.001 && dist > 0) {
            const invDist = 1 / dist;
            const normX = dx * invDist;
            const normY = dy * invDist;
            const tangentX = -normY;
            const tangentY = normX;
            const falloff = clamp(1 - dist / (pullR * 1.1), 0, 1);
            const swirlAmt = swirlStrength * falloff * dt * invZ;
            const radialAmt = radialStrength * (0.4 + 0.6 * falloff) * dt * invZ;

            switch (burstVariant) {
              case 'cascade': {
                const pulse = Math.sin(burstProgress * 7 + f.phase + burstWaveOffset);
                const pulseForce = radialAmt * (0.45 + 0.55 * pulse);
                f.vx += normX * pulseForce;
                f.vy += normY * pulseForce;
                f.vx += tangentX * swirlDir * swirlAmt * 0.65;
                f.vy += tangentY * swirlDir * swirlAmt * 0.65;
                break;
              }
              case 'aurora': {
                const wave = Math.sin(FIREFLIES.t * 4.5 + f.phase + burstWaveOffset);
                const waveForce = waveStrength * wave * dt * invZ * (0.6 + 0.4 * falloff);
                f.vx += tangentX * waveForce;
                f.vy += tangentY * waveForce;
                f.vx += normX * radialAmt * 0.3;
                f.vy += normY * radialAmt * 0.3;
                break;
              }
              default: {
                f.vx += tangentX * swirlDir * swirlAmt;
                f.vy += tangentY * swirlDir * swirlAmt;
                f.vx += normX * radialAmt * 0.2;
                f.vy += normY * radialAmt * 0.2;
                break;
              }
            }

            const jitter = (Math.random() - 0.5) * jitterStrength * dt * invZ;
            f.vx += tangentX * jitter;
            f.vy += tangentY * jitter;

            if (burstVariant === 'aurora') {
              f.hue = (f.hue + 18 * burstEase * dt * 60) % 360;
            } else {
              f.hue = (f.hue + 6 * burstEase * dt * 60) % 360;
            }
          }

          const settle = motionActivity > 0 ? lerp(0.00004, 0.00012, motionActivity) : 0;
          f.vx += (W * 0.5 - f.x) * settle;
          f.vy += (H * 0.5 - f.y) * settle;

          const maxLocal = Math.max(0.0002, maxSpeed * invZ);
          const maxLocalSq = maxLocal * maxLocal;
          const magSq = f.vx * f.vx + f.vy * f.vy;
          if (magSq > maxLocalSq && magSq > 0) {
            const scale = maxLocal / Math.sqrt(magSq);
            f.vx *= scale;
            f.vy *= scale;
          }

          f.vx *= damp;
          f.vy *= damp;
          f.x += f.vx * velScale;
          f.y += f.vy * velScale;

          const wrapped = flyWrap(f);
          if (!wrapped) {
            const hopX = Math.abs(f.x - f.px);
            const hopY = Math.abs(f.y - f.py);
            if (hopX > hopXLimit || hopY > hopYLimit) {
              f.px = f.x;
              f.py = f.y;
            }
          }

          f.phase += dt * (0.7 + 1.1 * motionActivity + burstEase * 1.6);
          const twinkle = 0.5 + 0.5 * Math.sin(f.phase + f.x * 0.01 + f.y * 0.01);
          const baseGlow = (0.20 + 0.26 * twinkle) * brightness;
          f.glow = clamp(baseGlow + near * (0.52 + 0.38 * visualActivity) + glowBoost, 0.18, 2.2);
        }

        const trailAlpha = clamp((0.03 + 0.12 * visualActivity) * brightness, 0, 0.85);
        const baseTrailW = 0.8 + 1.5 * visualActivity * brightness;
        const sizeBoost = (1.42 + 0.32 * brightness) + 0.26 * burstEase;
        const bloomScale = 4.0 + 6.5 * visualActivity * brightness;
        const coreAlpha = clamp((0.22 + 0.28 * visualActivity) * brightness, 0, 0.72);
        const bloomBase = clamp((0.06 + 0.12 * visualActivity) * brightness, 0, 0.5);

        ctx.lineCap = 'round';
        ctx.globalCompositeOperation = 'screen';
        for (let i = 0; i < N; i++) {
          const f = FIREFLIES.list[i];
          ctx.strokeStyle = `hsla(${(f.hue + 30) | 0}, 90%, 72%, ${trailAlpha})`;
          ctx.lineWidth = Math.max(0.6, baseTrailW * f.invZ);
          ctx.beginPath();
          ctx.moveTo(f.px, f.py);
          ctx.lineTo(f.x, f.y);
          ctx.stroke();

          const coreR = sizeBoost * (2.2 + 4.0 * f.glow) * f.invZ;
          const bloomR = coreR * bloomScale;

          const aCore = coreAlpha;
          const aBloom = bloomBase * clamp(f.glow / 3.2, 0.35, 0.95);

          drawFirefly(f, coreR, bloomR, aCore, aBloom);
        }
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
      }

      function drawPulseOverlay() {
        if (pulseFlash <= 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = Math.pow(pulseFlash, 1.25) * 0.55;
        const radius = Math.max(W, H) * 0.55;
        const grad = ctx.createRadialGradient(burstFocus.x, burstFocus.y, radius * 0.15, burstFocus.x, burstFocus.y, radius);
        grad.addColorStop(0.0, 'rgba(140, 255, 230, 0.85)');
        grad.addColorStop(0.45, 'rgba(60, 180, 255, 0.35)');
        grad.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }

      function triggerBurst() {
        const now = performance.now();
        if (now - lastBurstTime < 180) return;
        lastBurstTime = now;

        pulseBoost = Math.min(1, Math.max(pulseBoost, 0.65) + 0.45);
        pulseFlash = 1;
        burstFocus.x = W * (0.15 + Math.random() * 0.7);
        burstFocus.y = H * (0.18 + Math.random() * 0.64);

        burstTimer = BURST_DURATION;
        const selectedEffect = effectSelect?.value || 'swirl';
        const variantPool = EFFECT_VARIANTS[selectedEffect] || BURST_VARIANTS;
        burstVariant = variantPool[Math.floor(Math.random() * variantPool.length)];
        swirlDir = Math.random() < 0.5 ? -1 : 1;
        burstWaveOffset = Math.random() * Math.PI * 2;

        const boostBase = 0.34 + Math.random() * 0.42;
        for (const f of FIREFLIES.list) {
          const angle = Math.atan2(burstFocus.y - f.y, burstFocus.x - f.x) + (Math.random() - 0.5) * 0.9;
          const strength = boostBase * (0.5 + Math.random() * 0.9);
          f.vx += Math.cos(angle) * strength;
          f.vy += Math.sin(angle) * strength;
          f.glow = Math.max(f.glow, 0.95 + Math.random() * 0.7);
          f.hue = (f.hue + 12 + Math.random() * 34) % 360;
        }
        playPing(520 + Math.random() * 160);
      }

      function resizeCanvas() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        burstFocus.x = W * 0.5;
        burstFocus.y = H * 0.5;
        firefliesInit();
        clearToBg(true);
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      function frame(now) {
        if (!running) return;
        if (!lastFrame) lastFrame = now;
        const dt = Math.min(0.1, (now - lastFrame) / 1000);
        lastFrame = now;

        const intensity = mapIntensity();

        renderFireflies(dt, intensity);
        drawPulseOverlay();
        pulseBoost = Math.max(0, pulseBoost - dt * (0.16 + 0.26 * intensity));
        pulseFlash = Math.max(0, pulseFlash - dt * 1.4);
        if (burstTimer > 0) {
          burstTimer = Math.max(0, burstTimer - dt);
        }

        animationId = requestAnimationFrame(frame);
      }

      function startExperience() {
        if (running) return;
        running = true;
        document.body.classList.add('playing');
        if (gameOptions) {
          gameOptions.classList.add('hidden');
          setTimeout(() => {
            if (gameOptions && gameOptions.parentElement) {
              gameOptions.parentElement.removeChild(gameOptions);
            }
          }, 400);
        }

        if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen().catch(() => {});
        }

        ensureAudioCtx();
        resumeAudioCtx();
        applySoundPreference();

        lastFrame = performance.now();
        animationId = requestAnimationFrame(frame);
      }

      function stopExperience() {
        running = false;
        document.body.classList.remove('playing');
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        if (musicWanted) {
          music.pause();
        }
      }

      startButton?.addEventListener('click', startExperience);
      startButton?.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          startExperience();
        }
      });

      document.addEventListener('keydown', (ev) => {
        if (ev.code === 'Space' || ev.key === ' ') {
          ev.preventDefault();
          if (!running) {
            startExperience();
          } else {
            triggerBurst();
          }
        }
        if (ev.key === 'm' || ev.key === 'M') {
          musicWanted = !musicWanted;
          if (soundToggle) {
            soundToggle.checked = musicWanted;
          }
          applySoundPreference();
        }
      });

      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && running && musicWanted) {
          const p = music.play();
          if (p && p.catch) p.catch(() => {});
        }
      });

      ['pointerdown', 'touchstart', 'keydown'].forEach((evName) => {
        document.addEventListener(evName, () => {
          ensureAudioCtx();
          resumeAudioCtx();
        }, { once: true, passive: true });
      });

      window.addEventListener('beforeunload', stopExperience);
    });
  </script>
</body>
</html>
