<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Pictogram Customizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <!-- Use your existing light-theme CSS stack -->
  <link rel="stylesheet" href="../../css/choix.css"/>
  <link rel="stylesheet" href="../../css/cvigenerator.css"/>

  <style>
    :root { --accent:#009688; --line:#e6eaef; }
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#fff; color:#000; font-family:Arial, sans-serif; }
    .app-container { display:flex; height:100vh; width:100%; }

    /* Left sidebar (use your classes; these keep spacing consistent) */
    #menu {
      width:30vw; min-width:260px; max-width:520px; padding:20px;
      background:#fff; color:#000; border-right:4px solid var(--accent);
      overflow-y:auto; box-sizing:border-box;
    }
    #menu h2 {
      margin:0 0 1rem; color:var(--accent); font-size:1.5rem;
      border-bottom:2px solid var(--accent); padding-bottom:.5rem; text-align:center;
    }
    .group { box-shadow:0 1px 4px rgba(0,0,0,0.15); border-radius:6px; padding:1rem 1.2rem; background:#fff; margin:1rem 0; }
    .group h3 { margin:0 0 .6rem; color:#333; }
    .row { display:flex; align-items:center; gap:.6rem; margin:.5rem 0; }
    .row input[type="text"], .row input[type="number"], .row select {
      flex:1; padding:.6rem .75rem; border:1px solid var(--line); border-radius:6px; background:#fff; color:#000;
    }
    .row input[type="color"]{ width:42px; height:32px; border:none; background:transparent; padding:0; }
    .row input[type="range"]{ flex:1; }

    .inline { display:flex; align-items:center; justify-content:space-between; background:#eefaf8; border:1px solid #bfe7e1; padding:.55rem .7rem; border-radius:6px; }
    .export-btn {
      display:inline-block; padding:10px 16px; margin:4px;
      font-size:1rem; background:var(--accent); color:#fff;
      border:none; border-radius:4px; cursor:pointer;
    }
    .export-btn.alt { background:#fff; color:var(--accent); border:2px solid var(--accent); }
    .muted { color:#666; font-size:.9rem; }

    /* Right preview area – match your page */
    #content { flex:1; display:flex; justify-content:center; align-items:center; background:#f3f4f6; }
    #previewCanvas { width:min(72vmin,860px); height:min(72vmin,860px); background:#fff; border:1px solid var(--line); border-radius:10px; }

    /* Toolbar */
    #toolbar{
      position:fixed; right:20px; bottom:20px; display:flex; gap:10px; flex-wrap:wrap;
      background:#fff; border:1px solid var(--line); border-radius:10px; padding:10px;
      box-shadow:0 8px 24px rgba(0,0,0,.08);
    }

    /* Modal — same style family as your other page */
    .modal {
      display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6);
      justify-content:center; align-items:flex-start; padding-top:5%;
      opacity:0; transition:opacity .25s ease; z-index:2000; pointer-events:none;
    }
    .modal.show { display:flex; opacity:1; pointer-events:auto; }
    .modal-content {
      background:#fff; color:#000; border:2px solid var(--accent);
      border-radius:6px; padding:16px; width:min(1100px,92vw); max-height:80vh; overflow:auto;
    }
    .modal-content h3 { margin-top:0; color:var(--accent); }

    .gm-toolbar { display:flex; gap:.5rem; align-items:center; margin-bottom:.6rem; }
    .gm-toolbar input[type="text"]{ flex:1; padding:.6rem .75rem; border:1px solid var(--line); border-radius:6px; }
    .gm-grid { --cell:120px; display:grid; grid-template-columns:repeat(auto-fill, minmax(var(--cell), 1fr)); gap:10px; }
    .gm-item { border:1px solid var(--line); border-radius:8px; background:#fff; aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; cursor:pointer; }
    .gm-item img { width:100%; height:100%; object-fit:contain; }
    .gm-item:hover { box-shadow:0 1px 4px rgba(0,0,0,.2); }
    .gm-footer { margin-top:10px; display:flex; align-items:center; gap:10px; color:#444; }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- ===== LEFT: options (full set of controls restored) ===== -->
    <aside id="menu">
      <h2>Pictogram Customizer</h2>

      <!-- Image source -->
      <div class="group">
        <h3>Image</h3>
        <div class="row" style="justify-content:center;">
          <button id="openGalleryBtn" class="export-btn">Open folder gallery</button>
          <input id="uploadInput" type="file" accept="image/*" multiple style="display:none;">
          <button id="uploadBtn" class="export-btn alt">Upload…</button>
        </div>
        <div class="row">
          <input id="pathInput" type="text" placeholder="apple.png or ../path/to/file.png">
          <button id="loadPathBtn" class="export-btn alt">Load</button>
        </div>
        <div class="muted">Folder: <code>../../images/pictos/</code></div>
      </div>

      <!-- Export -->
      <div class="group">
        <h3>Export</h3>
        <div class="row">
          <label style="flex:1">PNG size (px)
            <input id="sizePx" type="range" min="128" max="2048" step="128" value="512">
          </label>
          <span id="sizePxVal">512</span>
        </div>
      </div>

      <!-- Background & Shape -->
      <div class="group">
        <h3>Background / Shape</h3>
        <div class="row inline">
          <span>Transparent background</span>
          <input id="bgTransparent" type="checkbox" checked>
        </div>
        <div class="row">
          <label>Color <input id="bgColor" type="color" value="#ffffff"></label>
          <label style="flex:1">Shape
            <select id="bgShape">
              <option value="none">None</option>
              <option value="rounded" selected>Rounded square</option>
              <option value="circle">Circle</option>
              <option value="roundedRect">Rounded rectangle</option>
            </select>
          </label>
        </div>
        <div class="row">
          <label style="flex:1">Corner radius (%) <input id="cornerPct" type="range" min="0" max="50" value="22"></label>
          <label style="flex:1">Padding (%) <input id="paddingPct" type="range" min="0" max="40" value="10"></label>
        </div>
        <div class="row inline">
          <span>Border</span><input id="strokeOn" type="checkbox">
        </div>
        <div class="row">
          <label>Color <input id="strokeColor" type="color" value="#000000"></label>
          <label style="flex:1">Thickness (%) <input id="strokePct" type="range" min="0" max="8" value="2"></label>
        </div>
        <div class="row inline">
          <span>Shadow</span><input id="shadowOn" type="checkbox">
        </div>
      </div>

      <!-- Icon -->
      <div class="group">
        <h3>Icon</h3>
        <div class="row">
          <label style="flex:1">Tint (%) <input id="tintPct" type="range" min="0" max="100" value="0"></label>
          <label>Color <input id="tintColor" type="color" value="#000000"></label>
        </div>
        <div class="row">
          <label style="flex:1">Scale (%) <input id="iconScalePct" type="range" min="40" max="110" value="100"></label>
        </div>
      </div>

      <!-- Label -->
      <div class="group">
        <h3>Label</h3>
        <div class="row"><input id="labelText" type="text" placeholder="Optional text"></div>
        <div class="row">
          <label>Size (px) <input id="labelSize" type="number" min="8" max="240" value="64"></label>
          <label>Color <input id="labelColor" type="color" value="#000000"></label>
        </div>
        <div class="row inline">
          <span>Banner behind text</span><input id="labelBandOn" type="checkbox" checked>
        </div>
        <div class="row">
          <label>Banner color <input id="labelBandColor" type="color" value="#ffffff"></label>
          <label style="flex:1">Banner padding (%) <input id="labelBandPadPct" type="range" min="0" max="20" value="6"></label>
        </div>
      </div>

      <!-- Download -->
      <h3 style="text-align:center; margin-top:1rem;">Download</h3>
      <div class="export-section" style="display:flex; justify-content:center;">
        <button id="downloadBtn" class="export-btn">Download PNG</button>
      </div>
    </aside>

    <!-- ===== RIGHT: preview (canvas) ===== -->
    <main id="content">
      <canvas id="previewCanvas" width="1024" height="1024" aria-label="Preview"></canvas>

      <div id="toolbar">
        <button id="fitBtn"     class="export-btn alt" title="Fit preview">Fit</button>
        <button id="clearBtn"   class="export-btn alt" title="Clear image">Clear</button>
      </div>
    </main>
  </div>

  <!-- ===== Folder gallery modal ===== -->
  <div id="galleryModal" class="modal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-label="Folder gallery">
      <h3>Folder gallery</h3>
      <div class="gm-toolbar">
        <input id="gmSearch" type="text" placeholder="Filter…">
        <label>Thumb size <input id="gmSize" type="range" min="90" max="220" value="120"></label>
        <button id="gmReload" class="export-btn alt">Reload</button>
        <button id="gmClose"  class="export-btn">Close</button>
      </div>
      <div id="gmStatus" style="margin:.25rem 0 .75rem; color:#444;"></div>
      <div id="gmGrid" class="gm-grid"></div>
      <div class="gm-footer">
        <span id="gmCount">0</span>
        <span style="margin-left:auto;">Source: <code>../../images/pictos/index.json</code></span>
      </div>
    </div>
  </div>

  <script>
    // ===== Canvas & state =====
    const cvs = document.getElementById('previewCanvas');
    const ctx = cvs.getContext('2d');

    const sizePx = document.getElementById('sizePx');
    const sizePxVal = document.getElementById('sizePxVal');
    const bgTransparent = document.getElementById('bgTransparent');
    const bgShape = document.getElementById('bgShape');
    const bgColor = document.getElementById('bgColor');
    const cornerPct = document.getElementById('cornerPct');
    const paddingPct = document.getElementById('paddingPct');
    const strokeOn = document.getElementById('strokeOn');
    const strokeColor = document.getElementById('strokeColor');
    const strokePct = document.getElementById('strokePct');
    const shadowOn = document.getElementById('shadowOn');
    const tintPct = document.getElementById('tintPct');
    const tintColor = document.getElementById('tintColor');
    const iconScalePct = document.getElementById('iconScalePct');
    const labelText = document.getElementById('labelText');
    const labelSize = document.getElementById('labelSize');
    const labelColor = document.getElementById('labelColor');
    const labelBandOn = document.getElementById('labelBandOn');
    const labelBandColor = document.getElementById('labelBandColor');
    const labelBandPadPct = document.getElementById('labelBandPadPct');

    const fitBtn = document.getElementById('fitBtn');
    const clearBtn = document.getElementById('clearBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    const openGalleryBtn = document.getElementById('openGalleryBtn');
    const uploadInput = document.getElementById('uploadInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const pathInput = document.getElementById('pathInput');
    const loadPathBtn = document.getElementById('loadPathBtn');

    // Gallery modal
    const galleryModal = document.getElementById('galleryModal');
    const gmGrid = document.getElementById('gmGrid');
    const gmSearch = document.getElementById('gmSearch');
    const gmSize = document.getElementById('gmSize');
    const gmStatus = document.getElementById('gmStatus');
    const gmReload = document.getElementById('gmReload');
    const gmClose = document.getElementById('gmClose');
    const gmCount = document.getElementById('gmCount');

    let img = null;               // current image element
    let exportSize = parseInt(sizePx.value,10);
    let manifest = null;          // { base, files }
    let gridItems = [];           // for filter

    // ===== Drawing helpers =====
    function roundRectPath(ctx, x, y, w, h, r){
      const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawShape(ctx, shape, x, y, w, h, radiusPct){
      if (shape === 'none') return;
      if (shape === 'circle'){
        const cx = x + w/2, cy = y + h/2, r = Math.min(w,h)/2;
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.closePath();
      } else {
        const rr = (Math.min(w,h) * (radiusPct/100));
        roundRectPath(ctx, x, y, w, h, rr);
      }
    }
    function drawLabel(ctx, text, sizePx, color, bandOn, bandColor, bandPad, box){
      if (!text) return 0;
      ctx.save();
      ctx.font = `600 ${sizePx}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const metrics = ctx.measureText(text);
      const ascent = metrics.actualBoundingBoxAscent || sizePx * 0.8;
      const descent = metrics.actualBoundingBoxDescent || sizePx * 0.2;
      const textH = ascent + descent;
      const pad = box.w * bandPad;
      const bandH = textH + pad*2;

      if (bandOn){
        ctx.fillStyle = bandColor;
        roundRectPath(ctx, box.x, box.y + box.h - bandH, box.w, bandH, Math.min(16, bandH*0.3));
        ctx.fill();
      }
      ctx.fillStyle = color;
      ctx.fillText(text, box.x + box.w/2, box.y + box.h - bandH/2);
      ctx.restore();
      return bandH;
    }
    function drawTinted(ctx, image, dx, dy, dw, dh, color, alpha){
      ctx.save();
      ctx.drawImage(image, dx, dy, dw, dh);
      if (alpha > 0){
        ctx.globalCompositeOperation = 'source-atop';
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.fillRect(dx, dy, dw, dh);
      }
      ctx.restore();
    }

    function render(size=cvs.width){
      cvs.width = cvs.height = size;
      ctx.clearRect(0,0,size,size);

      const padPct = parseFloat(paddingPct.value)/100;
      const corner = parseFloat(cornerPct.value);
      const shape = bgShape.value;
      const transparent = bgTransparent.checked;
      const strokeEnabled = strokeOn.checked;
      const strokeW = (parseFloat(strokePct.value)/100) * size;
      const shadow = shadowOn.checked;

      const label = labelText.value.trim();
      const labelPx = parseInt(labelSize.value,10);
      const labelCol = labelColor.value;
      const bandOn = labelBandOn.checked;
      const bandCol = labelBandColor.value;
      const bandPadPct = parseFloat(labelBandPadPct.value)/100;

      const box = { x:0, y:0, w:size, h:size };

      // Background
      if (!transparent){
        if (shadow && shape !== 'none'){
          ctx.save();
          ctx.shadowColor = 'rgba(0,0,0,0.35)';
          ctx.shadowBlur = Math.max(2, size*0.02);
          ctx.shadowOffsetY = size*0.01;
        }
        ctx.fillStyle = bgColor.value;
        if (shape === 'none'){
          ctx.fillRect(box.x, box.y, box.w, box.h);
        } else {
          drawShape(ctx, shape, box.x, box.y, box.w, box.h, corner);
          ctx.fill();
        }
        if (shadow && shape !== 'none'){ ctx.restore(); }
      }

      // Reserve banner height
      let reservedBottom = 0;
      if (label){
        const tmp = document.createElement('canvas');
        const tctx = tmp.getContext('2d');
        reservedBottom = drawLabel(tctx, label, labelPx, labelCol, bandOn, bandCol, bandPadPct, box);
      }

      // Inner area for icon
      const inner = {
        x: box.x + size*padPct,
        y: box.y + size*padPct,
        w: box.w - size*padPct*2,
        h: box.h - size*padPct*2 - reservedBottom
      };

      if (img){
        const scalePct = parseFloat(iconScalePct.value)/100;
        const aspect = img.width / img.height;
        let dw = inner.w * scalePct;
        let dh = dw / aspect;
        if (dh > inner.h * scalePct){
          dh = inner.h * scalePct;
          dw = dh * aspect;
        }
        const dx = inner.x + (inner.w - dw)/2;
        const dy = inner.y + (inner.h - dh)/2;
        const a = parseFloat(tintPct.value)/100;
        drawTinted(ctx, img, dx, dy, dw, dh, tintColor.value, a);
      }

      // Border
      if (strokeEnabled && shape !== 'none'){
        ctx.save();
        ctx.lineWidth = Math.max(1, strokeW);
        ctx.strokeStyle = strokeColor.value;
        drawShape(ctx, shape, box.x + ctx.lineWidth/2, box.y + ctx.lineWidth/2, box.w - ctx.lineWidth, box.h - ctx.lineWidth, corner);
        ctx.stroke();
        ctx.restore();
      }

      // Label
      if (label){
        drawLabel(ctx, label, labelPx, labelCol, bandOn, bandCol, bandPadPct, box);
      }
    }

    function fitPreview(){
      const s = Math.min(window.innerWidth - 360, window.innerHeight - 100);
      const size = Math.max(256, Math.min(1024, Math.floor(s)));
      render(size);
    }
    window.addEventListener('resize', fitPreview);

    // Wire inputs -> render
    [
      sizePx, bgTransparent, bgShape, bgColor, cornerPct, paddingPct,
      strokeOn, strokeColor, strokePct, shadowOn,
      tintPct, tintColor, iconScalePct,
      labelText, labelSize, labelColor, labelBandOn, labelBandColor, labelBandPadPct
    ].forEach(el => el.addEventListener('input', ()=>{
      exportSize = parseInt(sizePx.value,10);
      sizePxVal.textContent = exportSize;
      render(cvs.width);
    }));

    clearBtn.addEventListener('click', ()=>{ img=null; render(); });
    fitBtn.addEventListener('click', fitPreview);

    // Export PNG
    downloadBtn.addEventListener('click', ()=>{
      const off = document.createElement('canvas');
      const octx = off.getContext('2d');
      off.width = off.height = exportSize;
      // render to offscreen at export size
      const prev = cvs.width;
      render(exportSize);
      octx.drawImage(cvs,0,0,exportSize,exportSize);
      // restore preview
      render(prev);

      off.toBlob((blob)=>{
        const label = (labelText.value.trim() || 'pictogram').toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9-_]/g,'');
        const a = document.createElement('a');
        a.download = `${label}-${exportSize}.png`;
        a.href = URL.createObjectURL(blob);
        a.click();
        setTimeout(()=> URL.revokeObjectURL(a.href), 800);
      }, 'image/png');
    });

    // ===== Image loading: upload / path =====
    uploadBtn.onclick = ()=> uploadInput.click();
    uploadInput.onchange = e=>{
      const file = e.target.files?.[0]; if(!file) return;
      const url = URL.createObjectURL(file);
      const im = new Image();
      im.onload = ()=>{ img = im; render(); URL.revokeObjectURL(url); };
      im.src = url;
    };

    loadPathBtn.onclick = ()=>{
      const name = pathInput.value.trim(); if(!name) return;
      const base = '../../images/pictos/';
      const path = (name.startsWith('../')||name.startsWith('./')||name.startsWith('/')) ? name : (base + name);
      const im = new Image(); im.crossOrigin='anonymous';
      im.onload = ()=>{ img = im; render(); };
      im.onerror = ()=> alert('Cannot load: ' + path);
      im.src = path;
    };

    // ===== Folder gallery modal (uses index.json) =====
    function showModal(){ galleryModal.classList.add('show'); }
    function hideModal(){ galleryModal.classList.remove('show'); }
    openGalleryBtn.onclick = ()=>{ showModal(); buildGrid(); };
    gmClose.onclick = hideModal;
    gmReload.onclick = async ()=>{ manifest=null; await buildGrid(); };
    gmSize.oninput = ()=> document.querySelector('.gm-grid').style.setProperty('--cell', gmSize.value+'px');
    gmSearch.oninput = ()=> filterGrid(gmSearch.value.trim().toLowerCase());
    document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='g') { showModal(); buildGrid(); } });

    async function fetchManifest(){
      const res = await fetch('../../images/pictos/index.json', {cache:'no-store'});
      if(!res.ok) throw new Error(res.status + ' ' + res.statusText);
      const data = await res.json();
      if(!data || !Array.isArray(data.files)) throw new Error('Invalid manifest format');
      return data;
    }
    async function buildGrid(){
      gmStatus.textContent = 'Loading…';
      gmGrid.innerHTML = '';
      try{
        manifest = manifest || await fetchManifest();
        const base = manifest.base || '../../images/pictos/';
        gridItems = manifest.files.map(fn => ({ name: fn, src: base + fn }));
        gmStatus.textContent = `Found ${gridItems.length} file(s).`;
        renderGrid(gridItems);
      }catch(err){
        gmStatus.innerHTML = `<span style="color:#b00">Could not load manifest: ${String(err)}</span><br><small>Ensure <code>index.json</code> exists.</small>`;
      }
    }
    function renderGrid(list){
      gmGrid.innerHTML = '';
      list.forEach(item=>{
        const cell = document.createElement('button'); cell.className='gm-item'; cell.title=item.name;
        const im = document.createElement('img'); im.loading='lazy'; im.alt=item.name; im.src=item.src; cell.appendChild(im);
        cell.onclick = ()=>{
          const imageEl = new Image(); imageEl.crossOrigin='anonymous';
          imageEl.onload = ()=>{ img = imageEl; render(); hideModal(); };
          imageEl.src = item.src;
        };
        gmGrid.appendChild(cell);
      });
      gmCount.textContent = list.length + ' items';
    }
    function filterGrid(q){
      const arr = q ? gridItems.filter(it => it.name.toLowerCase().includes(q)) : gridItems;
      renderGrid(arr);
    }

    // ===== Defaults =====
    sizePxVal.textContent = sizePx.value;
    // Friendly defaults for nice look
    bgShape.value = 'rounded';
    cornerPct.value = 22;
    paddingPct.value = 10;
    strokeOn.checked = false;
    labelBandOn.checked = true;
    labelBandColor.value = '#ffffff';
    labelBandPadPct.value = 6;

    fitPreview();
  </script>
</body>
</html>
