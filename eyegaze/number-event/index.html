<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title class="translate" data-fr="Nombre-événement" data-en="Number as Event" data-ja="イベントとしての数">Nombre-événement</title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #e2e8f0;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
    }

    #langToggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 2000;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 2px solid #14b8a6;
      background: rgba(5, 9, 21, 0.85);
      color: #a5f3fc;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
    }

    #game-options.modal {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #control-panel-options {
      max-width: 980px;
    }

    .intro-text {
      margin: 0 0 12px;
      line-height: 1.5;
      color: #0f172a;
      background: linear-gradient(120deg, rgba(94, 234, 212, 0.18), rgba(96, 165, 250, 0.16));
      border: 1px solid rgba(94, 234, 212, 0.35);
      padding: 12px 14px;
      border-radius: 12px;
    }

    #game-options-controls {
      display: flex;
      justify-content: center;
      gap: 14px;
      padding-bottom: 10px;
    }

    .scene {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: inherit;
    }

    #burstCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      mix-blend-mode: screen;
    }

    #hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 14px;
      background: rgba(5, 9, 21, 0.6);
      border: 1px solid rgba(94, 234, 212, 0.35);
      border-radius: 12px;
      color: #e0f2fe;
      font-weight: 600;
      z-index: 3;
      text-align: center;
      backdrop-filter: blur(6px);
    }

    #gazePointer {
      position: absolute;
      width: 60px;
      height: 60px;
      margin-left: -30px;
      margin-top: -30px;
      border-radius: 50%;
      pointer-events: none;
      background: radial-gradient(circle, rgba(94, 234, 212, 0.24) 0%, rgba(94, 234, 212, 0.07) 60%, transparent 70%);
      border: 2px solid rgba(94, 234, 212, 0.9);
      box-shadow: 0 0 20px rgba(94, 234, 212, 0.55), 0 0 40px rgba(96, 165, 250, 0.35);
      transition: transform 0.16s ease, opacity 0.2s ease;
      opacity: 0;
      z-index: 2;
    }

    body.playing #gazePointer { opacity: 1; }
    body.pointer-hidden #gazePointer { opacity: 0 !important; }

    .caption {
      color: #0f172a;
      margin-top: 6px;
      font-size: 14px;
      line-height: 1.4;
    }

    body.playing #game-options { display: none !important; }
    body.playing #hint, body.playing #langToggle { display: none !important; }
  </style>
</head>
<body>
  <button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title" class="translate" data-fr="Nombre-événement" data-en="Number as Event" data-ja="イベントとしての数">Nombre-événement</h2>
    </div>

    <div id="control-panel-options">
      <p class="intro-text translate" data-fr="Fixe l'écran : chaque regard déclenche une voix qui annonce un nombre, puis exactement autant d'éclats lumineux." data-en="Look at the screen: every gaze cues a spoken number, followed by the same count of light blooms." data-ja="画面を見つめると、数が読み上げられ、その数だけ光のイベントが起こります。">Fixe l'écran : chaque regard déclenche une voix qui annonce un nombre, puis exactement autant d'éclats lumineux.</p>

      <div id="mode-divider"></div>
      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label for="maxNumber" class="teal-label">
              <span class="translate" data-fr="Nombre maximum" data-en="Highest number" data-ja="最大の数">Nombre maximum</span>:
              <span id="maxNumberVal">5</span>
            </label>
            <input type="range" id="maxNumber" class="styled-slider" min="1" max="9" value="5">
          </div>
          <div class="option-item">
            <label for="cooldown" class="teal-label">
              <span class="translate" data-fr="Rythme minimum" data-en="Minimum pace" data-ja="最小の間隔">Rythme minimum</span>:
              <span id="cooldownVal">1.8</span> s
            </label>
            <input type="range" id="cooldown" class="styled-slider" min="0.8" max="3.5" step="0.1" value="1.8">
            <div class="caption translate" data-fr="Temps minimum entre deux déclenchements." data-en="Minimum time between triggers." data-ja="連続の発動までの最小時間です。">Temps minimum entre deux déclenchements.</div>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="voiceVol" class="teal-label">
              <span class="translate" data-fr="Volume de la voix" data-en="Voice volume" data-ja="音声の音量">Volume de la voix</span>:
              <span id="voiceVolVal">100</span>%
            </label>
            <input type="range" id="voiceVol" class="styled-slider" min="20" max="100" value="100">
          </div>
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="softChime" checked>
              <span class="translate" data-fr="Tintement doux avec chaque nombre" data-en="Soft chime with each number" data-ja="数ごとにやさしいチャイム">Tintement doux avec chaque nombre</span>
            </label>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="dwellTimeSlider" class="teal-label">
              <span class="translate" data-fr="Temps de fixation" data-en="Dwell time" data-ja="注視時間">Temps de fixation</span>:
              <span id="dwellTimeVal">1500</span> ms
            </label>
            <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="4000" step="100" value="1500">
          </div>
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="showPointer" checked>
              <span class="translate" data-fr="Afficher l'onde du regard" data-en="Show gaze ripple" data-ja="視線の波紋を表示">Afficher l'onde du regard</span>
            </label>
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <div id="game-options-controls">
        <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
      </div>
    </div>
  </div>

  <div id="scene" class="scene" aria-live="polite">
    <canvas id="burstCanvas"></canvas>
    <div id="gazePointer"></div>
    <div id="hint" class="translate" data-fr="Fixe n'importe où : un nombre sera prononcé et la même quantité d'éclats apparaîtra." data-en="Look anywhere: a number will be spoken and the same count of bursts will appear." data-ja="どこを見ても、その数だけ光のイベントが現れます。">Fixe n'importe où : un nombre sera prononcé et la même quantité d'éclats apparaîtra.</div>
  </div>

  <audio id="chimeSound" src="../../sounds/harp.mp3" preload="auto"></audio>

  <script src="../../js/eyegaze-menu.js"></script>
  <script src="../../js/translationmain.js"></script>
  <script>
    const startButton = document.getElementById('startButton');
    const scene = document.getElementById('scene');
    const gazePointer = document.getElementById('gazePointer');
    const maxNumber = document.getElementById('maxNumber');
    const maxNumberVal = document.getElementById('maxNumberVal');
    const cooldown = document.getElementById('cooldown');
    const cooldownVal = document.getElementById('cooldownVal');
    const dwellSlider = document.getElementById('dwellTimeSlider');
    const dwellVal = document.getElementById('dwellTimeVal');
    const voiceVol = document.getElementById('voiceVol');
    const voiceVolVal = document.getElementById('voiceVolVal');
    const softChime = document.getElementById('softChime');
    const showPointer = document.getElementById('showPointer');
    const chimeSound = document.getElementById('chimeSound');
    const langBtn = document.getElementById('langToggle');
    const hint = document.getElementById('hint');

    let gazePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let lastMove = performance.now();
    let lastTrigger = 0;
    let playing = false;
    const burstCanvas = document.getElementById('burstCanvas');
    const ctx = burstCanvas.getContext('2d');
    let bursts = [];
    let rafId = null;

    const numberWords = {
      fr: ['un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit', 'neuf'],
      en: ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'],
      ja: ['いち', 'に', 'さん', 'よん', 'ご', 'ろく', 'なな', 'はち', 'きゅう']
    };

    function clamp(num, min, max) {
      return Math.min(Math.max(num, min), max);
    }

    function updateLabels() {
      maxNumberVal.textContent = maxNumber.value;
      cooldownVal.textContent = Number(cooldown.value).toFixed(1);
      voiceVolVal.textContent = voiceVol.value;
      dwellVal.textContent = dwellSlider.value;
    }

    function requestFullscreenIfPossible() {
      const el = document.documentElement;
      if (!document.fullscreenElement && el.requestFullscreen) {
        el.requestFullscreen().catch(() => {});
      }
    }

    function randomBetween(min, max) {
      return Math.random() * (max - min) + min;
    }

    function pickPalette() {
      const palettes = [
        ['#7dd3fc', '#38bdf8', '#0ea5e9', '#0369a1'],
        ['#f9a8d4', '#f472b6', '#db2777', '#9d174d'],
        ['#facc15', '#f59e0b', '#ea580c', '#b45309'],
        ['#a7f3d0', '#34d399', '#10b981', '#0f766e']
      ];
      return palettes[Math.floor(Math.random() * palettes.length)];
    }

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      burstCanvas.width = window.innerWidth * dpr;
      burstCanvas.height = window.innerHeight * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function drawParticle(p, now) {
      const lifeRatio = Math.min(1, (now - p.start) / p.life);
      const ease = lifeRatio * (2 - lifeRatio);
      const px = p.x + p.vx * ease;
      const py = p.y + p.vy * ease;
      const size = p.size * (1 + ease * 0.45);
      const alpha = (1 - lifeRatio) * 0.9;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(px, py);
      ctx.rotate(p.rotation);

      switch (p.shape) {
        case 'orb': {
          const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
          grad.addColorStop(0, `${p.color}ff`);
          grad.addColorStop(0.6, `${p.color}66`);
          grad.addColorStop(1, `${p.color}00`);
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(0, 0, size, 0, Math.PI * 2);
          ctx.fill();
          break;
        }
        case 'diamond': {
          const gradient = ctx.createLinearGradient(-size, -size, size, size);
          gradient.addColorStop(0, `${p.color}aa`);
          gradient.addColorStop(1, `${p.color}22`);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(0, -size * 1.2);
          ctx.lineTo(size * 1.2, 0);
          ctx.lineTo(0, size * 1.2);
          ctx.lineTo(-size * 1.2, 0);
          ctx.closePath();
          ctx.fill();
          break;
        }
        case 'ray': {
          ctx.strokeStyle = `${p.color}aa`;
          ctx.lineWidth = Math.max(3, size * 0.2);
          ctx.beginPath();
          ctx.moveTo(-size * 1.4, 0);
          ctx.lineTo(size * 1.4, 0);
          ctx.stroke();
          break;
        }
        case 'ring': {
          ctx.strokeStyle = `${p.color}cc`;
          ctx.lineWidth = Math.max(2.5, size * 0.18);
          ctx.beginPath();
          ctx.arc(0, 0, size * 1.3, 0, Math.PI * 2);
          ctx.stroke();
          break;
        }
        case 'star':
        default: {
          ctx.fillStyle = `${p.color}bb`;
          ctx.beginPath();
          const spikes = 6;
          for (let i = 0; i < spikes * 2; i++) {
            const r = i % 2 === 0 ? size * 1.2 : size * 0.45;
            const angle = (i / (spikes * 2)) * Math.PI * 2;
            ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
          }
          ctx.closePath();
          ctx.fill();
          break;
        }
      }

      ctx.restore();
    }

    function animateBursts() {
      ctx.clearRect(0, 0, burstCanvas.width, burstCanvas.height);
      const now = performance.now();

      bursts = bursts.filter(burst => {
        const age = now - burst.startedAt;
        const alive = age < burst.duration;
        if (!alive) return false;

        burst.particles.forEach(p => drawParticle(p, now));

        return true;
      });

      if (bursts.length > 0) {
        rafId = requestAnimationFrame(animateBursts);
      } else {
        rafId = null;
        ctx.clearRect(0, 0, burstCanvas.width, burstCanvas.height);
      }
    }

    function addBurst(x, y, count, palette) {
      const particles = [];
      for (let i = 0; i < count; i++) {
        const angle = randomBetween(0, Math.PI * 2);
        const speed = randomBetween(38, 96);
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: randomBetween(34, 96),
          life: randomBetween(980, 1700),
          start: performance.now(),
          color: palette[i % palette.length],
          shape: ['star', 'orb', 'diamond', 'ring', 'ray'][i % 5],
          rotation: randomBetween(0, Math.PI * 2)
        });
      }

      bursts.push({ particles, startedAt: performance.now(), duration: 1900 });
      if (!rafId) animateBursts();
    }

    function triggerSequence(x, y) {
      const maxVal = parseInt(maxNumber.value, 10) || 1;
      const count = Math.max(1, Math.floor(Math.random() * maxVal) + 1);
      const lang = document.documentElement.lang || 'en';
      const words = numberWords[lang] || numberWords.en;
      const spoken = words[count - 1] || words[words.length - 1] || String(count);

      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(spoken);
        utterance.lang = lang === 'fr' ? 'fr-FR' : (lang === 'ja' ? 'ja-JP' : 'en-US');
        utterance.volume = clamp(parseInt(voiceVol.value, 10) / 100, 0, 1);
        try { speechSynthesis.cancel(); } catch (e) {}
        speechSynthesis.speak(utterance);
      }

      if (softChime.checked) {
        const clone = chimeSound.cloneNode(true);
        clone.volume = 0.6;
        clone.play().catch(() => {});
      }

      if (navigator.vibrate) {
        const pattern = Array(count).fill(120);
        navigator.vibrate(pattern);
      }

      const palette = pickPalette();
      addBurst(x, y, count, palette);
      lastTrigger = performance.now();
    }

    function maybeTrigger(now) {
      if (!playing) return;
      const dwellNeeded = window.eyegazeSettings?.dwellTime || parseInt(dwellSlider.value, 10);
      const gapNeeded = parseFloat(cooldown.value) * 1000;
      if (now - lastMove >= dwellNeeded && now - lastTrigger >= gapNeeded) {
        triggerSequence(gazePos.x, gazePos.y);
      }
      requestAnimationFrame(maybeTrigger);
    }

    function updateGaze(evt) {
      const point = evt.touches ? evt.touches[0] : evt;
      gazePos.x = point.clientX;
      gazePos.y = point.clientY;
      lastMove = performance.now();
      gazePointer.style.transform = `translate(${gazePos.x}px, ${gazePos.y}px)`;
    }

    function startExperience() {
      requestFullscreenIfPossible();
      document.body.classList.add('playing');
      hint.style.display = 'none';
      playing = true;
      const dwellNeeded = window.eyegazeSettings?.dwellTime || parseInt(dwellSlider.value, 10);
      lastMove = performance.now() - dwellNeeded;
      lastTrigger = 0;
      maybeTrigger(performance.now());
    }

    function togglePointerVisibility() {
      document.body.classList.toggle('pointer-hidden', !showPointer.checked);
    }

    function syncDwellWithMenu() {
      const val = setEyegazeDwellTime(dwellSlider.value);
      dwellVal.textContent = val;
    }

    langBtn?.addEventListener('click', toggleLanguage);
    startButton.addEventListener('click', startExperience);

    scene.addEventListener('pointermove', updateGaze);
    scene.addEventListener('touchmove', updateGaze, { passive: true });

    maxNumber.addEventListener('input', updateLabels);
    cooldown.addEventListener('input', updateLabels);
    voiceVol.addEventListener('input', updateLabels);
    dwellSlider.addEventListener('input', syncDwellWithMenu);
    showPointer.addEventListener('change', togglePointerVisibility);

    initEyegazeMenu();
    resizeCanvas();
    updateLabels();
    syncDwellWithMenu();
    togglePointerVisibility();
    gazePointer.style.transform = `translate(${gazePos.x}px, ${gazePos.y}px)`;

    window.addEventListener('resize', () => {
      gazePos.x = clamp(gazePos.x, 0, window.innerWidth);
      gazePos.y = clamp(gazePos.y, 0, window.innerHeight);
      gazePointer.style.transform = `translate(${gazePos.x}px, ${gazePos.y}px)`;
      resizeCanvas();
    });
  </script>
</body>
</html>
