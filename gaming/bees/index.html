<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title
    class="translate"
    data-fr="Construction de ruche - Compétitif"
    data-en="Hive Builder - Competitive"
    data-ja="ハチの巣づくり：対戦モード">
    Construction de ruche - Compétitif
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Common styles (same file as other switch games) -->
  <link rel="stylesheet" href="../../css/otherswitch.css">

  <style>
    :root {
      --c1: #fbbf24; --c2: #d97706; --c3: #FFCA3A; --c4: #8AC926;
      --c5: #1982C4; --c6: #6A4C93; --c7: #B5179E; --c8: #2EC4B6;
      --gap: 3rem;
      --side-pad: 3rem;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      touch-action: manipulation;
    }

    /* -------- LANG BUTTON -------- */
    #langToggle {
      position: fixed;
      top: 14px;
      right: 44px;
      z-index: 11;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      border: 2px solid #04c8bb;
      background: #0b0f12;
      color: #04c8bb;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 0 0 0 rgba(4, 200, 187, 0);
      transition: box-shadow 0.2s ease, transform 0.05s ease, background 0.2s ease;
    }

    #langToggle:hover {
      box-shadow: 0 0 0 3px rgba(4, 200, 187, 0.2);
    }

    #langToggle:active {
      transform: translateY(1px);
    }

    /* -------- LANDING OVERLAY -------- */
    #promptOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1rem;
      z-index: 10;
    }
    #promptOverlay p {
      font-size: 1.25rem;
      max-width: 80%;
      margin-bottom: 1.5rem;
    }
    #modeSelect {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
    }
    #modeSelect button {
      flex: 1;
      min-width: 120px;
      padding: 0.75rem 1rem;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 8px;
      color: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    #modeSelect button:hover {
      background: rgba(255,255,255,0.2);
    }
    #modeSelect button.active {
      background: #00bfff;
      color: #000;
      font-weight: bold;
    }
    .goal-setting {
      margin: 0.5rem 0 1.25rem;
      display: flex;
      gap: 0.6rem;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    .goal-setting label {
      font-weight: 700;
      font-size: 1rem;
    }
    .goal-setting input[type="number"] {
      width: 72px;
      padding: 0.4rem 0.5rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: 1rem;
      text-align: center;
    }
    .goal-setting input[type="checkbox"] {
      width: 1.2rem;
      height: 1.2rem;
      accent-color: #00bfff;
      cursor: pointer;
    }

    #editPlayers {
      display: none;
      padding: 0.65rem 1rem;
      background: rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      margin-bottom: 1rem;
    }
    #promptOverlay button#startButton {
      padding: 1rem 2rem;
      font-size: 1.25rem;
      margin-top: 1rem;
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }

    /* -------- Player Modal -------- */
    #playerConfigModal {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 12;
    }
    #playerConfigModal .modal-content {
      background: #0f172a;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 14px;
      padding: 1.5rem;
      width: min(720px, 90vw);
      box-shadow: 0 15px 40px rgba(0,0,0,0.5);
    }
    #playerConfigModal h3 {
      margin-bottom: 1rem;
      font-size: 1.25rem;
      text-align: center;
    }
    .player-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }
    .player-card {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 1rem;
    }
    .player-card label {
      display: block;
      margin-bottom: 0.35rem;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .player-card input[type="text"] {
      width: 100%;
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: #0b1220;
      color: #fff;
      font-size: 1rem;
    }
    .player-card input[type="color"] {
      width: 100%;
      height: 42px;
      border: none;
      border-radius: 8px;
      padding: 0;
      background: #0b1220;
      cursor: pointer;
    }
    .modal-actions {
      margin-top: 1rem;
      text-align: center;
      display: flex;
      gap: 0.75rem;
      justify-content: center;
    }
    .modal-actions button {
      padding: 0.75rem 1.6rem;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      font-weight: 700;
    }

    #goalDisplay {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.45rem 0.9rem;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px;
      font-weight: 700;
      letter-spacing: 0.02em;
      z-index: 9;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    }
    #endBanner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.92);
      padding: 1rem 1.5rem;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: 800;
      letter-spacing: 0.03em;
      color: #fefefe;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 10;
    }
    #endBanner.visible {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    .restart-subtext {
      display: block;
      margin-top: 0.35rem;
      font-size: 0.95rem;
      font-weight: 650;
      color: #d8e7f3;
    }

    /* -------- GAME CANVAS -------- */
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .controls-hint {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
      line-height: 1.6;
    }
    .key {
      display: inline-block;
      padding: 2px 6px;
      border: 1px solid #666;
      border-radius: 4px;
      background: #222;
      font-family: monospace;
      color: #fbbf24;
    }
  </style>
</head>

<body>
  <!-- Language toggle button -->
  <button id="langToggle" title="Changer de langue / Change language">FR / EN / JA</button>

  <!-- Landing overlay -->
  <div id="promptOverlay">
    <p class="translate"
       data-fr="Choisissez un mode puis appuyez sur Commencer."
       data-en="Select a mode then press Start."
       data-ja="モードを選んで「開始」を押してください。">
      Choisissez un mode puis appuyez sur Commencer.
    </p>

    <div id="modeSelect">
      <button data-mode="1p" class="active">
        <span class="translate"
              data-fr="1 joueur"
              data-en="1 player"
              data-ja="1人プレイ">1 joueur</span>
      </button>
      <button data-mode="2p">
        <span class="translate"
              data-fr="2 joueurs"
              data-en="2 players"
              data-ja="2人プレイ">2 joueurs</span>
      </button>
    </div>

    <div class="goal-setting">
      <label for="tripGoalInput" class="translate"
             data-fr="Allers-retours requis :"
             data-en="Flower trips needed:"
             data-ja="花への往復回数：">
        Allers-retours requis :
      </label>
      <input id="tripGoalInput" type="number" min="1" max="15" value="5">
    </div>

    <!-- Timing mode checkbox -->
    <div class="goal-setting">
      <label for="timingModeInput" class="translate"
             data-fr="Mode timing (fleurs qui apparaissent/disparaissent)"
             data-en="Timing mode (flowers appear/disappear)"
             data-ja="タイミングモード（花が出たり消えたり）">
        Mode timing (fleurs qui apparaissent/disparaissent)
      </label>
      <input id="timingModeInput" type="checkbox">
    </div>

    <!-- Penalty mode checkbox -->
    <div class="goal-setting">
      <label for="penaltyModeInput" class="translate"
             data-fr="Pénalité si on appuie quand les abeilles ne sont pas prêtes"
             data-en="Penalty if pressed when bees are not ready"
             data-ja="ハチが準備できていない時に押すとペナルティ">
        Pénalité si on appuie quand les abeilles ne sont pas prêtes
      </label>
      <input id="penaltyModeInput" type="checkbox">
    </div>

    <div id="controlsText" class="controls-hint">
     <span id="p2hint" style="display:none;"></span>
    </div>

    <button id="editPlayers">Configurer les joueurs</button>

    <button id="startButton" class="translate"
            data-fr="Commencer"
            data-en="Start"
            data-ja="開始">
      Commencer
    </button>
  </div>

  <div id="playerConfigModal">
    <div class="modal-content">
      <h3>Configurer les joueurs</h3>
      <div class="player-grid">
        <div class="player-card">
          <label for="p1Name">Nom du joueur 1</label>
          <input id="p1Name" type="text" value="Joueur 1" maxlength="20">
          <label for="p1Color" style="margin-top:0.75rem;">Couleur du miel</label>
          <input id="p1Color" type="color" value="#fbbf24">
        </div>
        <div class="player-card">
          <label for="p2Name">Nom du joueur 2</label>
          <input id="p2Name" type="text" value="Joueur 2" maxlength="20">
          <label for="p2Color" style="margin-top:0.75rem;">Couleur du miel</label>
          <input id="p2Color" type="color" value="#6a4c93">
        </div>
      </div>
      <div class="modal-actions">
        <button id="closeModal">Fermer</button>
        <button id="savePlayers">Enregistrer</button>
      </div>
    </div>
  </div>

  <canvas id="simCanvas"></canvas>
  <div id="goalDisplay"></div>
  <div id="endBanner" aria-live="polite"></div>
  <span id="restartHintTemplate" class="translate" aria-hidden="true" style="display:none;"
        data-fr="Maintenez votre contacteur pour recommencer"
        data-en="Hold your switch to restart"
        data-ja="スイッチを長押しして再スタート">Hold your switch to restart</span>

  <script>
    /**
     * CONFIGURATION & ASSETS
     */
    const COLORS = {
      bgLeft: '#120a02',
      bgRight: '#4a7c25',
      bgDark: '#120a02',
      hexBorderLight: '#ffd700',
      hexBorderDark: '#b45309',
      waxBase: '#fbbf24',
      waxDeep: '#78350f',
      beeYellowBright: '#ffdf00',
      beeYellowDark: '#c7a008',
      beeBlack: '#0a0a0a'
    };

    const playerConfigs = [
      { name: 'Joueur 1', color: COLORS.waxBase },
      { name: 'Joueur 2', color: '#6a4c93' }
    ];

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // ----- Color helpers -----
    function hexToRgb(hex) {
      const cleaned = hex.replace('#','');
      const bigint = parseInt(cleaned, 16);
      return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }

    function rgbToHex(r, g, b) {
      const toHex = (c) => c.toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function mixHex(base, target, amount) {
      const a = hexToRgb(base);
      const b = hexToRgb(target);
      const clamp = (v) => Math.max(0, Math.min(255, v));
      return rgbToHex(
        clamp(Math.round(a.r + (b.r - a.r) * amount)),
        clamp(Math.round(a.g + (b.g - a.g) * amount)),
        clamp(Math.round(a.b + (b.b - a.b) * amount))
      );
    }

    function createWaxTexture(baseColor) {
      const canvasPattern = document.createElement('canvas');
      canvasPattern.width = 128;
      canvasPattern.height = 128;
      const pCtx = canvasPattern.getContext('2d');

      const deep = mixHex(baseColor, '#000000', 0.45);
      const waxGrad = pCtx.createRadialGradient(64,64,0, 64,64,90);
      waxGrad.addColorStop(0, baseColor);
      waxGrad.addColorStop(1, deep);
      pCtx.fillStyle = waxGrad;
      pCtx.fillRect(0,0,128,128);

      for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 128;
        const y = Math.random() * 128;
        const alpha = Math.random() * 0.25;
        const light = mixHex(baseColor, '#ffffff', 0.4);
        const dark = mixHex(baseColor, '#000000', 0.6);
        const lightRgb = hexToRgb(light);
        const darkRgb = hexToRgb(dark);
        pCtx.fillStyle = Math.random() > 0.5
          ? `rgba(${lightRgb.r}, ${lightRgb.g}, ${lightRgb.b}, ${alpha})`
          : `rgba(${darkRgb.r}, ${darkRgb.g}, ${darkRgb.b}, ${alpha})`;
        pCtx.beginPath();
        pCtx.arc(x, y, Math.random()*1.5, 0, Math.PI*2);
        pCtx.fill();
      }
      return pCtx.createPattern(canvasPattern, 'repeat');
    }

    // ----- Canvas Setup -----
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    let width, height;

    // ----- Game State -----
    let gameRunning = false;
    let gameMode = '1p'; // '1p' or '2p'
    let gameEnded = false;
    let tripGoal = 5;

    // Timing mode state
    let timingMode = false;
    let flowersActive = true;
    let timingState = 'static'; // 'static', 'waiting', 'visible'
    let timeUntilNextState = 0;
    let timingSpentThisCycle = false;
    let timingCapturedByPlayerIndex = null; // 0 or 1

    const PENALTY_DURATION = 2.0;

    // Hives and other entities
    let hives = [];
    const flowers = [];
    const particles = [];

    let hexRadius = 45;

    // ----- DOM Elements -----
    const modeButtons = document.querySelectorAll('#modeSelect button');
    const p2Hint = document.getElementById('p2hint');
    const startButton = document.getElementById('startButton');
    const overlay = document.getElementById('promptOverlay');
    const editPlayersBtn = document.getElementById('editPlayers');
    const playerModal = document.getElementById('playerConfigModal');
    const p1NameInput = document.getElementById('p1Name');
    const p2NameInput = document.getElementById('p2Name');
    const p1ColorInput = document.getElementById('p1Color');
    const p2ColorInput = document.getElementById('p2Color');
    const closeModalBtn = document.getElementById('closeModal');
    const savePlayersBtn = document.getElementById('savePlayers');
    const langToggle = document.getElementById('langToggle');
    const tripGoalInput = document.getElementById('tripGoalInput');
    const timingModeInput = document.getElementById('timingModeInput');
    const penaltyModeInput = document.getElementById('penaltyModeInput');
    const goalDisplay = document.getElementById('goalDisplay');
    const endBanner = document.getElementById('endBanner');
    const restartHintTemplate = document.getElementById('restartHintTemplate');

    // Audio
    const pressSoundSrc = '../../sounds/startactivity.mp3';
    let buttonMusic;
    const finishSound = new Audio('../../sounds/victory.mp3');
    finishSound.volume = 0.5;

    // ----- UI Logic -----
    function applyPlayerConfig() {
      playerConfigs[0].name = (p1NameInput.value || 'Joueur 1').trim() || 'Joueur 1';
      playerConfigs[1].name = (p2NameInput.value || 'Joueur 2').trim() || 'Joueur 2';
      playerConfigs[0].color = p1ColorInput.value || playerConfigs[0].color;
      playerConfigs[1].color = p2ColorInput.value || playerConfigs[1].color;
    }

    function openPlayerModal() {
      p1NameInput.value = playerConfigs[0].name;
      p2NameInput.value = playerConfigs[1].name;
      p1ColorInput.value = playerConfigs[0].color;
      p2ColorInput.value = playerConfigs[1].color;
      playerModal.style.display = 'flex';
    }

    function closePlayerModal() {
      playerModal.style.display = 'none';
    }

    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        p2Hint.style.display = (gameMode === '2p') ? 'inline' : 'none';
        editPlayersBtn.style.display = (gameMode === '2p') ? 'inline-block' : 'none';
        if (gameMode === '2p') openPlayerModal();
        else closePlayerModal();
      });
    });

    editPlayersBtn.addEventListener('click', openPlayerModal);
    closeModalBtn.addEventListener('click', closePlayerModal);
    savePlayersBtn.addEventListener('click', () => {
      applyPlayerConfig();
      closePlayerModal();
    });

    function readTripGoal() {
      const value = parseInt(tripGoalInput.value, 10);
      if (isNaN(value)) return 5;
      return Math.min(15, Math.max(1, value));
    }

    function updateGoalDisplay() {
      if (!gameRunning) return;
      const goalText = [];
      if (gameMode === '1p' && hives[0]) {
        goalText.push(`${playerConfigs[0].name}: ${Math.min(hives[0].voyagesCompleted, tripGoal)}/${tripGoal}`);
      }
      if (gameMode === '2p' && hives.length === 2) {
        goalText.push(`${playerConfigs[0].name}: ${Math.min(hives[0].voyagesCompleted, tripGoal)}/${tripGoal}`);
        goalText.push(`${playerConfigs[1].name}: ${Math.min(hives[1].voyagesCompleted, tripGoal)}/${tripGoal}`);
      }
      goalDisplay.textContent = goalText.join('  •  ');
    }

    function getRestartHintText() {
      const lang = (document.documentElement.lang || 'fr').split('-')[0];
      return restartHintTemplate?.getAttribute(`data-${lang}`)
        || restartHintTemplate?.getAttribute('data-en')
        || 'Hold your switch to restart';
    }

    function endGame(message) {
      gameEnded = true;
      const restartCopy = getRestartHintText();
      endBanner.innerHTML = `${message}<span class="restart-subtext">${restartCopy}</span>`;
      endBanner.className = 'visible';
    }

    function checkGameEnd() {
      if (gameMode === '1p') {
        if (hives[0] && hives[0].finished) {
          endGame(`${playerConfigs[0].name} a terminé sa ruche !`);
        }
        return;
      }
      if (hives.length === 2 && hives[0].finished && hives[1].finished) {
        endGame('Les deux ruches sont complètes !');
      }
    }

    function playPressSound() {
      if (!buttonMusic) {
        buttonMusic = new Audio(pressSoundSrc);
        buttonMusic.volume = 0.35;
      } else {
        buttonMusic.currentTime = 0;
      }
      buttonMusic.play().catch(()=>{});
    }

    let restartHoldTimer = null;
    const RESTART_HOLD_MS = 3000;

    function cancelRestartHold() {
      if (restartHoldTimer) {
        clearTimeout(restartHoldTimer);
        restartHoldTimer = null;
      }
    }

    function beginGame() {
      overlay.style.display = 'none';
      gameRunning = true;
      gameEnded = false;
      endBanner.className = '';
      endBanner.textContent = '';
      cancelRestartHold();
      langToggle?.remove();
      initGame();
      updateGoalDisplay();
    }

    startButton.addEventListener('click', (e) => {
      e.preventDefault();
      applyPlayerConfig();
      tripGoal = readTripGoal();
      tripGoalInput.value = tripGoal;
      timingMode = !!timingModeInput.checked;

      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(()=>{});
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
      }

      closePlayerModal();
      beginGame();
    });

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * window.devicePixelRatio;
      canvas.height = height * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);

      if (gameRunning) initGame();
    }
    window.addEventListener('resize', resize);

    // ----- HIVE CLASS -----
    class Hive {
      constructor(centerX, isRightSide, options = {}) {
        this.centerX = centerX;
        this.centerY = height * 0.5;
        this.isRightSide = isRightSide;
        this.label = options.name || 'Joueur';
        this.waxColor = options.color || COLORS.waxBase;
        this.index = options.index ?? 0;   // player index (0 or 1)
        this.waxPattern = createWaxTexture(this.waxColor);
        this.borderLight = mixHex(this.waxColor, '#ffffff', 0.35);
        this.borderDark = mixHex(this.waxColor, '#000000', 0.4);
        this.beeAccentLight = mixHex(this.waxColor, '#ffffff', 0.25);
        this.beeAccentDeep = mixHex(this.waxColor, '#000000', 0.35);
        this.cells = [];
        this.bees = [];
        this.occupiedMap = new Set();
        this.reservedMap = new Set();
        this.voyagesCompleted = 0;
        this.voyageLogged = false;
        this.finishing = false;
        this.finished = false;
        this.ready = false; // visual "ready" state

        // penalty state
        this.penaltyTime = 0;
        this.penaltyBeesState = null;

        this.addCell(0,0);

        for(let i=0; i<6; i++) this.bees.push(this.createBee());
      }

      hexToPixel(q, r) {
        const x = this.centerX + hexRadius * (3/2 * q);
        const y = this.centerY + hexRadius * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
        return { x, y };
      }

      addCell(q, r) {
        const pos = this.hexToPixel(q, r);
        this.cells.push({
          q, r, x: pos.x, y: pos.y,
          scale: 0,
          variation: Math.random(),
          wobble: Math.random() * Math.PI*2
        });
        const key = `${q},${r}`;
        this.occupiedMap.add(key);
        if(this.reservedMap.has(key)) this.reservedMap.delete(key);
      }

      findNextBuildSpot() {
        const HEX_DIRECTIONS = [
          {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
          {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
        ];

        let queue = [{q:0, r:0}];
        let visited = new Set(['0,0']);
        let iterations = 0;

        while (queue.length > 0 && iterations < 3000) {
          iterations++;
          let current = queue.shift();
          for (let dir of HEX_DIRECTIONS) {
            let nq = current.q + dir.q;
            let nr = current.r + dir.r;
            let key = `${nq},${nr}`;

            if (!visited.has(key)) {
              visited.add(key);
              if (!this.occupiedMap.has(key) && !this.reservedMap.has(key)) {
                return { q: nq, r: nr };
              }
              if (this.occupiedMap.has(key)) {
                queue.push({q: nq, r: nr});
              }
            }
          }
        }
        return null;
      }

      createBee() {
        const home = this.hexToPixel(0, 0);
        return {
          x: home.x + (Math.random()-0.5)*50,
          y: home.y + (Math.random()-0.5)*50,
          vx: 0, vy: 0,
          state: 'idle',
          target: null,
          targetGrid: null,
          angle: this.isRightSide ? Math.PI : 0,
          wobblePhase: Math.random() * Math.PI * 2,
          wingSpeed: 1,
          sizeScale: 1.3 + Math.random() * 0.4,
          accentLight: this.beeAccentLight,
          accentDeep: this.beeAccentDeep,
          canScoreThisTrip: false,
          canBuildThisTrip: false,
          penaltyBase: null
        };
      }

      /**
       * Trigger a 2s penalty animation: bees freeze & shake, then resume.
       */
      triggerPenalty() {
        if (this.penaltyTime > 0) return;
        if (!this.bees.length) return;

        // Backup state for each bee to restore after penalty
        this.penaltyBeesState = this.bees.map(b => ({
          x: b.x,
          y: b.y,
          vx: b.vx,
          vy: b.vy,
          state: b.state,
          target: b.target ? { x: b.target.x, y: b.target.y } : null,
          targetGrid: b.targetGrid ? { q: b.targetGrid.q, r: b.targetGrid.r } : null,
          angle: b.angle,
          wobblePhase: b.wobblePhase,
          wingSpeed: b.wingSpeed,
          sizeScale: b.sizeScale,
          accentLight: b.accentLight,
          accentDeep: b.accentDeep,
          canScoreThisTrip: b.canScoreThisTrip,
          canBuildThisTrip: b.canBuildThisTrip
        }));

        this.bees.forEach(b => {
          b.penaltyBase = { x: b.x, y: b.y, angle: b.angle };
        });

        this.penaltyTime = PENALTY_DURATION;
      }

      /**
       * Returns true only if at least one bee is launched AND canScoreThisTrip is true.
       * Also enforces: can only launch when ALL bees are idle (all back home).
       */
      sendBees() {
        if (this.finished || this.finishing) return false;
        if (this.penaltyTime > 0) return false;

        // must wait until all bees are idle
        const allIdle = this.bees.every(b => b.state === 'idle');
        if (!allIdle) return false;

        if (timingMode && !flowersActive) return false;

        // Determine scoring/build permissions for this launch
        let canScoreTrip = true;
        let canBuildTrip = true;

        if (timingMode && gameMode === '2p') {
          if (!flowersActive || timingState !== 'visible') {
            canScoreTrip = false;
            canBuildTrip = false;
          } else if (
            timingCapturedByPlayerIndex !== null &&
            timingCapturedByPlayerIndex !== this.index
          ) {
            // Other player already captured this cycle
            canScoreTrip = false;
            canBuildTrip = false;
          } else {
            canScoreTrip = true;
            canBuildTrip = true;
          }
        }

        let launched = false;
        let hasScoringBee = false;

        this.bees.forEach(b => {
          if (b.state === 'idle' && flowers.length > 0) {
            b.state = 'outbound';
            b.wingSpeed = 3.5;
            const flower = flowers[Math.floor(Math.random() * flowers.length)];
            const bloom = getFlowerBloom(flower);
            b.target = {
              x: bloom.x + (Math.random()-0.5)*10,
              y: bloom.y + (Math.random()-0.5)*10 - 15
            };
            b.canScoreThisTrip = canScoreTrip;
            b.canBuildThisTrip = canBuildTrip;
            launched = true;
            if (canScoreTrip) hasScoringBee = true;
          }
        });

        if (launched) {
          this.voyageLogged = false;

          // First player to send while visible captures this flower cycle
          if (timingMode && gameMode === '2p' &&
              flowersActive && timingState === 'visible' &&
              timingCapturedByPlayerIndex === null &&
              canScoreTrip) {
            timingCapturedByPlayerIndex = this.index;
          }
        }

        // Only treat this as a "meaningful" press if at least one bee can score
        return hasScoringBee;
      }

      update(dt) {
        // Determine "ready" visual state:
        // - all bees idle
        // - not finishing/finished
        // - penalty not active
        // - in timing mode, flowers must be visible
        const allIdle = this.bees.every(b => b.state === 'idle');
        this.ready =
          allIdle &&
          !this.finished &&
          !this.finishing &&
          this.penaltyTime <= 0 &&
          (!timingMode || flowersActive);

        // Animate cell growth
        this.cells.forEach(c => {
          if (c.scale < 1) c.scale += (1 - c.scale) * 0.1;
        });

        // Penalty animation: bees shake in place, no movement/state changes
        if (this.penaltyTime > 0) {
          this.penaltyTime -= dt;
          this.bees.forEach(b => {
            if (!b.penaltyBase) {
              b.penaltyBase = { x: b.x, y: b.y, angle: b.angle };
            }
            b.wobblePhase += dt * 12;
            const shakeAmp = 4;
            b.x = b.penaltyBase.x + Math.sin(b.wobblePhase * 25) * shakeAmp;
            b.y = b.penaltyBase.y + Math.cos(b.wobblePhase * 30) * shakeAmp;
            b.angle = b.penaltyBase.angle + Math.sin(b.wobblePhase * 20) * 0.3;
          });

          if (this.penaltyTime <= 0) {
            if (this.penaltyBeesState) {
              this.bees.forEach((b, i) => {
                const s = this.penaltyBeesState[i];
                Object.assign(b, s);
                b.penaltyBase = null;
              });
              this.penaltyBeesState = null;
            }
            this.penaltyTime = 0;
          }

          // While in penalty, skip normal movement/logic
          return;
        }

        const homeCenter = this.hexToPixel(0,0);

        this.bees.forEach(b => {
          b.wobblePhase += dt * 5 * b.wingSpeed;

          if (b.state === 'idle') {
            b.wingSpeed = 1;
            const hoverX = homeCenter.x + Math.cos(b.wobblePhase*0.2)*70;
            const hoverY = homeCenter.y + Math.sin(b.wobblePhase*0.3)*50;
            const dx = hoverX - b.x;
            const dy = hoverY - b.y;
            b.x += dx * 0.03;
            b.y += dy * 0.03;

            const desiredAngle = this.isRightSide ? Math.PI : 0;
            let angleDiff = desiredAngle - b.angle;
            if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
            if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
            b.angle += angleDiff * 0.05;
          }
          else {
            const dx = b.target.x - b.x;
            const dy = b.target.y - b.y;
            const dist = Math.hypot(dx, dy);
            const speed = 180 * dt;

            if (dist < 20) {
              if (b.state === 'outbound') {
                // Score only if this bee is allowed to score for this trip
                if (!this.finished && !this.voyageLogged && b.canScoreThisTrip) {
                  this.voyagesCompleted = Math.min(tripGoal, this.voyagesCompleted + 1);
                  this.voyageLogged = true;
                  if (this.voyagesCompleted >= tripGoal) {
                    this.finishing = true;
                  }
                  updateGoalDisplay();
                }
                b.state = 'returning';
                const nextSpot = this.findNextBuildSpot();
                if (nextSpot) {
                  this.reservedMap.add(`${nextSpot.q},${nextSpot.r}`);
                  b.targetGrid = nextSpot;
                  b.target = this.hexToPixel(nextSpot.q, nextSpot.r);
                } else {
                  b.target = homeCenter;
                  b.targetGrid = null;
                }
                spawnParticles(b.x, b.y, ['#fff', this.borderLight]);

              } else if (b.state === 'returning') {
                b.state = 'idle';
                // Build cell only if allowed to build for this trip
                if (b.targetGrid && b.canBuildThisTrip) {
                  this.addCell(b.targetGrid.q, b.targetGrid.r);
                }
                b.targetGrid = null;
                spawnParticles(b.x, b.y, [this.borderLight, this.waxColor]);
              }
            } else {
              b.vx = (dx/dist) * speed;
              b.vy = (dy/dist) * speed;
              b.x += b.vx;
              b.y += b.vy;
              const targetAngle = Math.atan2(dy, dx);
              let angleDiff = targetAngle - b.angle;
              if (angleDiff > Math.PI) angleDiff -= Math.PI*2;
              if (angleDiff < -Math.PI) angleDiff += Math.PI*2;
              b.angle += angleDiff * 0.15;
            }
          }
        });

        // Timing competitive mode: hide flowers when the LAST outbound bee
        // of the capturing player has finished
        if (timingMode && gameMode === '2p' &&
            timingState === 'visible' &&
            !timingSpentThisCycle &&
            timingCapturedByPlayerIndex === this.index) {

          const anyOutbound = this.bees.some(b => b.state === 'outbound');
          if (!anyOutbound) {
            timingSpentThisCycle = true;
            flowersActive = false;
            timingState = 'waiting';
            timeUntilNextState = randRange(2, 5); // reappear after 2–5 s
            timingCapturedByPlayerIndex = null;
          }
        }

        if (this.finishing && !this.finished) {
          const allHomeNow = this.bees.every(b => b.state === 'idle');
          if (allHomeNow) {
            this.finished = true;
            this.finishing = false;
            finishSound.currentTime = 0;
            finishSound.play().catch(()=>{});
            checkGameEnd();
          }
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 25;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 10;
        this.cells.forEach(c => drawOrganicHexBase(c.x, c.y, hexRadius * c.scale, c.wobble));
        ctx.restore();

        this.cells.forEach(c => drawOrganicHexDetail(
          c.x,
          c.y,
          hexRadius * c.scale,
          c.variation,
          c.wobble,
          this.waxPattern,
          this.borderLight,
          this.borderDark
        ));

        // Pass "ready" state to bees for visual cue
        this.bees.forEach(b => drawBee(b, this.ready));
      }
    }

    // ----- Logic Initialization -----
    function initGame() {
      hives = [];
      flowers.length = 0;
      particles.length = 0;

      if (gameMode === '1p') {
        hives.push(new Hive(width * 0.2, false, { ...playerConfigs[0], index: 0 }));
        generateFlowers(width * 0.4, width * 0.95);
      } else {
        hives.push(new Hive(width * 0.15, false, { ...playerConfigs[0], index: 0 }));
        hives.push(new Hive(width * 0.85, true,  { ...playerConfigs[1], index: 1 }));
        generateFlowers(width * 0.35, width * 0.65);
      }

      if (timingMode) {
        flowersActive = false;
        timingState = 'waiting';
        timeUntilNextState = randRange(2, 5);
        timingSpentThisCycle = false;
        timingCapturedByPlayerIndex = null;
      } else {
        flowersActive = true;
        timingState = 'static';
        timeUntilNextState = 0;
        timingSpentThisCycle = false;
        timingCapturedByPlayerIndex = null;
      }
    }

    function getFieldZone() {
      if (gameMode === '1p') {
        const startX = width * 0.4;
        return { startX, zoneWidth: width - startX };
      }
      const startX = width * 0.3;
      return { startX, zoneWidth: width * 0.4 };
    }

    // ----- Flower Generation -----
    function generateFlowers(minX, maxX) {
      const count = 25;
      const daisyPalette = ['#ffb4e6', '#ffd6a5', '#c1fba4', '#b5dfff'];
      const tulipPalette = ['#ff7aa2', '#ff9f1c', '#ffcad4', '#c99bff'];

      for(let i=0; i<count; i++) {
        const type = Math.random() > 0.5 ? 'daisy' : 'tulip';
        const size = 12 + Math.random() * 10;
        const stemHeight = 90 + Math.random() * 70;
        flowers.push({
          x: minX + Math.random() * (maxX - minX),
          stemHeight,
          type: type,
          colorMain: type === 'daisy'
            ? daisyPalette[Math.floor(Math.random()*daisyPalette.length)]
            : tulipPalette[Math.floor(Math.random()*tulipPalette.length)],
          colorCenter: type === 'daisy' ? '#f6c453' : '#ffd166',
          size,
          stemCurve: (Math.random() - 0.5) * 80
        });
      }
    }

    // ----- Controls -----
    function restartGame() {
      if (!gameEnded) return;
      beginGame();
    }

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (gameEnded) {
        if (e.code === 'Space') {
          e.preventDefault();
          if (!restartHoldTimer) {
            restartHoldTimer = setTimeout(() => restartGame(), RESTART_HOLD_MS);
          }
        }
        return;
      }
      if (!gameRunning) return;

      const penaltyOn = penaltyModeInput && penaltyModeInput.checked;

      // Player 1
      if (e.code === 'Space') {
        e.preventDefault();
        const hive = hives[0];
        if (!hive) return;

        // Penalty if pressing when bees are not ready
        if (penaltyOn && !hive.ready) {
          hive.triggerPenalty();
          playPressSound();
          return;
        }

        const meaningful = hive.sendBees();
        if (meaningful) playPressSound();
      }

      // Player 2
      if (e.code === 'Enter' && gameMode === '2p') {
        e.preventDefault();
        const hive = hives[1];
        if (!hive) return;

        if (penaltyOn && !hive.ready) {
          hive.triggerPenalty();
          playPressSound();
          return;
        }

        const meaningful = hive.sendBees();
        if (meaningful) playPressSound();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (gameEnded && e.code === 'Space') {
        cancelRestartHold();
      }
    });

    // No mouse/touch sending; only Space & Enter

    // ----- Particles -----
    function spawnParticles(x, y, colorPalette) {
      for(let i=0; i<15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 80;
        const size = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.0,
          decay: 0.8 + Math.random()*0.5,
          color: colorPalette[Math.floor(Math.random()*colorPalette.length)],
          size
        });
      }
    }

    // ----- Main Update -----
    function update(dt) {
      // Timing mode cycles
      if (timingMode) {
        if (timeUntilNextState > 0) {
          timeUntilNextState -= dt;
        }
        if (timeUntilNextState <= 0) {
          if (timingState === 'waiting') {
            // Flowers appear
            flowersActive = true;
            timingState = 'visible';
            timeUntilNextState = 10;
            timingSpentThisCycle = false;
            timingCapturedByPlayerIndex = null;
          } else if (timingState === 'visible') {
            // Timeout: flowers disappear
            flowersActive = false;
            timingState = 'waiting';
            timeUntilNextState = randRange(2, 5);
            timingSpentThisCycle = false;
            timingCapturedByPlayerIndex = null;
          }
        }
      }

      hives.forEach(h => h.update(dt));

      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 80 * dt;
        p.life -= dt * p.decay;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // ----- Drawing -----
    function draw() {
      let layoutInfo;
      if (gameMode === '1p') {
        const splitX = width * 0.4;
        layoutInfo = { type: '1p', splitX };
        ctx.fillStyle = COLORS.bgLeft;
        ctx.fillRect(0, 0, splitX, height);
        drawFieldBackdrop(splitX, width - splitX);
      } else {
        const leftEdge = width * 0.3;
        const rightEdge = width * 0.7;
        layoutInfo = { type: '2p', leftEdge, rightEdge };

        ctx.fillStyle = COLORS.bgDark;
        ctx.fillRect(0, 0, leftEdge, height);

        ctx.fillStyle = COLORS.bgDark;
        ctx.fillRect(rightEdge, 0, width - rightEdge, height);

        drawFieldBackdrop(leftEdge, rightEdge - leftEdge);
      }

      drawPlayerLabels(layoutInfo);
      drawFlowers();
      hives.forEach(h => h.draw(ctx));
      drawParticles();
    }

    function drawPlayerLabels(layoutInfo) {
      if (!layoutInfo) return;
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = '700 18px sans-serif';

      if (layoutInfo.type === '2p') {
        const padY = 16;
        const leftX = layoutInfo.leftEdge * 0.5;
        const rightX = layoutInfo.rightEdge + (width - layoutInfo.rightEdge) * 0.5;

        [{x: leftX, config: playerConfigs[0]}, {x: rightX, config: playerConfigs[1]}].forEach(({x, config}) => {
          const badgeWidth = 210;
          const badgeHeight = 46;
          const radius = 12;
          const left = x - badgeWidth * 0.5;
          const top = padY;
          const labelY = top + badgeHeight * 0.5;
          const accentBright = mixHex(config.color, '#ffffff', 0.35);
          const accentDark = mixHex(config.color, '#000000', 0.45);

          ctx.save();
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.font = '700 18px "Segoe UI", "Nunito", sans-serif';

          ctx.beginPath();
          ctx.moveTo(left + radius, top);
          ctx.lineTo(left + badgeWidth - radius, top);
          ctx.quadraticCurveTo(left + badgeWidth, top, left + badgeWidth, top + radius);
          ctx.lineTo(left + badgeWidth, top + badgeHeight - radius);
          ctx.quadraticCurveTo(left + badgeWidth, top + badgeHeight, left + badgeWidth - radius, top + badgeHeight);
          ctx.lineTo(left + radius, top + badgeHeight);
          ctx.quadraticCurveTo(left, top + badgeHeight, left, top + badgeHeight - radius);
          ctx.lineTo(left, top + radius);
          ctx.quadraticCurveTo(left, top, left + radius, top);
          ctx.closePath();

          ctx.shadowColor = 'rgba(0,0,0,0.35)';
          ctx.shadowBlur = 12;
          ctx.fillStyle = 'rgba(0,0,0,0.55)';
          ctx.fill();

          const shine = ctx.createLinearGradient(left, top, left + badgeWidth, top + badgeHeight);
          shine.addColorStop(0, mixHex(config.color, '#ffffff', 0.18));
          shine.addColorStop(1, mixHex(config.color, '#000000', 0.35));
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = shine;
          ctx.fill();
          ctx.globalAlpha = 1;

          ctx.lineWidth = 2;
          ctx.strokeStyle = accentBright;
          ctx.stroke();

          ctx.beginPath();
          ctx.shadowColor = accentDark;
          ctx.shadowBlur = 8;
          ctx.fillStyle = config.color;
          ctx.arc(left + 22, labelY, 11, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = accentBright;
          ctx.stroke();

          ctx.fillStyle = '#fdfdfd';
          ctx.shadowColor = 'rgba(0,0,0,0.45)';
          ctx.shadowBlur = 4;
          ctx.fillText(config.name, left + 44, labelY);
          ctx.shadowBlur = 0;
          ctx.restore();
        });
      }

      ctx.restore();
    }

    function groundHeightAt(x) {
      const { startX, zoneWidth } = getFieldZone();
      const baseY = height * 0.86;
      const relX = Math.max(0, Math.min(zoneWidth, x - startX));
      const midX = zoneWidth * 0.5;

      if (relX <= midX) {
        const t = relX / midX;
        const p0 = baseY + 20;
        const p1 = baseY - 40;
        const p2 = baseY;
        return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
      }

      const t = (relX - midX) / (zoneWidth - midX);
      const p0 = baseY;
      const p1 = baseY + 40;
      const p2 = baseY - 10;
      return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
    }

    function drawFieldBackdrop(startX, zoneWidth) {
      const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
      skyGrad.addColorStop(0, '#cde9ff');
      skyGrad.addColorStop(0.6, '#93d2ff');
      skyGrad.addColorStop(1, '#7fc8ff');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(startX, 0, zoneWidth, height);

      const sunX = startX + zoneWidth * 0.18;
      const sunY = height * 0.18;
      const sunRadius = Math.min(120, zoneWidth * 0.25);
      const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);
      sunGrad.addColorStop(0, 'rgba(255, 240, 180, 0.95)');
      sunGrad.addColorStop(0.5, 'rgba(255, 220, 120, 0.75)');
      sunGrad.addColorStop(1, 'rgba(255, 200, 80, 0)');
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();

      const groundY = height * 0.86;
      ctx.save();
      ctx.translate(startX, 0);
      ctx.fillStyle = '#5fb34b';
      ctx.beginPath();
      ctx.moveTo(0, groundY + 20);
      ctx.quadraticCurveTo(zoneWidth * 0.25, groundY - 40, zoneWidth * 0.5, groundY);
      ctx.quadraticCurveTo(zoneWidth * 0.8, groundY + 40, zoneWidth, groundY - 10);
      ctx.lineTo(zoneWidth, height);
      ctx.lineTo(0, height);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      for (let i = 0; i < zoneWidth; i += 80) {
        const ripple = Math.sin((i + startX) * 0.01) * 8;
        ctx.beginPath();
        ctx.ellipse(i + 30, groundY - 25 + ripple, 50, 14, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function getFlowerBloom(f) {
      const groundY = groundHeightAt(f.x);
      return {
        x: f.x + f.stemCurve,
        y: groundY - f.stemHeight
      };
    }

    function drawLeaf(x, y, w, h, angle, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-w * 0.4, -h * 0.2, 0, -h);
      ctx.quadraticCurveTo(w * 0.4, -h * 0.2, 0, 0);
      ctx.fill();
      ctx.restore();
    }

    function drawFlowers() {
      const leafColor = '#3b7a2a';

      flowers.forEach(f => {
        const groundY = groundHeightAt(f.x);
        const bloomY = groundY - f.stemHeight;
        const controlY = groundY - f.stemHeight * 0.55;
        const sway = f.stemCurve;

        // Stem (always visible)
        ctx.beginPath();
        ctx.moveTo(f.x, groundY);
        ctx.quadraticCurveTo(f.x + sway * 0.35, controlY, f.x + sway, bloomY);
        ctx.strokeStyle = '#2d5e1c';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Leaves (always visible)
        const leafY = groundY - f.stemHeight * 0.45;
        drawLeaf(f.x + sway * 0.15, leafY, f.size * 2.2, f.size * 1.8, -0.9, leafColor);
        drawLeaf(f.x + sway * 0.05, leafY - f.size * 3, f.size * 2.4, f.size * 1.6, 1.1, leafColor);

        // Blossoms appear/disappear with timing
        if (timingMode && !flowersActive) {
          return;
        }

        if (f.type === 'daisy') {
          const petalCount = 12;
          for(let i=0; i<petalCount; i++) {
            const angle = (Math.PI*2 / petalCount) * i;
            ctx.fillStyle = f.colorMain;
            ctx.beginPath();
            ctx.ellipse(
              f.x + sway + Math.cos(angle)*f.size*1.2,
              bloomY + Math.sin(angle)*f.size*1.2,
              f.size*1.1,
              f.size*0.6,
              angle,
              0, Math.PI*2
            );
            ctx.fill();
          }
          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.arc(f.x + sway, bloomY, f.size*0.9, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.35)';
          ctx.beginPath();
          ctx.arc(f.x + sway - f.size*0.2, bloomY - f.size*0.2, f.size*0.3, 0, Math.PI*2);
          ctx.fill();
        }
        else if (f.type === 'tulip') {
          const baseX = f.x + sway;
          ctx.fillStyle = f.colorMain;
          ctx.beginPath();
          ctx.moveTo(baseX, bloomY + f.size*1.4);
          ctx.bezierCurveTo(
            baseX - f.size*2.2, bloomY,
            baseX - f.size*0.8, bloomY - f.size*2.2,
            baseX, bloomY - f.size
          );
          ctx.bezierCurveTo(
            baseX + f.size*0.8, bloomY - f.size*2.2,
            baseX + f.size*2.2, bloomY,
            baseX, bloomY + f.size*1.4
          );
          ctx.fill();

          ctx.fillStyle = f.colorCenter;
          ctx.beginPath();
          ctx.ellipse(
            baseX, bloomY - f.size,
            f.size*0.6, f.size*0.35,
            0, 0, Math.PI*2
          );
          ctx.fill();
        }
      });
    }

    function getHexPath(x, y, r, wobbleOffset) {
      const path = new Path2D();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i + Math.PI/6;
        const nextAngle = (Math.PI / 3) * (i+1) + Math.PI/6;
        const r1 = r + Math.sin(wobbleOffset + i)*r*0.05;
        const r2 = r + Math.sin(wobbleOffset + i+1)*r*0.05;
        const px1 = x + r1 * Math.cos(angle);
        const py1 = y + r1 * Math.sin(angle);
        const px2 = x + r2 * Math.cos(nextAngle);
        const py2 = y + r2 * Math.sin(nextAngle);

        if (i === 0) path.moveTo(px1, py1);
        const cpX = (px1 + px2) / 2 + Math.cos(angle+Math.PI/6)*r*0.1;
        const cpY = (py1 + py2) / 2 + Math.sin(angle+Math.PI/6)*r*0.1;
        path.quadraticCurveTo(cpX, cpY, px2, py2);
      }
      path.closePath();
      return path;
    }

    function drawOrganicHexBase(x, y, r, wobble) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);
      ctx.fillStyle = COLORS.bgDark;
      ctx.fill(path);
    }

    function drawOrganicHexDetail(x, y, r, variance, wobble, pattern, borderLight, borderDark) {
      if (r <= 1) return;
      const path = getHexPath(x, y, r, wobble);

      ctx.save();
      ctx.fillStyle = pattern;
      ctx.fill(path);
      ctx.fillStyle = `rgba(255, 220, 0, ${variance * 0.2})`;
      ctx.fill(path);

      ctx.clip(path);
      const grad = ctx.createRadialGradient(x, y, 0, x, y, r*1.2);
      grad.addColorStop(0, 'rgba(255, 240, 150, 0.3)');
      grad.addColorStop(0.6, borderLight);
      grad.addColorStop(1, borderDark);
      ctx.fillStyle = grad;
      ctx.fillRect(x-r*2, y-r*2, r*4, r*4);

      ctx.lineWidth = r * 0.1;
      ctx.strokeStyle = 'rgba(50, 20, 0, 0.5)';
      ctx.stroke(path);
      ctx.restore();

      ctx.lineCap = 'round';
      ctx.lineWidth = r * 0.15;
      ctx.strokeStyle = borderDark;
      ctx.stroke(path);

      const pathHighlight = getHexPath(x-r*0.02, y-r*0.05, r*0.98, wobble);
      ctx.lineWidth = r * 0.05;
      ctx.strokeStyle = borderLight;
      ctx.stroke(pathHighlight);
    }

    // isReady = hive.ready
    function drawBee(b, isReady = false) {
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);

      // Pulsing scale when hive is ready & bee idle
      const readyPulse = (isReady && b.state === 'idle')
        ? 1 + 0.15 * Math.sin(b.wobblePhase * 3)
        : 1;
      ctx.scale(b.sizeScale * readyPulse, b.sizeScale * readyPulse);

      const accentLight = b.accentLight || COLORS.beeYellowBright;
      const accentDeep = b.accentDeep || mixHex(accentLight, '#000000', 0.45);
      const abdomenBright = mixHex(accentLight, COLORS.beeYellowBright, 0.5);
      const abdomenDark = mixHex(accentDeep, COLORS.beeYellowDark, 0.5);

      const wingCycle = Math.sin(b.wobblePhase*1.5);

      // Glowing halo when ready
      if (isReady && b.state === 'idle') {
        ctx.save();
        const haloRadius = 24;
        const haloGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, haloRadius);
        haloGrad.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
        haloGrad.addColorStop(1, 'rgba(255, 255, 0, 0)');
        ctx.fillStyle = haloGrad;
        ctx.globalAlpha = 0.65;
        ctx.beginPath();
        ctx.arc(0, 0, haloRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Legs/Antennae (Behind)
      ctx.strokeStyle = COLORS.beeBlack;
      ctx.lineCap = 'round';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, -3); ctx.lineTo(18, -6);
      ctx.moveTo(10,  3); ctx.lineTo(18,  6);
      ctx.stroke();
      ctx.fillStyle = COLORS.beeBlack;
      ctx.beginPath(); ctx.arc(18,-6, 2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(18, 6, 2, 0, Math.PI*2); ctx.fill();

      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(4, -6); ctx.lineTo(6, -12);
      ctx.moveTo(4,  6); ctx.lineTo(6,  12);
      ctx.stroke();

      // Thorax
      const thoraxGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
      thoraxGrad.addColorStop(0, accentLight);
      thoraxGrad.addColorStop(1, accentDeep);
      ctx.fillStyle = thoraxGrad;
      ctx.beginPath();
      ctx.arc(0, 0, 10, 0, Math.PI*2);
      ctx.fill();

      // Head
      ctx.fillStyle = COLORS.beeBlack;
      ctx.beginPath();
      ctx.arc(12, 0, 6, 0, Math.PI*2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(14, -3, 3, 4, 0, 0, Math.PI*2);
      ctx.ellipse(14,  3, 3, 4, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(15, -4, 1.5, 0, Math.PI*2);
      ctx.arc(15,  2, 1.5, 0, Math.PI*2);
      ctx.fill();

      // Abdomen with stripes
      const abX = -12;
      const abY = 0;
      const abRX = 14;
      const abRY = 11;

      ctx.save();
      ctx.beginPath();
      ctx.ellipse(abX, abY, abRX, abRY, 0, 0, Math.PI*2);
      ctx.clip();

      const abdomenGrad = ctx.createRadialGradient(abX, abY, 5, abX, abY, abRX);
      abdomenGrad.addColorStop(0, abdomenBright);
      abdomenGrad.addColorStop(1, abdomenDark);
      ctx.fillStyle = abdomenGrad;
      ctx.fill();

      ctx.fillStyle = accentDeep;
      const stripeWidth = 4;
      const stripeSpacing = 4;
      let currentStripeX = abX + abRX - stripeWidth/2 - stripeSpacing;

      for(let i = 0; i < 3; i++) {
        ctx.fillRect(
          currentStripeX - stripeWidth,
          -abRY,
          stripeWidth,
          abRY * 2
        );
        currentStripeX -= (stripeWidth + stripeSpacing);
      }

      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      currentStripeX = abX + abRX - stripeWidth/2 - stripeSpacing;
      for(let i = 0; i < 3; i++) {
        ctx.fillRect(
          currentStripeX - stripeWidth * 0.35,
          -abRY,
          stripeWidth * 0.7,
          abRY * 2
        );
        currentStripeX -= (stripeWidth + stripeSpacing);
      }
      ctx.restore();

      // Wings
      const wingGrad = ctx.createLinearGradient(-10, -10, 10, 10);
      wingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      wingGrad.addColorStop(0.5, 'rgba(200, 255, 255, 0.5)');
      wingGrad.addColorStop(1, 'rgba(255, 200, 255, 0.8)');
      ctx.fillStyle = wingGrad;

      ctx.beginPath();
      ctx.ellipse(-4, -10, 16, 8, 0.3 + wingCycle * 0.4, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-4,  10, 16, 8, -0.3 - wingCycle * 0.4, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.65;
      ctx.fillStyle = accentLight;
      ctx.beginPath();
      ctx.ellipse(-10, 0, 6, 3.5, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      });
    }

    let lastTime = 0;
    function loop(timestamp) {
      requestAnimationFrame(loop);
      if (!gameRunning) return;

      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;
      update(dt);
      draw();
    }

    // Kickoff
    resize();
    loop(0);
  </script>

  <!-- Translation system -->
  <script src="../../js/translationmain.js"></script>
  <script>
    document.getElementById('langToggle')?.addEventListener('pointerup', () => {
      toggleLanguage();
    });
    document.addEventListener('DOMContentLoaded', () => {
      updateLanguage();
    });
  </script>
  <script src="../../js/translationonly.js"></script>
</body>
</html>
