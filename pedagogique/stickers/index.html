<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Planche d’autocollants (PNG pour Cricut)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    :root {
      --accent: #009688;
      --line: #e6eaef;
      --text-main: #000;
      --text-muted: #666;
      --bg-main: #f3f4f6;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: Arial, sans-serif;
      background: var(--bg-main);
      color: var(--text-main);
      overflow: hidden;
    }

    .app-container {
      display: flex;
      height: 100vh;
      width: 100%;
    }

    /* Sidebar (left menu) */
    #sidebar {
      width: 30vw;
      min-width: 260px;
      max-width: 520px;
      padding: 20px;
      background: #fff;
      color: #000;
      border-right: 4px solid var(--accent);
      overflow-y: auto;
      box-sizing: border-box;
    }

    #sidebar h1 {
      margin: 0 0 0.25rem;
      font-size: 1.4rem;
      color: var(--accent);
      text-align: center;
      border-bottom: 2px solid var(--accent);
      padding-bottom: 0.5rem;
    }

    #sidebar .subtitle {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: var(--text-muted);
      text-align: center;
    }

    .group {
      box-shadow: 0 1px 4px rgba(0,0,0,.12);
      border-radius: 6px;
      padding: 1rem 1.2rem;
      background: #fff;
      margin: 1rem 0;
    }

    .group h3 {
      margin: 0 0 0.6rem;
      color: #333;
      font-size: 1rem;
    }

    .row {
      display: flex;
      align-items: center;
      gap: .6rem;
      margin: .5rem 0;
      flex-wrap: wrap;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.85rem;
      flex: 1;
      min-width: 0;
    }

    .field label {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .field input[type="number"],
    .field input[type="text"],
    .field input[type="color"],
    .field select,
    .field textarea {
      padding: .6rem .75rem;
      border: 1px solid var(--line);
      border-radius: 6px;
      background: #fff;
      color: #000;
      font: inherit;
      outline: none;
      width: 100%;
    }

    .field textarea {
      resize: vertical;
      min-height: 2.5rem;
    }

    .field input[type="number"]:focus,
    .field input[type="text"]:focus,
    .field input[type="color"]:focus,
    .field textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0,150,136,0.18);
    }

    .field input[type="range"] {
      width: 100%;
    }

    .toggle-container {
      margin-top: 0.75rem;
    }

    .teal-label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: #333;
    }

    .teal-label input[type="checkbox"] {
      accent-color: var(--accent);
    }

    .inline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #eefaf8;
      border: 1px solid #bfe7e1;
      padding: .55rem .7rem;
      border-radius: 6px;
      gap: 0.75rem;
    }

    .inline label {
      margin: 0;
      color: #333;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .export-btn {
      display: inline-block;
      padding: 8px 16px;
      margin: 4px;
      font-size: 0.9rem;
      background: #009688;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
    }

    .export-btn.alt {
      background: #fff;
      color: #009688;
      border: 2px solid #009688;
    }

    .export-btn.small {
      padding: 6px 10px;
      font-size: 0.8rem;
    }

    .export-btn.danger {
      background: #fff;
      color: #c62828;
      border: 2px solid #c62828;
    }

    .export-btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    small.hint {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* Right side: preview / sheet */
    #content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      background: var(--bg-main);
      box-sizing: border-box;
      overflow: hidden;
    }

    #sheetFrame {
      position: relative;
      flex: 1;
      min-height: 280px;
      border-radius: 10px;
      background:
        linear-gradient(45deg, #e5e7eb 25%, transparent 25%, transparent 75%, #e5e7eb 75%, #e5e7eb),
        linear-gradient(45deg, #e5e7eb 25%, transparent 25%, transparent 75%, #e5e7eb 75%, #e5e7eb);
      background-color: #f9fafb;
      background-size: 16px 16px;
      background-position: 0 0, 8px 8px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.18);
      padding: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #sheetContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #sheet {
      position: relative;
      background: transparent;
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.8);
      border-radius: 6px;
      transform-origin: top left;
      image-rendering: crisp-edges;
    }

    #helperText {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-top: 0.6rem;
    }

    /* Sprites / handles */
    .sprite {
      position: absolute;
      cursor: move;
      touch-action: none;
      user-select: none;
      box-sizing: border-box;
      transform-origin: center center;
    }

    .sprite.selected {
      outline: 2px dashed rgba(0, 150, 136, 0.9);
      outline-offset: 2px;
    }

    .sprite img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
    }

    .sprite-text {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      font-weight: 800;              /* VERY BOLD BY DEFAULT */
      letter-spacing: 0.03em;
      white-space: pre;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      pointer-events: none;
    }

    .sprite-handle {
      position: absolute;
      background: #009688;
      border: 1px solid #004d40;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

    .sprite-handle-resize {
      width: 12px;
      height: 12px;
      bottom: -8px;
      right: -8px;
      border-radius: 3px;
      cursor: nwse-resize;
    }

    .sprite-handle-rotate {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      top: -24px;
      left: 50%;
      margin-left: -6px;
      cursor: grab;
    }

    /* Object panel */
    #objectTypeLabel {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }

    .object-subfield {
      display: none;
    }

    .object-subfield.active {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }

    #cricutHelp {
      font-size: 0.78rem;
      color: var(--text-muted);
      line-height: 1.4;
      margin-top: 0.5rem;
    }

    #cricutHelp strong {
      color: #000;
    }

    /* Preset strip */
    #presetStripWrapper {
      margin-top: 0.5rem;
      display: none; /* toggled by Galerie button */
    }

    #presetStrip {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.25rem;
    }

    .preset-thumb {
      width: 72px;
      height: 72px;
      border-radius: 6px;
      border: 1px solid var(--line);
      background: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      overflow: hidden;
    }

    .preset-thumb img {
      max-width: 100%;
      max-height: 100%;
      display: block;
      pointer-events: none;
    }

    /* Sprite list (menu of objects) */
    #spriteList {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 0.35rem;
    }

    .sprite-list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--line);
      background: #fafafa;
      font-size: 0.8rem;
      cursor: pointer;
      text-align: left;
      gap: 6px;
    }

    .sprite-list-item span.sprite-label-main {
      font-weight: 600;
      color: #333;
    }

    .sprite-list-item span.sprite-label-sub {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .sprite-list-item .type-pill {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: #e0f2f1;
      color: #00695c;
      white-space: nowrap;
    }

    .sprite-list-item.is-selected {
      border-color: var(--accent);
      background: #e0f2f1;
    }

    .sprite-list-text-input {
      width: 100%;
      border: none;
      background: transparent;
      font-size: 0.8rem;
      font-weight: 600;
      color: #333;
      padding: 0;
      margin: 0;
      outline: none;
    }

    /* Advanced panel initially hidden */
    #advPanel {
      display: none;
    }

    /* CVI pictogrammes */
    #cviPanel {
      margin-top: 0.6rem;
      border-top: 1px solid var(--line);
      padding-top: 0.6rem;
    }

    #cviStrip {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.35rem;
    }

    .preset-thumb.is-selected {
      box-shadow: 0 0 0 2px var(--accent);
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="app-container">
    <aside id="sidebar">
      <h1>Planche d’autocollants</h1>
      <div class="subtitle">
        Ajouter des images, flèches et textes, puis exporter un PNG transparent.
      </div>

      <!-- BASIC: images (galerie + upload) -->
      <div class="group">
        <h3>Basic pictograms</h3>
        <div class="row" style="justify-content:center;">
          <button id="openGalleryBtn" class="export-btn">
            Basic pictograms
          </button>
          <input id="imageFiles" type="file" accept="image/png,image/*" multiple style="display:none;">
          <button id="uploadBtn" class="export-btn alt">
            Importer PNG…
          </button>
        </div>

        <div id="presetStripWrapper">
          <div id="presetStrip">
            <!-- Thumbnails from stickers.json will be injected here -->
          </div>
        </div>

        <div id="cviPanel">
          <div class="row">
            <div class="field" style="flex: 0 1 180px;">
              <label for="cviCategory">Catégorie des pictogrammes</label>
              <select id="cviCategory"></select>
            </div>
            <div class="field" style="flex: 1 1 auto;">
              <label>Additional pictograms</label>
              <small class="hint">Cliquer pour ajouter un pictogramme.</small>
            </div>
          </div>
          <div id="cviStrip"></div>
        </div>
      </div>

      <!-- BASIC: elements (text + arrow + clear) -->
      <div class="group">
        <h3>Éléments</h3>
        <div class="row">
          <button type="button" id="addTextBtn" class="export-btn alt small">
            + Texte
          </button>
          <button type="button" id="addArrowBtn" class="export-btn alt small">
            + Flèche
          </button>
        </div>
        <div class="row">
          <button type="button" id="clearAll" class="export-btn danger small">
            Effacer la planche
          </button>
        </div>
      </div>

      <!-- Sprite list / menu of objects -->
      <div class="group">
        <h3>Liste des objets</h3>
        <div id="spriteList">
          <!-- Items generated via JS -->
        </div>
      </div>

      <!-- BASIC: export (file name + download) -->
      <div class="group">
        <h3>Exportation</h3>
        <div class="field">
          <label for="sheetName">Nom du fichier</label>
          <input type="text" id="sheetName" placeholder="Ma planche" />
        </div>
        <div class="row" style="justify-content:center; margin-top:0.75rem;">
          <button type="button" id="downloadPng" class="export-btn">
            Télécharger PNG
          </button>
        </div>
      </div>

      <!-- Toggle for advanced -->
      <div class="toggle-container">
        <label class="teal-label">
          <input type="checkbox" id="toggleAdvanced" />
          <span>Afficher les réglages avancés</span>
        </label>
      </div>

      <!-- ADVANCED PANEL -->
      <div id="advPanel">
        <!-- Planche (advanced sizing) -->
        <div class="group">
          <h3>Planche (avancé)</h3>
          <div class="row">
            <div class="field">
              <label for="sheetWidth">Largeur (px)</label>
              <input type="number" id="sheetWidth" value="1200" min="200" max="4000" />
            </div>
            <div class="field">
              <label for="sheetHeight">Hauteur (px)</label>
              <input type="number" id="sheetHeight" value="800" min="200" max="4000" />
            </div>
          </div>
        </div>

        <!-- Selected object settings -->
        <div class="group">
          <h3>Objet sélectionné</h3>
          <div id="objectPanel">
            <div id="objectTypeLabel">Aucun objet sélectionné</div>

            <div class="field">
              <label for="sizePercent">
                Taille (<span id="sizePercentLabel">100</span>%)
              </label>
              <input type="range" id="sizePercent" min="10" max="300" value="100" />
            </div>

            <div class="field">
              <div class="inline">
                <label>
                  <input type="checkbox" id="flipH" />
                  <span>Inverser horizontalement</span>
                </label>
              </div>
            </div>

            <!-- Text controls -->
            <div class="object-subfield" id="textControls">
              <div class="field">
                <label for="textSpriteContent">Texte</label>
                <textarea id="textSpriteContent"></textarea>
              </div>
              <div class="row">
                <div class="field">
                  <label for="textSpriteSize">Taille de police</label>
                  <input type="number" id="textSpriteSize" value="48" min="8" max="200" />
                </div>
                <div class="field">
                  <label for="textSpriteColor">Couleur</label>
                  <input type="color" id="textSpriteColor" value="#000000" />
                </div>
              </div>
            </div>

            <!-- Arrow controls -->
            <div class="object-subfield" id="arrowControls">
              <div class="field">
                <label for="arrowColor">Couleur de la flèche</label>
                <input type="color" id="arrowColor" value="#000000" />
              </div>
            </div>
          </div>

          <div id="cricutHelp">
            <strong>Astuce Cricut :</strong> Importer le PNG dans Cricut Design Space,
            choisir <strong>Cut image</strong> (ou Print then Cut) et ajuster la taille.
          </div>
        </div>
      </div>
    </aside>

    <main id="content">
      <section id="sheetFrame">
        <div id="sheetContainer">
          <div id="sheet">
            <!-- Sprite <div>s will be injected here -->
          </div>
        </div>
      </section>
      <div id="helperText">
        Glisser les éléments. Utiliser le carré pour redimensionner et le cercle pour tourner.
      </div>
    </main>
  </div>

  <!-- JS -->
  <script src="../../js/cviPngArray.js"></script>
  <script>
    const imageFilesEl = document.getElementById("imageFiles");
    const openGalleryBtn = document.getElementById("openGalleryBtn");
    const uploadBtn = document.getElementById("uploadBtn");
    const presetStripWrapperEl = document.getElementById("presetStripWrapper");
    const presetStripEl = document.getElementById("presetStrip");

    const sheetWidthEl = document.getElementById("sheetWidth");
    const sheetHeightEl = document.getElementById("sheetHeight");
    const sheetNameEl = document.getElementById("sheetName");
    const clearAllBtn = document.getElementById("clearAll");
    const downloadPngBtn = document.getElementById("downloadPng");
    const addTextBtn = document.getElementById("addTextBtn");
    const addArrowBtn = document.getElementById("addArrowBtn");

    const sheetContainerEl = document.getElementById("sheetContainer");
    const sheetEl = document.getElementById("sheet");

    const objectTypeLabelEl = document.getElementById("objectTypeLabel");
    const sizePercentEl = document.getElementById("sizePercent");
    const sizePercentLabelEl = document.getElementById("sizePercentLabel");
    const flipHEl = document.getElementById("flipH");

    const textControlsEl = document.getElementById("textControls");
    const textSpriteContentEl = document.getElementById("textSpriteContent");
    const textSpriteSizeEl = document.getElementById("textSpriteSize");
    const textSpriteColorEl = document.getElementById("textSpriteColor");

    const arrowControlsEl = document.getElementById("arrowControls");
    const arrowColorEl = document.getElementById("arrowColor");

    const toggleAdvancedEl = document.getElementById("toggleAdvanced");
    const advPanelEl = document.getElementById("advPanel");

    const spriteListEl = document.getElementById("spriteList");
    const cviCategoryEl = document.getElementById("cviCategory");
    const cviStripEl = document.getElementById("cviStrip");

    // Paths for JSON manifest
    const STICKER_BASE_PATH = "../../images/stickers/";
    const STICKER_MANIFEST_URL = STICKER_BASE_PATH + "stickers.json";

    // CVI pictograms (see js/cviPngArray.js)
    const CVI_PNG_LIST = Array.isArray(window.PNG_ARRAY)
      ? window.PNG_ARRAY.filter((item) => item && item.file)
      : [];

    if (toggleAdvancedEl && advPanelEl) {
      toggleAdvancedEl.addEventListener("change", () => {
        advPanelEl.style.display = toggleAdvancedEl.checked ? "block" : "none";
      });
    }

    // Folder gallery button: toggle visibility of preset thumbnails
    if (openGalleryBtn && presetStripWrapperEl) {
      openGalleryBtn.addEventListener("click", () => {
        const isVisible = presetStripWrapperEl.style.display === "block";
        presetStripWrapperEl.style.display = isVisible ? "none" : "block";
      });
    }

    // Upload button triggers hidden file input
    if (uploadBtn && imageFilesEl) {
      uploadBtn.addEventListener("click", () => {
        imageFilesEl.click();
      });
    }

    let sprites = []; // {id, type, name, ...}
    let nextSpriteId = 1;
    let selectedSpriteId = null;

    let sheetWidth = parseInt(sheetWidthEl.value, 10) || 1200;
    let sheetHeight = parseInt(sheetHeightEl.value, 10) || 800;

    function applySheetSize() {
      sheetWidth = Math.max(200, parseInt(sheetWidthEl.value, 10) || 1200);
      sheetHeight = Math.max(200, parseInt(sheetHeightEl.value, 10) || 800);
      sheetEl.style.width = sheetWidth + "px";
      sheetEl.style.height = sheetHeight + "px";
      applySheetScale();
      repositionSpritesDom();
    }

    function applySheetScale() {
      const frameRect = sheetContainerEl.getBoundingClientRect();
      if (!frameRect.width || !frameRect.height) return;
      const scaleX = frameRect.width / sheetWidth;
      const scaleY = frameRect.height / sheetHeight;
      const scale = Math.min(scaleX, scaleY, 1);
      sheetEl.style.transform = `scale(${scale})`;
    }

    window.addEventListener("resize", applySheetScale);

    function getSpriteById(id) {
      return sprites.find((s) => s.id === id) || null;
    }

    function refreshSpriteList() {
      if (!spriteListEl) return;
      spriteListEl.innerHTML = "";
      if (!sprites.length) return;

      sprites.forEach((s) => {
        const item = document.createElement("button");
        item.type = "button";
        item.className = "sprite-list-item" + (s.id === selectedSpriteId ? " is-selected" : "");

        let typeLabel = "";
        if (s.type === "image") typeLabel = "Image";
        else if (s.type === "text") typeLabel = "Texte";
        else if (s.type === "arrow") typeLabel = "Flèche";
        else typeLabel = s.type;

        const leftGroup = document.createElement("div");
        leftGroup.style.display = "flex";
        leftGroup.style.flexDirection = "column";
        leftGroup.style.flex = "1 1 auto";
        leftGroup.style.minWidth = "0";

        if (s.type === "text") {
          const input = document.createElement("input");
          input.type = "text";
          input.className = "sprite-list-text-input";

          const currentFirstLine = (s.text || "").split(/\r?\n/)[0] || ("Texte " + s.id);
          input.value = currentFirstLine;

          input.addEventListener("click", (ev) => {
            ev.stopPropagation();
          });

          input.addEventListener("input", () => {
            s.text = input.value;
            if (s.textEl) {
              s.textEl.textContent = s.text;
            }
            if (selectedSpriteId === s.id && textSpriteContentEl) {
              textSpriteContentEl.value = s.text;
            }
            s.name = (s.text || "").split(/\r?\n/)[0] || ("Texte " + s.id);
            refreshSpriteList();
          });

          leftGroup.appendChild(input);
        } else {
          const labelMain = document.createElement("span");
          labelMain.className = "sprite-label-main";
          const displayName = (s.name || typeLabel) || "";
          labelMain.textContent = displayName;

          const labelSub = document.createElement("span");
          labelSub.className = "sprite-label-sub";
          labelSub.textContent = `ID ${s.id}`;

          leftGroup.appendChild(labelMain);
          leftGroup.appendChild(labelSub);
        }

        const typePill = document.createElement("span");
        typePill.className = "type-pill";
        typePill.textContent = typeLabel;

        item.appendChild(leftGroup);
        item.appendChild(typePill);

        item.addEventListener("click", () => {
          setSelectedSprite(s.id);
        });

        spriteListEl.appendChild(item);
      });
    }

    function setSelectedSprite(id) {
      selectedSpriteId = id;
      sprites.forEach((s) => {
        if (s.wrapper) {
          s.wrapper.classList.toggle("selected", s.id === selectedSpriteId);
        }
      });
      refreshObjectControls();
      refreshSpriteList();
    }

    function repositionSpritesDom() {
      sprites.forEach((sprite) => {
        if (!sprite.wrapper) return;
        sprite.wrapper.style.left = sprite.x + "px";
        sprite.wrapper.style.top = sprite.y + "px";
        sprite.wrapper.style.width = sprite.width + "px";
        sprite.wrapper.style.height = sprite.height + "px";
      });
    }

    function updateSpriteDomAppearance(sprite) {
      if (!sprite.wrapper) return;
      sprite.width = sprite.baseWidth * sprite.scale;
      sprite.height = sprite.baseHeight * sprite.scale;
      sprite.wrapper.style.width = sprite.width + "px";
      sprite.wrapper.style.height = sprite.height + "px";

      const flipFactor = sprite.flipH ? -1 : 1;
      const rot = sprite.rotation || 0;
      sprite.wrapper.style.transform = `rotate(${rot}deg) scale(${flipFactor}, 1)`;

      if (sprite.type === "text" && sprite.textEl) {
        sprite.textEl.textContent = sprite.text || "";
        const effectiveFontSize = (sprite.fontSize || 48) * (sprite.scale || 1);
        sprite.textEl.style.fontSize = effectiveFontSize + "px";
        sprite.textEl.style.color = sprite.textColor;
      }

      if (sprite.type === "arrow" && sprite.arrowPathEl) {
        sprite.arrowPathEl.setAttribute("stroke", sprite.color);
      }
    }

    function createHandlesForSprite(sprite) {
      if (!sprite.wrapper) return;
      const resizeHandle = document.createElement("div");
      resizeHandle.className = "sprite-handle sprite-handle-resize";

      const rotateHandle = document.createElement("div");
      rotateHandle.className = "sprite-handle sprite-handle-rotate";

      sprite.wrapper.appendChild(resizeHandle);
      sprite.wrapper.appendChild(rotateHandle);

      resizeHandle.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        e.preventDefault();
        setSelectedSprite(sprite.id);

        let resizing = true;
        const sheetRect = sheetEl.getBoundingClientRect();
        const scaleX = sheetWidth / sheetRect.width;
        const scaleY = sheetHeight / sheetRect.height;

        const startClientX = e.clientX;
        const startClientY = e.clientY;
        const startWidth = sprite.width;
        const startHeight = sprite.height;
        const aspect = startWidth / startHeight;

        function onMove(ev) {
          if (!resizing) return;
          const dx = (ev.clientX - startClientX) * scaleX;
          const dy = (ev.clientY - startClientY) * scaleY;
          const delta = Math.max(dx, dy);
          let newWidth = Math.max(20, startWidth + delta);
          let newHeight = newWidth / aspect;
          sprite.scale = newWidth / sprite.baseWidth;
          sprite.width = newWidth;
          sprite.height = newHeight;
          updateSpriteDomAppearance(sprite);
        }

        function onUp() {
          resizing = false;
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onUp);
        }

        window.addEventListener("pointermove", onMove);
        window.addEventListener("pointerup", onUp);
      });

      rotateHandle.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        e.preventDefault();
        setSelectedSprite(sprite.id);
        let rotating = true;

        function getCenter() {
          const rect = sprite.wrapper.getBoundingClientRect();
          return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        }

        const center = getCenter();

        function onMove(ev) {
          if (!rotating) return;
          const angleRad = Math.atan2(ev.clientY - center.y, ev.clientX - center.x);
          const deg = angleRad * (180 / Math.PI);
          sprite.rotation = deg;
          updateSpriteDomAppearance(sprite);
        }

        function onUp() {
          rotating = false;
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onUp);
        }

        window.addEventListener("pointermove", onMove);
        window.addEventListener("pointerup", onUp);
      });
    }

    function addImageSpriteFromFile(file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        addImageSpriteFromDataUrl(ev.target.result, file.name);
      };
      reader.readAsDataURL(file);
    }

    function addImageSpriteFromDataUrl(dataUrl, name) {
      const img = new Image();
      img.onload = () => {
        const spriteId = nextSpriteId++;
        const wrapper = document.createElement("div");
        wrapper.className = "sprite";
        wrapper.dataset.spriteId = String(spriteId);

        const startX = (sheetWidth - img.naturalWidth) / 2;
        const startY = (sheetHeight - img.naturalHeight) / 2;

        wrapper.style.left = startX + "px";
        wrapper.style.top = startY + "px";
        wrapper.style.width = img.naturalWidth + "px";
        wrapper.style.height = img.naturalHeight + "px";

        img.draggable = false;
        wrapper.appendChild(img);
        sheetEl.appendChild(wrapper);

        const spriteName = name || "Image";

        const sprite = {
          id: spriteId,
          type: "image",
          name: spriteName,
          wrapper,
          imgEl: img,
          x: startX,
          y: startY,
          baseWidth: img.naturalWidth,
          baseHeight: img.naturalHeight,
          scale: 1,
          width: img.naturalWidth,
          height: img.naturalHeight,
          flipH: false,
          rotation: 0
        };

        sprites.push(sprite);
        createHandlesForSprite(sprite);
        updateSpriteDomAppearance(sprite);
        setupDragForSprite(wrapper, sprite);
        setSelectedSprite(sprite.id);
        applySheetScale();
        refreshSpriteList();
      };
      img.src = dataUrl;
    }

    function addTextSprite() {
      const spriteId = nextSpriteId++;
      const wrapper = document.createElement("div");
      wrapper.className = "sprite";
      wrapper.dataset.spriteId = String(spriteId);

      const textEl = document.createElement("div");
      textEl.className = "sprite-text";
      textEl.textContent = "TEXTE";
      wrapper.appendChild(textEl);

      const baseWidth = 300;
      const baseHeight = 80;
      const startX = (sheetWidth - baseWidth) / 2;
      const startY = (sheetHeight - baseHeight) / 2;

      wrapper.style.left = startX + "px";
      wrapper.style.top = startY + "px";

      sheetEl.appendChild(wrapper);

      const sprite = {
        id: spriteId,
        type: "text",
        name: "Texte " + spriteId,
        wrapper,
        textEl,
        x: startX,
        y: startY,
        baseWidth,
        baseHeight,
        scale: 1,
        width: baseWidth,
        height: baseHeight,
        flipH: false,
        rotation: 0,
        text: "TEXTE",
        fontSize: 48,
        textColor: "#000000"
      };

      sprites.push(sprite);
      createHandlesForSprite(sprite);
      updateSpriteDomAppearance(sprite);
      setupDragForSprite(wrapper, sprite);
      setSelectedSprite(sprite.id);
      applySheetScale();
      refreshSpriteList();
    }

    function addArrowSprite() {
      const spriteId = nextSpriteId++;
      const wrapper = document.createElement("div");
      wrapper.className = "sprite";
      wrapper.dataset.spriteId = String(spriteId);

      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", "0 0 200 40");
      svg.style.width = "100%";
      svg.style.height = "100%";

      const path = document.createElementNS(svgNS, "path");
      path.setAttribute("d", "M10 20 H160 M160 20 L145 10 M160 20 L145 30");
      path.setAttribute("stroke", "#000000");
      path.setAttribute("stroke-width", "8");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-linecap", "round");
      path.setAttribute("stroke-linejoin", "round");

      svg.appendChild(path);
      wrapper.appendChild(svg);

      const baseWidth = 200;
      const baseHeight = 40;
      const startX = (sheetWidth - baseWidth) / 2;
      const startY = (sheetHeight - baseHeight) / 2;

      wrapper.style.left = startX + "px";
      wrapper.style.top = startY + "px";

      sheetEl.appendChild(wrapper);

      const sprite = {
        id: spriteId,
        type: "arrow",
        name: "Flèche " + spriteId,
        wrapper,
        svgEl: svg,
        arrowPathEl: path,
        x: startX,
        y: startY,
        baseWidth,
        baseHeight,
        scale: 1,
        width: baseWidth,
        height: baseHeight,
        flipH: false,
        rotation: 0,
        color: "#000000"
      };

      sprites.push(sprite);
      createHandlesForSprite(sprite);
      updateSpriteDomAppearance(sprite);
      setupDragForSprite(wrapper, sprite);
      setSelectedSprite(sprite.id);
      applySheetScale();
      refreshSpriteList();
    }

    function setupDragForSprite(wrapper, sprite) {
      wrapper.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        const id = parseInt(wrapper.dataset.spriteId, 10);
        setSelectedSprite(id);

        let dragging = true;
        wrapper.setPointerCapture(e.pointerId);

        const sheetRect = sheetEl.getBoundingClientRect();
        const scaleX = sheetWidth / sheetRect.width;
        const scaleY = sheetHeight / sheetRect.height;

        const startClientX = e.clientX;
        const startClientY = e.clientY;
        const startX = sprite.x;
        const startY = sprite.y;

        function onPointerMove(ev) {
          if (!dragging) return;
          const dxSheet = (ev.clientX - startClientX) * scaleX;
          const dySheet = (ev.clientY - startClientY) * scaleY;
          sprite.x = startX + dxSheet;
          sprite.y = startY + dySheet;
          wrapper.style.left = sprite.x + "px";
          wrapper.style.top = sprite.y + "px";
        }

        function onPointerUp() {
          dragging = false;
          wrapper.releasePointerCapture(e.pointerId);
          window.removeEventListener("pointermove", onPointerMove);
          window.removeEventListener("pointerup", onPointerUp);
        }

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", onPointerUp);
      });
    }

    function refreshObjectControls() {
      const sprite = selectedSpriteId ? getSpriteById(selectedSpriteId) : null;

      if (!sprite) {
        objectTypeLabelEl.textContent = "Aucun objet sélectionné";
        sizePercentEl.value = 100;
        sizePercentLabelEl.textContent = "100";
        flipHEl.checked = false;
        textControlsEl.classList.remove("active");
        arrowControlsEl.classList.remove("active");
        return;
      }

      objectTypeLabelEl.textContent = `ID ${sprite.id} — ${sprite.type}`;
      const percent = Math.round(sprite.scale * 100);
      sizePercentEl.value = percent;
      sizePercentLabelEl.textContent = percent.toString();
      flipHEl.checked = sprite.flipH;

      if (sprite.type === "text") {
        textControlsEl.classList.add("active");
        textSpriteContentEl.value = sprite.text || "";
        textSpriteSizeEl.value = sprite.fontSize || 48;
        textSpriteColorEl.value = sprite.textColor || "#000000";
      } else {
        textControlsEl.classList.remove("active");
      }

      if (sprite.type === "arrow") {
        arrowControlsEl.classList.add("active");
        arrowColorEl.value = sprite.color || "#000000";
      } else {
        arrowControlsEl.classList.remove("active");
      }
    }

    sizePercentEl.addEventListener("input", () => {
      const sprite = selectedSpriteId ? getSpriteById(selectedSpriteId) : null;
      const val = parseInt(sizePercentEl.value, 10) || 100;
      sizePercentLabelEl.textContent = val.toString();
      if (!sprite) return;
      sprite.scale = val / 100;
      updateSpriteDomAppearance(sprite);
      applySheetScale();
    });

    flipHEl.addEventListener("change", () => {
      const sprite = selectedSpriteId ? getSpriteById(selectedSpriteId) : null;
      if (!sprite) return;
      sprite.flipH = flipHEl.checked;
      updateSpriteDomAppearance(sprite);
    });

    textSpriteContentEl.addEventListener("input", () => {
      const sprite = selectedSpriteId ? getSpriteById(selectedSpriteId) : null;
      if (!sprite || sprite.type !== "text") return;
      sprite.text = textSpriteContentEl.value;
      if (sprite.textEl) {
        sprite.textEl.textContent = sprite.text;
      }
      const firstLine = (sprite.text || "").split(/\r?\n/)[0];
      sprite.name = firstLine || ("Texte " + sprite.id);
      refreshSpriteList();
      updateSpriteDomAppearance(sprite);
    });

    textSpriteSizeEl.addEventListener("input", () => {
      const sprite = selectedSpriteId ? getSpriteById(selectedSpriteId) : null;
      if (!sprite || sprite.type !== "text") return;
      const size = Math.max(8, parseInt(textSpriteSizeEl.value, 10) || 48);
      sprite.fontSize = size;
      updateSpriteDomAppearance(sprite);
    });

    textSpriteColorEl.addEventListener("input", () => {
      const sprite = selectedSpriteId ? getSpriteById(selectedSpriteId) : null;
      if (!sprite || sprite.type !== "text") return;
      sprite.textColor = textSpriteColorEl.value || "#000000";
      updateSpriteDomAppearance(sprite);
    });

    arrowColorEl.addEventListener("input", () => {
      const sprite = selectedSpriteId ? getSpriteById(selectedSpriteId) : null;
      if (!sprite || sprite.type !== "arrow") return;
      sprite.color = arrowColorEl.value || "#000000";
      updateSpriteDomAppearance(sprite);
    });

    function drawArrowOnCanvas(ctx, sprite) {
      ctx.save();
      const cx = sprite.x + sprite.width / 2;
      const cy = sprite.y + sprite.height / 2;
      ctx.translate(cx, cy);
      const rotRad = (sprite.rotation || 0) * (Math.PI / 180);
      ctx.rotate(rotRad);
      const flipFactor = sprite.flipH ? -1 : 1;
      const scaleX = (sprite.width / sprite.baseWidth) * flipFactor;
      const scaleY = sprite.height / sprite.baseHeight;
      ctx.scale(scaleX, scaleY);
      ctx.translate(-sprite.baseWidth / 2, -sprite.baseHeight / 2);

      ctx.lineWidth = 8;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = sprite.color || "#000000";

      ctx.beginPath();
      ctx.moveTo(10, 20);
      ctx.lineTo(160, 20);
      ctx.moveTo(160, 20);
      ctx.lineTo(145, 10);
      ctx.moveTo(160, 20);
      ctx.lineTo(145, 30);
      ctx.stroke();

      ctx.restore();
    }

    function drawTextOnCanvas(ctx, sprite) {
      ctx.save();
      const cx = sprite.x + sprite.width / 2;
      const cy = sprite.y + sprite.height / 2;
      ctx.translate(cx, cy);
      const rotRad = (sprite.rotation || 0) * (Math.PI / 180);
      ctx.rotate(rotRad);
      const flipFactor = sprite.flipH ? -1 : 1;
      ctx.scale(flipFactor, 1);

      ctx.fillStyle = sprite.textColor || "#000000";
      const fontSize = (sprite.fontSize || 48) * (sprite.scale || 1);
      ctx.font = `800 ${fontSize}px system-ui, -apple-system, 'Segoe UI', sans-serif`;
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";

      const lines = (sprite.text || "").split(/\r?\n/);
      const lineHeight = fontSize * 1.2;
      lines.forEach((line, i) => {
        const y = (i - (lines.length - 1) / 2) * lineHeight;
        ctx.fillText(line, 0, y);
      });

      ctx.restore();
    }

    function downloadSheetAsPng() {
      if (!sprites.length) {
        alert("Ajouter au moins un autocollant, une flèche ou un texte avant d’exporter.");
        return;
      }

      const canvas = document.createElement("canvas");
      canvas.width = sheetWidth;
      canvas.height = sheetHeight;
      const ctx = canvas.getContext("2d");

      sprites.forEach((sprite) => {
        if (sprite.type === "image" && sprite.imgEl) {
          ctx.save();
          const cx = sprite.x + sprite.width / 2;
          const cy = sprite.y + sprite.height / 2;
          ctx.translate(cx, cy);
          const rotRad = (sprite.rotation || 0) * (Math.PI / 180);
          ctx.rotate(rotRad);
          const flipFactor = sprite.flipH ? -1 : 1;
          ctx.scale(flipFactor * sprite.scale, sprite.scale);
          ctx.drawImage(
            sprite.imgEl,
            -sprite.baseWidth / 2,
            -sprite.baseHeight / 2,
            sprite.baseWidth,
            sprite.baseHeight
          );
          ctx.restore();
        } else if (sprite.type === "arrow") {
          drawArrowOnCanvas(ctx, sprite);
        } else if (sprite.type === "text") {
          drawTextOnCanvas(ctx, sprite);
        }
      });

      canvas.toBlob((blob) => {
        if (!blob) {
          alert("Impossible de générer le PNG.");
          return;
        }
        const url = URL.createObjectURL(blob);
        const baseName = (sheetNameEl.value || "sticker-sheet")
          .trim()
          .replace(/\s+/g, "-");
        const a = document.createElement("a");
        a.download = baseName + ".png";
        a.href = url;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, "image/png");
    }

    imageFilesEl.addEventListener("change", (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      files.forEach((file) => {
        if (!file.type.startsWith("image/")) return;
        addImageSpriteFromFile(file);
      });
      imageFilesEl.value = "";
    });

    // Load preset stickers from JSON (with id + file)
    async function loadStickerPresets() {
      if (!presetStripEl) return;
      try {
        const res = await fetch(STICKER_MANIFEST_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(res.status + " " + res.statusText);
        const data = await res.json();

        let stickers = Array.isArray(data.stickers) ? data.stickers : [];

        // Backward compatibility if needed
        if (!stickers.length && Array.isArray(data.files)) {
          stickers = data.files.map((f) => ({ id: f, file: f }));
        }

        presetStripEl.innerHTML = "";

        stickers.forEach((sticker) => {
          if (!sticker || !sticker.file) return;

          const src = STICKER_BASE_PATH + sticker.file;
          const label = sticker.id || sticker.file;

          const thumb = document.createElement("div");
          thumb.className = "preset-thumb";
          thumb.dataset.src = src;
          thumb.dataset.label = label;
          thumb.title = label;

          const img = document.createElement("img");
          img.src = src;
          img.alt = label;

          thumb.appendChild(img);
          presetStripEl.appendChild(thumb);
        });
      } catch (err) {
        console.error("Erreur de chargement des autocollants prédéfinis:", err);
      }
    }

    function populateCviCategories() {
      if (!cviCategoryEl) return;
      const categories = Array.from(
        new Set(CVI_PNG_LIST.map((item) => item.category || "Divers"))
      ).sort((a, b) => a.localeCompare(b, "fr"));

      cviCategoryEl.innerHTML = "";

      const allOption = document.createElement("option");
      allOption.value = "__all";
      allOption.textContent = "Toutes les catégories";
      cviCategoryEl.appendChild(allOption);

      categories.forEach((cat) => {
        const opt = document.createElement("option");
        opt.value = cat;
        opt.textContent = cat;
        cviCategoryEl.appendChild(opt);
      });

      let initialValue = "";
      let highlightFile = null;

      if (CVI_PNG_LIST.length) {
        const randomItem = CVI_PNG_LIST[Math.floor(Math.random() * CVI_PNG_LIST.length)];
        initialValue = randomItem.category || "Divers";
        highlightFile = randomItem.file;
      } else if (categories.length) {
        initialValue = categories[0];
      }

      cviCategoryEl.value = initialValue || "";
      renderCviStrip(initialValue, highlightFile);

      cviCategoryEl.addEventListener("change", () => {
        renderCviStrip(cviCategoryEl.value);
      });
    }

    function renderCviStrip(categoryValue, highlightFile = null) {
      if (!cviStripEl) return;

      cviStripEl.innerHTML = "";
      if (!CVI_PNG_LIST.length) {
        const msg = document.createElement("small");
        msg.className = "hint";
        msg.textContent = "Aucun pictogramme CVI disponible.";
        cviStripEl.appendChild(msg);
        return;
      }

      const filtered = CVI_PNG_LIST.filter((item) => {
        if (!item) return false;
        const cat = item.category || "Divers";
        if (!categoryValue || categoryValue === "__all") return true;
        return cat === categoryValue;
      });

      filtered.forEach((item) => {
        const src = item.file;
        const label = item.name || item.file;

        const thumb = document.createElement("div");
        thumb.className = "preset-thumb";
        thumb.dataset.src = src;
        thumb.dataset.label = label;
        thumb.title = `${label} (${item.category || "Divers"})`;

        if (highlightFile && highlightFile === item.file) {
          thumb.classList.add("is-selected");
        }

        const img = document.createElement("img");
        img.src = src;
        img.alt = label;

        thumb.appendChild(img);
        cviStripEl.appendChild(thumb);
      });
    }

    if (cviStripEl) {
      cviStripEl.addEventListener("click", (e) => {
        const thumb = e.target.closest(".preset-thumb");
        if (!thumb) return;

        const src = thumb.dataset.src;
        if (!src) return;

        const label = thumb.dataset.label || thumb.title || "Sticker";
        addImageSpriteFromDataUrl(src, label);
      });
    }

    // Click on preset thumb => add sprite with nice label
    presetStripEl.addEventListener("click", (e) => {
      const thumb = e.target.closest(".preset-thumb");
      if (!thumb) return;

      const imgEl = thumb.querySelector("img");
      if (!imgEl || !imgEl.src) return;

      const label = thumb.dataset.label || thumb.title || "Sticker";
      addImageSpriteFromDataUrl(imgEl.src, label);
    });

    [sheetWidthEl, sheetHeightEl].forEach((el) => {
      el.addEventListener("input", applySheetSize);
    });

    function deleteSelectedSprite() {
      if (selectedSpriteId == null) return;
      const sprite = getSpriteById(selectedSpriteId);
      if (!sprite) return;
      if (sprite.wrapper && sprite.wrapper.parentNode) {
        sprite.wrapper.parentNode.removeChild(sprite.wrapper);
      }
      sprites = sprites.filter((s) => s.id !== selectedSpriteId);
      selectedSpriteId = null;
      refreshSpriteList();
      refreshObjectControls();
    }

    // Delete key removes selected sprite (but not when typing in inputs/textarea)
    document.addEventListener("keydown", (e) => {
      if (e.key !== "Delete" && e.key !== "Backspace") return;

      const active = document.activeElement;
      if (
        active &&
        (active.tagName === "INPUT" ||
         active.tagName === "TEXTAREA" ||
         active.isContentEditable)
      ) {
        // Let normal text editing happen
        return;
      }

      e.preventDefault();
      deleteSelectedSprite();
    });

    clearAllBtn.addEventListener("click", () => {
      if (!sprites.length) return;
      if (!confirm("Effacer tous les éléments de la planche ?")) return;
      sprites.forEach((sprite) => {
        if (sprite.wrapper && sprite.wrapper.parentNode) {
          sprite.wrapper.parentNode.removeChild(sprite.wrapper);
        }
      });
      sprites = [];
      setSelectedSprite(null);
      refreshSpriteList();
    });

    downloadPngBtn.addEventListener("click", downloadSheetAsPng);
    addTextBtn.addEventListener("click", addTextSprite);
    addArrowBtn.addEventListener("click", addArrowSprite);

    applySheetSize();
    refreshSpriteList();
    loadStickerPresets();
    populateCviCategories();
  </script>
</body>
</html>
