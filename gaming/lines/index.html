<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title
    class="translate"
    data-fr="Lignes fluides"
    data-en="Flow Lines"
    data-ja="流れる線">
    Lignes fluides (ESPACE = activer)
  </title>

  <!-- Styles / libs -->
  <link rel="stylesheet" href="../../css/otherswitch.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>

  <style>
    /* Language pill – unified style */
    #langToggle {
      position: fixed;
      top: 14px;
      right: 44px;
      z-index: 11;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      border: 2px solid #04c8bb;
      background: #0b0f12;
      color: #04c8bb;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 0 0 0 rgba(4, 200, 187, 0);
      transition: box-shadow 0.2s ease, transform 0.05s ease, background 0.2s ease;
      user-select: none;
    }
    #langToggle:hover { box-shadow: 0 0 0 3px rgba(4, 200, 187, 0.2); }
    #langToggle:active { transform: translateY(1px); }

    /* Info toggle top-left (hidden after Start) */
    #infoButton{
      position: fixed; top:10px; left:10px; z-index:99999;
      display:inline-flex; align-items:center; justify-content:center;
      width:40px; height:40px; border-radius:10px; border:2px solid #009688;
      background:#fff; color:#009688; font-weight:700; cursor:pointer;
      user-select:none;
    }
    body.dark #infoButton { background:#111; color:#00b3a4; border-color:#00b3a4; }

    /* Start overlay layout helpers */
    #startOptions{
      display:flex; gap:12px; align-items:center; justify-content:center; margin:14px 0;
      flex-wrap: wrap;
    }

    /* ===== Segmented two-button switch ===== */
    #segSwitch{
      display:inline-flex; align-items:center;
      border:2px solid #009688; border-radius:999px; overflow:hidden;
      box-shadow:0 2px 6px rgba(0,0,0,.12);
    }
    #segSwitch .seg-btn{
      padding:8px 14px; border:0; background:#fff; color:#009688;
      font-weight:700; cursor:pointer; user-select:none;
    }
    #segSwitch .seg-btn[aria-selected="true"]{
      background:#009688; color:#fff;
    }

    /* Better contrast against overlay bg */
    #promptOverlay #segSwitch{ border-color:#fff; }
    #promptOverlay #segSwitch .seg-btn{ background:rgba(255,255,255,0.1); color:#fff; }
    #promptOverlay #segSwitch .seg-btn[aria-selected="true"]{ background:#fff; color:#009688; }

    /* Dark mode */
    body.dark #segSwitch{ border-color:#00b3a4; }
    body.dark #segSwitch .seg-btn{ background:#111; color:#00b3a4; }
    body.dark #segSwitch .seg-btn[aria-selected="true"]{ background:#00b3a4; color:#111; }
  </style>

  <!-- GA (optional) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-B45TJG4GBJ');
  </script>
</head>

<body>
  <!-- Language toggle -->
  <button id="langToggle" title="Basculer la langue / Toggle language">FR / EN / JA</button>

  <!-- Info toggle (hidden after Start) -->
  <button id="infoButton" title="Plus d'infos" class="translate" data-fr="ⓘ" data-en="ⓘ" data-ja="ⓘ">ⓘ</button>

  <!-- Prompt Overlay -->
  <div id="promptOverlay">
    <p class="translate translate-html"
       data-fr="<b>Mode 1 (maintenir)</b> : Maintenir ESPACE = les lignes accélèrent graduellement (rampe), relâcher = tout s’arrête.<br><b>Mode 2 (10 secondes)</b> : Appuyer ESPACE = mouvement pendant 10 secondes, puis arrêt. Appuyer de nouveau pour repartir.<br><br>Après <b>10 secondes de mouvement</b>, la couleur change (fondu + nouvelle couleur)."
       data-en="<b>Mode 1 (hold)</b>: Hold SPACE = lines ramp up to a steady speed, release = everything stops.<br><b>Mode 2 (10 seconds)</b>: Press SPACE = movement for 10 seconds, then stop. Press again to restart.<br><br>After <b>10 seconds of movement</b>, the color changes (fade + new color)."
       data-ja="<b>モード1（押し続け）</b>：スペースを押し続けると徐々に加速、離すと停止。<br><b>モード2（10秒）</b>：スペースで10秒動き、その後停止。もう一度押すと再開。<br><br><b>動いている時間が10秒</b>で色が変わります（フェード＋新色）。">
      Mode 1: maintenir ESPACE, relâcher = arrêt. Mode 2: 10 secondes par appui. Après 10 secondes de mouvement, la couleur change.
    </p>

    <!-- Mode chooser -->
    <div id="startOptions">
      <div id="segSwitch" role="tablist" aria-label="Control mode">
        <button type="button" role="tab" id="segHold" aria-selected="true" class="seg-btn">
          <span class="translate" data-fr="Mode 1 — maintenir" data-en="Mode 1 — hold" data-ja="モード1 — 押し続け">
            Mode 1 — maintenir
          </span>
        </button>
        <button type="button" role="tab" id="segTimed" aria-selected="false" class="seg-btn">
          <span class="translate" data-fr="Mode 2 — 10 secondes" data-en="Mode 2 — 10 seconds" data-ja="モード2 — 10秒">
            Mode 2 — 10 secondes
          </span>
        </button>
      </div>
    </div>

    <button id="startButton" class="translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
  </div>

  <!-- Info Modal -->
  <div id="infoModal" style="display:none;">
    <p class="translate translate-html"
       data-fr="Compétences: cause à effet, maintien (mode 1), anticipation/relance (mode 2), autorégulation par stimulation visuelle douce.<br>Variabilité: changement de couleur toutes les 10 secondes de mouvement."
       data-en="Skills: cause-and-effect, holding (mode 1), anticipation/restart (mode 2), self-regulation with gentle visuals.<br>Variation: color changes every 10 seconds of movement."
       data-ja="スキル：因果関係、保持（モード1）、再開の予測（モード2）、穏やかな視覚刺激による調整。<br>変化：動作10秒ごとに色が変わります。">
      Compétences: cause à effet, maintien, anticipation, autorégulation.
    </p>
    <button id="closeModal" class="translate" data-fr="Fermer" data-en="Close" data-ja="閉じる">Fermer</button>
  </div>

  <script>
    /* ===== Translation system ===== */
    const LS_LANG_KEY = 'siteLanguage';
    const SUPPORTED_LANGS = ['en', 'ja', 'fr'];
    const langToggle = document.getElementById('langToggle');

    function documentLangFallback() {
      const htmlLang = (document.documentElement.lang || '').toLowerCase();
      return SUPPORTED_LANGS.includes(htmlLang) ? htmlLang : 'en';
    }
    function getText(el, lang) {
      for (const code of [lang, ...SUPPORTED_LANGS.filter(c => c !== lang)]) {
        const val = el.getAttribute(`data-${code}`);
        if (val != null) return val;
      }
      return null;
    }
    function applyTranslations(lang) {
      const safeLang = SUPPORTED_LANGS.includes(lang) ? lang : 'en';
      document.querySelectorAll('.translate').forEach(el => {
        const value = getText(el, safeLang);
        if (value == null) return;
        if (['P', 'BUTTON', 'DIV', 'H1', 'H2', 'H3', 'SPAN'].includes(el.tagName)) el.innerHTML = value;
        else el.textContent = value;
      });
      document.documentElement.lang = safeLang;

      const titleEl = document.querySelector('title');
      if (titleEl) {
        const nextTitle = getText(titleEl, safeLang);
        if (nextTitle) { titleEl.textContent = nextTitle; document.title = nextTitle; }
      }

      if (langToggle) {
        const idx = SUPPORTED_LANGS.indexOf(safeLang);
        langToggle.textContent = SUPPORTED_LANGS[(idx + 1) % SUPPORTED_LANGS.length].toUpperCase();
      }
    }
    function setLang(lang) {
      const safeLang = SUPPORTED_LANGS.includes(lang) ? lang : 'en';
      try { localStorage.setItem(LS_LANG_KEY, safeLang); } catch (e) {}
      applyTranslations(safeLang);
    }
    function getInitialLang() {
      let initial = documentLangFallback();
      try {
        const stored = localStorage.getItem(LS_LANG_KEY);
        if (SUPPORTED_LANGS.includes(stored)) initial = stored;
      } catch (e) {}
      return initial;
    }
    langToggle?.addEventListener('click', () => {
      const currentRaw =
        (typeof localStorage !== 'undefined' && localStorage.getItem(LS_LANG_KEY)) ||
        document.documentElement.lang ||
        'en';
      const current = currentRaw.toLowerCase();
      const idx = SUPPORTED_LANGS.indexOf(current);
      setLang(SUPPORTED_LANGS[(idx + 1) % SUPPORTED_LANGS.length]);
    });
    setLang(getInitialLang());

    /* ===== Mode selection (pre-start) ===== */
    let segChoice = 'hold'; // 'hold' | 'timed'
    const segHold = document.getElementById('segHold');
    const segTimed = document.getElementById('segTimed');

    function selectSeg(which){
      segChoice = which;
      segHold.setAttribute('aria-selected', which === 'hold' ? 'true' : 'false');
      segTimed.setAttribute('aria-selected', which === 'timed' ? 'true' : 'false');
    }
    segHold.addEventListener('click', ()=> selectSeg('hold'));
    segTimed.addEventListener('click', ()=> selectSeg('timed'));

    /* ===== Start / info UI ===== */
    let started = false;

    document.getElementById("startButton").addEventListener("click", function() {
      started = true;

      document.getElementById("promptOverlay").style.display = "none";
      const pill = document.getElementById('langToggle'); if (pill) pill.style.display = 'none';
      const info = document.getElementById('infoButton'); if (info) info.style.display = 'none';

      goFullscreen();
    });

    document.getElementById("infoButton").addEventListener("click", function() {
      document.getElementById("infoModal").style.display = "block";
    });
    document.getElementById("closeModal").addEventListener("click", function() {
      document.getElementById("infoModal").style.display = "none";
    });

    function goFullscreen(){
      if(!document.fullscreenElement){
        document.documentElement.requestFullscreen().catch(()=>{});
      }
    }
  </script>

  <script>
    /* =========================================================
       FLOW LINES – single-color cycles with fade transitions
       - Choose 1 color (from 7)
       - After 10 seconds of ACTIVE movement, fade out, respawn new ribbons, new color, fade in
       ========================================================= */

    let canvas;
    let ribbons = [];
    const RIBBON_COUNT = 78;
    const RIBBON_LEN   = 70;

    let currentAngle = 0;
    let targetAngle  = 0;

    let influence = { x: 0, y: 0 };

    // Switch modes
    let isHolding = false;
    let runActive = false;
    let runStartMs = 0;
    const RAMP_MS = 2400;
    const TIMED_RUN_MS = 10000;

    // Speed control
    let speed = 0.0;
    let speedTarget = 0.0;
    const CRUISE_SPEED = 1.0;

    // Flow field
    let noiseScale = 0.0026;
    let timeScale  = 0.00022;
    let coherence  = 0.72;

    // Glow layer
    let glowG;

    // === Color cycle system ===
    const COLOR_BANK = [
      [  60, 220, 140], // green
      [  70, 160, 255], // blue
      [ 190, 120, 255], // violet
      [ 255, 150, 210], // pink
      [ 255, 185, 110], // warm orange
      [  80, 235, 235], // cyan
      [ 255, 240, 150], // soft yellow
    ];

    const ACTIVE_MOVE_MS = 10000;  // 10 seconds of movement => change color
    let activeMoveAccum = 0;       // accumulates only while moving

    // Transition phases
    // 0 = normal, 1 = fading out, 2 = fading in
    let cyclePhase = 0;
    let phaseStartMs = 0;
    const FADE_OUT_MS = 1200;
    const FADE_IN_MS  = 1000;

    let colorIndex = 0;
    let currentColor = [60,220,140];

    // Global multiplier applied to all ribbon drawing during fade
    let fadeMult = 1.0;

    function setup(){
      canvas = createCanvas(windowWidth, windowHeight);
      canvas.position(0,0);

      glowG = createGraphics(windowWidth, windowHeight);
      glowG.clear();
      glowG.blendMode(ADD);

      influence.x = width/2;
      influence.y = height/2;

      // Start on a random color
      colorIndex = floor(random(COLOR_BANK.length));
      currentColor = COLOR_BANK[colorIndex];

      spawnRibbons();

      strokeCap(ROUND);
      noFill();
    }

    function draw(){
      if(!started){
        background(0);
        return;
      }

      drawGradientBackground();

      influence.x = mouseX;
      influence.y = mouseY;

      // Determine motion and speed based on mode
      if(segChoice === 'hold'){
        runActive = isHolding;
        if(!runActive){
          speed = 0.0; speedTarget = 0.0;
        } else {
          const e = millis() - runStartMs;
          const ramp = constrain(e / RAMP_MS, 0, 1);
          speedTarget = lerp(0.0, CRUISE_SPEED, easeInOut(ramp));
          speed = lerp(speed, speedTarget, 0.10);
        }
      } else {
        if(runActive){
          const e = millis() - runStartMs;
          if(e >= TIMED_RUN_MS){
            runActive = false;
            speed = 0.0; speedTarget = 0.0;
          } else {
            const ramp = constrain(e / min(RAMP_MS, 1500), 0, 1);
            speedTarget = lerp(0.0, CRUISE_SPEED, easeInOut(ramp));
            speed = lerp(speed, speedTarget, 0.10);
          }
        } else {
          speed = 0.0; speedTarget = 0.0;
        }
      }

      // Accumulate “active movement time” only when speed is meaningfully > 0
      // Use deltaTime (p5) so it’s frame-rate independent.
      if(speed > 0.05 && cyclePhase === 0){
        activeMoveAccum += deltaTime;
        if(activeMoveAccum >= ACTIVE_MOVE_MS){
          startFadeOut();
        }
      }

      // Handle fade transitions
      updateCyclePhase();

      currentAngle = lerp(currentAngle, targetAngle, 0.10);

      push();
      translate(width/2, height/2);
      rotate(radians(currentAngle));
      translate(-width/2, -height/2);

      // Fade glow buffer slightly each frame
      glowG.noStroke();
      glowG.fill(0, 0, 0, 35);
      glowG.rect(0,0,width,height);

      // Draw ribbons
      for(const r of ribbons){
        r.update(speed);
        r.display(speed, fadeMult, currentColor);
        r.displayGlow(speed, fadeMult, currentColor);
      }
      pop();

      // Composite glow, also affected by fadeMult
      const glowAlpha = lerp(70, 160, constrain(speed, 0, 1)) * fadeMult;
      push();
      tint(255, glowAlpha);
      image(glowG, 0, 0);
      pop();

      // Optional: sparse spark points, but only when not fading out completely
      if(speed > 0.15 && fadeMult > 0.25) maybeDrawSparks(speed, fadeMult, currentColor);
    }

    function windowResized(){
      resizeCanvas(windowWidth, windowHeight);
      glowG = createGraphics(windowWidth, windowHeight);
      glowG.clear();
      glowG.blendMode(ADD);
    }

    function keyPressed(){
      if(!started) return;

      if(keyCode === 32){
        if(segChoice === 'hold'){
          if(!isHolding){
            isHolding = true;
            runStartMs = millis();
          }
        } else {
          runActive = true;
          runStartMs = millis();
        }
      }

      if(keyCode === LEFT_ARROW)  targetAngle -= 90;
      if(keyCode === RIGHT_ARROW) targetAngle += 90;
    }

    function keyReleased(){
      if(!started) return;
      if(keyCode === 32 && segChoice === 'hold'){
        isHolding = false;
      }
    }

    // === Cycle helpers ===

    function startFadeOut(){
      cyclePhase = 1;
      phaseStartMs = millis();
    }

    function updateCyclePhase(){
      if(cyclePhase === 0){
        fadeMult = 1.0;
        return;
      }

      const now = millis();
      const elapsed = now - phaseStartMs;

      if(cyclePhase === 1){
        // Fade OUT
        const t = constrain(elapsed / FADE_OUT_MS, 0, 1);
        fadeMult = 1.0 - easeInOut(t);

        if(t >= 1){
          // Pick a new color different from current
          let next = colorIndex;
          if(COLOR_BANK.length > 1){
            while(next === colorIndex) next = floor(random(COLOR_BANK.length));
          }
          colorIndex = next;
          currentColor = COLOR_BANK[colorIndex];

          // Respawn ribbons so “new lines appear”
          spawnRibbons(true);

          // Reset active timer for next cycle
          activeMoveAccum = 0;

          // Start fade IN
          cyclePhase = 2;
          phaseStartMs = millis();
        }
      } else if(cyclePhase === 2){
        // Fade IN
        const t = constrain(elapsed / FADE_IN_MS, 0, 1);
        fadeMult = easeInOut(t);

        if(t >= 1){
          cyclePhase = 0;
          fadeMult = 1.0;
        }
      }
    }

    function spawnRibbons(first=false){
      ribbons = [];
      for (let i=0; i<RIBBON_COUNT; i++){
        ribbons.push(new Ribbon(i, first));
      }
    }

    // === Visual polish ===

    function drawGradientBackground(){
      const t = millis() * 0.00006;

      const top = color(
        10 + 10*sin(t*2.1),
        14 + 10*sin(t*1.7 + 1),
        22 + 12*sin(t*1.9 + 2)
      );
      const mid = color(
        10,
        20 + 20*sin(t*1.2 + 0.8),
        35 + 25*sin(t*1.1 + 2.2)
      );
      const bot = color(
        4,
        8,
        12 + 10*sin(t*1.6 + 1.4)
      );

      for(let y=0; y<height; y++){
        const p = y / (height-1);
        let c;
        if(p < 0.55) c = lerpColor(top, mid, p/0.55);
        else c = lerpColor(mid, bot, (p-0.55)/0.45);
        stroke(c);
        line(0, y, width, y);
      }

      noStroke();
      fill(0, 40);
      rect(0,0,width,height);
    }

    function maybeDrawSparks(spd, f, col){
      const chance = 0.10 * spd * f;
      if(random() > chance) return;

      const x = random(width);
      const y = random(height);
      const r = random(1.5, 3.5);

      noStroke();
      fill(col[0], col[1], col[2], 120 * f);
      ellipse(x, y, r, r);
    }

    // === Math/helpers ===

    function easeInOut(t){
      return t*t*t*(t*(t*6 - 15) + 10); // smootherstep
    }

    function lerpAngle(a, b, amt){
      let diff = ((b - a + PI) % (TWO_PI)) - PI;
      return a + diff * amt;
    }

    function flowAt(x, y, t, spd){
      const s = lerp(noiseScale * 1.7, noiseScale * 0.85, coherence);
      const n = noise(x * s, y * s, t);
      let a = n * TWO_PI * 2.0;

      const dx = influence.x - x;
      const dy = influence.y - y;
      const dist = sqrt(dx*dx + dy*dy) + 0.0001;
      const influenceRadius = min(width, height) * 0.45;
      const w = constrain(1.0 - (dist / influenceRadius), 0, 1);
      const attractAngle = atan2(dy, dx);

      const bend = w * (0.10 + 0.25 * spd);
      a = lerpAngle(a, attractAngle, bend);

      const v = p5.Vector.fromAngle(a);
      v.mult(2.0 * spd);
      return v;
    }

    // === Ribbon entity ===

    class Ribbon{
      constructor(i, first=false){
        this.index = i;
        this.reset(first);

        this.alpha = random(80, 150);
        this.baseW = random(0.9, 2.6);

        this.seed = random(1000);
        this.wobble = random(0.2, 0.8);

        // Small per-ribbon brightness variance so “one color” still feels rich
        this.bright = random(0.85, 1.10);
      }

      reset(first=false){
        const side = floor(random(4));
        if(side === 0){ this.head = createVector(random(width), -20); }
        if(side === 1){ this.head = createVector(width+20, random(height)); }
        if(side === 2){ this.head = createVector(random(width), height+20); }
        if(side === 3){ this.head = createVector(-20, random(height)); }

        this.points = [];
        for(let i=0;i<RIBBON_LEN;i++) this.points.push(this.head.copy());

        if(first){
          for(let i=0;i<RIBBON_LEN;i++){
            this.points[i].x += random(-3, 3);
            this.points[i].y += random(-3, 3);
          }
        }
      }

      update(spd){
        if(spd <= 0.0001){
          return; // true freeze
        }

        const t = millis() * timeScale + this.seed;
        const v = flowAt(this.head.x, this.head.y, t, spd);
        v.limit(3.2 * spd);

        const wob = (noise(this.head.x*0.01, this.head.y*0.01, t) - 0.5) * this.wobble;
        this.head.x += wob * 0.3;
        this.head.y += wob * 0.3;

        this.head.add(v);

        if(this.head.x < -80 || this.head.x > width+80 || this.head.y < -80 || this.head.y > height+80){
          this.reset();
          return;
        }

        this.points.unshift(this.head.copy());
        this.points.pop();

        for(let i=1;i<this.points.length-1;i++){
          this.points[i].x = lerp(this.points[i].x, (this.points[i-1].x + this.points[i+1].x)/2, 0.09);
          this.points[i].y = lerp(this.points[i].y, (this.points[i-1].y + this.points[i+1].y)/2, 0.09);
        }
      }

      display(spd, f, col){
        const w = this.baseW * (0.95 + 0.75 * spd);
        const a = this.alpha * (0.55 + 0.75 * spd) * f;

        stroke(col[0]*this.bright, col[1]*this.bright, col[2]*this.bright, a);
        strokeWeight(w);

        beginShape();
        for(const p of this.points) vertex(p.x, p.y);
        endShape();
      }

      displayGlow(spd, f, col){
        const w = this.baseW * (2.1 + 2.6 * spd);
        const a = (30 + 70 * spd) * f;

        glowG.stroke(col[0], col[1], col[2], a);
        glowG.strokeWeight(w);
        glowG.noFill();

        glowG.beginShape();
        for(const p of this.points) glowG.vertex(p.x, p.y);
        glowG.endShape();
      }
    }
  </script>
</body>
</html>
