<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-fr="Effets partagés" data-en="Shared Effects" data-ja="共有エフェクト">Effets partagés Ably</title>
  <link rel="stylesheet" href="../../css/menu.css">
  <link rel="stylesheet" href="../../css/global.css">
  <link rel="stylesheet" href="../../css/layout.css">
  <link rel="stylesheet" href="../../css/components.css">
  <style>
    :root {
      --muted: #4b5563;
      --success: #0f9d58;
      --danger: #e54335;
      --orb-color: #f8f8f8;
    }

    body.menu {
      background: #050505;
      color: #e5efe7;
    }

    .page-shell {
      max-width: 760px;
      width: min(92vw, 820px);
      margin: 0 auto;
      padding: clamp(18px, 3vw, 32px) clamp(14px, 4vw, 34px) 42px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 100vh;
      justify-content: center;
    }

    .hero-minimalist h1 {
      margin: 0;
      color: #e8f7ed;
      text-align: center;
      letter-spacing: 0.02em;
      font-weight: 900;
    }

    .card {
      background: linear-gradient(135deg, rgba(17, 24, 39, 0.92), rgba(15, 23, 42, 0.92));
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: clamp(16px, 3vw, 24px) clamp(16px, 3vw, 28px);
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.28);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      align-items: end;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-group label {
      font-weight: 800;
      color: #c6d7c7;
      letter-spacing: 0.01em;
    }

    .control-group input,
    .control-group select,
    .control-group button {
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 12px 14px;
      font-size: 15px;
      background: rgba(255, 255, 255, 0.06);
      color: #e8f7ed;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
    }

    .control-group button {
      cursor: pointer;
      background: linear-gradient(135deg, #2dd4bf, #3b82f6);
      color: white;
      font-weight: 900;
      border: none;
      transition: transform 140ms ease, box-shadow 140ms ease;
      box-shadow: 0 10px 28px rgba(59, 130, 246, 0.35);
      letter-spacing: 0.02em;
    }

    .control-group button:hover { transform: translateY(-1px); }

    .panel-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 8px 12px;
      font-weight: 700;
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 0 0 rgba(229, 67, 53, 0.35);
      transition: background 160ms ease, box-shadow 160ms ease;
    }

    .status-chip.connected {
      color: #a6f3c0;
    }

    .status-chip.connected .status-dot {
      background: var(--success);
      box-shadow: 0 0 0 6px rgba(15, 157, 88, 0.2);
    }

    .pill-list {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 9px 14px;
      border-radius: 999px;
      font-weight: 800;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 120ms ease, border 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }

    .pill:hover { transform: translateY(-1px); }
    .pill.active { border-color: #e8f7ed; }

    .start-row {
      display: flex;
      justify-content: flex-end;
      margin-top: 6px;
    }

    .start-button {
      background: linear-gradient(135deg, #f97316, #fb7185);
      color: #fff;
      border: none;
      padding: 12px 22px;
      border-radius: 16px;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 16px 36px rgba(251, 113, 133, 0.35);
      transition: transform 140ms ease;
      letter-spacing: 0.03em;
      font-size: 16px;
    }

    .start-button:hover { transform: translateY(-1px); }

    .effect-stage {
      position: relative;
      background: #000;
      border-radius: 16px;
      min-height: 360px;
      width: 100%;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.04);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
    }

    .stage-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .play-screen {
      display: none;
      width: 100vw;
      height: 100vh;
      background: #000;
      position: relative;
      overflow: hidden;
    }

    .play-screen .effect-stage {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      border: none;
      box-shadow: none;
    }

    body.playing { background: #000; }
    body.playing .page-shell { display: none; }
    body.playing .play-screen { display: block; }
  </style>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);} // eslint-disable-line
    gtag('js', new Date());
    gtag('config', 'G-B45TJG4GBJ');
  </script>
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
</head>
<body class="menu">
  <div class="page-shell setup-screen">
    <header class="hero-minimalist">
      <h1 data-fr="Effets partagés" data-en="Shared Effects" data-ja="共有エフェクト">Effets partagés</h1>
    </header>

    <section class="card">
      <div class="controls">
        <div class="control-group">
          <label for="colorInput">Couleur</label>
          <input type="color" id="colorInput" value="#ff6b6b" aria-label="Sélection de couleur">
        </div>
        <div class="control-group">
          <label for="effectSelect">Effet</label>
          <select id="effectSelect">
            <option value="flare">Flare</option>
            <option value="pulse">Pulse</option>
            <option value="wave">Wave</option>
          </select>
        </div>
        <div class="control-group">
          <label>&nbsp;</label>
          <button id="triggerBtn" type="button">Aperçu local</button>
        </div>
      </div>
      <div class="panel-row">
        <div class="pill-list" aria-label="Couleurs rapides">
          <span class="pill" data-color="#ff6b6b" style="background:#ff6b6b;color:#111;">Corail</span>
          <span class="pill" data-color="#22d3ee" style="background:#22d3ee;color:#0f172a;">Cyan</span>
          <span class="pill" data-color="#a855f7" style="background:#a855f7;color:#111;">Violet</span>
          <span class="pill" data-color="#facc15" style="background:#facc15;color:#0f172a;">Or</span>
          <span class="pill" data-color="#10b981" style="background:#10b981;color:#0f172a;">Émeraude</span>
        </div>
        <div class="status-chip" id="connectionStatus">
          <span class="status-dot" aria-hidden="true"></span>
          <span id="statusLabel">Initialisation...</span>
        </div>
      </div>
      <div class="start-row">
        <button id="startBtn" class="start-button" type="button">Commencer</button>
      </div>
    </section>

    <section class="card">
      <div class="effect-stage" id="stage" aria-live="polite"></div>
    </section>
  </div>

  <div class="play-screen" id="playScreen"></div>

  <script>
    // --------- Configuration ---------
    const config = {
      // Clé fournie pour les essais rapides
      ABLY_API_KEY: 'NfI_Ag.HjcdgA:FqxNZOXcM-Y4fFye8MPY-tiHwoXL0yJYkWBlMq7U03I'
    };

    // --------- State ---------
    const clientId = `client-${Math.random().toString(36).slice(2, 8)}`;
    const SIDES = ['left', 'right', 'top', 'bottom'];
    function getSideForClient(id) {
      let hash = 0;
      for (let i = 0; i < id.length; i += 1) {
        hash = (hash + id.charCodeAt(i) * (i + 3)) % 9973;
      }
      return SIDES[hash % SIDES.length];
    }
    const mySide = getSideForClient(clientId);
    const state = {
      color: localStorage.getItem('sharedEffectColor') || '#ff6b6b',
      effect: localStorage.getItem('sharedEffectType') || 'flare'
    };
    let isPlaying = false;
    let channel;
    let lastPublish = 0;

    // --------- DOM ---------
    const statusChip = document.getElementById('connectionStatus');
    const statusLabel = document.getElementById('statusLabel');
    const colorInput = document.getElementById('colorInput');
    const effectSelect = document.getElementById('effectSelect');
    const stage = document.getElementById('stage');
    const triggerBtn = document.getElementById('triggerBtn');
    const startBtn = document.getElementById('startBtn');
    const playScreen = document.getElementById('playScreen');

    const canvas = document.createElement('canvas');
    canvas.className = 'stage-canvas';
    stage.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    let width = 0;
    let height = 0;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    const orb = {
      x: 0,
      y: 0,
      baseRadius: 40,
      energy: 0,
      tint: '#ffffff',
      idlePhase: 0
    };

    const particles = [];
    const blooms = [];

    colorInput.value = state.color;
    effectSelect.value = state.effect;

    function updateStatus(connected, text) {
      statusChip.classList.toggle('connected', connected);
      statusLabel.textContent = text;
    }

    function savePrefs() {
      try {
        localStorage.setItem('sharedEffectColor', state.color);
        localStorage.setItem('sharedEffectType', state.effect);
      } catch (err) {
        // ignore storage errors
      }
    }

    function chooseColor(color) {
      state.color = color;
      colorInput.value = color;
      savePrefs();
    }

    function chooseEffect(effect) {
      state.effect = effect;
      effectSelect.value = effect;
      savePrefs();
    }

    // --------- Animation ---------
    function resizeStage() {
      const rect = stage.getBoundingClientRect();
      width = rect.width;
      height = rect.height;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = `${rect.width}px`;
      canvas.style.height = `${rect.height}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      orb.x = rect.width / 2;
      orb.y = rect.height / 2;
      orb.baseRadius = Math.min(rect.width, rect.height) * 0.06 + 24;
    }

    function hexToRgb(hex) {
      const clean = hex.replace('#', '');
      const bigint = parseInt(clean.length === 3 ? clean.split('').map((c) => c + c).join('') : clean, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    }

    function mixColor(a, b, amount) {
      const ca = hexToRgb(a);
      const cb = hexToRgb(b);
      const t = Math.max(0, Math.min(1, amount));
      const r = Math.round(ca.r + (cb.r - ca.r) * t);
      const g = Math.round(ca.g + (cb.g - ca.g) * t);
      const bl = Math.round(ca.b + (cb.b - ca.b) * t);
      return `rgb(${r}, ${g}, ${bl})`;
    }

    function cubicPoint(t, p0, p1, p2, p3) {
      const u = 1 - t;
      return {
        x: u ** 3 * p0.x + 3 * u ** 2 * t * p1.x + 3 * u * t ** 2 * p2.x + t ** 3 * p3.x,
        y: u ** 3 * p0.y + 3 * u ** 2 * t * p1.y + 3 * u * t ** 2 * p2.y + t ** 3 * p3.y
      };
    }

    function addBloom(x, y, color) {
      blooms.push({ x, y, color, life: 0, maxLife: 1.2 + Math.random() * 0.6 });
    }

    function emitBurst(color, effect, side = 'left') {
      const rect = stage.getBoundingClientRect();
      const baseCount = effect === 'wave' ? 120 : effect === 'pulse' ? 90 : 100;
      const count = Math.round(baseCount * (0.9 + Math.random() * 0.25));
      const baseDuration = effect === 'pulse' ? 5.6 : 6.4;
      const startForSide = () => {
        if (side === 'left') return { x: -40, y: Math.random() * rect.height };
        if (side === 'right') return { x: rect.width + 40, y: Math.random() * rect.height };
        if (side === 'top') return { x: Math.random() * rect.width, y: -40 };
        return { x: Math.random() * rect.width, y: rect.height + 40 };
      };

      for (let i = 0; i < count; i += 1) {
        const start = startForSide();
        const jitter = (amount) => (Math.random() - 0.5) * amount;
        const controlA = {
          x: (start.x + orb.x) / 2 + jitter(140),
          y: (start.y + orb.y) / 2 + jitter(140)
        };
        const controlB = {
          x: orb.x + jitter(120),
          y: orb.y + jitter(120)
        };
        const end = {
          x: orb.x + (orb.x - start.x) * 1.25 + jitter(120),
          y: orb.y + (orb.y - start.y) * 1.15 + jitter(90)
        };
        const duration = baseDuration + Math.random() * 1.8;
        particles.push({
          p0: start,
          p1: controlA,
          p2: controlB,
          p3: end,
          color,
          size: 7 + Math.random() * 10,
          t: 0,
          duration,
          hit: false,
          swirl: jitter(0.002)
        });
      }
    }

    function energize(color, magnitude = 0.18) {
      orb.energy = Math.min(1.6, orb.energy + magnitude);
      orb.tint = color;
      addBloom(orb.x, orb.y, color);
    }

    function drawParticles(dt) {
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      for (let i = particles.length - 1; i >= 0; i -= 1) {
        const p = particles[i];
        p.t += dt / p.duration;
        if (p.t >= 1) {
          particles.splice(i, 1);
          continue;
        }

        const eased = p.t * p.t * (3 - 2 * p.t);
        const pos = cubicPoint(eased + p.swirl, p.p0, p.p1, p.p2, p.p3);

        const dx = pos.x - orb.x;
        const dy = pos.y - orb.y;
        const dist = Math.hypot(dx, dy);
        if (!p.hit && dist < orb.baseRadius * 1.2) {
          p.hit = true;
          energize(p.color, 0.22 + Math.random() * 0.12);
        }

        const size = p.size * (0.9 + (1 - p.t) * 0.6);
        const grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, size * 1.8);
        grad.addColorStop(0, 'rgba(255,255,255,0.9)');
        grad.addColorStop(0.4, `${p.color}dd`);
        grad.addColorStop(1, `${p.color}00`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawBlooms(dt) {
      for (let i = blooms.length - 1; i >= 0; i -= 1) {
        const b = blooms[i];
        b.life += dt;
        const t = b.life / b.maxLife;
        if (t >= 1) {
          blooms.splice(i, 1);
          continue;
        }
        const eased = Math.sin(Math.min(1, t) * Math.PI * 0.5);
        const radius = orb.baseRadius * (1.5 + eased * 4.2);
        const alpha = 0.4 * (1 - t);
        const grad = ctx.createRadialGradient(b.x, b.y, radius * 0.2, b.x, b.y, radius);
        grad.addColorStop(0, `${b.color}${Math.floor(255 * alpha).toString(16).padStart(2, '0')}`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(b.x, b.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawOrb(dt) {
      orb.idlePhase += dt * 0.4;
      orb.energy = Math.max(0, orb.energy - dt * 0.32);
      const pulse = 0.04 * Math.sin(orb.idlePhase * Math.PI * 2);
      const radius = orb.baseRadius * (1 + pulse) + orb.energy * 36;
      const glowRadius = radius * (1.8 + orb.energy * 0.8);
      const color = mixColor('#f8f8f8', orb.tint, Math.min(1, 0.35 + orb.energy));

      ctx.globalCompositeOperation = 'screen';
      const grad = ctx.createRadialGradient(orb.x, orb.y, radius * 0.25, orb.x, orb.y, glowRadius);
      grad.addColorStop(0, 'rgba(255,255,255,0.9)');
      grad.addColorStop(0.4, `${color}cc`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = mixColor('#ffffff', orb.tint, 0.2 + orb.energy * 0.5);
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, radius * 0.72, 0, Math.PI * 2);
      ctx.fill();
    }

    let lastFrame = 0;
    function loop(timestamp) {
      if (!lastFrame) lastFrame = timestamp;
      const dt = Math.min(0.05, (timestamp - lastFrame) / 1000);
      lastFrame = timestamp;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(0, 0, width, height);

      drawParticles(dt);
      drawOrb(dt);
      drawBlooms(dt);

      requestAnimationFrame(loop);
    }

    function triggerEffect(color, effect, side = 'left') {
      emitBurst(color, effect, side);
    }

    // --------- Ably ---------
    function initAbly() {
      if (!config.ABLY_API_KEY) {
        updateStatus(false, 'Clé Ably manquante');
        return;
      }
      const realtime = new Ably.Realtime({ key: config.ABLY_API_KEY, clientId });
      channel = realtime.channels.get('shared-effects');

      realtime.connection.on('connected', () => updateStatus(true, 'Connecté'));
      realtime.connection.on('disconnected', () => updateStatus(false, 'Déconnecté'));
      realtime.connection.on('failed', () => updateStatus(false, 'Erreur de connexion'));

      channel.subscribe('message', (msg) => {
        const data = msg.data || {};
        if (!data.color || !data.effect) return;
        const side = data.side || getSideForClient(data.clientId || '');
        triggerEffect(data.color, data.effect, side);
      });
    }

    // --------- Publish ---------
    function publishSpace() {
      if (!isPlaying) return;
      const now = Date.now();
      if (now - lastPublish < 350) return;
      lastPublish = now;
      const payload = {
        type: 'space',
        color: state.color,
        effect: state.effect,
        clientId,
        side: mySide
      };
      if (channel) {
        channel.publish('message', payload);
      }
      triggerEffect(state.color, state.effect, mySide);
    }

    // --------- Events ---------
    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        event.preventDefault();
        publishSpace();
      }
    });

    triggerBtn.addEventListener('click', () => {
      triggerEffect(state.color, state.effect, mySide);
    });
    startBtn.addEventListener('click', () => {
      if (isPlaying) return;
      isPlaying = true;
      document.body.classList.add('playing');
      playScreen.appendChild(stage);
      resizeStage();
      playScreen.scrollIntoView({ behavior: 'smooth' });
    });

    colorInput.addEventListener('input', (e) => chooseColor(e.target.value));
    effectSelect.addEventListener('change', (e) => chooseEffect(e.target.value));

    document.querySelectorAll('.pill').forEach(pill => {
      pill.addEventListener('click', () => {
        document.querySelectorAll('.pill').forEach(p => p.classList.remove('active'));
        pill.classList.add('active');
        chooseColor(pill.dataset.color);
      });
      if (pill.dataset.color === state.color) {
        pill.classList.add('active');
      }
    });

    window.addEventListener('resize', resizeStage);
    resizeStage();
    requestAnimationFrame(loop);

    updateStatus(false, 'Initialisation...');
    initAbly();
  </script>
</body>
</html>
