<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cherry Blossom Cut — Background Image + Katana Cursor (Mirrored)</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: #fff;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    #game {
      display: block;
      width: 100vw; height: 100vh;
      cursor: crosshair;          /* fallback if custom cursor is not ready */
      background: #fff;
    }
    #startOverlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: rgba(255,255,255,0.9);
      z-index: 10;
    }
    #startBtn {
      padding: 14px 22px;
      border: 2px solid #d40000; color: #d40000; background: #fff;
      border-radius: 12px; font-size: 18px; font-weight: 700;
      box-shadow: 0 6px 24px rgba(0,0,0,0.08);
      cursor: pointer;
    }
    #startBtn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay">
    <button id="startBtn">Start • Fullscreen</button>
  </div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       CONFIG
    ======================= */
    const IMG_SRC = "../../images/cherryblossom.png";       // petal image
    const BG_SRC  = "../../images/cherryblossombg.png";     // background image
    const SLASH_SOUND = "../../sounds/blade.mp3";
    const KATANA_SRC = "../../images/samurai/katana.png";   // custom cursor source

    // Cursor limits and hotspot (in ORIGINAL image pixels)
    const CURSOR_MAX_PX = 124; // longest side; keeps browsers happy; aspect ratio preserved
    const HOTSPOT_ORIG = { x: 12, y: 28 }; // adjust if your katana tip is elsewhere

    // Larger blossoms, fewer on screen
    const SPAWN_EVERY_MS = 1400;
    const FALL_SPEED_MIN = 40;
    const FALL_SPEED_MAX = 95;
    const BLOSSOM_SIZE_MIN = 72 * 3;
    const BLOSSOM_SIZE_MAX = 138 * 3;
    const HOVER_CUT_RADIUS = 52;
    const SHARD_SPREAD_SPEED = 190;
    const SHARD_ROT_SPEED = 1.2;
    const SHARD_FADE_TIME = 0.85;
    const MAX_FALLING = 5;

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
    });

    // Images
    const img = new Image(); img.src = IMG_SRC;
    const bgImg = new Image(); bgImg.src = BG_SRC;

    // preload slash sound
    const slashAudio = new Audio(SLASH_SOUND);
    slashAudio.volume = 0.6;
    function playSlash() {
      const s = slashAudio.cloneNode(true);
      s.volume = slashAudio.volume;
      s.play().catch(()=>{});
    }

    // pointer + movement tracking for cursor flip
    const pointer = { x: -9999, y: -9999, prevX: -9999, inside: false };
    const MOVE_THRESH = 2; // px; prevents flicker when jittering
    let cursorOrient = 'left'; // 'left' by default

    canvas.addEventListener('pointermove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top)  * (canvas.height / rect.height);
      const dx = (pointer.prevX === -9999) ? 0 : (x - pointer.prevX);

      pointer.x = x; pointer.y = y; pointer.inside = true;

      // Flip cursor when moving right vs left
      if (started && katanaReady) {
        if (dx > MOVE_THRESH && cursorOrient !== 'right') {
          cursorOrient = 'right';
          applyKatanaCursor();
        } else if (dx < -MOVE_THRESH && cursorOrient !== 'left') {
          cursorOrient = 'left';
          applyKatanaCursor();
        }
      }
      pointer.prevX = x;
    });
    canvas.addEventListener('pointerleave', () => pointer.inside = false);

    const blossoms = [];
    const shards = [];
    const rand = (a, b) => a + Math.random() * (b - a);
    const nowSec = () => performance.now()/1000;

    /* =======================
       KATANA CURSOR (left/right, aspect preserved)
    ======================= */
    let katanaReady = false;
    let katanaLeft = null;   // {url, hx, hy}
    let katanaRight = null;  // {url, hx, hy}

    const katanaImg = new Image();
    katanaImg.onload = () => {
      const iw = katanaImg.width, ih = katanaImg.height;
      const scale = Math.min(1, CURSOR_MAX_PX / Math.max(iw, ih)); // keeps aspect ratio
      const dw = Math.round(iw * scale);
      const dh = Math.round(ih * scale);

      // draw LEFT-facing (original) at native aspect
      const leftCanvas = document.createElement('canvas');
      leftCanvas.width = dw; leftCanvas.height = dh;
      const lctx = leftCanvas.getContext('2d');
      lctx.imageSmoothingEnabled = true;
      lctx.drawImage(katanaImg, 0, 0, dw, dh);

      // draw RIGHT-facing (mirrored) at native aspect
      const rightCanvas = document.createElement('canvas');
      rightCanvas.width = dw; rightCanvas.height = dh;
      const rctx = rightCanvas.getContext('2d');
      rctx.imageSmoothingEnabled = true;
      rctx.translate(dw, 0);
      rctx.scale(-1, 1);
      rctx.drawImage(katanaImg, 0, 0, dw, dh);

      // compute hotspots (mirror X for right)
      const hxLeft  = Math.max(0, Math.min(dw - 1, Math.round(HOTSPOT_ORIG.x * scale)));
      const hyLeft  = Math.max(0, Math.min(dh - 1, Math.round(HOTSPOT_ORIG.y * scale)));
      const hxRight = (dw - 1) - hxLeft;
      const hyRight = hyLeft;

      katanaLeft  = { url: leftCanvas.toDataURL('image/png'),  hx: hxLeft,  hy: hyLeft };
      katanaRight = { url: rightCanvas.toDataURL('image/png'), hx: hxRight, hy: hyRight };
      katanaReady = true;
    };
    katanaImg.onerror = () => { katanaReady = false; };
    katanaImg.src = KATANA_SRC;

    function applyKatanaCursor() {
      if (!katanaReady) return;
      const k = (cursorOrient === 'right') ? katanaRight : katanaLeft;
      canvas.style.cursor = `url("${k.url}") ${k.hx} ${k.hy}, crosshair`;
    }

    /* =======================
       GAME ENTITIES
    ======================= */
    function spawnBlossom() {
      if (!img.complete) return;
      const size = rand(BLOSSOM_SIZE_MIN, BLOSSOM_SIZE_MAX);
      const aspect = img.width / img.height || 1;
      const w = aspect >= 1 ? size*aspect : size;
      const h = aspect >= 1 ? size : size/aspect;
      blossoms.push({
        x: rand(w * 0.5, W - w * 0.5),
        y: -h - rand(0, 100),
        w, h,
        angle: rand(-Math.PI, Math.PI),
        rot: rand(-0.5, 0.5),
        vy: rand(FALL_SPEED_MIN, FALL_SPEED_MAX),
        vx: rand(-12, 12),
        cut: false
      });
    }

    function cutBlossom(b) {
      playSlash();
      const leftRect  = { sx: 0, sy: 0, sw: img.width/2, sh: img.height };
      const rightRect = { sx: img.width/2, sy: 0, sw: img.width/2, sh: img.height };
      const tw = b.w, th = b.h, tBorn = nowSec();
      shards.push({clip:leftRect,x:b.x-tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx:-SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot:-SHARD_ROT_SPEED,born:tBorn,life:SHARD_FADE_TIME});
      shards.push({clip:rightRect,x:b.x+tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx:SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot:SHARD_ROT_SPEED,born:tBorn,life:SHARD_FADE_TIME});
      b.cut = true;
    }

    let lastT = performance.now(), spawnTimer = 0, started = false;

    function tick(tMs) {
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT) / 1000);
      lastT = tMs;

      spawnTimer += dt * 1000;
      if (spawnTimer > SPAWN_EVERY_MS && blossoms.length < MAX_FALLING) {
        spawnTimer = 0;
        spawnBlossom();
      }

      updateBlossoms(dt);
      updateShards(dt);
      render();

      requestAnimationFrame(tick);
    }

    /* =======================
       BACKGROUND IMAGE (cover)
    ======================= */
    function drawBackgroundImage() {
      if (bgImg.complete && bgImg.naturalWidth > 0) {
        const iw = bgImg.width, ih = bgImg.height;
        const scale = Math.max(W / iw, H / ih); // cover (fill without stretch)
        const dw = iw * scale, dh = ih * scale;
        const dx = (W - dw) * 0.5;
        const dy = (H - dh) * 0.5;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(bgImg, dx, dy, dw, dh);
      } else {
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, W, H);
      }
    }

    /* =======================
       GAME RENDER/UPDATE
    ======================= */
    function updateBlossoms(dt) {
      for (let i = blossoms.length-1; i>=0; i--) {
        const b = blossoms[i];
        b.y += b.vy * dt;
        b.x += b.vx * dt;
        b.angle += b.rot * dt;
        const dx = pointer.x - b.x, dy = pointer.y - b.y;
        if (pointer.inside && !b.cut && dx*dx+dy*dy<=HOVER_CUT_RADIUS*HOVER_CUT_RADIUS) cutBlossom(b);
        if (b.cut || b.y - b.h/2 > H+40) blossoms.splice(i, 1);
      }
    }

    function updateShards(dt) {
      const t = nowSec();
      for (let i = shards.length-1; i>=0; i--) {
        const s = shards[i];
        s.x += s.vx * dt; s.y += s.vy * dt; s.vy += 420*dt; s.angle += s.rot * dt;
        if (t - s.born > s.life) shards.splice(i, 1);
      }
    }

    function render() {
      drawBackgroundImage();
      // Whole blossoms
      for (const b of blossoms) {
        ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle);
        ctx.drawImage(img,-b.w/2,-b.h/2,b.w,b.h); ctx.restore();
      }
      // Shards
      const t = nowSec();
      for (const s of shards) {
        const alpha = Math.max(0,1-(t-s.born)/s.life);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.translate(s.x,s.y); ctx.rotate(s.angle);
        ctx.drawImage(img,s.clip.sx,s.clip.sy,s.clip.sw,s.clip.sh,-s.w/2,-s.h/2,s.w,s.h);
        ctx.restore();
      }
    }

    /* ===== FULLSCREEN START ===== */
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    async function enterFullscreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    }

    startBtn.addEventListener('click', async () => {
      try { await enterFullscreen(); } catch(e) {}
      startOverlay.style.display = 'none';
      started = true;

      // Apply initial cursor (left by default)
      if (katanaReady) applyKatanaCursor();
      else {
        katanaImg.onload = () => { katanaImg.onload = null; applyKatanaCursor(); };
      }

      lastT = performance.now();
      if (img.complete && bgImg.complete) requestAnimationFrame(tick);
      else {
        let pending = 0;
        const tryStart = () => { if (--pending <= 0) requestAnimationFrame(tick); };
        if (!img.complete)  { pending++; img.onload  = tryStart; }
        if (!bgImg.complete){ pending++; bgImg.onload = tryStart; }
        if (pending === 0) requestAnimationFrame(tick);
      }
    });
  })();
  </script>
</body>
</html>
