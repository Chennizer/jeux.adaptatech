<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Candle of Memory — Single Switch</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#0b0b12;color:#fff;overflow:hidden;font-family:system-ui, Segoe UI, Arial;}
    #hint{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:20px; padding:10px 14px; border-radius:12px;
      background:rgba(255,255,255,0.1); backdrop-filter:blur(4px);
      border:1px solid rgba(255,255,255,0.2); font-size:14px; letter-spacing:.2px;
      user-select:none
    }
    #topbar{
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      display:flex; gap:10px; align-items:center;
      background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.2);
      border-radius:12px; padding:6px 10px; font-size:13px
    }
    #topbar label{display:flex; gap:6px; align-items:center; cursor:pointer;}
    input[type="checkbox"]{transform:scale(1.2)}
  </style>
</head>
<body>
  <div id="topbar">
    <label><input id="highContrast" type="checkbox"> High contrast</label>
    <label><input id="reducedMotion" type="checkbox"> Reduced motion</label>
  </div>
  <div id="hint">Press SPACE (or click/tap) to brighten the flame and release memories</div>

  <script>
    // --- Scene state ---
    let embers = [];
    let glow = 0;
    let baseFlicker = 0.15;
    let t = 0;
    let hc = false, rm = false;
    let metrics = null;

    function setup(){
      createCanvas(windowWidth, windowHeight);
      noStroke();
      document.getElementById('highContrast').addEventListener('change', e => hc = e.target.checked);
      document.getElementById('reducedMotion').addEventListener('change', e => rm = e.target.checked);
    }
    function windowResized(){ resizeCanvas(windowWidth, windowHeight); }

    function computeMetrics(){
      const cx = width/2;
      const cy = height*0.74;                 // sits a little lower
      const w  = min(170, width*0.12);
      const h  = min(420, height*0.52);       // TALLER candle
      const r  = 20;

      const topY = cy - h;
      const wickHeight = h * 0.12;
      const wickBaseY  = topY + 14;
      const wickTopY   = wickBaseY - wickHeight;

      const flameY = wickTopY - h * 0.04;

      return {cx, cy, w, h, r, topY, wickBaseY, wickTopY, flameY};
    }

    function draw(){
      t += 0.01;
      metrics = computeMetrics();

      // background gradient
      for(let y=0; y<height; y+=4){
        const p = y/height;
        const c1 = color(10,12,24), c2 = color(24,10,36);
        const c = lerpColor(c1, c2, p);
        fill(c); rect(0,y,width,4);
      }

      // candle body / wick
      drawCandleBody(metrics);
      drawWick(metrics);

      // flame sizing and tilt
      const flicker = rm ? 0.05 : baseFlicker;
      const noiseF = map(noise(t*2), 0,1, -flicker, flicker);
      const size = lerp(height*0.12, height*0.16, constrain(glow,0,1)) * (1 + noiseF);
      const tilt = (rm ? 0.02 : 0.06) * sin(t*2.0);

      // flame
      drawFlame(metrics.cx, metrics.flameY, size, tilt);

      // aura — raised so it centers near the **tip** of the flame
      const auraCenterY = metrics.flameY - size*0.35;
      drawAura(metrics.cx, auraCenterY, size);

      if(!rm) drawWaxDrips(metrics);

      updateEmbers();
      glow = max(0, glow - (rm ? 0.01 : 0.02));
    }

    function drawCandleBody(m){
      const {cx, cy, w, h, r, topY} = m;
      push();
      translate(cx, cy);

      // White candle body
      const front = hc ? color(255) : color(248,248,246);
      fill(front);
      rectMode(CENTER);
      drawingContext.save();
      roundRect(-w/2, -h, w, h, r);
      drawingContext.restore();

      // Gentle vertical sheen
      const g = drawingContext.createLinearGradient(-w/2,0, w/2,0);
      g.addColorStop(0.0, 'rgba(255,255,255,0.15)');
      g.addColorStop(0.5, 'rgba(255,255,255,0.0)');
      g.addColorStop(1.0, 'rgba(0,0,0,0.08)');
      drawingContext.fillStyle = g;
      roundRect(-w/2, -h, w, h, r);

      // Top rim (white)
      fill(hc ? 255 : 252, hc ? 255 : 252, hc ? 255 : 250, 230);
      ellipse(0, -h, w*0.98, 24);

      // --- Wax pool ---
      // (KEEP it neutral/white; remove the previous warm base glow ellipse)
      const waxTop  = -h + 10;
      const waxBot  = -h + h*0.62;
      const waxR    = r * 1.1;

      // subtle warm band near the top of the wax for depth (light, not yellow)
      fill(255, 230, 210, 70);
      ellipse(0, waxTop + 20, w*0.95, 16);

      // solid wax (very light)
      fill(255, 248, 244, 210);
      drawingContext.save();
      roundRect(-w/2, waxTop + (waxBot - waxTop)*0.15, w, (waxBot - waxTop), waxR);
      drawingContext.restore();

      pop();
    }

    function roundRect(x,y,w,h,r){
      drawingContext.beginPath();
      drawingContext.moveTo(x+r, y);
      drawingContext.lineTo(x+w-r, y);
      drawingContext.quadraticCurveTo(x+w, y, x+w, y+r);
      drawingContext.lineTo(x+w, y+h-r);
      drawingContext.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      drawingContext.lineTo(x+r, y+h);
      drawingContext.quadraticCurveTo(x, y+h, x, y+h-r);
      drawingContext.lineTo(x, y+r);
      drawingContext.quadraticCurveTo(x, y, x+r, y);
      drawingContext.closePath();
      drawingContext.fill();
    }

    function drawWick(m){
      const {cx, wickBaseY, wickTopY} = m;
      push();
      fill(80);
      rectMode(CORNERS);
      rect(cx-2, wickTopY, cx+2, wickBaseY, 2);
      pop();
    }

    function drawFlame(x, y, s, tilt){
      push();
      translate(x, y);
      rotate(tilt);

      const core  = hc ? color(255,255,255, 240) : color(255, 245, 200, 240);
      const mid   = hc ? color(255,200,0, 200)   : color(255, 180, 70, 200);
      const outer = hc ? color(255,120,0, 150)   : color(255, 120, 40, 150);

      fill(outer); flameShape(0, 0, s*0.95);
      fill(mid);   flameShape(0, 0, s*0.70);
      fill(core);  flameShape(0, s*0.05, s*0.44);
      pop();
    }

    function flameShape(cx, cy, size){
      beginShape();
      const h = size;
      const w = size*0.55;
      vertex(cx, cy+h*0.05);
      bezierVertex(cx-w*0.5, cy+h*0.0, cx-w*0.6, cy-h*0.35, cx, cy-h*0.95);
      bezierVertex(cx+w*0.6, cy-h*0.35, cx+w*0.5, cy+h*0.0, cx, cy+h*0.05);
      endShape(CLOSE);
    }

    function drawAura(x, y, s){
      push();
      translate(x, y);
      const base = s*1.9;
      const rings = 5;
      for(let i=0; i<rings; i++){
        const a = map(i,0,rings-1, 70, 6) * (1 + glow*0.6);
        fill(255, 180, 80, a);
        ellipse(0, 0, base*(1+(i+1)/rings*0.9), base*(0.6+(i+1)/rings*0.6));
      }
      pop();
    }

    function drawWaxDrips(m){
      const {cx, topY, h} = m;
      push();
      translate(cx, topY + h*0.54);
      fill(255,255,255,28);
      const count = 4;
      for(let i=0;i<count;i++){
        const x = sin((t*0.4 + i)*1.7) * 40 + (i-1.5)*12;
        const hl = 10 + 12*(0.5+0.5*sin(t*0.7 + i));
        rect(x, -20, 6, hl, 3);
      }
      pop();
    }

    // --- Embers (memories) ---
    function spawnEmbers(n=12){
      const x = metrics.cx;
      const y = metrics.flameY;
      for(let i=0;i<n;i++){
        embers.push({
          x: x + random(-6,6),
          y: y + random(-6,6),
          vx: random(-0.25,0.25),
          vy: random(-1.4,-0.8),
          r: random(2,5),
          a: 255
        });
      }
    }
    function updateEmbers(){
      for(let i=embers.length-1; i>=0; i--){
        const e = embers[i];
        e.x += e.vx + (rm?0:0.15*sin((e.y+t)*0.05));
        e.y += e.vy;
        e.vy -= rm ? 0.002 : 0.004;
        e.a -= rm ? 1.5 : 2.2;
        if(e.a <= 0){ embers.splice(i,1); continue; }
        noStroke();
        fill(255, 180, 60, e.a*0.25);
        ellipse(e.x, e.y, e.r*4, e.r*4);
        fill(255, 200, 120, e.a);
        ellipse(e.x, e.y, e.r, e.r);
      }
    }

    // --- Input: single switch / press ---
    function triggerPress(){
      glow = min(1, glow + 0.45);
      spawnEmbers(rm ? 6 : 12);
    }
    function keyPressed(){ if(key === ' ' || key === 'Enter') triggerPress(); }
    function mousePressed(){ triggerPress(); }
    function touchStarted(){ triggerPress(); }
  </script>
</body>
</html>
