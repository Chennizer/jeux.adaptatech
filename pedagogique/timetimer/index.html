<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title data-fr="Minuteur Visuel" data-en="Time Timer">Minuteur Visuel</title>

<link rel="stylesheet" href="../../css/otherswitch.css">

<style>
  html, body { background:#fff; margin:0; height:100%; }

  /* Overlay + canvas */
  #overlay{
    position:fixed;inset:0;display:flex;justify-content:center;align-items:center;
    background:#fff;z-index:9999;
    pointer-events:auto;
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none;
  }
  #overlay button{font-size:5vmin;padding:1em 2em;}
  #timerCanvas{
    position:absolute;top:0;left:0;width:100vw;height:100vh;background:transparent;
    touch-action:none; /* smoother dragging on iPad */
  }

  /* Panels (unified look) */
  .controls,.special-controls{
    position:fixed;right:12px;top:50%;
    width:260px;max-height:calc(100vh - 100px);padding:14px;border-radius:12px;
    box-shadow:0 4px 12px rgba(0,0,0,0.35);
    background:rgba(18,18,18,0.94);color:#fff;overflow-y:auto;opacity:0;
    transform:translate(120%,-50%);transition:transform .28s ease,opacity .28s ease;z-index:2000;
    backdrop-filter:saturate(120%) blur(6px);
  }
  .controls.show,.special-controls.show{transform:translate(0,-50%);opacity:1;}
  .panel-title{margin:0 0 10px; font-size:16px; font-weight:700; letter-spacing:.2px; color:#7bdfff; text-align:center;}
  .controls label,.special-controls label{display:flex;flex-direction:column;gap:6px;margin:10px 0;font-size:13px;}
  .row,.formline,.inline{
    display:flex;align-items:center;justify-content:space-between;gap:8px;margin:8px 0;padding:6px 8px;border-radius:8px;background:#0f2c2c;
    font-size:13px;
  }
  .controls select,.controls input[type="color"],.special-controls select,.special-controls input[type="color"]{
    border-radius:6px;border:1px solid #2b2b2b;background:#0f0f0f;color:#fff;padding:.45em .6em;font-size:13px;
  }
  .special-controls input[type="range"]{width:140px;}

  /* Compact color swatch (desktop/Android) */
  .swatch{
    -webkit-appearance:none;appearance:none;
    width:42px;height:24px;
    padding:0;border:none;border-radius:6px;cursor:pointer;outline:none;
    background:transparent;
    box-shadow:0 0 0 1px rgba(255,255,255,0.18), inset 0 0 0 2px rgba(0,0,0,0.6);
  }
  .swatch:focus{ box-shadow:0 0 0 2px #00bfff, inset 0 0 0 2px rgba(0,0,0,0.5); }
  .swatch::-webkit-color-swatch-wrapper{ padding:0; border-radius:6px; }
  .swatch::-webkit-color-swatch{ border:none; border-radius:6px; }
  .swatch::-moz-color-swatch{ border:none; border-radius:6px; }

  /* iOS fallback swatch button */
  .swatch-proxy{
    width:42px;height:24px;border-radius:6px;cursor:pointer;outline:none;
    border:1px solid #2b2b2b; box-shadow:inset 0 0 0 2px rgba(0,0,0,0.6);
  }

  .btn{
    padding:.5em .8em;font-size:12px;border:none;border-radius:8px;cursor:pointer;
    background:#008080;color:#fff;transition:background .18s ease,transform .12s ease;display:inline-flex;align-items:center;gap:.4em;
  }
  .btn:hover{background:#006a6a;}
  .btn:active{transform:translateY(1px);}
  .btn.secondary{background:#2a2a2a;}
  .btn.secondary:hover{background:#1d1d1d;}
  .btn.ghost{background:transparent;border:1px solid #2a2a2a;}
  .btn.ghost:hover{background:#1a1a1a;}
  .btn.full{width:100%;justify-content:space-between}

  /* Floating toggles */
  #menuBtn,#specialBtn{
    position:fixed;right:10px;width:40px;height:40px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;
    color:#fff;background:rgba(0,0,0,0.7);z-index:2100;transition:background .2s ease,transform .1s ease;
  }
  #menuBtn:hover,#specialBtn:hover{background:rgba(0,0,0,0.9);transform:scale(1.06);}
  #menuBtn{top:10px;} #specialBtn{top:60px;}

  /* Picker Modal */
  .modal-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:2500;
  }
  .modal{
    background:#111;color:#eee; width:min(820px,94vw); max-height:86vh;
    border-radius:12px; box-shadow:0 12px 40px rgba(0,0,0,.45); display:flex; flex-direction:column; overflow:hidden;
    border:1px solid #2a2a2a;
  }
  .modal header{
    padding:.6rem .8rem;border-bottom:1px solid #222;display:flex;align-items:center;justify-content:space-between;gap:.5rem;flex-wrap:wrap;
  }
  .modal header .title{display:flex;align-items:center;gap:.5rem;font-weight:600;}
  .modal header .title small{opacity:.8;font-weight:400;}
  .modal .grid{
    padding:.75rem;display:grid;grid-template-columns:repeat(auto-fill,minmax(95px,1fr));gap:10px;overflow:auto;
  }
  .thumb{
    border:1px solid #2a2a2a;border-radius:8px;padding:6px;display:flex;flex-direction:column;align-items:center;background:#0e0e0e;
    transition:transform .08s ease,border-color .16s ease, box-shadow .16s ease;
  }
  .thumb.dragging{opacity:.6; transform:scale(.98);}
  .thumb:hover{border-color:#00bfff; box-shadow:0 0 0 2px rgba(0,191,255,.25) inset;}
  .thumb img{max-width:100%;max-height:70px;display:block;border-radius:6px;pointer-events:none;}
  .thumb span{font-size:11px;margin-top:.35rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100%;opacity:.85;}

  .modal .selected{border-top:1px solid #222; padding:.55rem .8rem; display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .slot{
    width:80px;height:80px;border:2px dashed #2a2a2a;border-radius:10px;display:flex;align-items:center;justify-content:center;position:relative;
    background:#0e0e0e; overflow:hidden; cursor:pointer;
  }
  .slot img{max-width:100%;max-height:100%;pointer-events:none;}
  .slot .badge{
    position:absolute;top:4px;left:4px;background:#0008;color:#fff;border-radius:999px;padding:2px 6px;font-size:11px;
    border:1px solid rgba(255,255,255,.25);
  }
  .slot[data-idx="0"]{border-color:#ff6b6b;}
  .slot[data-idx="1"]{border-color:#ffd93d;}
  .slot[data-idx="2"]{border-color:#4cd964;}
  .slot[data-idx="3"]{border-color:#66a5ff;}
  .slot.dragover{outline:2px solid #00bfff; outline-offset:2px;}
  .slot.active{outline:2px solid #00bfff; outline-offset:2px;}

  .modal footer{padding:.6rem .8rem;border-top:1px solid #222;display:flex;gap:.5rem;justify-content:flex-end;}
  .hidden{display:none !important;}

  /* Simple list modal (iPad select replacement) */
  .list-body{padding:.6rem .8rem;display:flex;flex-direction:column;gap:.5rem;overflow:auto}

  /* === NEW: smaller modal styling for iPad select replacement === */
  #listModal .modal{
    width: min(360px, 92vw);
    max-height: 56vh;
    border-radius: 12px;
  }
  #listModal .modal header{ padding: .5rem .7rem; }
  #listModal .list-body{
    padding: .5rem .7rem;
    max-height: 40vh;
  }
  #listModal .btn.ghost.full{
    font-size: 14px;
    padding: .55rem .7rem;
  }
</style>
</head>
<body>
  <div id="overlay"><button id="enterBtn" data-fr="Démarrer" data-en="Start">Démarrer</button></div>
  <canvas id="timerCanvas"></canvas>

  <div id="menuBtn" title="Settings">⚙️</div>
  <div id="specialBtn" title="Images">✨</div>

  <!-- Settings -->
  <div class="controls" aria-label="Settings">
    <h3 class="panel-title" data-fr="Paramètres" data-en="Settings">Paramètres</h3>

    <label>
      <span class="i18n" data-fr="Cadran" data-en="Dial">Cadran</span>
      <select id="dialSelect">
        <option value="60" selected>60 min</option>
        <option value="30">30 min</option>
        <option value="10">10 min</option>
        <option value="5">5 min</option>
        <option value="1">1 min</option>
        <option value="120">120 min</option>
      </select>
      <!-- iPad will see a proxy button here -->
      <button id="dialProxy" class="btn ghost hidden"></button>
    </label>

    <div class="inline">
      <span data-fr="Afficher les chiffres" data-en="Show numbers">Afficher les chiffres</span>
      <input type="checkbox" id="toggleDigits">
    </div>

    <label id="colorLabel">
      <span class="i18n" data-fr="Couleur du secteur (Spécial = Désactivé / Tâche→Récompense)" data-en="Wedge color (Special = Off / Task→Reward)">
        Couleur du secteur (Spécial = Désactivé / Tâche→Récompense)
      </span>

      <!-- Desktop/Android -->
      <input type="color" id="colorPicker" class="swatch" value="#d9534f" aria-label="Select colour">
      <!-- iOS fallback proxy -->
      <button id="colorProxy" type="button" class="swatch-proxy hidden" aria-label="Select colour"></button>
    </label>

    <label>
      <span class="i18n" data-fr="Son d’alarme" data-en="Alarm sound">Son d’alarme</span>
      <select id="alarmSelect">
        <option value="1" selected data-fr="TimeTimer 1" data-en="TimeTimer 1">TimeTimer 1</option>
        <option value="2" data-fr="TimeTimer 2" data-en="TimeTimer 2">TimeTimer 2</option>
        <option value="3" data-fr="TimeTimer 3" data-en="TimeTimer 3">TimeTimer 3</option>
        <option value="4" data-fr="TimeTimer 4" data-en="TimeTimer 4">TimeTimer 4</option>
      </select>
      <button id="alarmProxy" class="btn ghost hidden"></button>
    </label>

    <div class="inline">
      <button class="btn secondary" id="pauseBtn"
        data-fr-pause="Pause" data-en-pause="Pause"
        data-fr-resume="Reprendre" data-en-resume="Resume">Pause</button>
      <button class="btn" id="fsBtn" data-fr="Plein écran" data-en="Fullscreen">Plein écran</button>
    </div>
  </div>

  <!-- Special (images) -->
  <div class="special-controls" aria-label="Special features">
    <h3 class="panel-title" data-fr="Images" data-en="Images">Images</h3>

    <label>
      <span class="i18n" data-fr="Mode" data-en="Feature mode">Mode</span>
      <select id="specialMode">
        <option value="none" selected data-fr="Désactivé" data-en="Off">Désactivé</option>
        <option value="radial" data-fr="Images autour de l’horloge" data-en="Images Around Clock">Images autour de l’horloge</option>
        <option value="stacked" data-fr="Pile d’images à gauche" data-en="Images Stacked Left">Pile d’images à gauche</option>
        <option value="taskreward" data-fr="Tâche → Récompense (gauche)" data-en="Task → Reward (Left)">Tâche → Récompense (gauche)</option>
      </select>
      <button id="modeProxy" class="btn ghost hidden"></button>
    </label>

    <div class="formline">
      <span data-fr="Taille des images" data-en="Image size">Taille des images</span>
      <input type="range" id="imgSizeRange" min="0.16" max="0.6" step="0.01" value="0.22">
    </div>

    <div class="formline">
      <span data-fr="Nombre d’images" data-en="Image count">Nombre d’images</span>
      <select id="imgCountSelect">
        <option value="2">2</option>
        <option value="4" selected>4</option>
      </select>
    </div>

    <div class="inline">
      <span data-fr="Teinte de page" data-en="Page tint">Teinte de page</span>
      <input type="checkbox" id="bgTintToggleSpecial">
    </div>

    <div class="row">
      <span data-fr="Dossier d’images" data-en="Repository" id="repoLabel">Dossier d’images</span>
      <button class="btn" id="setRepoBtn" data-fr="📁 Choisir un dossier" data-en="📁 Set Repository">📁 Choisir un dossier</button>
    </div>
    <div id="repoStatus" style="opacity:.8;margin:-6px 0 6px 6px;font-size:12px;"
         data-fr="Aucun dossier sélectionné" data-en="No repository selected">Aucun dossier sélectionné</div>

    <div class="row">
      <span data-fr="Bibliothèque de pictogrammes" data-en="Pictogram Library">Bibliothèque de pictogrammes</span>
      <button class="btn" id="openPictosBtn" data-fr="🖼️ Ouvrir les pictogrammes" data-en="🖼️ Open Pictograms">🖼️ Ouvrir les pictogrammes</button>
    </div>
  </div>

  <!-- Hidden upload fallbacks (used on iPad only) -->
  <input id="uploadInput" type="file" accept="image/*" multiple style="display:none;" />
  <input id="uploadLibraryInput" type="file" accept="image/*" multiple style="display:none;" />
  <input id="uploadPhotoInput" type="file" accept="image/*" capture="environment" style="display:none;" />

  <!-- Shared Picker Modal -->
  <div id="pickerModal" class="modal-backdrop">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="pickerTitle">
      <header>
        <div class="title">
          <span id="pickerTitle" data-fr="Sélectionner des images" data-en="Select images">Sélectionner des images</span>
          <small id="pickerSub"></small>
        </div>
        <div style="display:flex;gap:.5rem;flex-wrap:wrap;">
          <button id="autoFillBtn" class="btn ghost"
            title="Fill slots 1–4"
            data-fr="Remplir 1–4" data-en="Auto-fill 1–4">Remplir 1–4</button>

          <!-- iPad-only convenience buttons -->
          <button id="pickLibraryBtn" class="btn secondary"
            data-fr="📚 Photothèque" data-en="📚 Library">📚 Photothèque</button>

          <button id="pickPhotoBtn" class="btn secondary"
            data-fr="📷 Photo" data-en="📷 Camera">📷 Photo</button>

          <button id="switchSourceBtn" class="btn secondary hidden"
            data-fr="Changer de dossier" data-en="Change Folder">Changer de dossier</button>

          <button id="closePickerBtn" class="btn secondary" data-fr="Fermer" data-en="Close">Fermer</button>
        </div>
      </header>

      <div id="pickerGrid" class="grid" aria-live="polite"></div>

      <div class="selected">
        <div class="slot" data-idx="0"><span class="badge">1</span></div>
        <div class="slot" data-idx="1"><span class="badge">2</span></div>
        <div class="slot" data-idx="2"><span class="badge">3</span></div>
        <div class="slot" data-idx="3"><span class="badge">4</span></div>
      </div>

      <footer>
        <button id="clearSlotsBtn" class="btn secondary" data-fr="Vider" data-en="Clear">Vider</button>
        <button id="assignBtn" class="btn" data-fr="Assigner" data-en="Assign">Assigner</button>
      </footer>
    </div>
  </div>

  <!-- Color Picker Mini Modal (iOS fallback) -->
  <div id="colorModal" class="modal-backdrop">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="colorTitle">
      <header>
        <div class="title">
          <span id="colorTitle" data-fr="Choisir une couleur" data-en="Pick a color">Choisir une couleur</span>
        </div>
        <div style="display:flex;gap:.5rem;">
          <button id="closeColorBtn" class="btn secondary" data-fr="Fermer" data-en="Close">Fermer</button>
        </div>
      </header>
      <div class="mini-body">
        <div class="chips">
          <div class="chip" data-col="#d9534f" style="background:#d9534f"></div>
          <div class="chip" data-col="#ff6b6b" style="background:#ff6b6b"></div>
          <div class="chip" data-col="#ffd93d" style="background:#ffd93d"></div>
          <div class="chip" data-col="#4cd964" style="background:#4cd964"></div>
          <div class="chip" data-col="#66a5ff" style="background:#66a5ff"></div>
          <div class="chip" data-col="#b36bff" style="background:#b36b5f"></div>
          <div class="chip" data-col="#000000" style="background:#000"></div>
          <div class="chip" data-col="#ffffff" style="background:#fff;border-color:#888"></div>
        </div>

        <div class="rgblines">
          <label><span>R</span><input id="rRange" type="range" min="0" max="255" value="217"><span id="rVal">217</span></label>
          <label><span>G</span><input id="gRange" type="range" min="0" max="255" value="83"><span id="gVal">83</span></label>
          <label><span>B</span><input id="bRange" type="range" min="0" max="255" value="79"><span id="bVal">79</span></label>
        </div>

        <div class="hexline">
          <span>#</span>
          <input id="hexInput" type="text" value="d9534f" maxlength="6" spellcheck="false" inputmode="latin" />
          <button id="okColorBtn" class="btn" data-fr="OK" data-en="OK">OK</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Generic List Modal (iPad: select replacement) -->
  <div id="listModal" class="modal-backdrop">
    <div class="modal" role="dialog" aria-modal="true">
      <header>
        <div class="title"><span id="listTitle">Choisir</span></div>
        <div><button id="closeListBtn" class="btn secondary" data-fr="Fermer" data-en="Close">Fermer</button></div>
      </header>
      <div id="listBody" class="list-body"></div>
    </div>
  </div>

<script>
/* ===========================================================
   CONSTANTS YOU CAN TWEAK
   =========================================================== */
const H_SHIFT = 0.26;             // horizontal nudge (4-image radial)
const H_SHIFT_2 = 0.12;           // horizontal nudge (2-image radial)
const V_OFFSET_TOP = 0.16;        // vertical offset for NE & NW (4-image radial)
const V_OFFSET_BOTTOM = -0.16;    // vertical offset for SE & SW (4-image radial)
const SHIFT_RIGHT_STACKED = 0.18; // move dial center right in stacked/taskreward modes
const INACTIVE_ALPHA = 0.45;      // dim inactive images
const IDLE_CLOSE_MS = 10000;      // auto-close panels after 10s idle
const MIN_STACKED_FIT = 0.55;     // desktop minimum column fit
const STACK_V_MARGIN = 0.06;      // top/bottom breathing space for stacked column

// Pulse
const PULSE_PERIOD = 1800;        // ms
const PULSE_AMPLITUDE = 0.04;     // +/- 4%

// Radial distance from number ring (desktop defaults)
const RADIAL_RADIUS_OFFSET_4 = 0.12;
const RADIAL_RADIUS_OFFSET_2 = 0.06;

// Task→Reward spacing multiplier
const TASKREWARD_SPACING_MULT = 3.5;

/* ==== iPad-only tunables (fixed start size + visible pulse) ==== */
const IOS_IMGBASE_DEFAULT = 0.28;   // ~1/6 from the left of the slider range (0.16→0.90)
const IOS_FS_FIT_PAD      = 0.006;  // slightly tighter padding on iPad FS
const IOS_FS_OVERFLOW     = 1.02;   // small base overflow
const IOS_FS_OVERFLOW_ACTIVE = 1.10; // extra headroom for the active image to show pulse

/* ===========================================================
   LAYOUT (image size etc.)
   =========================================================== */
const LAYOUT = {
  imgBase: 0.30,     // desktop default; iPad overrides at startup
  activeScale: 1.33,
  radial: { radiusOffset: RADIAL_RADIUS_OFFSET_4 },
  stacked:{ spacing: 0.025, marginLeft: 0.06 }
};
/* ===========================================================
   END CONFIG
   =========================================================== */

/* ---------- iOS detection ---------- */
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
              (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

/* ---------- fullscreen helpers ---------- */
function requestFS(){
  (document.documentElement.requestFullscreen||document.documentElement.webkitRequestFullscreen)?.call(document.documentElement);
}
function exitFS(){
  (document.exitFullscreen||document.webkitExitFullscreen)?.call(document);
}
function ensureReturnToFullscreen(){
  if(overlay.style.display!=='none') return;
  if(!document.fullscreenElement){
    try{ requestFS(); }catch(_){}
  }
  setTimeout(resizeCanvas,120);
}
let iosModalOpen = false;
function tryKeepFullscreen(delay=350){
  if(!isIOS || iosModalOpen) return;
  setTimeout(ensureReturnToFullscreen, delay);
}

/* ---------- i18n helpers ---------- */
function getLang(){
  const l = document.documentElement.getAttribute('lang') || 'fr';
  return l.toLowerCase().startsWith('fr') ? 'fr' : 'en';
}
function setPauseLabel(paused){
  const btn = document.getElementById('pauseBtn');
  const lang = getLang();
  const label = paused ? (lang==='fr' ? btn.dataset.frResume : btn.dataset.enResume)
                       : (lang==='fr' ? btn.dataset.frPause  : btn.dataset.enPause);
  btn.textContent = label || (paused ? 'Resume' : 'Pause');
}

/* ---------- single-tap helper ---------- */
const supportsPointer = 'onpointerup' in window;
function addTap(el, handler){
  if(!el) return;
  if(supportsPointer){
    el.addEventListener('pointerup', (e)=>{
      if(e.pointerType === 'mouse' && e.button !== 0) return;
      e.preventDefault(); e.stopPropagation();
      handler(e);
    }, {passive:false});
  }else{
    el.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      handler(e);
    }, {passive:false});
  }
}

/* ---------- Canvas & state ---------- */
const canvas=document.getElementById('timerCanvas'),ctx=canvas.getContext('2d');
const overlay=document.getElementById('overlay'),enterBtn=document.getElementById('enterBtn');

let totalSeconds=300,remainingSeconds=0,intervalId=null,paused=false,dragging=false;
let showDigits=false,dialMax=60,timerColor='#d9534f';
let bgTintEnabled=false; const TINT_ALPHA=0.35;

let nowMs = 0; // for pulse

/* ---------- Special features ---------- */
let specialMode='none';
let IMG_COUNT = 4; // 2 or 4
const quadrantColors=['#ff6b6b','#ffd93d','#4cd964','#66a5ff'];
const imgs=[null,null,null,null];
async function loadRandomPictos(count=IMG_COUNT){
  try{
    const resp = await fetch('../../pictos/index.json', { cache:'no-store' });
    if(!resp.ok) return;
    const data = await resp.json();
    let files = [];
    if(data.categories && typeof data.categories === 'object'){
      for(const arr of Object.values(data.categories)) files = files.concat(arr);
    }else if(Array.isArray(data.files)){
      files = data.files;
    }
    if(!files.length) return;
    const base = new URL('.', resp.url).pathname;
    const picks = files.sort(()=>Math.random()-0.5).slice(0,count);
    await Promise.all(picks.map((f,i)=> new Promise(res=>{
      const im=new Image();
      im.onload=()=>{ imgs[i]=im; res(); };
      im.onerror=()=>res();
      im.src = base + f;
    })));
    saveLastImages();
  }catch(e){}
}

/* Persist last selection */
const LAST_KEY = 'timer-last-4';
function saveLastImages(){
  const sources = imgs.map(im => im ? im.src : null);
  localStorage.setItem(LAST_KEY, JSON.stringify(sources));
}
async function loadLastImagesIfEmpty(){
  if (imgs.some(Boolean)) { return; }
  try{
    const arr = JSON.parse(localStorage.getItem(LAST_KEY) || '[]');
    if(Array.isArray(arr) && arr.filter(Boolean).length){
      const loads = arr.map((src, i) => {
        if(!src){ imgs[i]=null; return Promise.resolve(); }
        return new Promise(res=>{
          const im = new Image();
          im.onload = ()=>{ imgs[i]=im; res(); };
          im.onerror = ()=> res();
          im.src = src;
        });
      });
      await Promise.all(loads);
      return;
    }
  }catch(e){}
  await loadRandomPictos(IMG_COUNT);
}

/* Dial configs */
const dialConfigs={
  60:{ticks:60,nums:[0,5,10,15,20,25,30,35,40,45,50,55],denom:60,short:true,step:5},
  120:{ticks:60,nums:[0,10,20,30,40,50,60,70,80,90,100,110],denom:120,short:true,step:5},
  30:{ticks:30,nums:[0,5,10,15,20,25],denom:30,short:false,step:1},
  10:{ticks:60,nums:[0,1,2,3,4,5,6,7,8,9],denom:10,short:true,step:6},
  5:{ticks:60,nums:[0,1,2,3,4],denom:5,short:true,step:12},
  1:{ticks:60,nums:[0,5,10,15,20,25,30,35,40,45,50,55],denom:60,short:true,step:5}
};

/* Helpers */
function hexToRGBA(hex,alpha){
  const r=parseInt(hex.substr(1,2),16),g=parseInt(hex.substr(3,2),16),b=parseInt(hex.substr(5,2),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function computeContainSize(img, targetPx){
  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;
  if(!iw || !ih){ return {w:targetPx, h:targetPx}; }
  const scale = targetPx / Math.max(iw, ih);
  return { w: iw * scale, h: ih * scale };
}
function getCenter(size){
  const baseCx = canvas.width/2, cy = canvas.height/2;
  if(specialMode==='stacked' || specialMode==='taskreward'){
    return { cx: baseCx + size * SHIFT_RIGHT_STACKED, cy };
  }
  return { cx: baseCx, cy };
}

/* Auto-fit utility
   padFrac: fraction of canvas used as padding to keep elements inside
   overflowBoost: >1 allows slight overspill vs the strict "fit" (used on iPad FS)
*/
function fitScaleForCenteredRect(cxR, cyR, w, h, padFrac = 0.02, overflowBoost = 1){
  const pad = Math.max(6, Math.min(canvas.width, canvas.height) * padFrac);
  const maxW = Math.max(1, Math.min(2*(cxR - pad), 2*(canvas.width - pad - cxR)));
  const maxH = Math.max(1, Math.min(2*(cyR - pad), 2*(canvas.height - pad - cyR)));
  const fit = Math.min(maxW / w, maxH / h);        // strict fit (<=1 if needs shrinking)
  const s = Math.min(1, fit * overflowBoost);      // allow a little larger than strict fit
  return (isFinite(s) && s>0) ? s : 1;
}

/* Drag helpers for dial */
function getSecondsFromEvent(e){
  const r=canvas.getBoundingClientRect(),
        x=(e.touches?e.touches[0].clientX:e.clientX)-r.left,
        y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
  const size=Math.min(canvas.width,canvas.height)*0.9;
  const {cx,cy} = getCenter(size);
  let ang=-Math.PI/2-Math.atan2(y-cy,x-cx);while(ang<0)ang+=Math.PI*2;
  const cfg=dialConfigs[dialMax],ratio=ang/(Math.PI*2);
  if(dialMax<=10){
    const tick=Math.round(ratio*cfg.ticks),secs=tick*(dialMax*60/cfg.ticks);
    return secs===0?dialMax*60:secs;
  }
  const mins=Math.round(ratio*dialMax);
  return (mins===0?dialMax:mins)*60;
}
function insideDial(e){
  const r=canvas.getBoundingClientRect(),
        x=(e.touches?e.touches[0].clientX:e.clientX)-r.left,
        y=(e.touches?e.touches[0].clientY:e.clientY)-r.top,
        size=Math.min(canvas.width,canvas.height)*0.9;
  const {cx,cy} = getCenter(size);
  return Math.hypot(x-cx,y-cy)<=size*0.4;
}
function updateDrag(e){
  const s=Math.max(1,Math.min(dialMax*60,getSecondsFromEvent(e)));
  totalSeconds=remainingSeconds=s;
  draw();
}

/* 2 or 4 active index */
function getActiveIndex(uiSeconds, denom, count){
  const t = Math.max(1, uiSeconds);
  if(count===4){
    const qLen = denom/4;
    const qIdx = Math.floor((t-1)/qLen);
    return 3 - qIdx; // NE,SE,SW,NW mapping
  }else{
    const hLen = denom/2;
    const hIdx = Math.floor((t-1)/hLen);
    return 1 - hIdx; // 0=Right,1=Left
  }
}
function colorForIndex(i,N){ return quadrantColors[ N===2 ? (i===0?0:3) : i ]; }
function getAnglesForCount(N){ return (N===2) ? [0, Math.PI] : [-Math.PI/4, Math.PI/4, 3*Math.PI/4, -3*Math.PI/4]; }

/* Draw */
function draw(){
  const size=Math.min(canvas.width,canvas.height)*0.9;
  const {cx,cy} = getCenter(size);

  const outerR=size*0.4,borderW=size*0.0067,wedgeR=outerR-borderW/2;
  const tickLong=size*0.05,tickShort=size*0.025,tickStart=outerR+borderW/2;
  const numbersR=tickStart+tickLong+size*0.03;

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Outer circle
  ctx.strokeStyle='#000';ctx.lineWidth=borderW;
  ctx.beginPath();ctx.arc(cx,cy,outerR,0,Math.PI*2);ctx.stroke();

  // Preview vs running seconds
  const uiSeconds = (remainingSeconds>0)
    ? remainingSeconds
    : Math.max(1, Math.round((dialMax*60)));

  const denom = dialMax*60;
  const angle = (uiSeconds/denom) * Math.PI * 2;

  // Wedge & background sectors
  if(specialMode==='radial' || specialMode==='stacked'){
    ctx.save();
    ctx.beginPath();ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,wedgeR,-Math.PI/2,-Math.PI/2-angle,true);
    ctx.closePath();ctx.clip();

    const N = IMG_COUNT;
    const fillSector = (start,end,color)=>{
      ctx.fillStyle=color;
      ctx.beginPath(); ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,wedgeR,start,end,true);
      ctx.closePath(); ctx.fill();
    };

    if(N===2){
      fillSector(-Math.PI/2,  Math.PI/2,  colorForIndex(1,2));
      fillSector( Math.PI/2,  3*Math.PI/2, colorForIndex(0,2));
    }else{
      for(let i=0;i<4;i++){
        const start = -Math.PI/2 - i*Math.PI/2;
        const end   = -Math.PI/2 - (i+1)*Math.PI/2;
        ctx.fillStyle = quadrantColors[(3-i)&3];
        ctx.beginPath(); ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,wedgeR,start,end,true);
        ctx.closePath(); ctx.fill();
      }
    }
    ctx.restore();
  }else{
    // 'none' and 'taskreward' => single-color wedge
    ctx.fillStyle=timerColor;
    ctx.beginPath();ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,wedgeR,-Math.PI/2,-Math.PI/2-angle,true);
    ctx.closePath();ctx.fill();
  }

  // Ticks & numbers
  const cfg=dialConfigs[dialMax];
  for(let i=0;i<cfg.ticks;i++){
    const ang=-Math.PI/2-(i/cfg.ticks)*Math.PI*2,
          sx=cx+Math.cos(ang)*tickStart, sy=cy+Math.sin(ang)*tickStart;
    const long=i%cfg.step===0, len=cfg.short?(long?tickLong:tickShort):tickLong;
    const ex=cx+Math.cos(ang)*(tickStart+len), ey=cy+Math.sin(ang)*(tickStart+len);
    ctx.lineWidth=long?size*0.006:size*0.003;
    ctx.beginPath();ctx.moveTo(sx,sy);ctx.lineTo(ex,ey);ctx.stroke();
  }

  ctx.fillStyle='#000';ctx.font=`${size*0.04}px Arial`;ctx.textAlign='center';ctx.textBaseline='middle';
  for(const m of cfg.nums){
    const ang=-Math.PI/2-(m/cfg.denom)*Math.PI*2;
    ctx.fillText(m.toString(),cx+Math.cos(ang)*numbersR,cy+Math.sin(ang)*numbersR);
  }

  if(showDigits){
    ctx.font=`bold ${size*0.12}px Arial`;
    const m=Math.floor(uiSeconds/60),s=Math.floor(uiSeconds%60);
    ctx.fillText(`${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`,cx,cy);
  }

  if(specialMode==='radial')      drawRadial(size,cx,cy,numbersR,uiSeconds,denom);
  if(specialMode==='stacked')     drawStacked(size,cx,cy,outerR,uiSeconds,denom);
  if(specialMode==='taskreward')  drawTaskReward(size,cx,cy,outerR);

  updatePageTint(uiSeconds, denom);
}

/* Page tint */
function updatePageTint(uiSeconds, denom){
  if(!bgTintEnabled){ document.body.style.backgroundColor=''; return; }

  if(specialMode==='none' || specialMode==='taskreward'){
    document.body.style.backgroundColor = hexToRGBA(timerColor, TINT_ALPHA);
    return;
  }
  const N = IMG_COUNT;
  const active = getActiveIndex(uiSeconds, denom, (N===2?2:4));
  const col = colorForIndex(active, (N===2?2:4));
  document.body.style.backgroundColor = hexToRGBA(col, TINT_ALPHA);
}

/* ---- RADIAL (iPad fullscreen tweaked) ---- */
function drawRadial(size,cx,cy,numbersR,uiSeconds,denom){
  const iosFS = isIOS && !!document.fullscreenElement;

  // Slightly farther from the dial on iPad FS so they can bleed outward a bit
  const radialOffset4 = iosFS ? 0.07 : (isIOS ? 0.08 : LAYOUT.radial.radiusOffset);
  const radialOffset2 = iosFS ? 0.05 : (isIOS ? 0.04 : RADIAL_RADIUS_OFFSET_2);

  const basePx = size * LAYOUT.imgBase;
  const radialOffset = (IMG_COUNT===2 ? radialOffset2 : radialOffset4);
  const imgR   = numbersR + size * radialOffset;

  // Soft nudges while fullscreen on iPad
  const hShiftPx_4 = size * (iosFS ? 0.18 : H_SHIFT);
  const hShiftPx_2 = size * (iosFS ? 0.09 : H_SHIFT_2);
  const vTopPx     = size * (iosFS ? 0.12 : V_OFFSET_TOP);
  const vBotPx     = size * (iosFS ? -0.12 : V_OFFSET_BOTTOM);

  const N = IMG_COUNT;
  const active = getActiveIndex(uiSeconds, denom, (N===2?2:4));
  const angles = getAnglesForCount(N);

  for(let i=0;i<N;i++){
    const im = imgs[i];
    if(!im) continue;

    const isActive = (i===active);
    const pulse = isActive ? (1 + PULSE_AMPLITUDE * Math.sin((nowMs % PULSE_PERIOD)/PULSE_PERIOD * 2*Math.PI)) : 1;
    const scale = (isActive ? LAYOUT.activeScale : 1) * pulse;
    const target = basePx * scale;
    let {w, h} = computeContainSize(im, target);

    const ang=angles[i];
    let dx=0, dy=0;
    if (N===2){
      const dxSign = (i===0) ? 1 : -1; // right, left
      dx = dxSign * hShiftPx_2;
    } else {
      const dxSign = (i===0 || i===1) ? 1 : -1; // east = +, west = -
      dx = dxSign * hShiftPx_4;
      dy = (i===0 || i===3) ? vTopPx : vBotPx;
    }

    const cxI = cx + Math.cos(ang)*imgR + dx;
    const cyI = cy + Math.sin(ang)*imgR + dy;

    // iPad FS: allow small overspill and tighter padding near screen edges
    const overflow = iosFS ? (isActive ? IOS_FS_OVERFLOW_ACTIVE : IOS_FS_OVERFLOW) : 1;
    const fitS = fitScaleForCenteredRect(
      cxI, cyI, w, h,
      iosFS ? IOS_FS_FIT_PAD : 0.02,
      overflow
    );
    w *= fitS; h *= fitS;

    const x = cxI - w/2;
    const y = cyI - h/2;

    ctx.save();
    if(!isActive) ctx.globalAlpha = 1 - INACTIVE_ALPHA;
    ctx.drawImage(im, x, y, w, h);
    ctx.strokeStyle=colorForIndex(i, (N===2?2:4));ctx.lineWidth=size*0.006;
    ctx.strokeRect(x, y, w, h);
    ctx.restore();
  }
}

/* ---- STACKED ---- */
function drawStacked(size,cx,cy,outerR,uiSeconds,denom){
  const basePx   = size * LAYOUT.imgBase;
  const spacing  = size * LAYOUT.stacked.spacing;
  const leftEdge = cx - outerR - size * LAYOUT.stacked.marginLeft;
  const xCenter  = leftEdge/2;

  const N = IMG_COUNT;
  const active = getActiveIndex(uiSeconds, denom, (N===2?2:4));

  const baseDims = Array.from({length:N}, (_,i)=>{
    const im = imgs[i];
    if(!im) return {w:basePx, h:basePx, has:false};
    const s  = (i===active) ? LAYOUT.activeScale : 1;
    const d  = computeContainSize(im, basePx * s);
    return {w:d.w, h:d.h, has:true, im};
  });

  const sumH   = baseDims.reduce((a,d)=>a+(d.h||basePx), 0);
  const availH = canvas.height - 2*(size*STACK_V_MARGIN);
  let g = Math.min(1, (availH - spacing*(N-1)) / Math.max(1, sumH));
  if(!isFinite(g) || g <= 0) g = 1;
  if(!isIOS) g = Math.max(g, MIN_STACKED_FIT);

  let totalH = baseDims.reduce((a,d)=>a + d.h*g, 0) + spacing*(N-1);
  let y = cy - totalH/2;

  for(let i=0;i<N;i++){
    const d = baseDims[i];
    const isActive = (i===active);

    const pulse = isActive ? (1 + PULSE_AMPLITUDE *
                     Math.sin((nowMs % PULSE_PERIOD)/PULSE_PERIOD * 2*Math.PI)) : 1;

    const reservedH = d.h * g;
    const drawH     = d.h * g * pulse;
    const drawW     = d.w * g * pulse;

    const x = xCenter - drawW/2;
    const yDraw = y + (reservedH - drawH)/2;

    if(d.has){
      ctx.save();
      if(!isActive) ctx.globalAlpha = 1 - INACTIVE_ALPHA;
      ctx.drawImage(d.im, x, yDraw, drawW, drawH);
      ctx.strokeStyle = colorForIndex(i, (N===2?2:4));
      ctx.lineWidth   = size*0.006;
      ctx.strokeRect(x, yDraw, drawW, drawH);
      ctx.restore();
    }

    y += reservedH + spacing;
  }
}

/* ---- TASK → REWARD ---- */
function drawTaskReward(size,cx,cy,outerR){
  const basePx   = size * LAYOUT.imgBase;
  const spacing  = size * LAYOUT.stacked.spacing * TASKREWARD_SPACING_MULT;
  const leftEdge = cx - outerR - size * LAYOUT.stacked.marginLeft;
  const xCenter  = leftEdge/2;

  const task = imgs[0], reward = imgs[1];
  if(!task && !reward) return;

  let tSize = task ? computeContainSize(task, basePx) : {w:basePx, h:basePx};
  let rSize = reward ? computeContainSize(reward, basePx) : {w:basePx, h:basePx};

  const totalH0 = tSize.h + spacing + rSize.h;
  let yTop = cy - totalH0/2;
  let yBot = yTop + tSize.h + spacing;

  if(task){
    const cxI = xCenter;
    const cyI = yTop + tSize.h/2;
    const s = fitScaleForCenteredRect(cxI, cyI, tSize.w, tSize.h);
    tSize = { w: tSize.w*s, h: tSize.h*s };
  }
  if(reward){
    const cxI = xCenter;
    const cyI = yBot + rSize.h/2;
    const s = fitScaleForCenteredRect(cxI, cyI, rSize.w, rSize.h);
    rSize = { w: rSize.w*s, h: rSize.h*s };
  }

  const totalH = tSize.h + spacing + rSize.h;
  yTop = cy - totalH/2;
  yBot = yTop + tSize.h + spacing;

  const tx = xCenter - tSize.w/2;
  const ty = yTop;
  const rx = xCenter - rSize.w/2;
  const ry = yBot;

  if(task) ctx.drawImage(task, tx, ty, tSize.w, tSize.h);
  if(reward) ctx.drawImage(reward, rx, ry, rSize.w, rSize.h);

  if(task){
    ctx.save();
    ctx.strokeStyle = timerColor;
    ctx.lineWidth = Math.max(2, size * 0.008);
    ctx.strokeRect(tx, ty, tSize.w, tSize.h);
    ctx.restore();
  }

  if(task && reward){
    const startX = xCenter;
    const startY = ty + tSize.h + Math.min(spacing*0.25, size*0.04);
    const endX   = xCenter;
    const endY   = ry - Math.min(spacing*0.25, size*0.04);
    const head   = Math.min(size*0.03, 14);

    ctx.save();
    ctx.strokeStyle = timerColor;
    ctx.fillStyle = timerColor;
    ctx.lineWidth = Math.max(2, size*0.004);

    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(endX, endY + head);
    ctx.lineTo(endX - head*0.7, endY - head*0.6);
    ctx.lineTo(endX + head*0.7, endY - head*0.6);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

/* Timer */
function tick(){
  if(!paused){
    remainingSeconds--;
    if(remainingSeconds<=0){ remainingSeconds=0; clearInterval(intervalId); playAlarm(); }
    draw();
  }
}
function startTimerFromDrag(){
  if(isNaN(totalSeconds)||totalSeconds<=0) return;
  if(totalSeconds>dialMax*60){totalSeconds=dialMax*60;}
  remainingSeconds=totalSeconds;paused=false;
  setPauseLabel(false);
  clearInterval(intervalId);intervalId=setInterval(tick,1000);
  draw();
}
function startTimerAtFullDial(){
  totalSeconds = dialMax * 60;
  remainingSeconds = totalSeconds;
  paused = false;
  setPauseLabel(false);
  clearInterval(intervalId);
  intervalId = setInterval(tick, 1000);
  draw();
}
const pauseTimer=()=>{ paused=!paused; setPauseLabel(paused); };

/* Drag & resize for dial */
function startDrag(e){
  if(!insideDial(e))return;
  clearInterval(intervalId);paused=false;
  setPauseLabel(false);
  dragging=true;updateDrag(e);
}
const dragMove=e=>{ if(!dragging)return; e.preventDefault(); updateDrag(e); };
const endDrag=()=>{ if(!dragging)return; dragging=false; startTimerFromDrag(); };
function resizeCanvas(){ canvas.width=innerWidth; canvas.height=innerHeight; draw(); }

/* Panel toggles + auto-close on idle */
const menuBtn=document.getElementById('menuBtn'),menu=document.querySelector('.controls');
const specialBtn=document.getElementById('specialBtn'),specialMenu=document.querySelector('.special-controls');

let menuIdle=null, specialIdle=null;
function startIdle(panel){
  stopIdle(panel);
  const t = setTimeout(()=>{ const el = (panel==='menu') ? menu : specialMenu; el.classList.remove('show'); }, IDLE_CLOSE_MS);
  if(panel==='menu') menuIdle=t; else specialIdle=t;
}
function stopIdle(panel){
  if(panel==='menu' && menuIdle){ clearTimeout(menuIdle); menuIdle=null; }
  if(panel==='special' && specialIdle){ clearTimeout(specialIdle); specialIdle=null; }
}
function attachIdleSources(el, panel){
  ['pointerdown','input','change','wheel','keydown'].forEach(ev=>{ el.addEventListener(ev, ()=> startIdle(panel)); });
}
attachIdleSources(menu,'menu');
attachIdleSources(specialMenu,'special');

addTap(menuBtn, (e)=>{
  e.stopPropagation();
  const open = !menu.classList.contains('show');
  menu.classList.toggle('show');
  specialMenu.classList.remove('show'); stopIdle('special');
  if(open) startIdle('menu'); else stopIdle('menu');
  tryKeepFullscreen(300);
});
addTap(specialBtn, (e)=>{
  e.stopPropagation();
  const open = !specialMenu.classList.contains('show');
  specialMenu.classList.toggle('show');
  menu.classList.remove('show'); stopIdle('menu');
  if(open) startIdle('special'); else stopIdle('special');
  tryKeepFullscreen(300);
});
document.addEventListener('click',e=>{
  if(!menu.contains(e.target)&&!menuBtn.contains(e.target)){ menu.classList.remove('show'); stopIdle('menu'); }
  if(!specialMenu.contains(e.target)&&!specialBtn.contains(e.target)){ specialMenu.classList.remove('show'); stopIdle('special'); }
});

/* Inputs (common) */
document.getElementById('pauseBtn').addEventListener('click',()=>{ pauseTimer(); tryKeepFullscreen(200); });
document.getElementById('fsBtn').addEventListener('click',()=>{ if(!document.fullscreenElement){ requestFS(); }else{ exitFS(); } setTimeout(resizeCanvas,120); });

document.getElementById('toggleDigits').addEventListener('change',e=>{showDigits=e.target.checked;draw(); tryKeepFullscreen(200);});
document.getElementById('dialSelect').addEventListener('change',e=>{
  dialMax=parseInt(e.target.value,10);
  startTimerAtFullDial();
  tryKeepFullscreen(200);
});

/* Special mode */
const specialModeSelect=document.getElementById('specialMode');
specialModeSelect.addEventListener('change',async e=>{
  specialMode=e.target.value;
  if(specialMode==='radial' || specialMode==='stacked' || specialMode==='taskreward'){
    await loadLastImagesIfEmpty();
    draw();
  } else {
    draw();
  }
  // iPad: always reset to conservative start size for radial so pulse won't be clamped
  if (isIOS && specialMode === 'radial') {
    LAYOUT.imgBase = IOS_IMGBASE_DEFAULT;
    const r = document.getElementById('imgSizeRange');
    r.min = '0.16';
    r.max = '0.90';
    r.value = String(LAYOUT.imgBase);
  }
  tryKeepFullscreen(200);
});

/* Color handling (desktop + iOS fallback) */
const colorPicker=document.getElementById('colorPicker');
const colorProxy=document.getElementById('colorProxy');
function applyTimerColor(hex){
  timerColor = hex;
  if(!isIOS){ colorPicker.value = hex; }
  colorProxy.style.background = hex;
  if(specialMode==='none' || specialMode==='taskreward'){ draw(); }
  if(bgTintEnabled){
    updatePageTint(remainingSeconds>0?remainingSeconds:(dialMax*60), dialMax*60);
  }
}
if(!isIOS){
  colorProxy.classList.add('hidden');
  colorPicker.classList.remove('hidden');
  colorPicker.addEventListener('input',e=>{ applyTimerColor(e.target.value); });
}else{
  // iPad: hide native input, use mini modal
  colorPicker.classList.add('hidden');
  colorProxy.classList.remove('hidden');
  colorProxy.style.background = timerColor;
  addTap(colorProxy, ()=>{ openColorModal(); });
}

/* Simple color modal logic (iOS) */
const colorModal = document.getElementById('colorModal');
const closeColorBtn = document.getElementById('closeColorBtn');
const okColorBtn = document.getElementById('okColorBtn');
const hexInput = document.getElementById('hexInput');
const rRange = document.getElementById('rRange');
const gRange = document.getElementById('gRange');
const bRange = document.getElementById('bRange');
const rVal = document.getElementById('rVal');
const gVal = document.getElementById('gVal');
const bVal = document.getElementById('bVal');

function hexToRgbObj(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  if(!m) return {r:217,g:83,b:79};
  const n = parseInt(m[1],16);
  return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
}
function rgbToHex(r,g,b){
  const h = (x)=>x.toString(16).padStart(2,'0');
  return '#'+h(r)+h(g)+h(b);
}
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function syncRGBtoUI(rgb){
  rRange.value = rgb.r; gRange.value = rgb.g; bRange.value = rgb.b;
  rVal.textContent = rgb.r; gVal.textContent = rgb.g; bVal.textContent = rgb.b;
  hexInput.value = rgbToHex(rgb.r, rgb.g, rgb.b).slice(1);
}
function syncUItoColor(){
  const r = clamp(parseInt(rRange.value,10)||0,0,255);
  const g = clamp(parseInt(gRange.value,10)||0,0,255);
  const b = clamp(parseInt(bRange.value,10)||0,0,255);
  rVal.textContent=r; gVal.textContent=g; bVal.textContent=b;
  hexInput.value = rgbToHex(r,g,b).slice(1);
}
function openColorModal(){
  iosModalOpen = true;
  const rgb = hexToRgbObj(timerColor);
  syncRGBtoUI(rgb);
  colorModal.style.display='flex';
}
function closeColorModal(){
  colorModal.style.display='none';
  iosModalOpen = false;
  ensureReturnToFullscreen();
}
[rRange,gRange,bRange].forEach(el=>{
  el.addEventListener('input', ()=>{ syncUItoColor(); });
});
hexInput.addEventListener('input', ()=>{
  const h = '#'+hexInput.value.replace(/[^0-9a-f]/ig,'').slice(0,6);
  const rgb = hexToRgbObj(h.length===7?h:'#d9534f');
  syncRGBtoUI(rgb);
});
document.querySelectorAll('#colorModal .chip').forEach(ch=>{
  ch.addEventListener('click', ()=>{
    const col = ch.getAttribute('data-col');
    const rgb = hexToRgbObj(col);
    syncRGBtoUI(rgb);
  });
});
closeColorBtn.addEventListener('click', closeColorModal);
okColorBtn.addEventListener('click', ()=>{
  const r = parseInt(rRange.value,10)||217;
  const g = parseInt(gRange.value,10)||83;
  const b = parseInt(bRange.value,10)||79;
  const hex = rgbToHex(clamp(r,0,255), clamp(g,0,255));
  applyTimerColor(hex);
  closeColorModal();
});

/* --------- iPad select replacement: generic list modal ---------- */
const listModal = document.getElementById('listModal');
const listTitle = document.getElementById('listTitle');
const listBody  = document.getElementById('listBody');
const closeListBtn = document.getElementById('closeListBtn');

function openListModal(title, items, onPick){
  iosModalOpen = true;
  listTitle.textContent = title;
  listBody.innerHTML = '';
  for(const it of items){
    const btn = document.createElement('button');
    btn.className = 'btn ghost full';
    btn.innerHTML = `<span>${it.label}</span>${it.selected ? '<span>✓</span>' : '<span>&nbsp;</span>'}`;
    btn.addEventListener('click', ()=>{
      onPick(it.value, it.label);
      closeListModal();
    });
    listBody.appendChild(btn);
  }
  listModal.style.display = 'flex';
}
function closeListModal(){
  listModal.style.display = 'none';
  iosModalOpen = false;
  ensureReturnToFullscreen();
}

/* NEW: close handlers for the small list modal */
closeListBtn.addEventListener('click', closeListModal);
listModal.addEventListener('click', (e) => {
  if (e.target === listModal) closeListModal();
}, { passive: false });
const listInner = listModal.querySelector('.modal');
if (listInner) {
  listInner.addEventListener('click', (e) => e.stopPropagation(), { passive: true });
}

/* Build an iPad proxy for a <select> */
function createSelectProxy(selectEl, proxyBtn, title){
  if(!isIOS) return;
  selectEl.classList.add('hidden');
  proxyBtn.classList.remove('hidden');

  const curr = selectEl.options[selectEl.selectedIndex];
  proxyBtn.textContent = curr ? curr.textContent : title;

  addTap(proxyBtn, ()=>{
    const items = Array.from(selectEl.options).map(opt=>({
      value: opt.value,
      label: opt.textContent,
      selected: opt.selected
    }));
    openListModal(title, items, (val, label)=>{
      selectEl.value = val;
      proxyBtn.textContent = label;
      selectEl.dispatchEvent(new Event('change', {bubbles:true}));
    });
  });
}

/* Image size/count + tint */
const imgSizeRange = document.getElementById('imgSizeRange');
document.getElementById('imgSizeRange').addEventListener('input', (e)=>{ LAYOUT.imgBase = parseFloat(e.target.value); draw(); tryKeepFullscreen(150); });
document.getElementById('imgCountSelect').addEventListener('change', (e)=>{ IMG_COUNT = parseInt(e.target.value,10); draw(); tryKeepFullscreen(150); });

document.getElementById('bgTintToggleSpecial').addEventListener('change', (e)=>{
  bgTintEnabled = e.target.checked;
  draw();
  tryKeepFullscreen(150);
});

/* Alarm sound */
let selectedSound = '1', audioPreview = null;
function soundPath(id){ return `../../sounds/timetimer/timetimer${id}.mp3`; }
document.getElementById('alarmSelect').addEventListener('change',(e)=>{
  selectedSound = e.target.value;
  try{
    if(audioPreview){ audioPreview.pause(); audioPreview = null; }
    const a = new Audio(soundPath(selectedSound));
    audioPreview = a; a.volume=1; a.play().catch(()=>{});
  }catch(_){}
  tryKeepFullscreen(300);
});
function playAlarm(){
  try{
    const a=new Audio(soundPath(selectedSound));
    a.volume=1; a.play().catch(()=>{});
  }catch(_){}
}

/* ---------- File Source Handling ---------- */
const supportsDirPicker = 'showDirectoryPicker' in window;
const setRepoBtn = document.getElementById('setRepoBtn');
const repoStatus = document.getElementById('repoStatus');
const repoLabel  = document.getElementById('repoLabel');
const uploadInput = document.getElementById('uploadInput');

if(!supportsDirPicker){
  const lang = getLang();
  setRepoBtn.textContent = (lang==='fr' ? '⬆️ Importer des images' : '⬆️ Upload images');
  repoLabel.textContent  = (lang==='fr' ? 'Images importées' : 'Uploaded images');
  repoStatus.textContent = (lang==='fr' ? 'Aucune image importée' : 'No images uploaded');
}

let repoHandle = null;

/* IndexedDB for repo handle */
const DB_NAME='timer-handles', STORE='handles';
function withHandleStore(mode, fn){
  return new Promise((res, rej)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = ()=> req.result.createObjectStore(STORE);
    req.onerror = ()=> rej(req.error);
    req.onsuccess = ()=>{
      const db = req.result;
      const tx = db.transaction(STORE, mode);
      fn(tx.objectStore(STORE));
      tx.oncomplete = ()=> res();
      tx.onerror = ()=> rej(tx.error);
    };
  });
}
async function saveRepoHandle(handle){
  try{ await withHandleStore('readwrite', store => store.put(handle,'repo')); localStorage.setItem('hasRepo','1'); }catch(e){}
}
function getRepoHandle(){
  return new Promise((res)=>{
    const req = indexedDB.open(DB_NAME,1);
    req.onupgradeneeded = ()=> req.result.createObjectStore(STORE);
    req.onsuccess = ()=>{
      const db = req.result;
      const tx = db.transaction(STORE,'readonly');
      const store = tx.objectStore(STORE);
      const g = store.get('repo');
      g.onsuccess = async ()=>{
        const h = g.result || null;
        if(h && (await h.queryPermission?.({mode:'read'})) === 'granted'){ res(h); }
        else { res(null); }
      };
      g.onerror = ()=> res(null);
    };
    req.onerror = ()=> res(null);
  });
}

/* ---------- Picker Modal (shared) ---------- */
const pickerModal = document.getElementById('pickerModal');
const pickerGrid  = document.getElementById('pickerGrid');
const pickerTitle = document.getElementById('pickerTitle');
const pickerSub   = document.getElementById('pickerSub');
const closePickerBtn = document.getElementById('closePickerBtn');
const switchSourceBtn = document.getElementById('switchSourceBtn');
const autoFillBtn = document.getElementById('autoFillBtn');
const assignBtn = document.getElementById('assignBtn');
const openPictosBtn = document.getElementById('openPictosBtn');
const selectedSlots = Array.from(document.querySelectorAll('.selected .slot'));

const pickLibraryBtn = document.getElementById('pickLibraryBtn');
const pickPhotoBtn   = document.getElementById('pickPhotoBtn');
const uploadLibraryInput = document.getElementById('uploadLibraryInput');
const uploadPhotoInput   = document.getElementById('uploadPhotoInput');

let gridItems = [];

/* iPad slot cursor */
let nextSlot = 0;
function setCurrentSlot(i){
  nextSlot = ((i % 4) + 4) % 4;
  selectedSlots.forEach((s,idx)=>{
    if(idx===nextSlot) s.classList.add('active'); else s.classList.remove('active');
  });
}
function setSlotSrc(idx, src){
  const slot = selectedSlots[idx];
  slot.innerHTML = `<span class="badge">${idx+1}</span>` + (src ? `<img src="${src}" alt="" draggable="false" />` : '');
  if(!isIOS){ slot.setAttribute('draggable','true'); } else { slot.removeAttribute('draggable'); }
}
function placeInNextSlot(url){
  setSlotSrc(nextSlot, url);
  setCurrentSlot(nextSlot + 1);
}

/* Drag & drop inside slots (desktop unchanged) */
if(!isIOS){
  let dragFromIdx = null;
  selectedSlots.forEach(slot=>{
    slot.setAttribute('draggable','true');
    slot.addEventListener('dragstart', e=>{
      dragFromIdx = parseInt(slot.dataset.idx,10);
      e.dataTransfer.effectAllowed='move';
      e.dataTransfer.setData('text/x-slot', String(dragFromIdx));
    });
    slot.addEventListener('dragover', e=>{ e.preventDefault(); slot.classList.add('dragover'); });
    slot.addEventListener('dragleave', ()=> slot.classList.remove('dragover'));
    slot.addEventListener('drop', e=>{
      e.preventDefault(); slot.classList.remove('dragover');
      const toIdx = parseInt(slot.dataset.idx,10);

      const gridUrl = e.dataTransfer.getData('text/plain');
      if(gridUrl){ setSlotSrc(toIdx, gridUrl); return; }

      const fromStr = e.dataTransfer.getData('text/x-slot');
      const fromIdx = fromStr ? parseInt(fromStr,10) : dragFromIdx;
      if(Number.isInteger(fromIdx) && fromIdx!==toIdx){
        const srcA = selectedSlots[fromIdx].querySelector('img')?.src || null;
        const srcB = selectedSlots[toIdx].querySelector('img')?.src || null;
        setSlotSrc(fromIdx, srcB); setSlotSrc(toIdx, srcA);
      }
      dragFromIdx=null;
    });
    slot.addEventListener('dragend', ()=>{ dragFromIdx=null; selectedSlots.forEach(s=>s.classList.remove('dragover')); });
  });
}else{
  // iPad: tap to choose slot
  selectedSlots.forEach((slot)=>{
    addTap(slot, ()=>{ setCurrentSlot(parseInt(slot.dataset.idx,10)); });
  });
}

/* Modal helpers */
function openPickerModal(){ iosModalOpen = true; pickerModal.style.display='flex'; }
function closePickerModal(){
  pickerModal.style.display='none';
  iosModalOpen = false;
  pickerGrid.innerHTML='';
  for(const it of gridItems){ if(it.file && it.url) try{ URL.revokeObjectURL(it.url); }catch(_){} }
  gridItems = [];
  ensureReturnToFullscreen();
}

/* Choose repo */
async function chooseRepository(){
  try{
    const handle = await window.showDirectoryPicker();
    repoHandle = handle;
    const lang = getLang();
    if (repoStatus) {
      repoStatus.textContent = (lang==='fr' ? `Dossier : ${handle.name}` : `Repository: ${handle.name}`);
    }
    await saveRepoHandle(handle);
    if (pickerModal.style.display !== 'flex') openPickerModal();
    await populateFromRepo();
    return true;
  }catch(e){ return false; }
}

/* General upload fallback (mobile) */
uploadInput.addEventListener('change', ()=>{
  pickerGrid.innerHTML=''; gridItems = [];
  appendFilesToGrid(uploadInput.files);
  const lang = getLang();
  if (pickerModal.style.display !== 'flex') openPickerModal();
  pickerTitle.textContent = (lang==='fr' ? 'Sélectionner des images' : 'Select images');
  pickerSub.textContent = (lang==='fr' ? '(importées)' : '(uploaded)') + (isIOS ? (lang==='fr' ? ' — iPad : touchez pour remplir 1→4' : ' — iPad: tap to fill 1→4') : '');
  switchSourceBtn.classList.remove('hidden');
  setCurrentSlot(0);
});

/* Add files ADDITIVELY to grid */
function appendFilesToGrid(fileList){
  if(!fileList || !fileList.length) return;
  const frag = document.createDocumentFragment();

  for (const file of Array.from(fileList)){
    if(!file.type.startsWith('image/')) continue;
    const url = URL.createObjectURL(file);
    gridItems.push({ name:file.name, file, url });

    const card = document.createElement('div');
    card.className='thumb';
    card.innerHTML = `<img src="${url}" alt="${file.name}"><span>${file.name}</span>`;

    if(!isIOS){
      card.draggable = true;
      card.addEventListener('dragstart', (e)=>{ card.classList.add('dragging'); e.dataTransfer.effectAllowed='copy'; e.dataTransfer.setData('text/plain', url); });
      card.addEventListener('dragend', ()=> card.classList.remove('dragging'));
    }else{
      card.draggable = false;
      addTap(card, ()=>{ placeInNextSlot(url); });
    }
    frag.appendChild(card);
  }
  pickerGrid.appendChild(frag);
}

/* iPad modal buttons */
addTap(pickLibraryBtn, ()=>{ if(!isIOS) return; uploadLibraryInput.value = ''; uploadLibraryInput.click(); });
uploadLibraryInput.addEventListener('change', ()=>{ if(!isIOS) return; appendFilesToGrid(uploadLibraryInput.files); setCurrentSlot(nextSlot); });

addTap(pickPhotoBtn, ()=>{ if(!isIOS) return; uploadPhotoInput.value = ''; uploadPhotoInput.click(); });
uploadPhotoInput.addEventListener('change', ()=>{ if(!isIOS) return; appendFilesToGrid(uploadPhotoInput.files); setCurrentSlot(nextSlot); });

/* Iterate image files */
async function* iterImages(dirHandle){
  for await (const entry of dirHandle.values()){
    if(entry.kind !== 'file') continue;
    if(!/\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(entry.name)) continue;
    yield entry;
  }
}

/* Populate grid from repo */
async function populateFromRepo(){
  const lang = getLang();
  pickerTitle.textContent = (lang==='fr' ? 'Sélectionner des images' : 'Select images');
  const hint = isIOS ? (lang==='fr' ? ' — iPad : touchez pour remplir 1→4' : ' — iPad: tap to fill 1→4') : '';
  pickerSub.textContent = repoHandle ? `(${repoHandle.name})${hint}` : hint;
  switchSourceBtn.classList.remove('hidden');
  pickerGrid.innerHTML=''; gridItems = [];
  if(!repoHandle){
    const p = document.createElement('div'); p.style.padding='10px'; p.style.opacity='.85';
    p.textContent = (lang==='fr' ? 'Aucun dossier sélectionné. Cliquez « Changer de dossier ».' : 'No folder selected. Click “Change Folder”.');
    pickerGrid.appendChild(p); return;
  }
  const frag = document.createDocumentFragment();
  for await (const entry of iterImages(repoHandle)){
    const file = await entry.getFile();
    const url = URL.createObjectURL(file);
    gridItems.push({ name: entry.name, url, file });

    const card = document.createElement('div');
    card.className='thumb';
    card.innerHTML = `<img src="${url}" alt="${entry.name}"><span>${entry.name}</span>`;

    if(!isIOS){
      card.draggable = true;
      card.addEventListener('dragstart', (e)=>{ card.classList.add('dragging'); e.dataTransfer.effectAllowed='copy'; e.dataTransfer.setData('text/plain', url); });
      card.addEventListener('dragend', ()=> card.classList.remove('dragging'));
    }else{
      card.draggable = false;
      addTap(card, ()=>{ placeInNextSlot(url); });
    }
    frag.appendChild(card);
  }
  if(!frag.childNodes.length){
    const p = document.createElement('div'); p.style.padding='10px'; p.style.opacity='.85';
    p.textContent = (lang==='fr' ? 'Aucune image dans ce dossier.' : 'No images in this folder.');
    pickerGrid.appendChild(p);
  }else{ pickerGrid.appendChild(frag); }

  setCurrentSlot(0);
}

/* Populate grid from pictogram index.json */
async function populateFromPictos(){
  const lang = getLang();
  pickerTitle.textContent = (lang==='fr' ? 'Sélectionner des pictogrammes' : 'Select pictograms');
  const hint = isIOS ? (lang==='fr' ? ' — iPad : touchez pour remplir 1→4' : ' — iPad: tap to fill 1→4') : '';
  pickerSub.textContent = '(../../pictos/)' + hint;
  switchSourceBtn.classList.add('hidden');
  pickerGrid.innerHTML=''; gridItems = [];

  try{
    const resp = await fetch('../../pictos/index.json', { cache:'no-store' });
    if(!resp.ok) throw new Error('HTTP '+resp.status);
    const data = await resp.json();
    const base = new URL('.', resp.url).pathname;

    const makeCard = (url, name)=>{
      const card = document.createElement('div');
      card.className='thumb';
      card.innerHTML = `<img src="${url}" alt="${name}"><span>${name}</span>`;
      if(!isIOS){
        card.draggable = true;
        card.addEventListener('dragstart', (e)=>{ card.classList.add('dragging'); e.dataTransfer.effectAllowed='copy'; e.dataTransfer.setData('text/plain', url); });
        card.addEventListener('dragend', ()=> card.classList.remove('dragging'));
      }else{
        card.draggable = false;
        addTap(card, ()=>{ placeInNextSlot(url); });
      }
      return card;
    };

    const frag = document.createDocumentFragment();

    if (data && data.categories && typeof data.categories === 'object'){
      for (const [cat, files] of Object.entries(data.categories)){
        const hdr = document.createElement('div');
        hdr.textContent = cat;
        hdr.style.cssText = 'grid-column:1/-1;font-weight:700;opacity:.9;padding:.25rem 0;';
        frag.appendChild(hdr);

        (files||[]).forEach(f=>{
          const url = f.startsWith('http') || f.startsWith('/') ? f : (base + f);
          const name = f.split('/').pop();
          gridItems.push({name,url});
          frag.appendChild(makeCard(url, name));
        });
      }
    } else if (Array.isArray(data?.files)){
      (data.files).forEach(f=>{
        const url = f.startsWith('http') || f.startsWith('/') ? f : (base + f);
        const name = f.split('/').pop();
        gridItems.push({name,url});
        frag.appendChild(makeCard(url, name));
      });
    } else {
      const p=document.createElement('div');
      p.style.padding='10px'; p.style.opacity='.85';
      p.textContent = (lang==='fr' ? 'index.json est vide ou invalide.' : 'index.json is empty or invalid.');
      pickerGrid.appendChild(p);
      setCurrentSlot(0);
      return;
    }

    pickerGrid.appendChild(frag);
  }catch(err){
    const p=document.createElement('div');
    p.textContent = (lang==='fr' ? 'Impossible de charger ../../pictos/index.json' : 'Could not load ../../pictos/index.json');
    p.style.padding='10px'; p.style.opacity='.85';
    pickerGrid.appendChild(p);
  }

  setCurrentSlot(0);
}

/* Auto-fill top 4 */
function autoFillTop4(){
  const top4 = gridItems.slice(0,4);
  for(let i=0;i<4;i++){ setSlotSrc(i, top4[i]?.url || null); }
  setCurrentSlot(0);
}

/* Prefer radial when images chosen */
function ensureRadialIfImagesChosen(){
  const any = imgs.some(Boolean);
  if(any && (specialMode === 'none')){
    specialMode = 'radial';
    const sel = document.getElementById('specialMode'); if(sel) sel.value = 'radial';
  }
}

/* Assign selected slots into imgs[] */
function assignFromSlots(){
  const toLoad = [];
  for(let i=0;i<4;i++){
    const src = selectedSlots[i].querySelector('img')?.src || null;
    if(!src){ imgs[i]=null; continue; }
    toLoad.push(new Promise(res=>{
      const im = new Image();
      im.onload = ()=>{ imgs[i]=im; res(); };
      im.src = src;
    }));
  }
  Promise.all(toLoad).then(()=>{
    ensureRadialIfImagesChosen();
    saveLastImages();
    draw();
    closePickerModal();
  });
}

/* Clear slots */
function clearSlots(){
  for(let i=0;i<4;i++) setSlotSrc(i, null);
  setCurrentSlot(0);
}

/* Openers */
setRepoBtn.addEventListener('click', async ()=>{
  if(supportsDirPicker){
    if(!repoHandle){
      const ok = await chooseRepository(); if(!ok) return;
    }else{
      if (pickerModal.style.display !== 'flex') openPickerModal();
      await populateFromRepo();
    }
  }else{
    uploadInput.click();
  }
});
addTap(openPictosBtn, ()=>{ openPickerModal(); populateFromPictos(); });

/* Modal controls */
addTap(closePickerBtn, closePickerModal);
addTap(switchSourceBtn, async ()=>{
  if(supportsDirPicker){
    const ok = await chooseRepository();
    if(ok){
      if(pickerModal.style.display!=='flex') openPickerModal();
      await populateFromRepo();
    }
  }else{
    uploadInput.click();
  }
});
addTap(autoFillBtn, autoFillTop4);
addTap(assignBtn, assignFromSlots);
addTap(clearSlotsBtn, clearSlots);

/* Try restore repo on boot (desktop path intact) */
(async ()=>{
  if (navigator.storage?.persist) { try{ await navigator.storage.persist(); }catch(e){} }
  if(!supportsDirPicker) return;
  const saved = await getRepoHandle();
  if(saved){
    const perm = await saved.requestPermission?.({mode:'read'});
    if(perm === 'granted'){
      repoHandle = saved;
      const lang = getLang();
      if (repoStatus) {
        repoStatus.textContent = (lang==='fr' ? `Dossier : ${repoHandle.name}` : `Repository: ${repoHandle.name}`);
      }
    }
  }
})();

/* ====== START/OVERLAY BEHAVIOR ====== */
function startApp(){
  try{ requestFS(); }catch(_){}       // iPad may ignore; fine
  overlay.style.display='none';
  resizeCanvas();
  startTimerAtFullDial();
}
addTap(enterBtn, ()=>{ startApp(); });

overlay.addEventListener('click', e => { e.stopPropagation(); }, {passive:false});

/* Startup adjustments */
window.addEventListener('DOMContentLoaded', ()=>{
  if(isIOS){
    // iPad: smaller default images now, and bigger ceiling still available
    LAYOUT.imgBase = IOS_IMGBASE_DEFAULT;
    const r = document.getElementById('imgSizeRange');
    r.max = '0.95';
    r.value = String(LAYOUT.imgBase);

    // Replace selects with custom pickers (keeps fullscreen)
    createSelectProxy(
      document.getElementById('dialSelect'),
      document.getElementById('dialProxy'),
      getLang()==='fr' ? 'Cadran' : 'Dial'
    );
    createSelectProxy(
      document.getElementById('specialMode'),
      document.getElementById('modeProxy'),
      getLang()==='fr' ? 'Mode' : 'Mode'
    );
    createSelectProxy(
      document.getElementById('alarmSelect'),
      document.getElementById('alarmProxy'),
      getLang()==='fr' ? 'Son d’alarme' : 'Alarm sound'
    );
  }else{
    // Hide iPad-only buttons on desktop
    document.getElementById('pickLibraryBtn')?.classList.add('hidden');
    document.getElementById('pickPhotoBtn')?.classList.add('hidden');
    document.getElementById('dialProxy')?.classList.add('hidden');
    document.getElementById('modeProxy')?.classList.add('hidden');
    document.getElementById('alarmProxy')?.classList.add('hidden');
  }
  draw();
});

/* Reassert fullscreen after lifecycle changes (iPad only) */
if(isIOS){
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') tryKeepFullscreen(200); });
  window.addEventListener('focus', ()=>{ tryKeepFullscreen(200); });
  document.addEventListener('fullscreenchange', ()=>{ if(!document.fullscreenElement) tryKeepFullscreen(300); });
}

/* Drag & input bindings */
canvas.addEventListener('mousedown',startDrag);
canvas.addEventListener('touchstart',startDrag,{passive:false});
window.addEventListener('mousemove',dragMove,{passive:false});
window.addEventListener('touchmove',dragMove,{passive:false});
window.addEventListener('mouseup',endDrag);
window.addEventListener('touchend',endDrag);
window.addEventListener('resize',resizeCanvas);

/* RAF loop for pulse */
function rafLoop(ts){ nowMs = ts || 0; draw(); requestAnimationFrame(rafLoop); }
requestAnimationFrame(rafLoop);

/* Defaults */
dialMax = 60;
remainingSeconds = 0;
setPauseLabel(false);
document.getElementById('colorProxy').style.background = timerColor;
document.getElementById('colorPicker').value = timerColor;
resizeCanvas();
</script>

<!-- Translation Script for Static Elements -->
<script src="../../js/translationonly.js"></script>
</body>
</html>
