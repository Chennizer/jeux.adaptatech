<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Eyegaze — Sensory Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    body.light { background:#fff; color:#000; }
    body.dark  { background:#000; color:#fff; }

    html, body { height:100%; margin:0; overflow:hidden; }
    canvas#c { position:fixed; inset:0; display:none; }

    #game-options.modal {
      display:flex; align-items:center; justify-content:center;
    }

    .value-badge{
      display:inline-block; min-width:2ch; padding:2px 6px; border-radius:8px;
      background:rgba(255,255,255,.12); color:#0b1a18; font-variant-numeric:tabular-nums
    }
    body.light .value-badge{ background:rgba(0,0,0,.08); color:inherit; }
    body.playing,
    body.playing * {
    cursor: none !important;
    }

    .series-option-block {
      display: grid;
      row-gap: 8px;
      justify-items: start;
    }
    .series-summary-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-left: 26px;
    }
    .series-summary-text {
      font-size: 0.9rem;
      color: rgba(255,255,255,0.8);
    }
    body.light .series-summary-text {
      color: rgba(0,0,0,0.7);
    }
    .series-config-link {
      background: none;
      border: 1px solid #009688;
      color: #009688;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .series-config-link:hover,
    .series-config-link:focus {
      background: #009688;
      color: #fff;
      outline: none;
    }
    body.dark .series-config-link {
      color: #4ad9c4;
      border-color: #4ad9c4;
    }
    body.dark .series-config-link:hover,
    body.dark .series-config-link:focus {
      background: #4ad9c4;
      color: #021819;
    }

    .series-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 32px 24px;
      background: rgba(0,0,0,0.65);
      z-index: 1000;
    }
    .series-modal.open {
      display: flex;
    }
    .series-modal-panel {
      width: min(960px, 95vw);
      max-height: 92vh;
      overflow: hidden;
      background: #04131a;
      color: #f2f8f9;
      border-radius: 16px;
      box-shadow: 0 18px 42px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 24px;
      outline: none;
    }
    body.light .series-modal-panel {
      background: #ffffff;
      color: #04131a;
      box-shadow: 0 18px 42px rgba(0,0,0,0.25);
    }
    .series-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .series-modal-header h3 {
      margin: 0;
      font-size: 1.6rem;
    }
    .series-close {
      background: none;
      border: none;
      color: inherit;
      font-size: 1.6rem;
      cursor: pointer;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .series-close:hover,
    .series-close:focus {
      background: rgba(255,255,255,0.12);
      outline: none;
    }
    body.light .series-close:hover,
    body.light .series-close:focus {
      background: rgba(0,0,0,0.08);
    }
    .series-modal-intro {
      margin: 0;
      font-size: 0.95rem;
      opacity: 0.85;
    }
    .series-modal-grid {
      display: flex;
      gap: 24px;
      flex: 1;
      min-height: 320px;
    }
    .series-column-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 0;
    }
    .series-column-title {
      margin: 0;
      font-size: 1.05rem;
    }
    .series-column {
      flex: 1;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
      position: relative;
    }
    body.light .series-column {
      background: rgba(0,0,0,0.05);
      border-color: rgba(0,0,0,0.12);
    }
    .series-column[data-drop-active="true"] {
      box-shadow: 0 0 0 2px rgba(0,150,136,0.45);
    }
    .series-column[data-empty="true"]::before {
      content: attr(data-empty-text);
      position: absolute;
      inset: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 0.9rem;
      color: rgba(255,255,255,0.6);
      pointer-events: none;
    }
    body.light .series-column[data-empty="true"]::before {
      color: rgba(0,0,0,0.55);
    }
    .series-scene {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: inherit;
      font-size: 0.95rem;
      font-weight: 600;
      padding: 10px 12px;
      border-radius: 10px;
      cursor: grab;
      transition: transform 0.15s, background 0.2s, border-color 0.2s;
    }
    .series-scene:focus {
      outline: 2px solid #009688;
      outline-offset: 2px;
    }
    body.dark .series-scene:focus {
      outline-color: #4ad9c4;
    }
    .series-scene:active {
      cursor: grabbing;
      transform: scale(0.98);
    }
    .series-scene.dragging {
      opacity: 0.5;
    }
    body.light .series-scene {
      background: rgba(0,0,0,0.04);
      border-color: rgba(0,0,0,0.15);
    }
    .series-drop-indicator {
      height: 4px;
      border-radius: 999px;
      background: rgba(0,150,136,0.8);
    }
    body.light .series-drop-indicator {
      background: rgba(0,121,107,0.8);
    }
    .series-modal-footer {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .series-duration-label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-weight: 600;
    }
    .series-duration-label .styled-select {
      min-width: 150px;
    }
    .series-footer-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .button-secondary {
      background: transparent;
      color: #009688;
      border: 2px solid #009688;
    }
    .button-secondary:hover,
    .button-secondary:focus {
      background: #009688;
      color: #fff;
    }
    body.dark .button-secondary {
      color: #4ad9c4;
      border-color: #4ad9c4;
    }
    body.dark .button-secondary:hover,
    body.dark .button-secondary:focus {
      background: #4ad9c4;
      color: #031111;
    }
    @media (max-width: 900px) {
      .series-modal-grid {
        flex-direction: column;
        min-height: 0;
      }
      .series-column {
        min-height: 160px;
        max-height: 40vh;
      }
      .series-summary-row {
        margin-left: 0;
      }
    }
  </style>
</head>
<body class="dark">
  <canvas id="c"></canvas>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title">Laboratoire Sensoriel</h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="muteSFX">
              <span>Désactiver les sons</span>
            </label>
          </div>

          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="disablePause">
              <span>Désactiver la pause auto (5 s + bords)</span>
            </label>
          </div>

          <div class="option-item">
            <label for="sfxVol" class="teal-label">
              <span>Volume des sons:&nbsp;</span>
              <span id="sfxVolVal" class="value-badge">50</span>
            </label>
            <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="themeSelect" class="teal-label label-block">Mode</label>
            <select id="themeSelect" class="styled-select">
              <option value="light">Clair</option>
              <option value="dark" selected>Sombre</option>
            </select>
          </div>

          <div class="option-item">
            <label for="sceneSelect" class="teal-label label-block">Scène</label>
            <select id="sceneSelect" class="styled-select">
              <option value="aurora">Aurore</option>
              <option value="ripples">Eau</option>
              <option value="fireworks" selected>Feux d’artifice</option>
              <option value="kaleido">Kaleido</option>
              <option value="fireflies">Lucioles</option>
              <option value="confetti">Confetti</option>
              <option value="nebula">Nébuleuse</option>
              <option value="jelly">Sphères</option>
              <option value="snow">Neige</option>
              <option value="sand">Sable</option>
              <option value="magnet">Aimant</option>
              <option value="glass">Vitrail</option>
              <option value="streamers">Soie</option>
              <option value="laserharp">Laser</option>
              <option value="bubblepop">Bulles</option>
              <option value="galaxy">Galaxie</option>
            </select>
          </div>

          <div class="option-item series-option-block">
            <label class="teal-label">
              <input type="checkbox" id="seriesToggle">
              <span>Séries</span>
            </label>
            <div id="seriesSummaryRow" class="series-summary-row" hidden>
              <span id="seriesSummaryText" class="series-summary-text" aria-live="polite"></span>
              <button type="button" id="seriesConfigure" class="series-config-link">Configurer</button>
            </div>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="intensitySlider" class="teal-label">
              <span>Intensité:&nbsp;</span>
              <span id="intensityVal" class="value-badge">50</span>
            </label>
            <input type="range" id="intensitySlider" class="styled-slider" min="0" max="100" value="50">
          </div>

          <div class="option-item">
            <label for="sizeSlider" class="teal-label">
              <span>Taille:&nbsp;</span>
              <span id="sizeVal" class="value-badge">105</span>
            </label>
            <input type="range" id="sizeSlider" class="styled-slider" min="10" max="200" value="105">
          </div>

          <div class="option-item">
            <label for="trailSlider" class="teal-label">
              <span>Traînée:&nbsp;</span>
              <span id="trailVal" class="value-badge">50</span>
            </label>
            <input type="range" id="trailSlider" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button">Commencer</button>
    </div>
  </div>

  <div id="seriesModal" class="series-modal" role="dialog" aria-modal="true" aria-labelledby="seriesModalTitle" aria-hidden="true">
    <div class="series-modal-panel" tabindex="-1">
      <div class="series-modal-header">
        <h3 id="seriesModalTitle">Créer une série</h3>
        <button type="button" id="seriesModalClose" class="series-close" aria-label="Fermer la fenêtre">×</button>
      </div>
      <p class="series-modal-intro">Faites glisser les scènes vers la colonne de droite pour définir l’ordre de lecture. Glissez-les vers la gauche ou double-cliquez pour les retirer.</p>
      <div class="series-modal-grid">
        <div class="series-column-wrapper">
          <h4 class="series-column-title">Scènes disponibles</h4>
          <div id="seriesAvailable" class="series-column" data-empty-text=""></div>
        </div>
        <div class="series-column-wrapper">
          <h4 class="series-column-title">Votre sélection</h4>
          <div id="seriesSelected" class="series-column" data-empty-text="Déposez des scènes ici"></div>
        </div>
      </div>
      <div class="series-modal-footer">
        <label for="seriesDuration" class="series-duration-label">
          Durée par scène
          <select id="seriesDuration" class="styled-select">
            <option value="30">30 s</option>
            <option value="60" selected>1 min</option>
            <option value="90">1 min 30</option>
            <option value="120">2 min</option>
            <option value="150">2 min 30</option>
            <option value="180">3 min</option>
            <option value="210">3 min 30</option>
            <option value="240">4 min</option>
            <option value="270">4 min 30</option>
            <option value="300">5 min</option>
          </select>
        </label>
        <div class="series-footer-actions">
          <button type="button" id="seriesClear" class="button button-secondary">Tout effacer</button>
          <button type="button" id="seriesModalDone" class="button">Terminer</button>
        </div>
      </div>
    </div>
  </div>

  <script src="../../js/eyegaze-menu.js"></script>

  <script>
  const startButton = document.getElementById('startButton');
  const themeSel  = document.getElementById('themeSelect');
  const sceneSel  = document.getElementById('sceneSelect');

  const muteSFX   = document.getElementById('muteSFX');
  const sfxVol    = document.getElementById('sfxVol');
  const sfxVolVal = document.getElementById('sfxVolVal');

  const disablePause = document.getElementById('disablePause');
  const PAUSE_CFG = { enabled: true };

  const intSlider = document.getElementById('intensitySlider');
  const sizeSlider= document.getElementById('sizeSlider');
  const trailSlider= document.getElementById('trailSlider');
  const intVal    = document.getElementById('intensityVal');
  const sizeVal   = document.getElementById('sizeVal');
  const trailVal  = document.getElementById('trailVal');

  const seriesToggle     = document.getElementById('seriesToggle');
  const seriesModal      = document.getElementById('seriesModal');
  const seriesModalPanel = seriesModal ? seriesModal.querySelector('.series-modal-panel') : null;
  const seriesModalClose = document.getElementById('seriesModalClose');
  const seriesModalDone  = document.getElementById('seriesModalDone');
  const seriesAvailable  = document.getElementById('seriesAvailable');
  const seriesSelected   = document.getElementById('seriesSelected');
  const seriesDuration   = document.getElementById('seriesDuration');
  const seriesClear      = document.getElementById('seriesClear');
  const seriesSummaryRow = document.getElementById('seriesSummaryRow');
  const seriesSummaryText= document.getElementById('seriesSummaryText');
  const seriesConfigure  = document.getElementById('seriesConfigure');

  const SCENE_LABELS = new Map(Array.from(sceneSel?.options || []).map(opt => [opt.value, opt.textContent.trim()]));

  let currentSceneId = sceneSel.value;
  const seriesConfig = {
    enabled: false,
    playlist: [],
    duration: (parseInt(seriesDuration?.value, 10) || 60) * 1000,
  };
  const seriesState = { active: false, index: 0, timer: 0 };

  if (seriesSelected) {
    seriesSelected.dataset.empty = 'true';
  }

  const dropIndicator = document.createElement('div');
  dropIndicator.className = 'series-drop-indicator';

  let dragContext = null;

  function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    const parts = [];
    if (mins > 0) parts.push(`${mins} min${mins > 1 ? 's' : ''}`);
    if (secs > 0) parts.push(`${secs} s`);
    return parts.join(' ') || '0 s';
  }

  function setDropActive(container, active) {
    if (!container) return;
    if (active) {
      container.setAttribute('data-drop-active', 'true');
    } else {
      container.removeAttribute('data-drop-active');
    }
  }

  function clearDropIndicator() {
    if (dropIndicator.parentElement) {
      dropIndicator.parentElement.removeChild(dropIndicator);
    }
  }

  function refreshSelectedEmptyState() {
    if (!seriesSelected) return;
    const hasItems = seriesSelected.querySelector('[data-role="selected"]');
    seriesSelected.dataset.empty = hasItems ? 'false' : 'true';
  }

  function updateSeriesSummary() {
    if (!seriesSummaryRow || !seriesSummaryText) return;
    if (!seriesConfig.enabled) {
      seriesSummaryRow.hidden = true;
      if (seriesConfigure) seriesConfigure.hidden = true;
      return;
    }
    const count = seriesConfig.playlist.length;
    const durationSeconds = Math.round(seriesConfig.duration / 1000);
    const baseLabel = count === 0
      ? 'Aucune scène sélectionnée'
      : `${count} scène${count > 1 ? 's' : ''}`;
    seriesSummaryText.textContent = `${baseLabel} • ${formatDuration(durationSeconds)}`;
    seriesSummaryRow.hidden = false;
    if (seriesConfigure) seriesConfigure.hidden = false;
  }

  function updateSeriesSelection() {
    if (!seriesSelected) return;
    seriesConfig.playlist = Array.from(seriesSelected.querySelectorAll('[data-role="selected"]')).map(btn => btn.dataset.scene);
    refreshSelectedEmptyState();
    updateSeriesSummary();
  }

  function attachDragHandlers(btn) {
    btn.addEventListener('dragstart', (event) => {
      dragContext = {
        scene: btn.dataset.scene,
        source: btn.dataset.role,
        element: btn,
        label: SCENE_LABELS.get(btn.dataset.scene) || btn.textContent,
      };
      btn.classList.add('dragging');
      if (event.dataTransfer) {
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', btn.dataset.scene);
      }
    });
    btn.addEventListener('dragend', () => {
      btn.classList.remove('dragging');
      dragContext = null;
      clearDropIndicator();
      setDropActive(seriesSelected, false);
      setDropActive(seriesAvailable, false);
    });
    if (btn.dataset.role === 'selected') {
      btn.addEventListener('dblclick', () => {
        btn.remove();
        updateSeriesSelection();
      });
      btn.addEventListener('keydown', (ev) => {
        if (ev.key === 'Delete' || ev.key === 'Backspace') {
          ev.preventDefault();
          btn.remove();
          updateSeriesSelection();
        }
      });
    }
  }

  function createSceneButton(sceneId, label, role) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'series-scene';
    btn.textContent = label;
    btn.dataset.scene = sceneId;
    btn.dataset.role = role;
    btn.draggable = true;
    attachDragHandlers(btn);
    return btn;
  }

  function addSceneToSelection(sceneId, label) {
    if (!seriesSelected) return;
    const btn = createSceneButton(sceneId, label, 'selected');
    seriesSelected.appendChild(btn);
    updateSeriesSelection();
    btn.focus();
    seriesSelected.scrollTop = seriesSelected.scrollHeight;
  }

  function populateAvailableScenes() {
    if (!seriesAvailable) return;
    seriesAvailable.innerHTML = '';
    SCENE_LABELS.forEach((label, value) => {
      const btn = createSceneButton(value, label, 'available');
      btn.addEventListener('click', () => addSceneToSelection(value, label));
      seriesAvailable.appendChild(btn);
    });
    seriesAvailable.dataset.empty = seriesAvailable.children.length ? 'false' : 'true';
  }

  function getDropAfterElement(container, clientY) {
    const items = Array.from(container.querySelectorAll('[data-role="selected"]:not(.dragging)'));
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const rect = item.getBoundingClientRect();
      if (clientY <= rect.top + rect.height / 2) {
        return item;
      }
    }
    return null;
  }

  function updateDropIndicator(container, reference) {
    if (!container) return;
    if (!container.contains(dropIndicator)) {
      container.appendChild(dropIndicator);
    }
    if (reference) {
      container.insertBefore(dropIndicator, reference);
    } else {
      container.appendChild(dropIndicator);
    }
  }

  function setCurrentScene(sceneId, opts = {}) {
    currentSceneId = sceneId;
    if (!opts.fromSeries && sceneSel) {
      sceneSel.value = sceneId;
    }
    if (typeof MUSIC !== 'undefined' && MUSIC && typeof MUSIC.setScene === 'function') {
      MUSIC.setScene(sceneId);
    }
  }

  function beginSeriesPlayback() {
    if (!seriesConfig.playlist.length) return;
    seriesState.active = true;
    seriesState.index = 0;
    seriesState.timer = seriesConfig.duration;
    setCurrentScene(seriesConfig.playlist[0], { fromSeries: true });
  }

  function advanceSeriesScene() {
    if (!seriesConfig.playlist.length) return;
    seriesState.index = (seriesState.index + 1) % seriesConfig.playlist.length;
    seriesState.timer = seriesState.timer + seriesConfig.duration;
    if (seriesState.timer <= 0) {
      seriesState.timer = seriesConfig.duration;
    }
    setCurrentScene(seriesConfig.playlist[seriesState.index], { fromSeries: true });
  }

  function isSeriesModalOpen() {
    return !!(seriesModal && seriesModal.classList.contains('open'));
  }

  function openSeriesModal() {
    if (!seriesModal) return;
    seriesModal.classList.add('open');
    seriesModal.setAttribute('aria-hidden', 'false');
    requestAnimationFrame(() => {
      seriesModalPanel?.focus();
    });
  }

  function closeSeriesModal() {
    if (!seriesModal) return;
    seriesModal.classList.remove('open');
    seriesModal.setAttribute('aria-hidden', 'true');
    clearDropIndicator();
    setDropActive(seriesSelected, false);
    setDropActive(seriesAvailable, false);
  }

  populateAvailableScenes();
  refreshSelectedEmptyState();
  updateSeriesSummary();

  if (seriesSelected) {
    seriesSelected.addEventListener('dragenter', (event) => {
      if (!dragContext) return;
      event.preventDefault();
      setDropActive(seriesSelected, true);
    });
    seriesSelected.addEventListener('dragover', (event) => {
      if (!dragContext) return;
      event.preventDefault();
      const reference = getDropAfterElement(seriesSelected, event.clientY);
      updateDropIndicator(seriesSelected, reference);
    });
    seriesSelected.addEventListener('dragleave', (event) => {
      if (!dragContext) return;
      const related = event.relatedTarget;
      if (related && seriesSelected.contains(related)) return;
      setDropActive(seriesSelected, false);
      clearDropIndicator();
    });
    seriesSelected.addEventListener('drop', (event) => {
      if (!dragContext) return;
      event.preventDefault();
      const reference = getDropAfterElement(seriesSelected, event.clientY);
      let item;
      if (dragContext.source === 'selected') {
        item = dragContext.element;
      } else {
        const label = dragContext.label || (SCENE_LABELS.get(dragContext.scene) || dragContext.scene);
        item = createSceneButton(dragContext.scene, label, 'selected');
      }
      if (reference) {
        seriesSelected.insertBefore(item, reference);
      } else {
        seriesSelected.appendChild(item);
      }
      updateSeriesSelection();
      if (dragContext.source !== 'selected') {
        item.focus();
        seriesSelected.scrollTop = seriesSelected.scrollHeight;
      }
      setDropActive(seriesSelected, false);
      clearDropIndicator();
    });
  }

  if (seriesAvailable) {
    seriesAvailable.addEventListener('dragenter', (event) => {
      if (!dragContext) return;
      event.preventDefault();
      setDropActive(seriesAvailable, true);
    });
    seriesAvailable.addEventListener('dragover', (event) => {
      if (!dragContext) return;
      event.preventDefault();
    });
    seriesAvailable.addEventListener('dragleave', (event) => {
      if (!dragContext) return;
      const related = event.relatedTarget;
      if (related && seriesAvailable.contains(related)) return;
      setDropActive(seriesAvailable, false);
    });
    seriesAvailable.addEventListener('drop', (event) => {
      if (!dragContext) return;
      event.preventDefault();
      if (dragContext.source === 'selected') {
        dragContext.element.remove();
        updateSeriesSelection();
      }
      setDropActive(seriesAvailable, false);
    });
  }

  seriesClear?.addEventListener('click', () => {
    if (!seriesSelected) return;
    seriesSelected.innerHTML = '';
    updateSeriesSelection();
  });

  seriesDuration?.addEventListener('change', () => {
    seriesConfig.duration = (parseInt(seriesDuration.value, 10) || 60) * 1000;
    updateSeriesSummary();
  });

  seriesToggle?.addEventListener('change', () => {
    seriesConfig.enabled = seriesToggle.checked;
    if (sceneSel) sceneSel.disabled = seriesConfig.enabled;
    if (seriesConfig.enabled) {
      openSeriesModal();
    } else {
      closeSeriesModal();
      seriesState.active = false;
      seriesState.timer = 0;
      seriesState.index = 0;
      currentSceneId = sceneSel.value;
    }
    updateSeriesSummary();
  });

  seriesConfigure?.addEventListener('click', () => {
    openSeriesModal();
  });

  seriesModalClose?.addEventListener('click', () => {
    closeSeriesModal();
  });
  seriesModalDone?.addEventListener('click', () => {
    closeSeriesModal();
  });
  seriesModal?.addEventListener('click', (event) => {
    if (event.target === seriesModal) {
      closeSeriesModal();
    }
  });
  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && isSeriesModalOpen()) {
      event.preventDefault();
      closeSeriesModal();
      seriesToggle?.focus();
    }
  });

  function reflectSliders(){
    sfxVolVal.textContent = sfxVol.value;
    intVal.textContent = intSlider.value;
    sizeVal.textContent = sizeSlider.value;
    trailVal.textContent = trailSlider.value;
  }
  [sfxVol,intSlider,sizeSlider,trailSlider].forEach(el=>el.addEventListener('input', reflectSliders));
  reflectSliders();

  function applyTheme(){
    document.body.classList.remove('light','dark');
    document.body.classList.add(themeSel.value === 'light' ? 'light' : 'dark');
  }
  themeSel.addEventListener('change', applyTheme);
  applyTheme();

  // NOTE: scene change handler moved below, after MUSIC is defined

  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d', { alpha:false });
  let W = innerWidth, H = innerHeight;
  cvs.width = W; cvs.height = H;

  // ---- Dead border + idle pause state ----
  // Hoisted to avoid TDZ when updatePauseGuard() runs before original declaration
  let paused = false;

  let borderPx = Math.max(1, Math.round(innerWidth * 0.01)); // ~1vw
  let edgeEnteredAt = null;

  function updateBorder(){
    borderPx = PAUSE_CFG.enabled ? Math.max(1, Math.round(innerWidth * 0.01)) : 0;
  }

  function inActiveArea(x, y){
    return x >= borderPx && x <= (W - borderPx) && y >= borderPx && y <= (H - borderPx);
  }

  function updatePauseGuard(){
    updateBorder();
    if (!PAUSE_CFG.enabled){
      paused = false;
      edgeEnteredAt = null;
    }
  }

  function recomputePaused(){
    // When disabled, never pause
    if (!PAUSE_CFG.enabled){
      paused = false;
      edgeEnteredAt = null;
      return;
    }

    const t = performance.now();

    // Idle pause: 5s of no movement anywhere
    const idle = (t - lastMoveT) >= 5000;

    // Edge logic with 3s grace
    const atEdge = !inActiveArea(mouse.x, mouse.y);

    if (atEdge) {
      if (edgeEnteredAt === null) edgeEnteredAt = t;
    } else {
      edgeEnteredAt = null;
    }

    const edgeGraceElapsed = edgeEnteredAt !== null && (t - edgeEnteredAt) >= 3000; // 3s

    const newPaused = idle || edgeGraceElapsed;

    if (newPaused !== paused){
      paused = newPaused;
      // Optional: clearToBg(true);

      // NEW: hard-silence Kaleido bed immediately on pause
      if (paused && typeof KALEIDO_SND !== 'undefined' && KALEIDO_SND.silenceNow){
        KALEIDO_SND.silenceNow();
      }
    }
  }

  // persist / restore pause preference
  const savedDisablePause = localStorage.getItem('disablePause');
  if (savedDisablePause !== null) {
    disablePause.checked = (savedDisablePause === '1');
  }
  PAUSE_CFG.enabled = !disablePause.checked;
  disablePause.addEventListener('change', () => {
    PAUSE_CFG.enabled = !disablePause.checked;
    localStorage.setItem('disablePause', disablePause.checked ? '1' : '0');
    updatePauseGuard();
  });
  updatePauseGuard();

  /* =========================
     GLOBAL MUSIC — per-scene playlists, shuffle, loop, crossfade
     ========================= */
  const MUSIC = (function(){
    const PLAYLISTS = {
      aurora: [
        "../../songs/space/space1.mp3",
        "../../songs/space/spacebest1.mp3",
        "../../songs/space/spacebest4.mp3",
      ],
      ripples: [
        "../../songs/space/space1.mp3",
        "../../songs/space/spacebest1.mp3",
        "../../songs/space/spacebest4.mp3",
      ],
      snow: [
        "../../songs/winter/wintersong2.mp3"
      ],
      bubblepop: [
        "../../songs/bubblepop1.mp3",
        "../../songs/bubblepop2.mp3"
      ],
      magnet: [
        "../../songs/magnet.mp3",
      ],
      streamers: [
        "../../songs/soie.mp3",
      ],
      jelly: [
        "../../songs/gelee1.mp3",
        "../../songs/gelee2.mp3",
      ],
      fireflies: [
        "../../songs/space/spacebest1.mp3",
        "../../songs/space/spacebest4.mp3",
      ],
      nebula: [
        "../../songs/space/spacebest1.mp3",
        "../../songs/space/spacebest4.mp3",
      ],
      galaxy: [
        "../../songs/space/spacevortex1.mp3",
        "../../songs/space/spacevortex5.mp3",
      ],
    };

    const CFG = {
      crossfadeSec: 0.6,
      sceneXfadeSec: 0.8,
      baseMusicScale: 0.7,
      mutePauseThreshold: 0.003,
    };

    let primed = false;
    let wanted = true;
    let scene = null;
    let sceneHasPlaylist = false;

    const ch = [
      { el: null, gain: 0, list: [], order: [], i: 0, name:"A" },
      { el: null, gain: 0, list: [], order: [], i: 0, name:"B" },
    ];
    let active = 0;
    let pendingXfade = 0;

    function makeAudio(){
      const a = new Audio();
      a.loop = false;
      a.preload = "auto";
      a.crossOrigin = "anonymous";
      a.volume = 0;
      return a;
    }
    function ensure(){
      if (!ch[0].el) ch[0].el = makeAudio();
      if (!ch[1].el) ch[1].el = makeAudio();
    }
    function shuffle(arr){
      for (let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; }
      return arr;
    }
    function buildOrder(list){ return shuffle(Array.from({length:list.length}, (_,i)=>i)); }
    function currentChannel(){ return ch[active]; }
    function idleChannel(){ return ch[1-active]; }
    function setPlaylistForBoth(list){
      ch[0].list = list; ch[0].order = buildOrder(list); ch[0].i = 0;
      ch[1].list = list; ch[1].order = buildOrder(list); ch[1].i = 0;
    }
    function nextIdx(c){ if (!c.list.length) return 0; c.i = (c.i + 1) % c.order.length; return c.i; }
    function pickSrc(c){ if (!c.list.length) return ""; const k = c.order[c.i] ?? 0; return c.list[k]; }
    function loadInto(c){
      if (!c.list.length) return;
      const src = pickSrc(c);
      c.el.src = src;
      const p = c.el.play();
      if (p && p.catch){ /* ignore autoplay errors */ }
      c.el.onended = ()=>{ nextIdx(c); loadInto(c); };
      c.el.onerror = ()=>{ nextIdx(c); loadInto(c); };
    }
    function prime(){ primed = true; ensure(); }
    function setScene(name){
      scene = name;
      const list = PLAYLISTS[name] || [];
      sceneHasPlaylist = list.length > 0;

      ensure();

      if (!sceneHasPlaylist){
        wanted = false;
        return;
      }

      setPlaylistForBoth(list);

      const idle = idleChannel();
      nextIdx(idle);
      loadInto(idle);
      pendingXfade = CFG.sceneXfadeSec;
    }
    function want(on){ wanted = !!on; }
    function tick(dt){
      if (!primed) return;
      ensure();

      const sceneWants = !!scene && sceneHasPlaylist && (ui.mode.value === scene);
      const shouldPlay = sceneWants && !paused && wanted !== false;

      const sfx = currentSfxGain();
      const targetBase = shouldPlay ? Math.min(1, sfx * CFG.baseMusicScale) : 0;

      if (pendingXfade > 0){
        const step = Math.min(pendingXfade, dt); pendingXfade -= step;
        const a = currentChannel(); const b = idleChannel();
        const t = 1 - (pendingXfade / (sceneWants ? CFG.sceneXfadeSec : CFG.crossfadeSec));
        a.gain = (1 - t) * targetBase; b.gain = t * targetBase;

        if (shouldPlay && b.el.paused && targetBase > 0){ const p = b.el.play(); if (p && p.catch){ /* ignore */ } }
        a.el.volume = a.gain; b.el.volume = b.gain;

        if (pendingXfade <= 0){
          active = 1 - active;
          const id = idleChannel();
          id.gain = 0; id.el.volume = 0;
          if (!sceneWants || targetBase === 0) id.el.pause();
        }
      } else {
        const a = currentChannel(); const b = idleChannel();
        a.gain = lerp(a.gain, targetBase, 1 - Math.pow(0.08, dt*60));
        a.el.volume = a.gain;
        b.gain = lerp(b.gain, 0, 1 - Math.pow(0.08, dt*60));
        b.el.volume = b.gain;

        if (shouldPlay && a.el.paused && targetBase > 0){ const p = a.el.play(); if (p && p.catch){ /* ignore */ } }
        if (!shouldPlay && a.el.volume < CFG.mutePauseThreshold && !a.el.paused) a.el.pause();
      }

      const a = currentChannel();
      if (shouldPlay && a.el.duration && !isNaN(a.el.duration)){
        const remain = a.el.duration - a.el.currentTime;
        if (remain < Math.max(0.25, CFG.crossfadeSec * 0.9) && pendingXfade <= 0){
          const b = idleChannel();
          nextIdx(b); loadInto(b);
          pendingXfade = CFG.crossfadeSec;
        }
      }
    }
    sfxVol.addEventListener('input', ()=>{});
    muteSFX.addEventListener('change', ()=>{});
    return {
      prime, setScene, want, tick,
      setPlaylist(sceneName, tracksArray){
        PLAYLISTS[sceneName] = tracksArray.slice();
        if (scene === sceneName){ setScene(sceneName); }
      }
    };
  })();

  // The scene change listener is attached later (after MUSIC exists)

  sceneSel.addEventListener('change', () => {
    if (seriesConfig.enabled) return;
    currentSceneId = sceneSel.value;
  });

  addEventListener('resize', ()=>{
    W=innerWidth; H=innerHeight; cvs.width=W; cvs.height=H;
    updateBorder();
    if (typeof resizeGlass === 'function') resizeGlass();
    if (typeof resizeLaser === 'function') resizeLaser();
    if (typeof caSandOnResize === 'function') caSandOnResize();
    if (typeof auroraResize === 'function') auroraResize();
    if (typeof snowResize === 'function') snowResize();
    if (typeof magnetResize === 'function') magnetResize();
    if (typeof ribbonsResize === 'function') ribbonsResize();
    if (typeof KALEIDO_SND !== 'undefined') KALEIDO_SND.onResize(); 
  // keep maxR updated
  });

  let menuOpen = true;
  cvs.style.display = 'none';

  let ac=null;
  function ensureAC(){ if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)(); return ac; }

  function currentSfxGain(){
    const vol = (parseInt(sfxVol.value,10)||50)/100;
    return (muteSFX.checked?0:1) * vol;
  }

  /* ===== Firework SFX (MP3-based, lazy-loaded) ===== */
  const FW_SFX_FILES = ["../../sounds/fireworks.mp3"];
  const FireworkSFX = (() => {
    let ready = false;
    let pending = null;
    let buffers = [];
    async function load(urls){
      if (ready || pending) return pending;
      ensureAC();
      const arr = Array.isArray(urls) ? urls : [urls];
      pending = Promise.all(arr.map(async (u) => {
        const res = await fetch(u);
        const ab  = await res.arrayBuffer();
        return ac.decodeAudioData(ab);
      }))
      .then(bs => { buffers = bs; ready = true; })
      .catch(err => { console.warn("SFX load failed:", err); pending = null; });
      return pending;
    }
    function play(x = W/2, y = H/2, power = 1){
      if (!ready || menuOpen) return;
      const master = currentSfxGain();
      if (master <= 0) return;
      const b = buffers[(Math.random()*buffers.length)|0];
      const src = ac.createBufferSource();
      src.buffer = b;
      src.playbackRate.value = 0.98 + Math.random()*0.04;
      const g = ac.createGain();
      g.gain.value = 0.32 * master * Math.min(1.6, 0.8 + power);
      const p = (ac.createStereoPanner ? ac.createStereoPanner() : null);
      if (p){
        p.pan.value = (x / W) * 2 - 1;
        src.connect(g).connect(p).connect(ac.destination);
      } else {
        src.connect(g).connect(ac.destination);
      }
      src.start();
    }
    return { load, play, isReady: () => ready };
  })();
  FireworkSFX.load(FW_SFX_FILES);

  function playPing(f=440, len=0.2, gain=0.05){
    if (menuOpen) return;
    try{
      ensureAC();
      const master = currentSfxGain();
      if (master <= 0) return;
      const o=ac.createOscillator(), g=ac.createGain(), hp=ac.createBiquadFilter();
      hp.type='highpass'; hp.frequency.value=300;
      o.type='sine'; o.frequency.value=f;
      g.gain.value = gain * master;
      o.connect(hp).connect(g).connect(ac.destination);
      const t = ac.currentTime;
      o.start(t);
      g.gain.setValueAtTime(g.gain.value, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t+len);
      o.stop(t+len+0.02);
    }catch(e){}
  }

  const uiModeProxy = {
    get value(){
      return currentSceneId;
    }
  };
  const ui = {
    mode: uiModeProxy,
    get intensity(){ return intSlider; },
    get size(){ return sizeSlider; },
    get trail(){ return trailSlider; }
  };

  let mouse = { x:W/2, y:H/2, vx:0, vy:0, speed:0, down:false };
  let last  = { x:mouse.x, y:mouse.y, t:performance.now() };
  let lastMoveT = performance.now();
  let dwellMs = 0;
  let now = performance.now();

  addEventListener('mousemove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const nx=e.clientX, ny=e.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
    recomputePaused();
  }, {passive:true});

  addEventListener('touchmove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const touch=e.touches[0]; if(!touch) return;
    const nx=touch.clientX, ny=touch.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
    recomputePaused();
  }, {passive:true});

  addEventListener('pointerdown', ()=>{ mouse.down=true; lastMoveT = performance.now(); playPing(700,0.08,0.05); });
  addEventListener('pointerup',   ()=>{ mouse.down=false; });

  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  const mapTrail = ()=> {
    const t = Number(ui.trail.value)/100;
    const shaped = Math.pow(1 - t, 2.2);
    return clamp(0.01 + shaped*0.98, 0.01, 0.99);
  };
  const mapIntensity = ()=> {
    const t = Number(ui.intensity.value)/100;
    return clamp(Math.pow(t, 1.6), 0, 1);
  };
  const mapSize = ()=> {
    const s = Number(ui.size.value);
    const t = (s - 10) / 190;
    const shaped = Math.pow(t, 1.35);
    return 8 + shaped * 420;
  };
  const mapSizeJelly = () => {
    const t = clamp((Number(ui.size.value) - 10) / 190, 0, 1); // 0..1
    return 45 + t * 100; // 45..145 (≈95 at mid)
  };
  const sizeNorm = ()=> clamp((Number(ui.size.value)-10)/190, 0, 1);

  const dwellFactor=()=> clamp(dwellMs/1200,0,1);
  let lastDwellStage=0;
  function dwellJustCrossed(ms){
    const stage = dwellMs >= ms ? 1 : 0;
    const crossed = stage > lastDwellStage;
    lastDwellStage = stage;
    return crossed;
  }
  function clearToBg(hard=false){
    const isLight = document.body.classList.contains('light');
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = hard ? (isLight ? '#fff' : '#000')
                         : (isLight ? `rgba(255,255,255,${mapTrail()})` : `rgba(0,0,0,${mapTrail()})`);
    ctx.fillRect(0,0,W,H);
  }



  /* =========================
     AURORA (snappier, no halo)
     ========================= */
  function _auroraQuality(){
    const ps  = (typeof perfScale   !== 'undefined') ? perfScale   : 1;
    const fma = (typeof frameMsAvg  !== 'undefined') ? frameMsAvg  : 16;
    const qFromFps  = clamp(1 - Math.max(0, (fma - 16)/16)*0.5, 0.6, 1);
    return Math.min(ps, qFromFps);
  }
  function fbm(x, t=0){
    let v=0, a=0.5, f=1.0;
    for (let i=0;i<4;i++){ v += a*Math.sin(x*f+t*(0.35+i*0.07)+i*1.3); a*=0.5; f*=1.8; }
    return v;
  }
  const AUR = { t:0, hueBase:140, stars:[], ribbons:[] };
  function auroraInit(){
    const q = _auroraQuality();
    const n = Math.floor((W*H) * (1/26000) * (0.7 + 0.6*q));
    AUR.stars = Array.from({length:n}, () => ({
      x:Math.random()*W, y:Math.random()*H, z:Math.random(), a:0.22+Math.random()*0.45
    }));
    const ribs = (q > 0.8 ? 3 : 2);
    AUR.ribbons.length = 0;
    for (let i=0;i<ribs;i++){
      AUR.ribbons.push({
        amp:   70 + i*24,
        thick: 46 + i*10,
        hue:   (AUR.hueBase + (i===0?40:i===1?0:-40)+360)%360,
        speed: 0.55 + i*0.18,
        alpha: 0.12 + i*0.06,
        warp:  0.90 + i*0.12,
        offsetY: 0.60 - i*0.08,
        jitter: 0.8 + i*0.25
      });
    }
  }
  function auroraResize(){ auroraInit(); }
  auroraInit();

  function drawStars(dt, boost=1){
    ctx.globalCompositeOperation = 'screen';
    const parX = (mouse.x - W*0.5) * 0.06;
    const parY = (mouse.y - H*0.5) * 0.03;
    const velSkewX = mouse.vx * 0.00005;
    for (let i=0;i<AUR.stars.length;i++){
      const s = AUR.stars[i];
      s.x += (mouse.vx*0.000015 + velSkewX) * (0.3 + s.z);
      if (s.x < -5) s.x = W+5; if (s.x > W+5) s.x = -5;
      const px = s.x - parX * s.z;
      const py = s.y - parY * s.z;
      const r = 0.6 + s.z*1.4;
      ctx.fillStyle = `hsla(200,100%,${68+26*s.z}%,${s.a*boost})`;
      ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
    }
  }
  function drawCurtainRibbon(rib, t, intensity){
    const q = _auroraQuality();
    const followY = 0.26 + 0.30*intensity;
    const baseY   = H * rib.offsetY + (mouse.y - H*0.5) * followY;
    const baseStep = Math.max(10, Math.round(W / (90 + 140*q)));
    const cx = mouse.x;
    const upper=[]; const lower=[];
    const phaseShift = (mouse.x/W - 0.5) * 1.8;
    const velPullX   = mouse.vx * 0.025;
    const velBend    = clamp(mouse.vx/800, -1.2, 1.2);

    for (let x=0; x<=W; ){
      const near = Math.max(0, 1 - Math.abs(x - cx) / (W*0.35));
      const step = Math.max(8, baseStep * (1 - 0.55*near));
      const u = x / W;

      const n = fbm(u*6*rib.warp + rib.jitter*0.6 + phaseShift, t*rib.speed);
      const amp = rib.amp * (0.9 + 0.8*intensity) * (1 + dwellFactor()*0.12);

      const dx = (x - cx);
      const prox = Math.max(0, 1 - Math.abs(dx) / (W*0.55));
      const proxShaped = prox*prox;
      const bend = ( - (dx / W) * amp * 0.75 * proxShaped * (0.7 + intensity) ) + velBend * 22 * prox;

      const y = baseY + n*amp + Math.sin(u*3 + t*0.3)*amp*0.05 + bend;
      const thick = rib.thick * (0.9 + 0.7*intensity) * (0.9 + 0.25*Math.abs(n));

      const skew = velPullX * (0.15 + 0.6*proxShaped);
      const xx = x + skew;

      upper.push([xx, y - thick]);
      lower.push([xx, y + thick]);

      x += step;
    }

    const hue = (rib.hue + 20*Math.sin(t*0.15))%360;
    const alpha = rib.alpha * (0.95 + 0.3*intensity) * q;

    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = `hsla(${hue}, 95%, 60%, ${alpha})`;
    ctx.beginPath();
    for (let i=0;i<upper.length;i++){ const [x,y]=upper[i]; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    for (let i=lower.length-1;i>=0;i--){ const [x,y]=lower[i]; ctx.lineTo(x, y); }
    ctx.closePath(); ctx.fill();

    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.22 * q;
    ctx.beginPath();
    for (let i=0;i<upper.length;i++){
      const [x,yU]=upper[i]; const yL = lower[i][1];
      ctx.lineTo(x, yU + 0.58*(yL - yU));
    }
    for (let i=lower.length-1;i>=0;i--){
      const [x,yL]=lower[i]; const yU = upper[i][1];
      ctx.lineTo(x, yL - 0.58*(yL - yU));
    }
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 1;
  }
  function renderAurora(dt){
    const q = _auroraQuality();
    AUR.t += dt; AUR.hueBase = (AUR.hueBase + 12*dt) % 360;

    ctx.globalCompositeOperation='source-over';
    ctx.globalAlpha = mapTrail()*0.9;
    ctx.fillStyle = document.body.classList.contains('light') ? '#fff' : '#000';
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    const intensity = mapIntensity();
    drawStars(dt, 0.95 + 0.4*intensity);

    for (let i=0;i<AUR.ribbons.length;i++){
      const rib=AUR.ribbons[i]; rib.hue=(rib.hue+6*dt)%360;
      drawCurtainRibbon(rib, AUR.t + i*0.12, intensity);
    }
  }
  const ripples = [];
  const MAX_RIPPLES = 18;
  let rippleCooldown = 0;
  let idleRippleDelay = 0;
  let waterT = 0;

  let waterBackdrop = null;
  let waterBackdropTheme = null;

  function rebuildWaterBackdrop(){
    waterBackdropTheme = document.body.classList.contains('light');
    const canvas = document.createElement('canvas');
    canvas.width = Math.max(1, Math.ceil(W));
    canvas.height = Math.max(1, Math.ceil(H));
    const gctx = canvas.getContext('2d');
    const isLight = waterBackdropTheme;
    const baseHue = isLight ? 188 : 204;

    const grad = gctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, `hsl(${baseHue}, 65%, ${isLight ? 82 : 26}%)`);
    grad.addColorStop(1, `hsl(${baseHue + 10}, 60%, ${isLight ? 68 : 18}%)`);
    gctx.fillStyle = grad;
    gctx.fillRect(0, 0, canvas.width, canvas.height);

    const flare = gctx.createRadialGradient(
      canvas.width * 0.22,
      canvas.height * 0.28,
      0,
      canvas.width * 0.22,
      canvas.height * 0.28,
      Math.max(canvas.width, canvas.height) * 0.9
    );
    flare.addColorStop(0, `hsla(${baseHue + 6}, 70%, ${isLight ? 88 : 46}%, ${isLight ? 0.28 : 0.24})`);
    flare.addColorStop(1, `hsla(${baseHue + 18}, 65%, ${isLight ? 72 : 32}%, 0)`);
    gctx.fillStyle = flare;
    gctx.fillRect(0, 0, canvas.width, canvas.height);

    waterBackdrop = canvas;
  }

  function ensureWaterBackdrop(){
    const needs = !waterBackdrop
      || waterBackdrop.width !== Math.max(1, Math.ceil(W))
      || waterBackdrop.height !== Math.max(1, Math.ceil(H))
      || waterBackdropTheme !== document.body.classList.contains('light');
    if (needs) rebuildWaterBackdrop();
  }

  function drawGlowSprite(sprite, x, y, radius, alpha, composite='screen'){
    if (!sprite || alpha <= 0.001) return;
    ctx.save();
    ctx.globalCompositeOperation = composite;
    ctx.globalAlpha = alpha;
    const scale = radius / sprite.radius;
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.drawImage(sprite.canvas, -sprite.radius, -sprite.radius);
    ctx.restore();
  }

  function emitRipple(x, y, strength = 1){
    const s = Math.max(0.2, strength);
    const intensity = mapIntensity();
    const sizeFactor = sizeNorm();
    const baseSpeed = (70 + 140 * intensity) * (0.9 + sizeFactor * 0.3);
    const fade = 0.55 + 0.45 * intensity;
    const hue = 192 + Math.random() * 16;

    ripples.push({
      x,
      y,
      r: 0,
      vr: baseSpeed * (0.7 + s * 0.6),
      width: (6 + sizeFactor * 14) * (0.45 + s * 0.55),
      alpha: 0.42 + s * 0.32,
      life: 1,
      fade,
      hue,
    });
    if (ripples.length > MAX_RIPPLES){
      ripples.shift();
    }
  }

  function ripplesResize(){
    waterBackdrop = null;
    ensureWaterBackdrop();
  }
  ripplesResize();

  function renderRipples(dt){
    ensureWaterBackdrop();
    waterT += dt;
    const isLight = document.body.classList.contains('light');

    ctx.globalCompositeOperation = 'source-over';
    const fade = mapTrail();
    ctx.fillStyle = isLight
      ? `rgba(255,255,255,${fade})`
      : `rgba(0,0,0,${fade})`;
    ctx.fillRect(0, 0, W, H);

    const bgAlpha = clamp(0.75 + fade * 0.2, 0.75, 0.95);
    ctx.globalAlpha = bgAlpha;
    if (waterBackdrop){
      ctx.drawImage(waterBackdrop, 0, 0, W, H);
    } else {
      ctx.fillStyle = isLight ? '#d9ecf6' : '#041b2c';
      ctx.fillRect(0, 0, W, H);
    }
    ctx.globalAlpha = 1;

    const shimmer = 0.05 + 0.03 * Math.sin(waterT * 0.4);
    ctx.fillStyle = isLight
      ? `rgba(255,255,255,${0.03 + shimmer * 0.4})`
      : `rgba(4,24,40,${0.10 + shimmer * 0.4})`;
    ctx.fillRect(0, 0, W, H);

    rippleCooldown = Math.max(0, rippleCooldown - dt);
    idleRippleDelay = Math.max(0, idleRippleDelay - dt);

    const speedN = clamp(mouse.speed / 1200, 0, 1);
    const intensity = mapIntensity();

    if (speedN > 0.08){
      if (rippleCooldown === 0){
        emitRipple(mouse.x, mouse.y, 0.5 + speedN * 0.7);
        rippleCooldown = Math.max(0.12, 0.22 - 0.10 * intensity);
      }
      idleRippleDelay = Math.max(0.6, 1.6 + 1.2 * (1 - intensity));
    } else if (idleRippleDelay === 0 && rippleCooldown === 0){
      emitRipple(mouse.x, mouse.y, 0.3);
      rippleCooldown = 0.55;
      idleRippleDelay = 3.6 + 2.2 * (1 - intensity);
    }

    if (dwellJustCrossed(650)){
      playPing(520, 0.14, 0.05);
      emitRipple(mouse.x, mouse.y, 1.1);
    }

    ctx.globalCompositeOperation = 'lighter';
    ctx.lineCap = 'round';

    const strokeLight = isLight ? 52 : 64;
    const fillLight = isLight ? 76 : 46;

    for (let i = ripples.length - 1; i >= 0; i--){
      const r = ripples[i];
      r.r += r.vr * dt;
      r.life -= dt * r.fade;
      if (r.life <= 0 || r.r > Math.hypot(W, H) * 1.2){
        ripples.splice(i, 1);
        continue;
      }
      const alpha = r.alpha * Math.max(0, r.life);
      const hue = (r.hue + Math.sin(waterT * 0.7 + r.r * 0.02) * 6 + 360) % 360;
      const width = Math.max(0.9, r.width * (0.8 + 0.2 * Math.sin(waterT * 0.5 + i)));

      ctx.strokeStyle = `hsla(${hue}, 70%, ${strokeLight}%, ${alpha})`;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.arc(r.x, r.y, Math.max(0.1, r.r), 0, Math.PI * 2);
      ctx.stroke();

      const innerAlpha = alpha * 0.45;
      if (innerAlpha > 0.01){
        ctx.fillStyle = `hsla(${(hue + 10) % 360}, 75%, ${fillLight}%, ${innerAlpha})`;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r * 0.72, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.globalCompositeOperation = 'source-over';
  }

  /* =========================
     FIREWORKS
     ========================= */
  const fwParts = [];
  let fwHueBase = 0;
  let fwMoveCooldown = 0;
  let fwAutoCooldown = 0;

  function fwSpawnBurst(x, y, power=1, style='peony'){
    FireworkSFX.play(x, y, power);  
    const sN = sizeNorm();
    const sPow = Math.pow(sN, 1.15);
    const base = 16 + Math.floor(28*mapIntensity());
    const count = Math.floor(base * (0.5 + 2.7*sPow) * power);

    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const speedBase = 1.8 + Math.random()*2.8;
      const speed = speedBase * (0.7 + 1.6*sPow);
      let vx = Math.cos(a)*speed, vy = Math.sin(a)*speed;

      if (style==='ring'){
        const ringR = (2.2 + Math.random()*1.2) * (0.8 + 1.4*sPow);
        vx = Math.cos(a)*ringR; vy = Math.sin(a)*ringR;
      } else if (style==='willow'){
        const willowS = (1.3 + Math.random()*1.1) * (0.7 + 1.4*sPow);
        vx = Math.cos(a)*willowS*0.85; vy = Math.sin(a)*willowS*0.6 - (0.8 + 0.6*sPow);
      }

      const hue = (fwHueBase + (Math.random()*40 - 20) + i)%360;
      fwParts.push({
        x, y, px:x, py:y,
        vx, vy,
        drag: 0.986,
        gy: 0.02,
        life: (0.6 + Math.random()*0.6) * (0.8 + 1.6*sPow),
        age: 0,
        size: (0.7 + Math.random()*1.2) * (0.8 + 2.6*sPow),
        hue,
        light: 60 + Math.random()*10,
        sat: 95
      });
    }
    if (power > 1.1) playPing(420+Math.random()*280, 0.15, 0.05);
  }

  function renderFireworks(dt){
    fwHueBase = (fwHueBase + 60*dt) % 360;

    const isLight = document.body.classList.contains('light');
    const fade = isLight ? `rgba(255,255,255,${mapTrail()*0.85})` : `rgba(0,0,0,${mapTrail()*0.82})`;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = fade; ctx.fillRect(0,0,W,H);

    fwMoveCooldown = Math.max(0, fwMoveCooldown - dt);
    fwAutoCooldown = Math.max(0, fwAutoCooldown - dt);
    const speedN = clamp(mouse.speed/1200, 0, 1);
    const sN = sizeNorm();

    if (speedN > 0.25 && fwMoveCooldown === 0){
      const pow = 0.8 + 0.8*speedN*mapIntensity();
      const style = (Math.random() < 0.25) ? 'ring' : (Math.random()<0.15 ? 'willow' : 'peony');
      fwSpawnBurst(mouse.x, mouse.y, pow, style);
      fwMoveCooldown = (0.08 + 0.10*(1-mapIntensity())) * (0.85 + 0.3*(1-sN));
    }
    if (dwellJustCrossed(600)){
      fwSpawnBurst(mouse.x, mouse.y, 1.2 + 0.9*mapIntensity(), (Math.random()<0.3?'ring':'peony'));
    }
    if (fwAutoCooldown === 0 && Math.random() < 0.02*mapIntensity()*(0.7 + 0.8*sN)){
      fwSpawnBurst(mouse.x + (Math.random()-0.5)*60, mouse.y + (Math.random()-0.5)*40, 0.9 + 0.6*sN, 'peony');
      fwAutoCooldown = 0.25 * (0.9 + 0.6*(1-sN));
    }

    ctx.globalCompositeOperation='lighter';
    ctx.lineCap='round';
    for (let i=fwParts.length-1;i>=0;i--){
      const p = fwParts[i];
      p.age += dt;
      if (p.age >= p.life){ fwParts.splice(i,1); continue; }

      p.vx *= Math.pow(p.drag, dt*60);
      p.vy = p.vy*Math.pow(p.drag, dt*60) + p.gy*(dt*60);
      p.px = p.x; p.py = p.y;
      p.x += p.vx*(dt*60);
      p.y += p.vy*(dt*60);

      const t = p.age / p.life;
      const alpha = Math.max(0, (1 - t) * (0.65 - 0.25*t));

      const strokeScale = 0.7 + 2.2*sN;
      ctx.strokeStyle = `hsla(${p.hue}, ${p.sat}%, ${p.light}%, ${alpha})`;
      ctx.lineWidth   = Math.max(1, (p.size * (1 - 0.5*t)) * strokeScale);
      ctx.beginPath(); ctx.moveTo(p.px, p.py); ctx.lineTo(p.x, p.y); ctx.stroke();

      const glowAlpha = alpha * (0.6 + 0.8*sN);
      ctx.fillStyle = `hsla(${(p.hue+10)%360}, ${p.sat}%, ${Math.min(90, p.light+15)}%, ${glowAlpha})`;
      const glowR = Math.max(1, p.size * (0.6 + 2.0*sN));
      ctx.beginPath(); ctx.arc(p.x, p.y, glowR*0.6, 0, Math.PI*2); ctx.fill();
    }

    const cap = Math.floor(900 + 1200*sizeNorm());
    if (fwParts.length > cap) fwParts.splice(0, fwParts.length - cap);
  }

  /* ======================================================================
     KALEIDO — with reactive sound bed that grows with center distance
     ====================================================================== */

  /* ===== Kaleido sound — grows with distance from center ===== */
  const KALEIDO_SND = (() => {
    let inited = false;
    let maxR = 1;
    let N = null;

    function onResize(){
      maxR = Math.hypot(W * 0.5, H * 0.5) || 1;
    }
    onResize();

    function shouldPlay(){
      return !menuOpen && !paused && ui.mode.value === 'kaleido';
    }

    function ensure(){
      if (inited || menuOpen) return;
      ensureAC();

      const master = ac.createGain();
      master.gain.value = 0;
      master.connect(ac.destination);

      const pan = (ac.createStereoPanner ? ac.createStereoPanner() : null);
      const lp  = ac.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 1600; lp.Q.value = 0.7;

      const o1 = ac.createOscillator(); o1.type = 'sine';
      const o2 = ac.createOscillator(); o2.type = 'triangle';
      const mix = ac.createGain(); mix.gain.value = 1;

      o1.connect(mix);
      o2.connect(mix);

      if (pan) { mix.connect(pan); pan.connect(lp); }
      else { mix.connect(lp); }
      lp.connect(master);

      const lfo = ac.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 4;
      const lfoGain = ac.createGain(); lfoGain.gain.value = 8;
      lfo.connect(lfoGain);
      lfoGain.connect(o1.detune);
      lfoGain.connect(o2.detune);

      const t = ac.currentTime;
      o1.start(t); o2.start(t); lfo.start(t);

      N = { master, pan, lp, o1, o2 };
      inited = true;
    }

    function tick(dt){
      ensure();
      if (!inited) return;

      const play = shouldPlay();
      const d = Math.hypot(mouse.x - W*0.5, mouse.y - H*0.5);
      const n = clamp(d / maxR, 0, 1);

      const sfx = currentSfxGain();
      const targetGain = play ? (0.02 + 0.38 * Math.pow(n, 1.2)) * sfx : 0;
      const targetFreq = 170 + 900 * Math.pow(n, 0.9);
      const targetLPF  = 1000 + 2200 * n;

      try {
        N.master.gain.setTargetAtTime(targetGain, ac.currentTime, 0.05);
        N.o1.frequency.setTargetAtTime(targetFreq, ac.currentTime, 0.05);
        N.o2.frequency.setTargetAtTime(targetFreq * 2, ac.currentTime, 0.05);
        N.lp.frequency.setTargetAtTime(targetLPF, ac.currentTime, 0.08);
        if (N.pan) {
          const panX = (mouse.x / W) * 2 - 1;
          N.pan.pan.setTargetAtTime(panX * 0.6, ac.currentTime, 0.05);
        }
      } catch(e) {}
    }

    // NEW: immediate silence helper (used when paused toggles on)
    function silenceNow(){
      if (!inited || !ac) return;
      try{
        N.master.gain.cancelScheduledValues(ac.currentTime);
        N.master.gain.setValueAtTime(0, ac.currentTime);
      }catch(e){}
    }

    return { tick, onResize, silenceNow };
  })();

  // Visuals
  let hueBase = 0;
  let kaleidoAngle=0;
  function renderKaleido(dt){
    KALEIDO_SND.tick(dt); // drive the reactive audio; will be 0 when paused

    const segs=8, r=mapSize()*0.8; kaleidoAngle += dt*0.4;
    clearToBg(false);
    const cx=W/2, cy=H/2, dx=mouse.x-cx, dy=mouse.y-cy;
    const baseHue=(performance.now()*0.02)%360, w=7+mapIntensity()*18;
    ctx.globalCompositeOperation='lighter'; ctx.lineCap='round'; ctx.lineJoin='round';
    for (let i=0;i<segs;i++){
      const a=(i/segs)*Math.PI*2 + kaleidoAngle;
      const x = cx + (dx*Math.cos(a) - dy*Math.sin(a));
      const y = cy + (dx*Math.sin(a) + dy*Math.cos(a));
      const h=(baseHue + i*(360/segs))%360;
      ctx.strokeStyle=`hsla(${h},85%,65%,0.5)`; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(lerp(cx,x,0.55), lerp(cy,y,0.55)); ctx.lineTo(x,y); ctx.stroke();
      ctx.fillStyle=`hsla(${(h+40)%360},85%,60%,0.25)`; ctx.beginPath(); ctx.arc(x,y, r*0.28, 0, Math.PI*2); ctx.fill();
    }
    if (dwellMs>600){
      const s=r*(1+0.12*Math.sin(performance.now()*0.006));
      ctx.strokeStyle=`hsla(${(baseHue+120)%360},90%,75%,0.35)`; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(cx,cy,s,0,Math.PI*2); ctx.stroke();
    }
  }

/* =========================
   FIREFLIES — Lucioles v2 (bigger, wrap-safe trails, toned-down glow)
   More numerous, wider spread, light the screen — now larger, subtler glow, and music
   ========================= */

// state
const FIREFLIES = { list: [], t: 0 };
const FIREFLY_NEIGHBORS = { a: [], b: [] };

const FIREFLY_SPRITE_SIZE = 256;
const FIREFLY_SPRITES = new Map();

function getFireflySprite(hue){
  const quant = ((Math.round(hue / 12) * 12) % 360 + 360) % 360;
  const key = `${quant}`;
  let sprite = FIREFLY_SPRITES.get(key);
  if (!sprite){
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = FIREFLY_SPRITE_SIZE;
    const gctx = canvas.getContext('2d');
    const cx = FIREFLY_SPRITE_SIZE / 2;

    const bloom = gctx.createRadialGradient(cx, cx, cx*0.10, cx, cx, cx*0.95);
    bloom.addColorStop(0.0, `hsla(${quant}, 100%, 70%, 1)`);
    bloom.addColorStop(0.55, `hsla(${(quant+16)%360}, 95%, 55%, 0.65)`);
    bloom.addColorStop(1.0, `hsla(${(quant+56)%360}, 85%, 45%, 0)`);
    gctx.fillStyle = bloom;
    gctx.fillRect(0, 0, FIREFLY_SPRITE_SIZE, FIREFLY_SPRITE_SIZE);

    const highlight = gctx.createRadialGradient(cx*0.68, cx*0.68, cx*0.06, cx*0.68, cx*0.68, cx*0.28);
    highlight.addColorStop(0.0, `hsla(${(quant+36)%360}, 100%, 90%, 0.75)`);
    highlight.addColorStop(1.0, `hsla(${(quant+36)%360}, 100%, 90%, 0)`);
    gctx.fillStyle = highlight;
    gctx.fillRect(0, 0, FIREFLY_SPRITE_SIZE, FIREFLY_SPRITE_SIZE);

    sprite = { canvas, radius: FIREFLY_SPRITE_SIZE / 2 };
    FIREFLY_SPRITES.set(key, sprite);
  }
  return sprite;
}

// (Re)create the swarm sized by the "Taille" slider
function firefliesInit(){
  FIREFLIES.list.length = 0;

  const sN = sizeNorm();
  const n = Math.floor(70 + 240 * sN);
  const spread = Math.hypot(W, H) * 0.6;
  const neighborA = FIREFLY_NEIGHBORS.a;
  const neighborB = FIREFLY_NEIGHBORS.b;
  neighborA.length = n;
  neighborB.length = n;

  for (let i=0; i<n; i++){
    const z   = 0.58 + Math.random()*0.82;          // "depth" (size/speed scaler)
    const invZ = 1 / z;
    const ang = Math.random()*Math.PI*2;
    const rad = Math.sqrt(Math.random()) * spread;  // spread them wide
    const cx  = W*0.5 + Math.cos(ang)*rad;
    const cy  = H*0.5 + Math.sin(ang)*rad;

    FIREFLIES.list.push({
      x: cx, y: cy, px: cx, py: cy,
      vx: (Math.random()-0.5)*0.25, vy:(Math.random()-0.5)*0.25,
      z,
      invZ,
      hue: 170 + Math.random()*80,           // cyan→lime range
      glow: 0.2 + Math.random()*0.4,
      phase: Math.random()*Math.PI*2,
    });
  }

  const shortOffset = Math.min(n-1, 13);
  const longOffset = Math.min(n-1, Math.max(shortOffset+1, Math.round(n*0.24)));
  for (let i=0; i<n; i++){
    neighborA[i] = (i + shortOffset) % n;
    neighborB[i] = (i + longOffset) % n;
  }
}
// call once on load
firefliesInit();

// helpful wrap with generous padding to keep them spread
// RETURNS true if we wrapped, so we can kill the trail that frame
function flyWrap(f){
  const pad = 80;
  let wrapped = false;
  if (f.x < -pad){ f.x = W + pad; wrapped = true; }
  if (f.x > W + pad){ f.x = -pad; wrapped = true; }
  if (f.y < -pad){ f.y = H + pad; wrapped = true; }
  if (f.y > H + pad){ f.y = -pad; wrapped = true; }
  if (wrapped){ f.px = f.x; f.py = f.y; } // reset trail to avoid full-screen line
  return wrapped;
}

// Draw one firefly with bloom that lights the screen around it (subtle)
function drawFirefly(f, coreR, bloomR, alphaCore, alphaBloom){
  const sprite = getFireflySprite(f.hue);
  if (alphaBloom > 0.001){
    drawGlowSprite(sprite, f.x, f.y, bloomR, alphaBloom, 'screen');
  }

  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 1;
  ctx.fillStyle = `hsla(${f.hue|0}, 100%, 68%, ${alphaCore})`;
  ctx.beginPath();
  ctx.arc(f.x, f.y, coreR, 0, Math.PI*2);
  ctx.fill();

  ctx.globalCompositeOperation = 'screen';
  ctx.strokeStyle = `hsla(${(f.hue+36)|0}, 100%, 88%, ${0.55*alphaCore})`;
  ctx.lineWidth = Math.max(0.7, coreR*0.3);
  ctx.beginPath();
  ctx.arc(f.x - coreR*0.32, f.y - coreR*0.32, coreR*0.30, 0, Math.PI*2);
  ctx.stroke();
}

function renderFireflies(dt){
  const intensity = mapIntensity();
  const sN        = sizeNorm();
  FIREFLIES.t    += dt;

  // Theme-aware fade
  clearToBg(false);

  // --- physics (slow + extra wander when not near the gaze) ---
  const baseWander = 0.10 + 0.12*intensity;      // base random meander
  const attractK   =  6  + 32*intensity;         // softer pointer attraction
  const repelK     = 12  + 22*intensity;         // gentle separation
  const maxSpeed   = 10  + 24*intensity;         // low top speed (floaty)
  const damp       = Math.pow(0.975, dt*60);     // strong damping
  const velScale   = dt * 38;                    // slower integration

  const pullR      = 220 + 380*sN;
  const pullR2     = pullR * pullR;
  const nearRange  = 180 + 260*sN;
  const nearRange2 = nearRange * nearRange;
  const repelR     = 140 + 260*sN;
  const repelR2    = repelR * repelR;
  const hopXLimit  = W * 0.45;
  const hopYLimit  = H * 0.45;

  const neighborsA = FIREFLY_NEIGHBORS.a;
  const neighborsB = FIREFLY_NEIGHBORS.b;

  const N = FIREFLIES.list.length;
  for (let i=0; i<N; i++){
    const f = FIREFLIES.list[i];

    // previous pos for trail
    f.px = f.x; f.py = f.y;

    // distance / nearness to pointer (avoid sqrt unless close)
    const dx = mouse.x - f.x;
    const dy = mouse.y - f.y;
    const dist2 = dx*dx + dy*dy;
    let near = 0;
    let dist = 0;
    if (dist2 < nearRange2){
      dist = Math.sqrt(dist2);
      near = clamp(1 - (dist / nearRange), 0, 1);
    } else if (dist2 < pullR2){
      dist = Math.sqrt(dist2);
    }

    const invZ = f.invZ;
    const wanderLocal = baseWander * (1 + 0.9*(1 - near));

    // wander (depth-scaled)
    f.vx += (Math.random()-0.5) * wanderLocal * invZ;
    f.vy += (Math.random()-0.5) * wanderLocal * invZ;

    // pointer attraction (soft radius that grows with size)
    if (dist2 < pullR2 && dist > 0){
      const t = 1 - dist/pullR;
      const pull = attractK * (0.25 + 0.75*t) * dt * invZ / 320;
      f.vx += dx * pull;
      f.vy += dy * pull;
    }

    // mild two-neighbour repulsion (O(n), not n^2)
    const idxA = neighborsA[i];
    const idxB = neighborsB[i];
    const gA = FIREFLIES.list[idxA];
    if (gA && gA !== f){
      const rx = f.x - gA.x;
      const ry = f.y - gA.y;
      const rd2 = rx*rx + ry*ry + 0.0001;
      if (rd2 < repelR2){
        const inv = 1/Math.sqrt(rd2);
        const repelScale = (repelK * (1 - rd2/repelR2)) * dt * invZ / 120;
        f.vx += rx * inv * repelScale;
        f.vy += ry * inv * repelScale;
      }
    }
    const gB = FIREFLIES.list[idxB];
    if (gB && gB !== f){
      const rx = f.x - gB.x;
      const ry = f.y - gB.y;
      const rd2 = rx*rx + ry*ry + 0.0001;
      if (rd2 < repelR2){
        const inv = 1/Math.sqrt(rd2);
        const repelScale = (repelK * (1 - rd2/repelR2)) * dt * invZ / 120;
        f.vx += rx * inv * repelScale;
        f.vy += ry * inv * repelScale;
      }
    }

    // gentle center bias
    const cdx = (W*0.5 - f.x), cdy = (H*0.5 - f.y);
    f.vx += cdx * 0.000015;
    f.vy += cdy * 0.000015;

    // limit & integrate (slower)
    const maxLocal = maxSpeed * invZ;
    const maxLocalSq = maxLocal * maxLocal;
    const magSq = f.vx*f.vx + f.vy*f.vy;
    if (magSq > maxLocalSq && magSq > 0){
      const scale = maxLocal / Math.sqrt(magSq);
      f.vx *= scale;
      f.vy *= scale;
    }
    f.vx *= damp; f.vy *= damp;
    f.x  += f.vx * velScale;
    f.y  += f.vy * velScale;

    // wrap; if it teleported a long way (edge wrap or browser hitch), nuke the trail
    const wrapped = flyWrap(f);
    if (!wrapped){
      const hopX = Math.abs(f.x - f.px);
      const hopY = Math.abs(f.y - f.py);
      if (hopX > hopXLimit || hopY > hopYLimit){ f.px = f.x; f.py = f.y; }
    }

    // photophore — adjust glow per nearness
    f.phase += dt * (0.6 + 1.4*intensity);
    const twinkle = 0.5 + 0.5*Math.sin(f.phase + f.x*0.01 + f.y*0.01);
    const baseGlow = 0.20 + 0.26*twinkle;
    f.glow = clamp(baseGlow + near*(0.50 + 0.42*intensity), 0.10, 1.5);
  }

  // Visuals (bloom + subtle trails)
  const trailAlpha = 0.05 + 0.11*intensity;
  const baseTrailW = 1.0 + 1.3*intensity;
  const sizeBoost  = 1.72;
  const bloomScale = 4.8 + 5.8*intensity;
  const coreAlpha  = clamp(0.22 + 0.28*intensity, 0, 0.6);
  const bloomBase  = clamp(0.05 + 0.10*intensity, 0, 0.32);

  ctx.lineCap = 'round';
  ctx.globalCompositeOperation = 'screen';
  for (let i=0; i<N; i++){
    const f = FIREFLIES.list[i];

    // trail (softer alpha to match reduced glow)
    ctx.strokeStyle = `hsla(${(f.hue+30)|0}, 90%, 72%, ${trailAlpha})`;
    ctx.lineWidth = Math.max(1, baseTrailW * f.invZ);
    ctx.beginPath(); ctx.moveTo(f.px, f.py); ctx.lineTo(f.x, f.y); ctx.stroke();

    const coreR  = sizeBoost * (2.4 + 4.1*f.glow) * f.invZ;
    const bloomR = coreR * bloomScale;

    const aCore  = coreAlpha;
    const aBloom = bloomBase * clamp(f.glow/3.2, 0.35, 0.95);

    drawFirefly(f, coreR, bloomR, aCore, aBloom);
  }
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;

  // Delight: on dwell, brief global sparkle & pitch (kept soft)
  if (dwellJustCrossed(800)){
    playPing(660, 0.10, 0.035);
    for (let k=0; k<FIREFLIES.list.length; k+=Math.floor(3+6*(1-intensity))){
      const f = FIREFLIES.list[k];
      f.glow = Math.max(f.glow, 1.0);
      f.hue  = (f.hue + 10) % 360;
    }
  }
}

/* =========================
     CONFETTI
     ========================= */
  const confettis = Array.from({length:220},()=>resetPiece({}));
  function resetPiece(p){
    p.x=Math.random()*W; p.y=Math.random()*H; p.vx=(Math.random()-0.5)*0.7; p.vy=Math.random()*0.6+0.2;
    p.size=2+Math.random()*4; p.h=Math.random()*360; p.spin=(Math.random()-0.5)*0.15; return p;
  }
  function renderConfetti(dt){
    clearToBg(false);
    const windX = clamp(mouse.vx/400, -1.5, 1.5) * (0.5 + mapIntensity());
    const windY = 0.15 + (dwellMs>600 ? 0.25 : 0);
    ctx.globalCompositeOperation='lighter';
    confettis.forEach(p=>{
      const dx = mouse.x - p.x, dy = mouse.y - p.y, pull = 0.02*mapIntensity();
      p.vx += windX*dt + dx*pull*dt; p.vy += windY*dt + dy*pull*dt;
      p.x += p.vx; p.y += p.vy; p.h += p.spin;
      ctx.fillStyle = `hsla(${(p.h)%360},90%,60%,0.8)`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
      if (p.x<-20||p.x>W+20||p.y<-20||p.y>H+20) resetPiece(p);
    });
    if (dwellJustCrossed(700)){
      playPing(550,0.12,0.04);
      for(let i=0;i<50;i++){ const q=resetPiece({}); q.x=mouse.x; q.y=mouse.y; q.vx=(Math.random()-0.5)*3.2; q.vy=Math.random()*-1.8; confettis.push(q); }
      if (confettis.length>400) confettis.splice(0, confettis.length-400);
    }
  }

  /* =========================
     NÉBULEUSE
     ========================= */
 /* =========================
   NÉBULEUSE v2 — parallax dust + flow gas + comets
   Adds scene music via MUSIC.setPlaylist('nebula', [...])
   ========================= */

const NEB = {
  inited: false,
  t: 0,
  dust: [],     // little stars/dust with parallax drift
  comets: [],   // fast streaks when the pointer darts
  hue: 0
};

function nebulaInit(){
  NEB.inited = true;
  NEB.dust.length = 0;
  NEB.comets.length = 0;

  // number of dust motes scales with Taille
  const n = Math.floor(140 + 420 * sizeNorm());
  for (let i=0;i<n;i++){
    const z = 0.25 + Math.random()*0.95; // depth: 0.25..1.2
    NEB.dust.push({
      x: Math.random()*W,
      y: Math.random()*H,
      z,
      a: 0.18 + Math.random()*0.45,
      r: 0.6 + z*1.6,
      tw: Math.random()*Math.PI*2
    });
  }
}

function spawnComet(x, y, vx, vy){
  // keep it light
  if (NEB.comets.length > 80) NEB.comets.splice(0, NEB.comets.length - 80);
  NEB.comets.push({
    x, y, vx, vy,
    life: 0.35 + Math.random()*0.25,
    age: 0,
    hue: (NEB.hue + 20 + Math.random()*40) % 360
  });
}

function renderNebula(dt){
  if (!NEB.inited) nebulaInit();

  const intensity = mapIntensity();
  const sN = sizeNorm();

  NEB.t   += dt;
  NEB.hue  = (NEB.hue + 12*dt) % 360;

  // Background (respect trail)
  clearToBg(false);

  // Star field (reuse Aurora stars as backdrop)
  if (!AUR.stars || AUR.stars.length === 0) auroraInit();
  drawStars(dt, 1.15 + 0.35*intensity);

  // ---------- Parallax dust ----------
  ctx.globalCompositeOperation = 'screen';
  const parX = (mouse.x - W*0.5) * 0.06;
  const parY = (mouse.y - H*0.5) * 0.04;
  for (let i=0;i<NEB.dust.length;i++){
    const d = NEB.dust[i];
    // gentle flow using tiny fbm-like wobble (fbm() exists in your file)
    d.tw += dt * (0.4 + 0.8*d.z);
    const driftX = Math.sin(d.tw*0.7 + d.z*5) * 0.08;
    const driftY = Math.cos(d.tw*0.6 + d.z*7) * 0.06;
    d.x += driftX; d.y += driftY;
    if (d.x < -6) d.x = W+6; else if (d.x > W+6) d.x = -6;
    if (d.y < -6) d.y = H+6; else if (d.y > H+6) d.y = -6;

    const px = d.x - parX * d.z;
    const py = d.y - parY * d.z;
    const twinkle = 0.6 + 0.4*Math.sin(d.tw*1.6 + d.z*10);
    ctx.fillStyle = `hsla(${(NEB.hue+170)%360}, 90%, ${60+25*d.z}%, ${(d.a*twinkle)*(0.8+0.6*intensity)})`;
    ctx.beginPath(); ctx.arc(px, py, d.r, 0, Math.PI*2); ctx.fill();
  }

  // ---------- Gas layers (flow field + chromatic fringe) ----------
  ctx.globalCompositeOperation='lighter';
  const layers = 3 + Math.floor(intensity*3);
  const baseS = mapSize() * (0.9 + 0.2*Math.sin(NEB.t*0.4));
  for (let i=0;i<layers;i++){
    // swirl around the pointer with subtle noise offset
    const u = i / Math.max(1, layers-1);
    const amp = (0.14 + 0.42*u) * (1 + 0.6*intensity);
    const nx = fbm((mouse.x*0.002 + u*1.3), NEB.t*0.35 + i*0.7);
    const ny = fbm((mouse.y*0.002 - u*1.1), NEB.t*0.32 + i*0.9);
    const offX = (nx-0.5) * baseS * amp;
    const offY = (ny-0.5) * baseS * amp * 0.8;

    const s  = baseS * (0.7 + i*0.36);
    const cx = mouse.x + offX;
    const cy = mouse.y + offY;

    // slight chromatic fringing = 3 passes with offset hues
    const H0 = (NEB.hue + i*28) % 360;
    const a0 = 0.12 + 0.10*intensity;
    const pass = (dh, shrink, extraAlpha)=>{
      const g = ctx.createRadialGradient(cx, cy, s*0.08, cx, cy, s*shrink);
      g.addColorStop(0.00, `hsla(${(H0+dh)%360}, 90%, 58%, ${a0*0.9*extraAlpha})`);
      g.addColorStop(0.55, `hsla(${(H0+dh+25)%360}, 85%, 50%, ${a0*0.35*extraAlpha})`);
      g.addColorStop(1.00, `hsla(${(H0+dh+60)%360}, 80%, 40%, 0)`);
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(cx, cy, s*shrink, 0, Math.PI*2); ctx.fill();
    };
    pass(0,   1.05, 1.00);
    pass(14,  0.98, 0.85);
    pass(-14, 0.92, 0.75);
  }

  // ---------- Speed-based comets ----------
  const spN = clamp(mouse.speed/1400, 0, 1);
  if (spN > 0.55){
    // spawn along motion vector (a little behind the cursor)
    const ang = Math.atan2(mouse.vy||0.001, mouse.vx||0.001);
    const dist = 18 + 44*spN;
    const cx = mouse.x - Math.cos(ang)*dist;
    const cy = mouse.y - Math.sin(ang)*dist;
    spawnComet(cx, cy, -Math.cos(ang)*220*spN, -Math.sin(ang)*220*spN);
  }

  // draw & advance comets
  ctx.globalCompositeOperation = 'screen';
  for (let i=NEB.comets.length-1; i>=0; i--){
    const c = NEB.comets[i];
    c.age += dt;
    if (c.age >= c.life){ NEB.comets.splice(i,1); continue; }
    const t = c.age / c.life;
    const fade = (1 - t);
    const len  = (18 + 120*fade) * (0.7 + 0.6*intensity);
    // tail line
    ctx.strokeStyle = `hsla(${c.hue}, 95%, 70%, ${0.35*fade})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x - c.vx*dt*len*0.07, c.y - c.vy*dt*len*0.07);
    ctx.stroke();
    // head glow
    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, 10+20*fade);
    g.addColorStop(0, `hsla(${(c.hue+10)%360}, 95%, 75%, ${0.5*fade})`);
    g.addColorStop(1, `hsla(${(c.hue+40)%360}, 90%, 55%, 0)`);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(c.x, c.y, 12, 0, Math.PI*2); ctx.fill();

    c.x += c.vx * dt; c.y += c.vy * dt;
  }

  // ---------- Dwell pulse ----------
  if (dwellMs > 700){
    ctx.globalCompositeOperation='screen';
    const r = mapSize()*(0.85 + 0.18*Math.sin(performance.now()*0.006));
    ctx.strokeStyle = `hsla(${(NEB.hue+150)%360}, 90%, 75%, ${0.28 + 0.18*intensity})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(mouse.x, mouse.y, r, 0, Math.PI*2); ctx.stroke();
  }
}

/* =========================
   GALAXY — center-dwell pulse + shockwave
   ========================= */

const GAL = {
  inited: false,
  t: 0,
  armStars: [],
  halo: [],
  dust: [],
  hue: 220,
  rot: 0,
  // center-dwell effect
  centerT: 0,
  pulse: 0,
  rings: [],
  cool: 0
};

function galaxyInit(){
  GAL.inited = true;
  GAL.armStars.length = 0;
  GAL.halo.length = 0;
  GAL.dust.length = 0;

  const sN = sizeNorm();
  const intensity = mapIntensity();

  const arms = 3 + Math.floor(1*intensity);                 // 3–4 arms
  const starCount = Math.floor(1200 + 2600 * sN);            // ↑ more stars
  const haloCount = Math.floor(480 + 1100 * sN);             // ↑ more halo
  const rMax = Math.min(W, H) * (0.62 + 0.25*sN);            // ↑ larger radius

  // Log spiral r = a * e^(bθ) — fairly loose for a diffuse look
  const a = 6;
  const b = 0.14 + 0.08*intensity;

  // Arm stars
  for (let i=0; i<starCount; i++){
    const arm = (i % arms);
    const theta = (Math.random()*Math.PI*6) + (arm * (2*Math.PI/arms));
    let r = a * Math.exp(b * theta);
    r += (Math.random()-0.5) * (38 + r*0.18); // widen a bit more

    const rr = Math.min(r, rMax * (0.85 + Math.random()*0.15));
    const x = Math.cos(theta) * rr;
    const y = Math.sin(theta) * rr;

    const z = 0.6 + Math.random()*0.7; // depth
    const hueJit = (Math.random()*26 - 13);
    const L = 58 + Math.random()*28;

    GAL.armStars.push({
      x, y, z,
      s: 0.9 + 1.5*z,                         // ↑ per-star size
      a: 0.22 + Math.random()*0.55,
      h: (GAL.hue + hueJit) % 360,
      l: L,
      tw: Math.random()*Math.PI*2
    });
  }

  // Diffuse halo
  for (let i=0; i<haloCount; i++){
    const u = Math.random(), v = Math.random();
    const r = Math.sqrt(u) * rMax * (0.3 + 0.7*v);
    const th = Math.random()*Math.PI*2;
    const x = Math.cos(th)*r, y=Math.sin(th)*r;
    const z = 0.5 + Math.random()*1.0;
    GAL.halo.push({
      x, y, z,
      s: 0.7 + 1.2*z,                         // ↑ halo speck size
      a: 0.10 + Math.random()*0.25,
      h: (GAL.hue + 150 + Math.random()*40) % 360,
      l: 52 + Math.random()*30,
      tw: Math.random()*Math.PI*2
    });
  }

  // Background dust
  const dustN = Math.floor(160 + 520*sN);
  for (let i=0; i<dustN; i++){
    GAL.dust.push({
      x: Math.random()*W,
      y: Math.random()*H,
      z: 0.3 + Math.random()*1.2,
      r: 0.6 + Math.random()*1.6,
      a: 0.10 + Math.random()*0.30,
      tw: Math.random()*Math.PI*2
    });
  }
}

function galaxyResize(){}

function renderGalaxy(dt){
  if (!GAL.inited) galaxyInit();

  const intensity = mapIntensity();
  const sN = sizeNorm();
  GAL.t += dt;
  GAL.hue = (GAL.hue + 6*dt) % 360;

  clearToBg(false);

  // ---- BACKGROUND DUST ----
  ctx.globalCompositeOperation = 'screen';
  const parX = (mouse.x - W*0.5) * 0.04;
  const parY = (mouse.y - H*0.5) * 0.03;
  for (let i=0;i<GAL.dust.length;i++){
    const d = GAL.dust[i];
    d.tw += dt * (0.3 + 0.7*d.z);
    d.x += Math.sin(d.tw*0.7 + d.z*9) * 0.06;
    d.y += Math.cos(d.tw*0.6 + d.z*7) * 0.05;
    if (d.x < -6) d.x = W+6; else if (d.x > W+6) d.x = -6;
    if (d.y < -6) d.y = H+6; else if (d.y > H+6) d.y = -6;

    const px = d.x - parX*d.z, py = d.y - parY*d.z;
    const tw = 0.6 + 0.4*Math.sin(d.tw*1.5 + d.z*8);
    ctx.fillStyle = `hsla(${(GAL.hue+160)%360}, 85%, ${58+26*d.z}%, ${(d.a*tw)*(0.7+0.6*intensity)})`;
    ctx.beginPath(); ctx.arc(px, py, d.r, 0, Math.PI*2); ctx.fill();
  }

  // ---- CORE GLOW ----
  const cx=W*0.5, cy=H*0.5;
  const coreR = 60 + mapSize()*0.28;
  ctx.globalCompositeOperation='lighter';
  const gCore = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
  gCore.addColorStop(0, `hsla(${(GAL.hue+10)%360}, 90%, 76%, ${0.26 + 0.25*GAL.pulse})`); // brighter when pulsing
  gCore.addColorStop(1, `hsla(${(GAL.hue+60)%360}, 80%, 50%, 0)`);
  ctx.fillStyle = gCore; ctx.beginPath(); ctx.arc(cx, cy, coreR, 0, Math.PI*2); ctx.fill();

  // ---- CENTER DWELL detection ------------------------------------------
  const dC = Math.hypot(mouse.x-cx, mouse.y-cy);
  const centerR = coreR * 1.15;
  if (dC < centerR) GAL.centerT += dt; else GAL.centerT = Math.max(0, GAL.centerT - dt*0.8);
  GAL.cool = Math.max(0, GAL.cool - dt);

  if (GAL.centerT >= 1.2 && GAL.cool === 0){
    GAL.centerT = 0;
    GAL.pulse = 1;                          // kick the pulse
    GAL.cool  = 1.0;                        // short cooldown
    GAL.rings.push({ t:0, hue:(GAL.hue+100)%360 });  // shockwave
    // soft ping (optional)
    if (typeof playPing === 'function') playPing(520, 0.16, 0.04);
  }

  // ---- SPIN (faster near center) + pulse boost + GAZE VECTORS ----------
  const maxC = Math.hypot(W*0.5, H*0.5);
  const centerN = clamp(1 - dC / maxC, 0, 1);     // 0 at edge, 1 at center
  const baseSpin = 0.022 + 0.20*intensity;        // edge speed
  const spin = baseSpin * (1 + centerN);          // up to ~2× at center
  const rotBoost = 1 + 0.6*GAL.pulse;             // brief extra spin on pulse
  GAL.rot = (GAL.rot + spin*rotBoost*dt) % (Math.PI*2);

  const gx = mouse.x - cx, gy = mouse.y - cy;
  const gLen = Math.hypot(gx, gy) || 1;
  const gDirX = gx/gLen, gDirY = gy/gLen;
  const gazeN = clamp(gLen / Math.hypot(W*0.5, H*0.5), 0, 1);

  const shearAmt = (0.16 + 0.32*intensity) * gazeN;
  const lensAmt  = 0.012 + 0.028*intensity;
  const vortexBase = (0.06 + 0.22*intensity);
  const pullBase   = (0.02 + 0.10*intensity);

  // warm shift helper toward ~30° (amber)
  const warmHue = 30;
  const hueLerp = (h, t)=> (h + ((warmHue - h + 540)%360 - 180)*t);

  function drawCloud(list, sizeBoostBase){
    for (let i=0;i<list.length;i++){
      const s = list[i];

      // depth-weighted rotation
      const cos = Math.cos(GAL.rot * (0.7 + 0.4/s.z));
      const sin = Math.sin(GAL.rot * (0.7 + 0.4/s.z));
      let lx = s.x*cos - s.y*sin;
      let ly = s.x*sin + s.y*cos;

      // shear toward gaze + tiny lens distortion
      const along = lx*gDirX + ly*gDirY;
      lx += gDirX * along * shearAmt;
      ly += gDirY * along * shearAmt;
      lx += (lx*gx + ly*gy) * lensAmt * 0.001;

      let px = cx + lx;
      let py = cy + ly;

      // local pointer influence: vortex + radial pull
      const dx = mouse.x - px, dy = mouse.y - py;
      const dd = Math.hypot(dx,dy) || 1;
      const near = clamp(1 - dd / (140 + 260*sizeNorm()), 0, 1);
      if (near > 0){
        const tx = -dy/dd, ty = dx/dd;
        const v = vortexBase * Math.pow(near, 1.2);
        const p = pullBase   * Math.pow(near, 1.1);
        px += (tx * v + (dx/dd) * p) * (40 + 80*sN);
        py += (ty * v + (dy/dd) * p) * (40 + 80*sN);
      }

      // twinkle
      s.tw += dt*(0.6 + 0.8*s.z);
      const tw = 0.65 + 0.35*Math.sin(s.tw + i*0.37);

      // warm near-gaze + pulse lift near center
      const centerNear = clamp(1 - Math.hypot(px-cx, py-cy) / (coreR*2.2), 0, 1);
      const warmT = Math.pow(near, 1.25) * (0.55 + 0.35*intensity) + GAL.pulse*0.35*centerNear;

      const hue = hueLerp(s.h, warmT);
      const light = s.l + 10*warmT;
      const satBoost = 1 + 0.10*warmT;

      let alpha = (s.a*tw) * (0.75 + 0.7*intensity) * (1 + 0.9*near);
      alpha *= (1 + 0.6 * GAL.pulse * centerNear);

      let rad = Math.max(0.6, (sizeBoostBase * s.s) * (0.8 + 0.4*tw) * (1 + 0.9*near));
      rad *= (1 + 0.18 * GAL.pulse * centerNear);

      ctx.fillStyle = `hsla(${hue}, ${Math.min(100, 90*satBoost)}%, ${light}%, ${alpha})`;
      ctx.beginPath(); ctx.arc(px, py, rad, 0, Math.PI*2); ctx.fill();

      if (intensity > 0.25){
        ctx.strokeStyle = `hsla(${(hue+20)%360}, 95%, 70%, ${alpha*0.28})`;
        ctx.lineWidth = Math.max(1, rad*0.7);
        ctx.beginPath();
        ctx.moveTo(px - sin*rad*1.6, py + cos*rad*1.6);
        ctx.lineTo(px + sin*rad*0.5, py - cos*rad*0.5);
        ctx.stroke();
      }
    }
  }

  // Pointer glow — smaller & subtler color zone
  ctx.globalCompositeOperation='screen';
  const glowR = 70 + 150*sizeNorm();
  const g = ctx.createRadialGradient(mouse.x, mouse.y, glowR*0.15, mouse.x, mouse.y, glowR);
  g.addColorStop(0, `hsla(${(GAL.hue+100)%360}, 85%, 70%, ${0.08 + 0.08*intensity})`);
  g.addColorStop(1, `hsla(${(GAL.hue+60)%360}, 80%, 50%, 0)`);
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, glowR, 0, Math.PI*2); ctx.fill();

  // Draw clouds — ↑ size boost to make the galaxy visually larger
  drawCloud(GAL.halo, 1.4 + 0.8*sizeNorm());
  drawCloud(GAL.armStars, 1.6 + 1.0*sizeNorm());

  // ---- Shockwave rings + pulse decay ------------------------------------
  const maxR = Math.min(W, H) * 0.9;
  ctx.globalCompositeOperation = 'screen';
  for (let i=GAL.rings.length-1; i>=0; i--){
    const r = GAL.rings[i];
    r.t += dt;
    const p = r.t / 0.9;                     // ring duration
    if (p >= 1){ GAL.rings.splice(i,1); continue; }
    const rr = Math.pow(p, 0.6) * maxR;
    const a  = (1 - p) * (0.35 + 0.25*intensity);
    ctx.strokeStyle = `hsla(${(r.hue+40)%360}, 95%, 75%, ${a})`;
    ctx.lineWidth = 1.5 + 6*(1-p);
    ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.stroke();
  }

  // decay the pulse
  GAL.pulse = lerp(GAL.pulse, 0, 1 - Math.pow(0.04, dt*60));
}



  /* =========================
     GELÉE
     ========================= */
  const blobs = Array.from({length:6}, ()=>({
    x: W*(0.2+0.6*Math.random()),
    y: H*(0.2+0.6*Math.random()),
    r: 40+Math.random()*80,
    hue: Math.random()*360,
    vx:0, vy:0
  }));
  function renderJelly(dt){
    clearToBg(false);
    const intensity = mapIntensity();
    const pull = 18*intensity;
    const damping = 0.99;
    const gravity = 0.012;
    const sizeJ = mapSizeJelly();

    blobs.forEach(b=>{
      const dx = mouse.x - b.x, dy = mouse.y - b.y;
      b.vx += dx * pull * 0.00018;
      b.vy += dy * pull * 0.00018 + gravity;
      b.vx *= damping; b.vy *= damping;
      b.x += b.vx; b.y += b.vy;
      if (b.x < -120) b.x = W+120; else if (b.x > W+120) b.x = -120;
      if (b.y < -120) b.y = H+120; else if (b.y > H+120) b.y = -120;
    });

    const parts = blobs.map(b=>{
      const speed = Math.hypot(b.vx, b.vy);
      const squish = clamp(1 + speed*0.03, 1, 1.5) * (1 + dwellFactor()*0.15);
      const rx = b.r * squish * (sizeJ/95);
      const ry = b.r * (2 - squish) * (sizeJ/95);
      const R  = (rx + ry) * 0.5;
      const h  = (b.hue + performance.now()*0.02)%360;
      return { b, rx, ry, R, h, squish };
    });

    for (let iter=0; iter<2; iter++){
      for (let i=0; i<parts.length; i++){
        for (let j=i+1; j<parts.length; j++){
          const pi = parts[i], pj = parts[j];
          const ax = pi.b.x, ay = pi.b.y;
          const bx = pj.b.x, by = pj.b.y;
          let dx = bx - ax, dy = by - ay;
          let d = Math.hypot(dx,dy);
          if (d === 0){ dx = (Math.random()-0.5)*0.001; dy=(Math.random()-0.5)*0.001; d = Math.hypot(dx,dy); }
          const minD = (pi.R + pj.R) * 0.95;
          if (d < minD){
            const push = (minD - d) * 0.5;
            const nx = dx / d, ny = dy / d;
            pi.b.x -= nx*push; pi.b.y -= ny*push;
            pj.b.x += nx*push; pj.b.y += ny*push;
            pi.b.vx *= 0.9; pi.b.vy *= 0.9;
            pj.b.vx *= 0.9; pj.b.vy *= 0.9;
          }
        }
      }
    }

    const links = [];
    for (let i=0;i<parts.length;i++){
      let bestJ=-1, bestD=1e9;
      for (let j=0;j<parts.length;j++){
        if (j===i) continue;
        const di = Math.hypot(parts[j].b.x - parts[i].b.x, parts[j].b.y - parts[i].b.y);
        if (di < bestD){ bestD=di; bestJ=j; }
      }
      if (bestJ>=0){
        const span = (parts[i].R + parts[bestJ].R) * 0.8;
        if (bestD < span) links.push([i, bestJ, bestD, span]);
      }
    }
    links.sort((A,B)=>A[2]-B[2]);
    if (links.length > 12) links.length = 12;

    ctx.lineJoin='round'; ctx.lineCap='round';
    parts.forEach(p=>{
      const b = p.b;
      ctx.globalCompositeOperation='multiply';
      const sx = b.x + b.vx*4, sy = b.y + b.vy*4;
      const sg = ctx.createRadialGradient(sx, sy, Math.min(p.rx,p.ry)*0.2, sx, sy, Math.max(p.rx,p.ry)*1.05);
      sg.addColorStop(0, 'rgba(0,0,0,0.10)');
      sg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = sg;
      ctx.beginPath(); ctx.ellipse(sx, sy, p.rx*1.02, p.ry*1.02, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.fill();
    });

    parts.forEach(p=>{
      const b = p.b;
      ctx.globalCompositeOperation='lighter';
      const g = ctx.createRadialGradient(b.x, b.y, Math.min(p.rx,p.ry)*0.28, b.x, b.y, Math.max(p.rx,p.ry));
      g.addColorStop(0.00, `hsla(${p.h},95%,58%,0.60)`);
      g.addColorStop(0.55, `hsla(${(p.h+30)%360},95%,50%,0.32)`);
      g.addColorStop(1.00, `hsla(${(p.h+60)%360},90%,45%,0.0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.ellipse(b.x, b.y, p.rx, p.ry, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.fill();

      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(p.h+40)%360},95%,80%,0.35)`;
      ctx.lineWidth = Math.max(1.2, 1.5 + sizeJ*0.01);
      ctx.beginPath(); ctx.ellipse(b.x, b.y, p.rx*0.98, p.ry*0.98, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.stroke();

      const glx = b.x - p.rx*0.28, gly = b.y - p.ry*0.28;
      const glr = Math.min(p.rx,p.ry)*0.22;
      const gl = ctx.createRadialGradient(glx, gly, glr*0.2, glx, gly, glr);
      gl.addColorStop(0, 'rgba(255,255,255,0.25)');
      gl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gl;
      ctx.beginPath(); ctx.arc(glx, gly, glr, 0, Math.PI*2); ctx.fill();
    });

    ctx.globalCompositeOperation='screen';
    links.forEach(link=>{
      const i = link[0], j = link[1], d = link[2], span = link[3];
      const a = parts[i], b = parts[j];
      const t = clamp(1 - d/span, 0, 1);
      if (t <= 0) return;
      const midH = ((a.h + b.h)*0.5) % 360;
      ctx.strokeStyle = `hsla(${midH},95%,70%,${0.08 + 0.22*t*(0.6+0.4*mapIntensity())})`;
      ctx.lineWidth = 2 + t * (2 + mapSizeJelly()*0.02);
      const mx = (a.b.x + b.b.x) * 0.5;
      const my = (a.b.y + b.b.y) * 0.5;
      const cx = mx + (mouse.x - mx) * 0.02 * t;
      const cy = my + (mouse.y - my) * 0.02 * t;
      ctx.beginPath();
      ctx.moveTo(a.b.x, a.b.y);
      ctx.quadraticCurveTo(cx, cy, b.b.x, b.b.y);
      ctx.stroke();
    });

    if (dwellJustCrossed(900)){
      playPing(330,0.12,0.05);
      blobs.forEach(b=>{ b.vx*=0.6; b.vy*=-0.8; b.hue = (b.hue+15)%360; });
    }
  }

  /* =========================
     SNOW — simplified & reactive
     ========================= */
  const SNOW = {
    layers: [[],[],[]],
    ground: { cell: 6, cols: 0, h: null },
    frameCounter: 0
  };

  function snowResize(){
    const c = SNOW.ground.cell;
    SNOW.ground.cols = Math.max(4, Math.floor(W / c));
    SNOW.ground.h = new Float32Array(SNOW.ground.cols);
    SNOW.ground.h.fill(0);
    initSnowFlakes();
  }

  function initSnowFlakes(){
    SNOW.layers.forEach(a=>a.length=0);
    const density = 0.00006;
    const N = clamp(Math.floor(W*H*density*(0.7 + 0.9*mapIntensity())), 180, 900);
    const counts = [Math.floor(N*0.35), Math.floor(N*0.40), N];
    for (let i=0;i<counts[0];i++) SNOW.layers[0].push(makeFlake(0.35));
    for (let i=0;i<counts[1];i++) SNOW.layers[1].push(makeFlake(0.65));
    for (let i=0;i<counts[2];i++) SNOW.layers[2].push(makeFlake(0.95));
  }

  function makeFlake(depth){
    const z = depth;
    const baseR = 0.8 + 2.2*z + sizeNorm()*1.4*z;
    const speed = (0.10 + 0.50*z) * (0.75 + 0.6*mapIntensity());
    return {
      x: Math.random()*W,
      y: Math.random()*H,
      z,
      r: baseR,
      vx: (Math.random()-0.5)*0.06*z,
      vy: speed,
      phase: Math.random()*Math.PI*2,
      swayAmp: 0.15 + 0.9*z
    };
  }
  function resetFlake(f, burst=false){
    f.x = Math.random()*W;
    f.y = (-20) - Math.random()*40;
    f.vx = (Math.random()-0.5)*0.08*f.z + (burst? (Math.random()-0.5)*0.6 : 0);
    f.vy = (0.10 + 0.50*f.z) * (0.75 + 0.6*mapIntensity()) + (burst? -0.3 : 0);
    f.phase = Math.random()*Math.PI*2;
  }

  function groundDeposit(x, amount){
    const G = SNOW.ground;
    const i = clamp(Math.floor(x / G.cell), 0, G.cols-1);
    G.h[i] += amount;
  }

  function groundDiffuseCheap(){
    const G = SNOW.ground;
    for (let i=1;i<G.cols-1;i++){
      const avg = (G.h[i-1]+G.h[i]+G.h[i+1]) / 3;
      G.h[i] = lerp(G.h[i], avg, 0.25);
    }
  }

  function drawSky(){
    ctx.globalCompositeOperation='source-over';
    const isLight = document.body.classList.contains('light');
    const g = ctx.createLinearGradient(0,0,0,H);
    if (isLight){
      g.addColorStop(0, 'rgba(225,235,255,1)');
      g.addColorStop(1, 'rgba(245,250,255,1)');
    } else {
      g.addColorStop(0, 'rgba(12,18,28,1)');
      g.addColorStop(1, 'rgba(16,24,36,1)');
    }
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawGround(){
    const {h, cols, cell} = SNOW.ground;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = 'rgba(255,255,255,0.96)';
    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let i=0;i<cols;i++){
      const x = i*cell;
      ctx.lineTo(x, H - h[i]);
    }
    ctx.lineTo(W, H - h[cols-1]);
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();
  }

  function renderSnow(dt){
    clearToBg(false);
    drawSky();

    const intensity = mapIntensity();
    const sN = sizeNorm();

    const windX = mouse.vx * 0.0016 * (0.6 + 1.0*intensity);
    const windY = mouse.vy * 0.0012 * (0.4 + 0.8*intensity);

    const radius = 180 + 140*sN;
    const invR = 1 / Math.max(1, radius);
    const pullBase = (mouse.down ? 0.9 : 0.6) * (0.4 + 1.2*intensity);

    const layerAlphas = [0.35, 0.55, 0.85];

    for (let L=0; L<3; L++){
      const arr = SNOW.layers[L];
      const alpha = layerAlphas[L];
      ctx.globalCompositeOperation='source-over';
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.beginPath();

      for (let i=0;i<arr.length;i++){
        const f = arr[i];

        f.phase += dt*(0.5 + 0.8*f.z);
        const sway = Math.sin(f.phase) * f.swayAmp;

        const dx = mouse.x - f.x;
        const dy = mouse.y - f.y;
        const d  = Math.hypot(dx,dy);
        const t  = clamp(1 - d*invR, 0, 1);
        const pull = (pullBase) * (t*t);

        f.vx += sway*0.02*dt + windX*(0.4 + 0.8*f.z) + (dx * pull * 0.06);
        f.vy += (0.03 + 0.10*f.z) + windY*(0.3 + 0.7*f.z) + (dy * pull * 0.06) - (t*0.06);

        const drag = 1 - (0.08 + 0.04*f.z)*dt;
        f.vx *= drag; f.vy *= drag;

        f.x += f.vx; f.y += f.vy;

        if (f.x < -8) f.x = W+8; else if (f.x > W+8) f.x = -8;

        const G = SNOW.ground;
        const col = clamp(Math.floor(f.x / G.cell), 0, G.cols-1);
        const surfaceY = H - G.h[col];
        if (f.y + f.r >= surfaceY){
          groundDeposit(f.x, clamp(f.r*0.5, 0.4, 2));
          resetFlake(f);
        }

        if (f.y > H + 40) resetFlake(f);

        ctx.moveTo(f.x + f.r, f.y);
        ctx.arc(f.x, f.y, Math.max(0.7, f.r), 0, Math.PI*2);
      }
      ctx.fill();
    }

    if ((SNOW.frameCounter++ & 7) === 0) groundDiffuseCheap();

    drawGround();

    if (dwellJustCrossed(800)){
      playPing(880,0.16,0.04);
      const arr = SNOW.layers[2];
      for (let k=0;k<20;k++){
        const nf = makeFlake(0.95);
        nf.x = mouse.x + (Math.random()-0.5)*40;
        nf.y = mouse.y + (Math.random()-0.5)*40;
        nf.vx += (Math.random()-0.5)*0.6 + windX*20;
        nf.vy += (Math.random()-0.5)*0.4 + windY*20 - 0.2;
        arr.push(nf);
      }
      if (arr.length > 600) arr.splice(0, arr.length-600);
    }
  }

/* =========================
   SAND (Cellular) — globally smaller grains
   ========================= */
const SAND_CELL = (()=> {
  const state = {
    cellSize: 3,          // dynamic, will be set from slider on init
    cols: 0, rows: 0,
    grid: null,
    palette: [],
    lastHueBase: 0
  };

  function desiredCellSizeFromSlider(){
    // Make everything smaller:
    // Taille 0..1  ->  2..6 px (nonlinear growth).
    // (Prev max was 15px; this is ~2.5× smaller at the top end.)
    const n = sizeNorm();                // 0..1 from the Taille slider
    const min = 2;
    const max = 6;
    const shaped = Math.pow(n, 1.2);     // gentle ease-in
    return Math.max(1, Math.round(min + (max - min) * shaped));
  }

  function allocGrid(){
    state.cols = Math.floor(W / state.cellSize);
    state.rows = Math.floor(H / state.cellSize);
    state.grid = new Int16Array(state.cols * state.rows);
    state.grid.fill(-1);
    state.palette = new Array(360);
    for (let h=0; h<360; h++) state.palette[h] = `hsla(${h},95%,60%,1)`;
  }

  function ensureCellSizeUpToDate(){
    const target = desiredCellSizeFromSlider();
    if (target !== state.cellSize){
      state.cellSize = target;
      allocGrid();
    }
  }

  const idx = (x,y)=> y*state.cols + x;
  const inBounds = (x,y)=> (x>=0 && x<state.cols && y>=0 && y<state.rows);

  function caSandReset(){ state.cellSize = desiredCellSizeFromSlider(); allocGrid(); }
  function caSandOnResize(){ state.cellSize = desiredCellSizeFromSlider(); allocGrid(); }

  function caEmitSand(px, py, n){
    const cs = state.cellSize;
    const cx = Math.floor(px / cs);
    const cy = Math.floor(py / cs);
    for (let i=0;i<n;i++){
      const rx = cx + ((Math.random()*5)|0) - 2;
      const ry = cy + ((Math.random()*5)|0) - 2;
      if (!inBounds(rx, ry)) continue;
      const id = idx(rx, ry);
      if (state.grid[id] === -1){
        const hue = ((state.lastHueBase + (Math.random()*40|0)) % 360)|0;
        state.grid[id] = hue;
      }
    }
  }

  function caStep(windBias){
    const C = state.cols, R = state.rows;
    const leftFirst = windBias < 0 ? true : windBias > 0 ? false : (Math.random() < 0.5);
    for (let y=R-2; y>=0; y--){
      const leftSweep = (Math.random() < 0.5);
      if (leftSweep){
        for (let x=0; x<C; x++){
          const i = y*C + x; const hue = state.grid[i]; if (hue === -1) continue;
          const iD = i + C;
          if (state.grid[iD] === -1){ state.grid[i] = -1; state.grid[iD] = hue; continue; }
          const tryDiag = leftFirst ? [-1,1] : [1,-1];
          for (let k=0;k<2;k++){
            const nx = x + tryDiag[k], ny = y + 1;
            if (nx<0 || nx>=C) continue;
            const ii = ny*C + nx;
            if (state.grid[ii] === -1){ state.grid[i] = -1; state.grid[ii] = hue; break; }
          }
        }
      } else {
        for (let x=C-1; x>=0; x--){
          const i = y*C + x; const hue = state.grid[i]; if (hue === -1) continue;
          const iD = i + C;
          if (state.grid[iD] === -1){ state.grid[i] = -1; state.grid[iD] = hue; continue; }
          const tryDiag = leftFirst ? [-1,1] : [1,-1];
          for (let k=0;k<2;k++){
            const nx = x + tryDiag[k], ny = y + 1;
            if (nx<0 || nx>=C) continue;
            const ii = ny*C + nx;
            if (state.grid[ii] === -1){ state.grid[i] = -1; state.grid[ii] = hue; break; }
          }
        }
      }
    }
  }

  function caDraw(){
    const cs = state.cellSize, C = state.cols, R = state.rows;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#000000';
    ctx.fillRect(0,0,W,H);

    for (let y=0; y<R; y++){
      let x=0;
      while (x<C){
        const h = state.grid[y*C + x];
        if (h === -1){ x++; continue; }
        let run = 1;
        while (x+run < C && state.grid[y*C + (x+run)] === h) run++;
        ctx.fillStyle = state.palette[h];
        ctx.fillRect(x*cs, y*cs, run*cs, cs);
        x += run;
      }
    }
  }

  function caRender(dt){
    ensureCellSizeUpToDate();
    state.lastHueBase = (state.lastHueBase + 60*dt) % 360;

    // Smaller grains = more cells; trim spawn a touch to keep perf balanced.
    const sizeFactor = state.cellSize / 3;               // ~0.67..2 vs old default
    const baseRate   = 4 + Math.floor(12 * mapIntensity());
    const dwellBoost = dwellMs>600 ? 4 : 0;
    const toSpawn    = Math.round((baseRate + dwellBoost) * (0.75 + 0.25*sizeFactor));

    caEmitSand(mouse.x, mouse.y, toSpawn + Math.floor(mouse.speed/250));

    const windBias = clamp(mouse.vx/1000, -1, 1);
    for (let s=0; s<2; s++) caStep(windBias);

    caDraw();
    if (dwellJustCrossed(700)) playPing(700,0.12,0.05);
  }

  return { caSandReset, caSandOnResize, caRender };
})();
function caSandOnResize(){ SAND_CELL.caSandOnResize(); }
(function(){ SAND_CELL.caSandReset(); })();
 /* =========================
     ESSAIM MAGNÉTIQUE
     ========================= */


/* =========================
     ESSAIM MAGNÉTIQUE — jitter-tamed + population healer
   ========================= */

const MAG = {
  pins: [],
  t: 0,
  // stability helpers
  axis: { x: 0, y: -1 },   // smoothed pole axis (unit vector)
  polarity: 1,
  flipCooldown: 0,
  poles: { xN: 0, yN: 0, xS: 0, yS: 0, inited: false },

  // population health
  healTimer: 0,
};

function magnetTargetCount(){ return Math.floor(160 + 500 * sizeNorm()); }
function makePin(){
  return {
    x: Math.random()*W, y: Math.random()*H,
    vx: 0, vy: 0,
    fx: 0, fy: 0,
    // health tracking
    slowT: 0,           // time spent “very slow”
    farT: 0             // time spent far from cursor
  };
}
function magnetResize(){ MAG.pins.forEach(p=>{ p.x = clamp(p.x,0,W); p.y = clamp(p.y,0,H); }); }
function ensureMagnetPins(){
  const target = magnetTargetCount();
  const cur = MAG.pins.length;
  if (cur < target){ for (let i=0;i<target-cur;i++) MAG.pins.push(makePin()); }
  else if (cur > target){ MAG.pins.splice(0, cur-target); }
}

function smoothDir(prev, tx, ty, k){
  const x = prev.x + (tx - prev.x) * k;
  const y = prev.y + (ty - prev.y) * k;
  const m = Math.hypot(x,y) || 1;
  return { x:x/m, y:y/m };
}

function renderMagnet(dt){
  ensureMagnetPins();
  clearToBg(false);

  const sN = sizeNorm();
  const intensity = mapIntensity();

  const sep  = 28 + 140*sN;
  const soft = 120;

  // --- Smooth pole axis
  {
    const vlen = Math.hypot(mouse.vx, mouse.vy);
    if (vlen > 60){
      const tx = mouse.vx / vlen, ty = mouse.vy / vlen;
      MAG.axis = smoothDir(MAG.axis, tx, ty, 1 - Math.pow(0.14, dt*60));
    } else {
      MAG.axis = smoothDir(MAG.axis, 0, -1, 1 - Math.pow(0.08, dt*60));
    }
  }

  // target poles
  const hx = MAG.axis.x, hy = MAG.axis.y;
  const tN = { x: mouse.x + hx*sep*0.5, y: mouse.y + hy*sep*0.5 };
  const tS = { x: mouse.x - hx*sep*0.5, y: mouse.y - hy*sep*0.5 };

  // --- Smooth pole positions
  {
    const kPole = 1 - Math.pow(0.10, dt*60);
    if (!MAG.poles.inited){
      MAG.poles = { xN:tN.x, yN:tN.y, xS:tS.x, yS:tS.y, inited:true };
    } else {
      MAG.poles.xN += (tN.x - MAG.poles.xN) * kPole;
      MAG.poles.yN += (tN.y - MAG.poles.yN) * kPole;
      MAG.poles.xS += (tS.x - MAG.poles.xS) * kPole;
      MAG.poles.yS += (tS.y - MAG.poles.yS) * kPole;
    }
  }
  const pxN = MAG.poles.xN, pyN = MAG.poles.yN;
  const pxS = MAG.poles.xS, pyS = MAG.poles.yS;

  // polarity (dwell)
  MAG.flipCooldown = Math.max(0, MAG.flipCooldown - dt);
  const wantPol = (dwellMs>600) ? -1 : 1;
  if (wantPol !== MAG.polarity && MAG.flipCooldown === 0){
    MAG.polarity = wantPol;
    MAG.flipCooldown = 0.30;
  }
  const polarity = MAG.polarity;

  // pole glows
  ctx.globalCompositeOperation='screen';
  const gN = ctx.createRadialGradient(pxN,pyN,sep*0.1, pxN,pyN, sep*0.9);
  gN.addColorStop(0, 'hsla(0,100%,60%,0.45)');
  gN.addColorStop(1, 'hsla(0,100%,60%,0)');
  ctx.fillStyle=gN; ctx.beginPath(); ctx.arc(pxN,pyN,sep*0.9,0,Math.PI*2); ctx.fill();

  const gS = ctx.createRadialGradient(pxS,pyS,sep*0.1, pxS,pyS, sep*0.9);
  gS.addColorStop(0, 'hsla(210,100%,60%,0.45)');
  gS.addColorStop(1, 'hsla(210,100%,60%,0)');
  ctx.fillStyle=gS; ctx.beginPath(); ctx.arc(pxS,pyS,sep*0.9,0,Math.PI*2); ctx.fill();

  // field lines
  const lines = 10;
  ctx.strokeStyle = `hsla(${polarity>0?30:200},100%,75%,${0.18+0.28*intensity})`;
  ctx.lineWidth = 1 + 1.8*sN;
  ctx.beginPath();
  for (let i=0;i<lines;i++){
    const a = (i/lines)*Math.PI*2 + MAG.t*0.4;
    const r1 = sep*0.25, r2 = sep*(1.0 + 0.2*Math.sin(MAG.t*0.8+i));
    const x1 = mouse.x + Math.cos(a)*r1, y1 = mouse.y + Math.sin(a)*r1;
    const cx = mouse.x + Math.cos(a+Math.PI/2)*r2*0.5;
    const cy = mouse.y + Math.sin(a+Math.PI/2)*r2*0.5;
    ctx.moveTo(pxN,pyN); ctx.quadraticCurveTo(cx,cy,pxS,pyS);
    ctx.moveTo(x1,y1);   ctx.quadraticCurveTo(cx,cy,pxS,pyS);
  }
  ctx.stroke();

  // physics params
  const baseK = 240 + 560*intensity;
  const boost  = mouse.down ? 1.5 : 1.0;

  // motion-aware swirl (less when fast)
  const vMoveN = clamp(Math.hypot(mouse.vx, mouse.vy)/1400, 0, 1);
  const swirl  = (0.6 + 2.2*intensity) * (1 - 0.55*vMoveN);

  const windX = mouse.vx * 0.0006, windY = mouse.vy * 0.00045;

  // soften near-pole force spikes
  const innerR = 28 + 42*sN;
  const innerR2 = innerR * innerR;

  // gentle “return” radius (only if pin is really far)
  const healR = Math.hypot(W, H) * 0.55;
  const healR2 = healR * healR;

  function poleForce(p, cx, cy, sign){
    const dx = cx - p.x, dy = cy - p.y;
    const r2 = dx*dx + dy*dy + soft;
    const r  = Math.sqrt(r2);
    const invR = 1 / r;

    const near = Math.min(1, r2 / innerR2);
    const invR3 = invR * invR * invR * near;

    const f = baseK * boost * sign * invR3;
    return { fx: dx * f, fy: dy * f };
  }

  ctx.globalCompositeOperation='lighter';
  ctx.lineCap='round';
  const segLen = 8 + 20*sN;
  const vMax = 26 + 30*intensity;
  const aMax = 1500;
  const damp = 0.965 - 0.08*intensity + (mouse.down?-0.02:0);

  const kF = 1 - Math.pow(0.25 - 0.15*intensity, dt*60);

  // population stats
  let farCount = 0;

  for (let i=0;i<MAG.pins.length;i++){
    const p = MAG.pins[i];

    // forces: poles
    const q = 1 * polarity;
    let f1 = poleForce(p, pxN, pyN, +q);
    let f2 = poleForce(p, pxS, pyS, -q);
    let ax = f1.fx + f2.fx;
    let ay = f1.fy + f2.fy;

    // swirl + wind
    const cx = mouse.x - p.x, cy = mouse.y - p.y;
    const c2 = cx*cx + cy*cy + 1;
    const cInv = 1/Math.sqrt(c2);
    ax += swirl * (-cy*cInv) * 0.35;
    ay += swirl * ( cx*cInv) * 0.35;

    ax += windX + (Math.random()-0.5)*0.0005;
    ay += windY + (Math.random()-0.5)*0.0005;

    // tiny center/return only if very far (prevents slow attrition)
    const d2 = (p.x-mouse.x)*(p.x-mouse.x) + (p.y-mouse.y)*(p.y-mouse.y);
    if (d2 > healR2){
      const d = Math.sqrt(d2) || 1;
      const back = (d - healR) / d;                 // 0 just inside, grows outside
      ax += (mouse.x - p.x) * back * 0.0025;        // very gentle
      ay += (mouse.y - p.y) * back * 0.0025;
      farCount++;
    }

    // anti-oscillation when crawling
    const sp = Math.hypot(p.vx, p.vy);
    if (sp < 6){
      const dot = p.vx*ax + p.vy*ay;
      if (dot < 0){ ax *= 0.6; ay *= 0.6; }
    }

    // accel cap
    const aMag = Math.hypot(ax, ay);
    if (aMag > aMax){ const s = aMax / aMag; ax *= s; ay *= s; }

    // force low-pass
    p.fx += (ax - p.fx) * kF;
    p.fy += (ay - p.fy) * kF;

    // integrate
    p.vx = (p.vx + p.fx * dt * 600) * damp;
    p.vy = (p.vy + p.fy * dt * 600) * damp;

    // speed clamp
    const sp2 = Math.hypot(p.vx, p.vy);
    if (sp2 > vMax){ const s = vMax / sp2; p.vx *= s; p.vy *= s; }

    // health: track “very slow” and “far” dwell times
    if (sp2 < 0.6) p.slowT += dt; else p.slowT = 0;
    if (d2 > healR2) p.farT += dt; else p.farT = 0;

    // if stuck slow for long, give a tiny random nudge
    if (p.slowT > 2.0){
      p.vx += (Math.random()-0.5)*0.8;
      p.vy += (Math.random()-0.5)*0.8;
      p.slowT = 0.8;
    }

    // draw trail
    const px0 = p.x - p.vx*segLen*0.04;
    const py0 = p.y - p.vy*segLen*0.04;
    const spN = clamp(sp2/(vMax||1),0,1);
    const hue = polarity>0 ? (10 + spN*100) % 360 : (200 + spN*100) % 360;
    ctx.strokeStyle = `hsla(${hue},100%,70%,${0.30 + 0.55*spN})`;
    ctx.lineWidth = 0.7 + 2.0*sN*spN;
    ctx.beginPath();
    ctx.moveTo(px0,py0); ctx.lineTo(p.x,p.y); ctx.stroke();

    // advance & wrap
    p.x += p.vx; p.y += p.vy;
    if (p.x < -5) p.x = W+5; else if (p.x > W+5) p.x = -5;
    if (p.y < -5) p.y = H+5; else if (p.y > H+5) p.y = -5;
  }

  // sparse-field healer: if too many are far for a bit, reseed a few near cursor
  MAG.healTimer += dt;
  if (MAG.healTimer > 0.6){
    MAG.healTimer = 0;
    const ratioFar = farCount / Math.max(1, MAG.pins.length);
    if (ratioFar > 0.35){
      // reseed 10% near the cursor (subtle)
      const reseedN = Math.floor(MAG.pins.length * 0.10);
      for (let k=0; k<reseedN; k++){
        const idx = (Math.random()*MAG.pins.length)|0;
        const p = MAG.pins[idx];
        const r = 20 + Math.random()*60;
        const a = Math.random()*Math.PI*2;
        p.x = mouse.x + Math.cos(a)*r;
        p.y = mouse.y + Math.sin(a)*r;
        p.vx = (Math.random()-0.5)*6;
        p.vy = (Math.random()-0.5)*6;
        p.fx = p.fy = 0;
        p.slowT = p.farT = 0;
      }
    }
  }

  MAG.t += dt;
}


  /* =========================
     VITRAIL + glassy chimes
     ========================= */
  let glassAudio = null;
  let glassGlobalCooldown = 0;
  function glassEnsureAudio(){
    if (menuOpen) return;
    ensureAC();
    if (!glassAudio){
      const master = ac.createGain();
      master.gain.value = 0.22 * currentSfxGain();
      master.connect(ac.destination);
      glassAudio = { master };
    } else {
      glassAudio.master.gain.value = 0.22 * currentSfxGain();
    }
  }
  function glassPling(hz=900, panPos=0, vel=0.7){
    if (menuOpen) return;
    glassEnsureAudio();
    const masterScale = currentSfxGain();
    if (masterScale <= 0) return;

    const t = ac.currentTime;
    const o1 = ac.createOscillator(); o1.type='sine'; o1.frequency.setValueAtTime(hz, t);
    const o2 = ac.createOscillator(); o2.type='triangle'; o2.frequency.setValueAtTime(hz*2, t);
    const mod = ac.createOscillator(); mod.type='sine'; mod.frequency.value = 6 + 10*Math.random();
    const modGain = ac.createGain(); modGain.gain.value = 12 + 18*vel;
    mod.connect(modGain);
    modGain.connect(o1.detune);
    modGain.connect(o2.detune);

    const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 600; hp.Q.value = 0.7;
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = hz; bp.Q.value = 6;
    const sh = ac.createWaveShaper();
    sh.curve = new Float32Array([ -1, -0.2, 0, 0.2, 1 ]);

    const g  = ac.createGain();
    const p  = (ac.createStereoPanner ? ac.createStereoPanner() : null);
    const peak = 0.6 * vel * masterScale;

    const A=0.004, D=0.18, R=0.35;
    const t0=t;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(peak, t0+A);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak*0.05), t0+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+A+D+R);

    o1.connect(hp); o2.connect(hp);
    hp.connect(bp); bp.connect(sh); sh.connect(g);
    if (p) { g.connect(p); p.pan.value = clamp(panPos,-1,1); p.connect(glassAudio.master); }
    else { g.connect(glassAudio.master); }

    o1.start(t0); o2.start(t0); mod.start(t0);
    o1.stop(t0+A+D+R+0.05); o2.stop(t0+A+D+R+0.05); mod.stop(t0+A+D+R+0.05);
  }

  let glassCells=[], glassCols=20, glassRows=12;
  function resizeGlass(){
    glassCells=[];
    const cw=W/glassCols, ch=H/glassRows;
    for(let y=0;y<glassRows;y++){
      for(let x=0;x<glassCols;x++){
        glassCells.push({
          x:x*cw, y:y*ch, w:cw, h:ch,
          hue:Math.random()*360,
          pop:0, vpop:0, prevPop:0, cool:0
        });
      }
    }
  }
  resizeGlass();

  function renderGlass(dt){
    clearToBg(false);

    const intensity = mapIntensity();
    const sN = sizeNorm();

    const radius = 240 + 220*sN;
    const invR = 1 / Math.max(1, radius);

    const stiffness = 6 + 20*intensity;
    const damping   = Math.pow(0.32 + 0.58*(1-intensity), dt*60);

    const maxScaleBoost = 0.18 + 0.22*sN;
    const maxLightBoost = 78 * (0.5 + 0.8*intensity);

    const isLight = document.body.classList.contains('light');
    const baseL = isLight ? 86 : 14;

    glassGlobalCooldown = Math.max(0, glassGlobalCooldown - dt);

    ctx.globalCompositeOperation='source-over';
    for (let i=0;i<glassCells.length;i++){
      const c = glassCells[i];
      const cx = c.x + c.w/2;
      const cy = c.y + c.h/2;

      const dx = mouse.x - cx;
      const dy = mouse.y - cy;
      const d  = Math.hypot(dx,dy);
      const n  = clamp(1 - d*invR, 0, 1);

      const target = Math.pow(n, 1.2 + 1.2*intensity) * (mouse.down ? 1.15 : 1.0);

      const accel = (target - c.pop) * stiffness;
      c.vpop += accel * dt;
      c.vpop *= (1 - damping);
      c.pop  += c.vpop;

      c.cool = Math.max(0, c.cool - dt);
      const dPop = c.pop - c.prevPop;
      const trigger = (c.pop > 0.38) && (dPop > 0.02 + 0.04*intensity) && (c.cool===0) && (glassGlobalCooldown===0);
      if (trigger){
        const hueN = ((c.hue%360)+360)/360;
        const hz = 700 + hueN*1000;
        const pan = (cx/W)*2 - 1;
        const vel = clamp(0.4 + 0.6*(c.pop) + 0.2*clamp(mouse.speed/1400,0,1), 0.2, 1.0);
        glassPling(hz, pan, vel);
        c.cool = 0.08 + 0.08*(1-intensity);
        glassGlobalCooldown = 0.02;
      }
      c.prevPop = c.pop;

      const scale = 1 + maxScaleBoost * c.pop;
      const lift  = 2 + 10 * c.pop;
      const L = baseL + maxLightBoost * c.pop;
      const sat = 85;

      ctx.globalCompositeOperation='multiply';
      const sg = ctx.createRadialGradient(cx, cy+lift, Math.min(c.w,c.h)*0.15, cx, cy+lift, Math.max(c.w,c.h)*0.75);
      sg.addColorStop(0, 'rgba(0,0,0,0.10)');
      sg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = sg;
      const sw = c.w*scale, sh = c.h*scale;
      ctx.fillRect(cx - sw/2, cy - sh/2 + lift, sw, sh);

      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle = `hsla(${c.hue},85%,${L}%,0.96)`;
      ctx.fillRect(cx - sw/2, cy - sh/2, sw, sh);

      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(c.hue+40)%360},90%,${Math.min(92, L+10)}%,${0.35 + 0.35*c.pop})`;
      ctx.lineWidth = Math.max(1, 1.2 + 2.2*c.pop);
      ctx.strokeRect(cx - sw/2+0.7, cy - sh/2+0.7, sw-1.4, sh-1.4);

      if (c.pop > 0.55){
        const r = Math.min(c.w,c.h)*0.18*scale;
        const glx = cx - sw*0.28, gly = cy - sh*0.28;
        const gl = ctx.createRadialGradient(glx, gly, r*0.25, glx, gly, r);
        gl.addColorStop(0, 'rgba(255,255,255,0.28)');
        gl.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gl;
        ctx.beginPath(); ctx.arc(glx, gly, r, 0, Math.PI*2); ctx.fill();
      }
    }
  }

/* =========================
   STREAMERS — Rubans de Soie
   Hundreds of small saturated ribbons + natural wind/rustle + GAZE WOOSH
   ========================= */

const RIB2 = { list: [], t: 0 };

const RCFG = {
  segsMin: 5,
  segsMax: 8,
  widthMin: 3.0,
  widthMax: 7.0,
  gravity: 380,          // px/s^2
  airDrag: 0.0022,
  friction: 0.996,
  restLen: 12,           // base segment length
  swayAmp: 22,
  swayHzMin: 0.15,
  swayHzMax: 0.35,
  windAmp: 36,
  // ↑ increase gaze reach by ~50% (95 -> 145)
  gazeRBase: 145,
  gazeDamp: 0.77,
  gazePull: 16,
  respawnPad: 60
};

function ribbonsInit(){
  RIB2.list.length = 0;
  const n = Math.floor(140 + 260 * sizeNorm()); // hundreds; scales with Taille
  for (let i=0;i<n;i++) RIB2.list.push(spawnRibbonSmall());
}

function ribbonsResize(){
  for (const r of RIB2.list){
    for (const p of r.pts){
      p.x = clamp(p.x, -50, W+50);
      p.y = clamp(p.y, -H-100, H+100);
    }
  }
}

function spawnRibbonSmall(){
  const segs = Math.floor(RCFG.segsMin + Math.random()*(RCFG.segsMax-RCFG.segsMin+1));
  const scl  = 0.85 + 0.7*sizeNorm();
  const rest = RCFG.restLen * scl;
  const x0   = Math.random()*W;
  const y0   = -Math.random()*H*0.5 - 20;

  const pts = [];
  for (let i=0;i<segs;i++){
    const x = x0 + (Math.random()-0.5)*2;
    const y = y0 - i*rest*0.92;
    pts.push({ x, y, px:x, py:y });
  }
  return {
    pts,
    rest,
    width: lerp(RCFG.widthMin, RCFG.widthMax, Math.random()) * (0.8 + 0.6*sizeNorm()),
    hue: (Math.random()*360)|0,
    sat: 92 + Math.random()*6,
    light: 52 + Math.random()*6,
    swayHz: lerp(RCFG.swayHzMin, RCFG.swayHzMax, Math.random()),
    swayPhase: Math.random()*Math.PI*2,
    swayAmp: RCFG.swayAmp * (0.7 + 0.8*Math.random()),
    wind: (Math.random()-0.5)*RCFG.windAmp,
    _sndT: 0 // per-ribbon sound cooldown timestamp
  };
}

function stepRibbonSmall(r, dt){
  const pts = r.pts, N = pts.length;
  const g   = RCFG.gravity;
  const fr  = Math.pow(RCFG.friction, dt*60);
  const intensity = mapIntensity();

  const t = RIB2.t + r.swayPhase;
  const sway = Math.sin(t*2*Math.PI*r.swayHz) * r.swayAmp * (0.7 + 0.9*intensity);

  const gazeR  = (RCFG.gazeRBase * (0.8 + 0.7*sizeNorm())) * (0.8 + 0.9*intensity);
  const gazeR2 = gazeR*gazeR;

  for (let i=0;i<N;i++){
    const p = pts[i];
    let vx = (p.x - p.px);
    let vy = (p.y - p.py);

    const w = (1 - i/(N-1));
    vy += g * dt*dt;
    vx += (sway * w + r.wind*0.25) * dt;

    const sp2 = vx*vx + vy*vy;
    if (sp2 > 0){
      const drag = 1 - Math.min(0.4, RCFG.airDrag * sp2);
      vx *= drag; vy *= drag;
    }

    const dx = mouse.x - p.x, dy = mouse.y - p.y, d2 = dx*dx + dy*dy;
    if (d2 < gazeR2){
      const n = 1 - (d2 / gazeR2);
      vx *= RCFG.gazeDamp; vy *= RCFG.gazeDamp;
      vx += dx * (RCFG.gazePull * n) * dt*dt;
      vy += dy * (RCFG.gazePull * n) * dt*dt;
    }

    p.px = p.x; p.py = p.y;
    p.x += vx * fr; p.y += vy * fr;
  }

  for (let it=0; it<2; it++){
    for (let i=0;i<N-1;i++){
      const a = pts[i], b = pts[i+1];
      let dx = b.x - a.x, dy = b.y - a.y;
      let d = Math.hypot(dx,dy) || 1;
      const diff = (d - r.rest) / d;
      const corr = 0.5 * diff;
      a.x += dx * corr; a.y += dy * corr;
      b.x -= dx * corr; b.y -= dy * corr;
    }
  }

  let below = 0;
  for (let i=0;i<N;i++){ if (pts[i].y > H + RCFG.respawnPad) below++; }
  if (below === N){
    const x0 = Math.random()*W, y0 = -20 - Math.random()*H*0.4;
    for (let i=0;i<N;i++){
      const x = x0 + (Math.random()-0.5)*2;
      const y = y0 - i*r.rest*0.9;
      pts[i].x=x; pts[i].y=y; pts[i].px=x; pts[i].py=y;
    }
    r.swayPhase = Math.random()*Math.PI*2;
    r.wind = (Math.random()-0.5)*RCFG.windAmp;
    r._sndT = performance.now();
  }
}

function drawRibbonSmall(r){
  const pts = r.pts, N = r.pts.length;
  if (N<2) return;

  const hue = r.hue, sat = r.sat|0, L = r.light|0;
  const w   = r.width;

  // saturated body
  ctx.globalCompositeOperation = 'source-over';
  ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${L}%, 0.92)`;
  ctx.lineWidth   = w;
  ctx.lineCap     = 'round';
  ctx.lineJoin    = 'round';
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i=1;i<N;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();

  // soft highlight (subtle, not white bars)
  ctx.globalCompositeOperation = 'lighter';
  ctx.strokeStyle = `hsla(${(hue+30)%360}, 95%, 70%, 0.25)`;
  ctx.lineWidth   = Math.max(1, w*0.35);
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i=1;i<N;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
}

// --- Sound system -------------------------------------------------------

const RIBSND = {
  inited: false,
  master: null,
  // one shared noise source feeding two chains:
  // 1) ambient wind, 2) gaze-woosh
  wind:  { gain: null, bp: null, hp: null, target: 0, cur: 0 },
  woosh: { gain: null, bp: null, hp: null, target: 0, cur: 0 },
  src: null,
  rustleLimiter: { active: 0, max: 6 },
  lastDwellBoost: 0,
  cooldownMs: 90
};

function ribbonsSoundEnsure(){
  if (menuOpen) return;
  ensureAC();
  if (RIBSND.inited){
    RIBSND.master.gain.value = 0.28 * currentSfxGain();
    return;
  }

  // Master
  const master = ac.createGain();
  master.gain.value = 0.28 * currentSfxGain();
  master.connect(ac.destination);
  RIBSND.master = master;

  // Looping noise buffer
  const noiseBuf = ac.createBuffer(1, ac.sampleRate * 2, ac.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for (let i=0;i<data.length;i++) data[i] = (Math.random()*2 - 1) * 0.6;
  const src = ac.createBufferSource(); src.buffer = noiseBuf; src.loop = true;
  RIBSND.src = src;

  // Chain 1: ambient wind
  const hp1 = ac.createBiquadFilter(); hp1.type='highpass'; hp1.frequency.value = 120; hp1.Q.value = 0.7;
  const bp1 = ac.createBiquadFilter(); bp1.type='bandpass'; bp1.frequency.value = 900; bp1.Q.value  = 0.8;
  const g1  = ac.createGain(); g1.gain.value = 0.0;

  // Chain 2: gaze-woosh (brighter, more “air”)
  const hp2 = ac.createBiquadFilter(); hp2.type='highpass'; hp2.frequency.value = 320; hp2.Q.value = 0.8;
  const bp2 = ac.createBiquadFilter(); bp2.type='bandpass'; bp2.frequency.value = 1400; bp2.Q.value = 0.9;
  const g2  = ac.createGain(); g2.gain.value = 0.0;

  // Connect both chains from the same noise source
  src.connect(hp1).connect(bp1).connect(g1).connect(master);
  src.connect(hp2).connect(bp2).connect(g2).connect(master);
  src.start();

  RIBSND.wind  = { gain:g1, bp:bp1, hp:hp1, target:0.0, cur:0.0 };
  RIBSND.woosh = { gain:g2, bp:bp2, hp:hp2, target:0.0, cur:0.0 };
  RIBSND.inited = true;
}

// brief rustle burst on strong local bend / speed (kept subtle)
function ribbonsPlayRustle(screenX=0.5, vel=0.6){
  if (menuOpen) return;
  if (RIBSND.rustleLimiter.active >= RIBSND.rustleLimiter.max) return;
  const mscale = currentSfxGain();
  if (mscale <= 0) return;

  ribbonsSoundEnsure();

  const t = ac.currentTime;
  const dur = 0.18 + 0.10*Math.random();
  const frames = Math.max(1, Math.floor(ac.sampleRate * dur));
  const buf = ac.createBuffer(1, frames, ac.sampleRate);
  const ch = buf.getChannelData(0);
  for (let i=0;i<frames;i++){
    const n = (Math.random()*2-1);
    ch[i] = (i>0 ? 0.98*ch[i-1] + 0.02*n : n) * 0.9;
  }
  const src = ac.createBufferSource(); src.buffer = buf;

  const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 800 + 500*Math.random();
  const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.Q.value = 1.2;
  const g  = ac.createGain();
  const pan = (ac.createStereoPanner ? ac.createStereoPanner() : null);

  const peak = 0.08 + 0.22*vel;            // dialed down so woosh leads
  const A=0.008, D=0.08, R=0.16;
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(peak*mscale, t+A);
  g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak*0.25*mscale), t+A+D);
  g.gain.exponentialRampToValueAtTime(0.0001, t+A+D+R);

  const f0 = 1500 + 700*Math.random();
  bp.frequency.setValueAtTime(f0, t);
  bp.frequency.linearRampToValueAtTime(f0 * (0.8 + 0.4*Math.random()), t + dur*0.6);

  src.connect(hp).connect(bp).connect(g);
  if (pan) { g.connect(pan); pan.pan.value = clamp(screenX*2-1, -1, 1); pan.connect(RIBSND.master); }
  else { g.connect(RIBSND.master); }

  src.start(t);
  src.stop(t + dur + 0.05);

  RIBSND.rustleLimiter.active++;
  src.onended = ()=>{ RIBSND.rustleLimiter.active = Math.max(0, RIBSND.rustleLimiter.active - 1); };
}

function ribbonsWindSet(target){
  if (!RIBSND.inited) return;
  RIBSND.wind.target = clamp(target, 0, 1);
}
function ribbonsWooshSet(target){
  if (!RIBSND.inited) return;
  RIBSND.woosh.target = clamp(target, 0, 1);
}
function ribbonsSoundTick(dt){
  if (!RIBSND.inited) return;

  // Smooth follow (same for wind & woosh)
  const follow = (cur, tgt) => lerp(cur, tgt, 1 - Math.pow(0.12, dt*60));

  // Ambient wind (field activity)
  RIBSND.wind.cur = follow(RIBSND.wind.cur, RIBSND.wind.target);
  RIBSND.wind.gain.gain.setTargetAtTime(0.08 * RIBSND.wind.cur * currentSfxGain(), ac.currentTime, 0.05);
  const windF = 850 + 500*RIBSND.wind.cur;
  RIBSND.wind.bp.frequency.setTargetAtTime(windF, ac.currentTime, 0.12);

  // Gaze woosh (captured ribbons)
  RIBSND.woosh.cur = follow(RIBSND.woosh.cur, RIBSND.woosh.target);
  // louder & brighter than wind; quick attack, slower release feel
  RIBSND.woosh.gain.gain.setTargetAtTime(0.16 * RIBSND.woosh.cur * currentSfxGain(), ac.currentTime, 0.03);
  const wooshF = 1200 + 1800*RIBSND.woosh.cur;
  RIBSND.woosh.bp.frequency.setTargetAtTime(wooshF, ac.currentTime, 0.06);
  RIBSND.woosh.hp.frequency.setTargetAtTime(300 + 400*RIBSND.woosh.cur, ac.currentTime, 0.06);
}

// --- Render loop (visuals + sound hooks) -------------------------------

let ribDwellPulse = 1.0;

function renderStreamers(dt){
  // background trail respecting theme
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle = document.body.classList.contains('light')
    ? `rgba(255,255,255,${mapTrail()})`
    : `rgba(0,0,0,${mapTrail()})`;
  ctx.fillRect(0,0,W,H);

  RIB2.t += dt * (0.6 + 0.8*mapIntensity());
  ribbonsSoundEnsure();

  // (Removed beep) — gentle visual pulse only
  if (dwellJustCrossed(750)){
    ribDwellPulse = 1.08;
    if (RIBSND.inited) RIBSND.lastDwellBoost = 0.6; // nudges ambient wind
  }
  ribDwellPulse = lerp(ribDwellPulse, 1.0, 0.06);

  let activity = 0;
  let captured = 0;

  const nowMs = performance.now();
  const gazeR  = (RCFG.gazeRBase * (0.8 + 0.7*sizeNorm())) * (0.8 + 0.9*mapIntensity());
  const gazeR2 = gazeR * gazeR;

  for (const r of RIB2.list){
    const orig = r.swayAmp;
    r.swayAmp = orig * ribDwellPulse;

    // head position before step (for speed measure)
    const h0 = r.pts[0]; const hx0 = h0.x, hy0 = h0.y;

    stepRibbonSmall(r, dt);
    drawRibbonSmall(r);

    // motion & curvature
    const hx1 = r.pts[0].x, hy1 = r.pts[0].y;
    const hvx = (hx1 - hx0) / (dt || 1/60);
    const hvy = (hy1 - hy0) / (dt || 1/60);
    const hsp = Math.hypot(hvx, hvy);

    const mid = (r.pts.length/2 | 0);
    const a = r.pts[Math.max(0, mid-1)], b = r.pts[mid], c = r.pts[Math.min(r.pts.length-1, mid+1)];
    const abx = b.x - a.x, aby = b.y - a.y;
    const bcx = c.x - b.x, bcy = c.y - b.y;
    const curv = Math.abs(abx*bcy - aby*bcx) / ((Math.hypot(abx,aby)*Math.hypot(bcx,bcy)) || 1);

    activity += clamp(hsp/300, 0, 1) * 0.4 + clamp(curv*3, 0, 1) * 0.6;

    // captured by gaze? (use middle point)
    const dx = mouse.x - b.x, dy = mouse.y - b.y, d2 = dx*dx + dy*dy;
    const inGaze = d2 < gazeR2;
    if (inGaze) captured++;

    // optional subtle rustle (kept low, not beepy)
    if (RIBSND.inited && (nowMs - r._sndT >= RIBSND.cooldownMs)){
      const bendHit = curv > 0.22;
      const speedHit = hsp > 260;
      if (bendHit || speedHit || (inGaze && curv>0.12)){
        const screenX = clamp(b.x / W, 0, 1);
        const vel = clamp( (hsp/700) + (curv*0.6), 0.12, 0.8 );
        ribbonsPlayRustle(screenX, vel);
        r._sndT = nowMs;
      }
    }

    r.swayAmp = orig;
  }

  // Ambient wind loudness from global activity
  const field = clamp(activity / Math.max(1, RIB2.list.length), 0, 1);
  let windTarget = 0.15 + field * (0.75 * (0.4 + 0.8*mapIntensity()));
  if (RIBSND.lastDwellBoost > 0){
    windTarget += RIBSND.lastDwellBoost * 0.15;
    RIBSND.lastDwellBoost = Math.max(0, RIBSND.lastDwellBoost - dt*1.8);
  }
  ribbonsWindSet(windTarget);

  // GAZE WOOSH: grows with #captured ribbons (nonlinear for feel)
  const capNormBase = 40 * (0.7 + 0.6*sizeNorm()); // how many ribbons to “fill” woosh
  const wooshTarget = Math.sqrt( clamp(captured / Math.max(1, capNormBase), 0, 1) );
  ribbonsWooshSet(wooshTarget);

  ribbonsSoundTick(dt);
}

// Initialize ribbons
ribbonsInit();

  /* =========================
     HARPE LASER (unchanged)
     ========================= */
  let laserCols=11;
  const laserGap = ()=> W / (laserCols + 1);
  let harpPalette = Array.from({ length: laserCols }, (_, i) => (i * (360 / laserCols)) | 0);
  let harpBeams=[], beamDwell=[], beamCooldown=[], beamHold=[], beamVoice=[];
  function initLaserArrays(){
    harpPalette = Array.from({length:laserCols},(_,i)=>(i*(360/laserCols))|0);
    harpBeams = Array.from({length:laserCols},(_,i)=>({energy:0,rippleT:0,rippleY:H/2,hue:harpPalette[i]}));
    beamDwell=new Array(laserCols).fill(0);
    beamCooldown=new Array(laserCols).fill(0);
    beamHold=new Array(laserCols).fill(false);
    beamVoice=new Array(laserCols).fill(null);
  }
  initLaserArrays();

  function harpEnsureAudio(){
    if (menuOpen) return;
    ensureAC();
    if (!harpEnsureAudio.master){
      const master=ac.createGain(); master.gain.value = (parseInt(sfxVol.value,10)||50)/100 * (muteSFX.checked?0:1) * 0.24;
      const delay = ac.createDelay(); delay.delayTime.value=0.18;
      const fb = ac.createGain(); fb.gain.value=0.38;
      delay.connect(fb).connect(delay);
      delay.connect(master);
      master.connect(ac.destination);
      harpEnsureAudio.master=master; harpEnsureAudio.delay=delay;
    }
  }
  function harpNote(i){
    const pent=[0,2,4,7,9]; const base=220;
    const si=i%pent.length, oct=Math.floor(i/pent.length);
    return base * Math.pow(2, (pent[si] + 12*oct)/12);
  }
  const sparks = [];
  function harpPluck(i, y, velocity=1){
    if (menuOpen) return;
    harpEnsureAudio();
    const f=harpNote(i), det=(Math.random()*14-7), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=det;
    const g=ac.createGain(); const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2200+1800*velocity;
    const A=0.005, D=0.08, S=0.25*velocity, R=0.35+0.25*(1-velocity);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.9*velocity, t+A);
    g.gain.exponentialRampToValueAtTime(Math.max(S,0.08), t+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t+A+D+R);
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t); o1.stop(t+A+D+R+0.02); o2.stop(t+A+D+R+0.02);
    const b=harpBeams[i]; b.energy=Math.min(1, b.energy + 0.6*velocity); b.rippleT=0; b.rippleY=y;
    for(let k=0;k<12;k++){
      sparks.push({x:(i+1)*laserGap(), y, vx:(Math.random()-0.5)*2.4, vy:(Math.random()-0.5)*2.4, life:26+Math.random()*18, h:(b.hue+10+Math.random()*40)%360});
    }
  }
  function startVoice(i){
    if (menuOpen) return;
    harpEnsureAudio();
    if (beamVoice[i]) return;
    const f=harpNote(i), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=-6;
    const g=ac.createGain(); g.gain.value=0.0001;
    const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1400;
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t);
    g.gain.linearRampToValueAtTime(0.18 + 0.10*mapIntensity(), t + 0.08);
    beamVoice[i]={o1,o2,g,lp,baseF:f,t0:t};
  }
  function stopVoice(i){
    const v=beamVoice[i]; if(!v||!ac){ beamVoice[i]=null; return; }
    const t=ac.currentTime;
    try{
      v.g.gain.cancelScheduledValues(t);
      v.g.gain.setValueAtTime(v.g.gain.value, t);
      v.g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      v.o1.stop(t+0.22); v.o2.stop(t+0.22);
    }catch(e){}
    beamVoice[i]=null;
  }
  function updateVoice(i){
    const v=beamVoice[i]; if(!v||!ac) return;
    const t=ac.currentTime, e=harpBeams[i].energy;
    const vib=0.25+0.35*mapIntensity(), amt=7+10*mapIntensity(), phase=(t-v.t0);
    const mod=Math.sin(phase*2*Math.PI*vib)*amt;
    v.o1.frequency.setValueAtTime(v.baseF,t); v.o2.frequency.setValueAtTime(v.baseF,t);
    v.o2.detune.setValueAtTime(mod,t);
    v.lp.frequency.setValueAtTime(1200 + 1200*e, t);
    const targetGain = 0.14 + 0.10*mapIntensity();
    v.g.gain.setTargetAtTime(targetGain, t, 0.08);
  }
  function resizeLaser(){
    if (harpBeams.length !== laserCols) initLaserArrays();
    for (let i=0;i<harpBeams.length;i++) harpBeams[i].rippleY = Math.min(harpBeams[i].rippleY, H);
  }
  function renderLaser(dt){
    clearToBg(false);
    const gap=laserGap(); const lineBase=10 + mapSize()*0.14;
    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap; const nearRadius=34 + lineBase*1.7;
      const near = Math.abs(mouse.x - x) < nearRadius;
      const stationary = mouse.speed < 60;
      const velocity = clamp(mouse.speed/1400, 0.05, 1);
      if (near && velocity>0.25){
        harpPluck(i, mouse.y, velocity);
        lastMoveT = performance.now();
        beamCooldown[i]=160; beamHold[i]=false; stopVoice(i);
      }
      beamCooldown[i]=Math.max(0, beamCooldown[i]-dt*1000);
      if (near){
        beamDwell[i]+=dt*1000;
        const dwellThreshold=450;
        if (!beamHold[i] && stationary && beamDwell[i]>=dwellThreshold && beamCooldown[i]===0){
          const vel=0.72+0.28*mapIntensity();
          harpPluck(i, mouse.y, vel); beamHold[i]=true; startVoice(i);
        }
      } else {
        if (beamHold[i]) stopVoice(i);
        beamDwell[i]=0; beamHold[i]=false;
      }
    }

    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap, b=harpBeams[i];
      const decay = beamHold[i] ? 0.96 : 0.82;
      b.energy *= Math.pow(decay, dt*60);
      b.rippleT += dt;
      if (beamHold[i]){ b.energy = lerp(b.energy, 0.85, 0.12); updateVoice(i); }

      ctx.globalCompositeOperation='screen';
      const e=b.energy; const hue=(b.hue + Math.sin((performance.now()*0.001+i)*0.7)*6)%360;

      const grad=ctx.createLinearGradient(x,0,x,H);
      grad.addColorStop(0.0, `hsla(${(hue+6)%360},100%,55%,${0.35+0.20*e})`);
      grad.addColorStop(0.5, `hsla(${hue},100%,52%,${0.65+0.30*e})`);
      grad.addColorStop(1.0, `hsla(${(hue+12)%360},100%,55%,${0.35+0.20*e})`);
      const w=Math.max(2, lineBase * (beamHold[i] ? 1.8 : (1 + 1.3*e)));
      ctx.strokeStyle=grad; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      ctx.strokeStyle=`hsla(${hue},100%,50%,${0.22+0.25*e})`; ctx.lineWidth=w*1.9;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      const waveAmp=(10+mapSize()*0.028)*e*(beamHold[i]?0.35:1.0);
      const waveFreq=0.02+0.035*mapIntensity();
      ctx.strokeStyle=`hsla(${(hue+200)%360},100%,80%,${0.55+0.35*e})`;
      ctx.lineWidth=Math.max(1.5, w*0.22);
      ctx.beginPath();
      for (let y=0;y<=H;y+=7){
        const off = Math.sin((y + performance.now()*0.6)*waveFreq)*waveAmp;
        ctx.lineTo(x+off, y);
      }
      ctx.stroke();

      if (e>0.02){
        const speed=480 + 420*mapIntensity();
        const r=Math.max(10,(b.rippleT*speed) % (H*1.2));
        ctx.strokeStyle=`hsla(${(hue+60)%360},100%,70%,${(beamHold[i]?0.28:0.42)*e})`;
        ctx.lineWidth=2.2;
        ctx.beginPath();
        ctx.arc(x, b.rippleY, r*(0.12+0.12*e), 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  /* =========================
     BUBBLE-POP (unchanged)
     ========================= */
  const bubbles = Array.from({length:70},()=>({x:Math.random()*W,y:H+Math.random()*200,r:8+Math.random()*22,vx:(Math.random()-0.5)*0.2,vy:-(0.4+Math.random()*0.6),charge:0,h:Math.random()*360}));
  function renderBubblePop(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    for(let i=bubbles.length-1;i>=0;i--){
      const b=bubbles[i];
      if (b.cool===undefined) b.cool=0;
      if (b.phase===undefined) b.phase=0;
      if (b.maxCharge===undefined) b.maxCharge=2.0;
      const d=Math.hypot(mouse.x-b.x, mouse.y-b.y);
      const near=clamp(1 - d/160, 0, 1);
      const baseGrow=(near*2.2 - 0.18)*dt;
      const dwellBoost=(dwellMs>600 ? 0.8*near*dt : 0);
      b.charge = clamp((b.charge||0) + baseGrow + dwellBoost, 0, b.maxCharge);
      b.phase += dt*(0.8 + b.charge*0.6);
      const pulse=1 + 0.04*Math.sin(b.phase*2.7);
      const growth=1 + Math.pow(b.charge,1.25)*2.6;
      const R=b.r*growth*pulse;
      const g=ctx.createRadialGradient(b.x,b.y,R*0.4,b.x,b.y,R*1.2);
      g.addColorStop(0,`hsla(${b.h},90%,70%,${0.10+0.25*near})`);
      g.addColorStop(1,`hsla(${(b.h+60)%360},90%,45%,0)`);
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=`hsla(${b.h},90%,70%,${0.22+0.5*near})`;
      ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=`hsla(${(b.h+40)%360},90%,85%,0.9)`; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.arc(b.x - R*0.35, b.y - R*0.35, R*0.32, 0, Math.PI*2); ctx.stroke();
      b.x += b.vx + (mouse.x-b.x)*0.00035*mapIntensity();
      b.y += b.vy - (mouse.y-b.y)*0.00025*mapIntensity();
      if (b.y<-R-20){ b.y=H+40; b.x=Math.random()*W; b.vx=(Math.random()-0.5)*0.2; b.vy=-(0.4+Math.random()*0.6); b.charge=0; b.cool=0; }
      const canPop=(b.cool<=0) && (b.charge>=1.7) && (near>0.6);
      if (canPop){
        playPing(740,0.12,0.06);
        for(let k=0;k<22;k++){
          sparks.push({x:b.x,y:b.y,vx:Math.cos(k*Math.PI/11)*(2.2+Math.random()*1.6),vy:Math.sin(k*Math.PI/11)*(2.2+Math.random()*1.6),life:40+Math.random()*20,h:(b.h+Math.random()*50)%360});
        }
        for(let d2=0; d2<8; d2++){
          sparks.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*4.5,vy:(Math.random()-0.5)*4.5,life:28,h:(b.h+20)%360});
        }
        ctx.globalCompositeOperation='screen';
        ctx.strokeStyle=`hsla(${(b.h+20)%360},95%,80%,0.8)`; ctx.lineWidth=2.2;
        ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.stroke();
        b.charge=0.15; b.cool=0.25;
      }
      if (b.cool>0) b.cool -= dt;
    }
  }

   function tick(t){
    const dt = clamp((t - now)/1000, 0, 0.05);
    now = t;
    dwellMs = t - lastMoveT;
    MUSIC.tick(dt);

    recomputePaused();

    if (menuOpen || paused){
      return requestAnimationFrame(tick);
    }

    if (seriesState.active && seriesConfig.playlist.length){
      seriesState.timer -= dt * 1000;
      if (seriesState.timer <= 0){
        advanceSeriesScene();
      }
    }

    switch (ui.mode.value){
      case 'aurora':    renderAurora(dt);     break;
      case 'ripples':   renderRipples(dt);    break;
      case 'fireworks': renderFireworks(dt);  break;
      case 'kaleido':   renderKaleido(dt);    break;
      case 'fireflies': renderFireflies(dt);  break;
      case 'confetti':  renderConfetti(dt);   break;
      case 'nebula':    renderNebula(dt);     break;
      case 'jelly':     renderJelly(dt);      break;
      case 'snow':      renderSnow(dt);       break;
      case 'sand':      SAND_CELL.caRender(dt); break;
      case 'magnet':    renderMagnet(dt);     break;
      case 'glass':     renderGlass(dt);      break;
      case 'streamers': renderStreamers(dt);  break;
      case 'laserharp': renderLaser(dt);      break;
      case 'bubblepop': renderBubblePop(dt);  break;
      case 'galaxy':    renderGalaxy(dt);  break;

    }
    requestAnimationFrame(tick);
  }

  (function seedBlueBg(){
    ctx.fillStyle = 'hsl(210, 70%, 8%)';
    ctx.fillRect(0,0,W,H);
  })();

  updateBorder();
  snowResize();
  requestAnimationFrame(tick);

  startButton.addEventListener('click', () => {
    if (seriesConfig.enabled && seriesConfig.playlist.length === 0) {
      openSeriesModal();
      alert('Veuillez sélectionner au moins une scène pour la série.');
      return;
    }

    closeSeriesModal();

    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen();
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if (el.msRequestFullscreen) el.msRequestFullscreen();

    document.getElementById('game-options').style.display = 'none';
    cvs.style.display = 'block';
    document.body.classList.add('playing');
    menuOpen = false;
    MUSIC.prime();

    if (seriesConfig.enabled) {
      beginSeriesPlayback();
    } else {
      seriesState.active = false;
      seriesState.timer = 0;
      seriesState.index = 0;
      setCurrentScene(sceneSel.value);
    }

    cvs.addEventListener('pointerdown', ()=>{ playPing(523,0.08,0.03); }, {once:true});
  });
  </script>
</body>
</html>