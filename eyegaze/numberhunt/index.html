<!DOCTYPE html> 
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chasse aux nombres</title>

  <!-- Shared styles -->
  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    /* Page theming applied after Start */
    body.light { background-color: #fff; color: #000; }
    body.dark  { background-color: #000; color: #fff; }
    body.light .letter-cell { background-color: #eee; color: #000; }
    body.dark  .letter-cell { background-color: #222; color: #fff; }

    /* Game container layout */
    .game-container {
      width: 100%;
      max-width: 100vw;
      height: 100%;
      display: none;             /* shown after Start */
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
      box-sizing: border-box;
    }

    /* Top strip */
    .top-strip{
      width: min(920px, 92vw);
      margin-top: 8px;
      padding: 6px 14px;
      border-radius: 12px;
      display: none;             /* shown after Start */
      box-sizing: border-box;
      border: 2px solid;
      box-shadow: 0 6px 20px rgba(0,0,0,0.06);
      transition: opacity 500ms ease, margin-bottom 120ms ease;
      margin-bottom: 16px;       /* will be reduced dynamically */
      opacity: 1;

      display: flex;
      align-items: center;
      gap: 10px;
    }
    .top-strip.fade-out { opacity: 0; }
    .top-strip.hidden{ display: none !important; }

    body.light .top-strip{
      background: #00bfa5;
      border-color: rgba(0,150,136,0.55);
    }
    body.dark .top-strip{
      background: #082422;
      border-color: rgba(20,184,166,0.55);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }

    .grid-outer{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 100vw;
    }

    .letter-grid {
      display: none;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      place-content: center;
      justify-items: stretch;
      align-items: stretch;
      margin: 0;
    }
    .letter-grid.no-input { pointer-events: none; }

    .letter-cell {
      position: relative;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: none;
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;
      transform: translateZ(0);
      background-clip: padding-box;
      background-color: #fff;
      color: #000;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      opacity: 1;
      transition: opacity 500ms ease, transform 500ms ease, filter 500ms ease;
    }
    body.dark .letter-cell { background-color: #222; color: #fff; }

    /* Prompt */
    #prompt {
      text-align: center;
      margin: 0;
      display: none;
      opacity: 1;
      transition: opacity 500ms ease;
      flex: 1;
    }
    #prompt .prompt-text { font-size: 1.3rem; font-weight: 600; color: #ffffff; line-height: 1.1; }
    body.dark #prompt .prompt-text { color: #e5e5e5; }
    #prompt .target-letter {
      display: block; font-size: 6rem; font-weight: 800; color: #ffffff; margin-top: 4px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.12); line-height: 1;
    }
    body.dark #prompt .target-letter { text-shadow: none; }

    /* Fade-out for other tiles */
    .letter-cell.dim {
      opacity: 0;
      transform: scale(0.92);
      filter: blur(1px);
    }

    /* Dwell overlay */
    .dwell-fill {
      position: absolute;
      background-color: rgba(255, 0, 0, 0.5);
      top: 50%; left: 50%;
      width: 0; height: 0;
      transform: translate(-50%, -50%);
      pointer-events: none;
      border-radius: 8px;
    }

    /* Inputs */
    .styled-input {
      width: 100%;
      max-width: 200px;
      padding: 10px 14px;
      font-size: 18px;
      font-weight: bold;
      color: #000;
      border: 2px solid #009688;
      border-radius: 8px;
      background-color: #fff;
      text-align: center;
      transition: border-color .2s, box-shadow .2s;
      letter-spacing: 2px;
    }
    .styled-input:focus {
      border-color: #14b8a6;
      box-shadow: 0 0 0 3px rgba(0,150,136,0.15);
      outline: none;
    }

    /* Correct selection state */
    .letter-cell.correct {
      color: #fff;
      background-color: #c62828;
    }

    /* Flying clone — fixed, pixel-anchored */
    .flying-tile {
      position: fixed;
      left: 0; top: 0;
      transform: translate3d(0, 0, 0) scale(1);
      transform-origin: center center;

      z-index: 9999;
      pointer-events: none;
      border-radius: 12px;
      border: 2px solid rgba(0,0,0,0.15);
      overflow: hidden;
      background-color: inherit;
      color: inherit;
      backface-visibility: hidden;
      will-change: transform;
      contain: layout paint style;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Lock state + ready cue (pop) */
    .letter-grid.grid-locked { pointer-events: none; }
    .letter-grid.grid-locked .letter-cell {
      opacity: .35;
      filter: grayscale(70%);
      transition: opacity 250ms ease, filter 250ms ease;
    }
    @keyframes readyPop { 0% { transform: scale(.98); } 100% { transform: scale(1); } }
    .letter-grid.ready-pop .letter-cell { animation: readyPop 220ms ease; }

    /* Reduced motion fallback for wrong feedback: quick red flash without movement */
    @media (prefers-reduced-motion: reduce) {
      .letter-cell.wrong-flash {
        box-shadow: inset 0 0 0 3px rgba(198,40,40,.5);
      }
    }
  </style>
</head>
<body>

<!-- Options modal -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title">Chasse aux nombres</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Column 1: Audio + TTS -->
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span>Désactiver les sons</span>
          </label>
        </div>

        <!-- TTS controls -->
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="ttsEnabled">
            <span>Lecture vocale</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span>Volume des sons: </span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Column 2: Numbers + theme -->
      <div class="options-column">
        <div class="option-item">
          <label for="numberSet" class="teal-label label-block">Nombres à afficher</label>
          <input id="numberSet" type="text" value="0123456789" maxlength="12" class="styled-input" inputmode="numeric" aria-label="Nombres à afficher (0-9)">
        </div>
        <div class="option-item">
          <label for="themeSelect" class="teal-label label-block">Mode</label>
          <select id="themeSelect" class="styled-select">
            <option value="light" selected>Clair</option>
            <option value="dark">Sombre</option>
          </select>
        </div>
      </div>

      <!-- Column 3: Dwell + layout scale -->
      <div class="options-column">
        <div class="option-item">
          <label for="dwellTimeSlider" class="teal-label">
            <span>Temps de fixation: </span>
            <span id="dwellTimeVal">1500</span> ms
          </label>
          <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="5000" step="100" value="1500">
        </div>
        <div class="option-item">
          <label for="layoutScale" class="teal-label">
            <span>Taille :</span>
            <span id="layoutScaleVal"> 1.00</span>
          </label>
          <input type="range" id="layoutScale" class="styled-slider" min="0.8" max="1.4" step="0.05" value="1.0">
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button">Commencer</button>
  </div>
</div>

<!-- Game area -->
<div class="game-container">

  <!-- Instruction strip -->
  <div id="topStrip" class="top-strip">
    <h2 id="prompt">
      <span class="prompt-text">Trouve le nombre</span><br>
      <span class="target-letter"></span>
    </h2>
  </div>

  <div class="grid-outer">
    <div class="letter-grid"></div>
  </div>
</div>

<!-- Audio -->
<audio id="correctSound" src="../../sounds/victory.mp3"></audio>
<audio id="wrongSound"   src="../../sounds/error.mp3"></audio>

<!-- Eyegaze helpers -->
<script src="../../js/eyegaze-menu.js"></script>

<script>
/* =========================
   Controls & UI bindings
   ========================= */
const muteSFX      = document.getElementById('muteSFX');
const sfxVol       = document.getElementById('sfxVol');
const sfxVolVal    = document.getElementById('sfxVolVal');
const dwellSlider  = document.getElementById('dwellTimeSlider');
const dwellTimeVal = document.getElementById('dwellTimeVal');
const themeSelect  = document.getElementById('themeSelect');
const startButton  = document.getElementById('startButton');

const ttsEnabled   = document.getElementById('ttsEnabled');

const layoutScaleEl = document.getElementById('layoutScale');
const layoutScaleVal= document.getElementById('layoutScaleVal');

/* =========================
   Local storage keys
   ========================= */
const LS_KEYS = {
  ttsEnabled: 'chassenombres:ttsEnabled'
};

/* Prefill persisted settings */
(function initPersistedControls(){
  try {
    const en = localStorage.getItem(LS_KEYS.ttsEnabled);
    if (en !== null) ttsEnabled.checked = (en === 'true');
  } catch(e){}
})();

sfxVol.addEventListener('input', () => sfxVolVal.textContent = sfxVol.value);
dwellSlider.addEventListener('input', () => dwellTimeVal.textContent = dwellSlider.value);
ttsEnabled.addEventListener('change', () => {
  try { localStorage.setItem(LS_KEYS.ttsEnabled, String(ttsEnabled.checked)); } catch(e){}
});

layoutScaleEl.addEventListener('input', () => {
  layoutScaleVal.textContent = parseFloat(layoutScaleEl.value).toFixed(2);
  if (document.querySelector('.game-container').style.display === 'flex') {
    layoutScale = parseFloat(layoutScaleEl.value);
    adjustGridSizes();
  }
});

/* Enforce only digits and cap length (up to 12 for future-proofing) */
const numberInput = document.getElementById('numberSet');
numberInput.addEventListener('input', () => {
  let v = numberInput.value.replace(/[^0-9]/g, '');
  if (v.length > 12) v = v.slice(0, 12);
  numberInput.value = v;
});

/* Sync eyegaze settings if present */
function syncEyegazeSettingsFromUI() {
  try {
    if (window.eyegazeSettings) {
      eyegazeSettings.sfxMuted  = !!muteSFX.checked;
      eyegazeSettings.sfxVolume = parseInt(sfxVol.value, 10) || 50;
      eyegazeSettings.dwellTime = parseInt(dwellSlider.value, 10) || 1500;
      eyegazeSettings.ttsEnabled= !!ttsEnabled.checked;
    }
  } catch(e) {}
}

/* =========================
   Game state
   ========================= */
let numbers = [];
let targetNumber;
let hoverTimeout;
let selectedTheme = 'light';

/* Track tile under pointer & last pointer position for auto-dwell on unlock */
let hoveredTile = null;
let lastPointer = { x: null, y: null };
window.addEventListener('pointermove', (e) => {
  lastPointer.x = e.clientX;
  lastPointer.y = e.clientY;
});

/* Layout scaling */
let layoutScale = 1.0;
/* constants tuned for 720p-fit */
const EDGE_PAD = 10;     // px edge padding inside grid
const MIN_TILE = 64;     // px minimal square for visibility
const GAP_MIN  = 80;     // px
const GAP_MAX  = 120;    // px

/* Lockout timing + readiness flag */
const READY_DELAY_MS = 3000; // delay before selection is allowed (ms)
let isReady = false;

const correctAudio = document.getElementById('correctSound');
const wrongAudio   = document.getElementById('wrongSound');

function applyTheme(theme) {
  document.body.classList.remove('light','dark');
  document.body.classList.add(theme);
}

/* =========================
   TTS helpers
   ========================= */
let preferredVoice = null;

function choosePreferredVoice() {
  const ss = window.speechSynthesis;
  if (!ss || !ss.getVoices) return;
  const voices = ss.getVoices() || [];
  if (!voices.length) return;

  const by = (fn) => voices.find(fn);
  preferredVoice =
    by(v => /sylvie/i.test(v.name || '') && /^fr[-_]?CA/i.test(v.lang || '')) ||
    by(v => /^fr[-_]?CA/i.test(v.lang || '')) ||
    by(v => /^fr[-_]?FR/i.test(v.lang || '')) ||
    by(v => (v.lang || '').toLowerCase().startsWith('fr')) ||
    voices[0];
}

function makeUtterance(text) {
  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;
  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number') ? sfxSetting : (isNaN(uiVol) ? 50 : uiVol);
  const volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));

  const u = new SpeechSynthesisUtterance(text);
  if (preferredVoice) { u.voice = preferredVoice; u.lang = preferredVoice.lang || 'fr-CA'; }
  else { u.lang = 'fr-CA'; }
  u.rate = 1.0;
  u.volume = volume;
  return u;
}
function speak(text) {
  if (!('speechSynthesis' in window)) return;
  try { speechSynthesis.cancel(); } catch(e) {}
  speechSynthesis.speak(makeUtterance(text));
}
function speakNoCancel(text) {
  if (!('speechSynthesis' in window)) return;
  speechSynthesis.speak(makeUtterance(text));
}

function speakPromptWithGap(nStr) {
  const enabled = !!ttsEnabled.checked || !!(window.eyegazeSettings?.ttsEnabled);
  if (!enabled || !nStr) return;

  try { speechSynthesis.cancel(); } catch(e) {}

  const text = 'Trouve le nombre';
  const first = makeUtterance(text);

  let handedOff = false;

  first.onboundary = (ev) => {
    const start = ev.charIndex ?? 0;
    const tail = text.slice(start);
    const approxLen = ev.charLength || (tail.split(/\s+/)[0] || '').length;
    const word = text.substr(start, approxLen).trim().toLowerCase();

    if (!handedOff && (word === 'nombre' || tail.trim().toLowerCase() === 'nombre')) {
      handedOff = true;
      setTimeout(() => { try { speechSynthesis.cancel(); } catch(e) {} speakNoCancel(nStr); }, TIMING.boundaryTailMs);
    }
  };

  first.onend = () => { if (!handedOff) setTimeout(() => speakNoCancel(nStr), TIMING.ttsGap); };

  speechSynthesis.speak(first);
}

function speakPromptIfEnabled() {
  if (!targetNumber) return;
  speakPromptWithGap(targetNumber);
}

if ('speechSynthesis' in window) {
  speechSynthesis.addEventListener('voiceschanged', choosePreferredVoice);
  choosePreferredVoice();
}

/* =========================
   Lock / unlock helpers
   ========================= */
function lockGrid() {
  const grid = document.querySelector('.letter-grid');
  isReady = false;
  stopHover();                          // clear any in-progress dwell/overlay
  if (grid) grid.classList.add('grid-locked');
}

function unlockGrid() {
  const grid = document.querySelector('.letter-grid');
  isReady = true;
  if (grid) {
    grid.classList.remove('grid-locked');
    grid.classList.add('ready-pop');
    setTimeout(() => grid.classList.remove('ready-pop'), 260);
  }
  // Auto-start dwell if pointer already rests on a tile.
  if (!hoveredTile && lastPointer.x !== null && lastPointer.y !== null) {
    const el = document.elementFromPoint(lastPointer.x, lastPointer.y);
    const tile = el && (el.closest ? el.closest('.letter-cell') : null);
    if (tile) hoveredTile = tile;
  }
  if (hoveredTile) startHover(hoveredTile);
}

/* =========================
   Startup & rounds
   ========================= */
function startGame() {
  // Request fullscreen
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.webkitRequestFullscreen) {
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) {
    document.documentElement.msRequestFullscreen();
  }

  // Sync options
  syncEyegazeSettingsFromUI();

  selectedTheme = themeSelect.value;
  applyTheme(selectedTheme);

  // Parse numbers (default to 0-9). Keep unique order.
  const raw = document.getElementById('numberSet').value.replace(/[^0-9]/g,'');
  const seen = new Set();
  numbers = Array.from(raw).filter(d => { if (seen.has(d)) return false; seen.add(d); return true; });
  if (numbers.length === 0) numbers = Array.from('0123456789');

  // Read layout scale
  layoutScale = parseFloat(layoutScaleEl.value) || 1.0;
  layoutScaleVal.textContent = layoutScale.toFixed(2);

  // Show game container & UI parts
  document.querySelector('.game-container').style.display = 'flex';
  document.getElementById('topStrip').style.display = 'block';

  const grid = document.querySelector('.letter-grid');
  grid.style.display = 'grid';
  document.getElementById('prompt').style.display = 'block';

  buildGrid();
  nextRound();

  try { if (window.eyegazeSettings?.hideOverlay) eyegazeSettings.hideOverlay(); } catch(e) {}

  choosePreferredVoice();
}
startButton.addEventListener('click', startGame);

/* ====== Grid build & sizing ====== */
function buildGrid() {
  const grid = document.querySelector('.letter-grid');
  grid.innerHTML = '';

  const total = numbers.length;
  // Allow up to 4 columns so 10 tiles fit comfortably (e.g., 4x3)
  const columns = Math.min(4, Math.ceil(Math.sqrt(total)));
  grid.dataset.columns = String(columns);

  // edge padding minimal
  grid.style.padding = EDGE_PAD + 'px';

  numbers.forEach(n => {
    const cell = document.createElement('div');
    cell.className = 'letter-cell';
    cell.innerHTML = `<span class="cell-char">${n}</span>`;

    // Track hovered tile & start/stop dwell; auto-begin if already ready
    cell.addEventListener('mouseover', () => {
      hoveredTile = cell;
      if (isReady) startHover(cell);
    });
    cell.addEventListener('mouseout', () => {
      if (hoveredTile === cell) hoveredTile = null;
      stopHover();
    });

    grid.appendChild(cell);
  });

  adjustGridSizes();
}
window.addEventListener('resize', adjustGridSizes);

/* Robust fit-to-viewport sizing up to 4 columns */
function adjustGridSizes() {
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  const grid = document.querySelector('.letter-grid');
  const cells = grid.querySelectorAll('.letter-cell');
  if (!cells.length) return;

  const columns = parseInt(grid.dataset.columns || '3', 10);
  const rows    = Math.ceil(cells.length / columns);

  // container dims: use grid-outer as height reference (below the strip)
  const outer = grid.parentElement; // .grid-outer
  const containerW = grid.clientWidth;
  const containerH = outer ? outer.clientHeight : grid.clientHeight;

  const contentW = Math.max(0, containerW - 2 * EDGE_PAD);
  const contentH = Math.max(0, containerH - 2 * EDGE_PAD);
  const contentMin = Math.min(contentW, contentH);

  // Gap scales with viewport, clamped and inversely affected by layoutScale
  let GAP = Math.round((contentMin * 0.02) / Math.max(0.8, layoutScale));
  GAP = clamp(GAP, GAP_MIN, GAP_MAX);
  grid.style.gap = GAP + 'px';

  // Compute the max square that fits both width and height (minus gaps)
  const maxByW = (contentW - (columns - 1) * GAP) / columns;
  const maxByH = (contentH - (rows    - 1) * GAP) / rows;
  const candidate = Math.floor(Math.min(maxByW, maxByH));

  // Apply layoutScale to allow shrinking (or fill if >1)
  const size = clamp(Math.floor(candidate * layoutScale), MIN_TILE, candidate);

  // Grid tracks
  const track = size + 'px';
  grid.style.gridTemplateColumns = `repeat(${columns}, ${track})`;
  grid.style.gridAutoRows        = track;

  // Scale font to tile size
  const fontPx = Math.max(24, Math.floor(size * 0.55));
  cells.forEach(c => { c.style.fontSize = fontPx + 'px'; });

  // Compact breathing room below the instruction strip (small cap so it never pushes tiles offscreen)
  const strip = document.getElementById('topStrip');
  if (strip && strip.style.display !== 'none') {
    const stripGap = clamp(Math.round(size * 0.12), 10, 22); // <= ~22px cap
    strip.style.marginBottom = stripGap + 'px';
  }
}

function nextRound() {
  const strip = document.getElementById('topStrip');
  strip.classList.remove('hidden','fade-out');

  targetNumber = numbers[Math.floor(Math.random() * numbers.length)];
  document.querySelector("#prompt .target-letter").textContent = targetNumber;

  // Lock grid while the prompt is spoken / for a short time
  lockGrid();
  speakPromptIfEnabled();
  adjustGridSizes();

  // Unlock after fixed delay (predictable for students)
  setTimeout(unlockGrid, READY_DELAY_MS);
}

/* ====== Dwell hover handling ====== */
let currentOverlay;

function startHover(tile) {
  // Block selection during lock period
  if (!isReady) return;

  const hoverTime = (window.eyegazeSettings?.dwellTime) || parseInt(dwellSlider.value, 10) || 1500;

  stopHover(); // clean previous
  currentOverlay = document.createElement('div');
  currentOverlay.className = 'dwell-fill';
  tile.appendChild(currentOverlay);

  requestAnimationFrame(() => {
    currentOverlay.style.transition = `width ${hoverTime}ms linear, height ${hoverTime}ms linear`;
    currentOverlay.style.width = '0';
    currentOverlay.style.height = '0';
    requestAnimationFrame(() => {
      currentOverlay.style.width = '100%';
      currentOverlay.style.height = '100%';
    });
  });

  hoverTimeout = setTimeout(() => {
    handleSelection(tile);
    stopHover();
  }, hoverTime);
}

function stopHover() {
  clearTimeout(hoverTimeout);
  if (currentOverlay && currentOverlay.parentElement) currentOverlay.parentElement.removeChild(currentOverlay);
  currentOverlay = null;
}

/* ====== Timings (ms) ====== */
const TIMING = {
  holdRed: 1000,
  glide: 4000,
  grow: 3000,
  pauseAfterGrow: 3000,
  ttsGap: 350,
  boundaryTailMs: 180
};

/* ====== WRONG feedback helper (JS-driven shake) ====== */
function wrongFeedback(el){
  // Reduced-motion users: no physical motion, just a flash
  const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  if (prefersReduce) {
    el.classList.add('wrong-flash');
    setTimeout(() => el.classList.remove('wrong-flash'), 250);
  } else if (el.animate) {
    // Use WAAPI so it can't be canceled by element's transition on transform
    el.animate(
      [
        { transform: 'translateX(0)' },
        { transform: 'translateX(-10px)' },
        { transform: 'translateX(10px)' },
        { transform: 'translateX(-7px)' },
        { transform: 'translateX(7px)' },
        { transform: 'translateX(-4px)' },
        { transform: 'translateX(4px)' },
        { transform: 'translateX(0)' }
      ],
      { duration: 420, easing: 'ease' }
    );
    // Red flash border using box-shadow via inline style (no class race)
    const prevShadow = el.style.boxShadow;
    el.style.boxShadow = 'inset 0 0 0 3px rgba(198,40,40,.45)';
    setTimeout(() => { el.style.boxShadow = prevShadow || ''; }, 420);
  } else {
    // Very old browsers: quick inline-transform shim
    const prev = el.style.transform;
    el.style.transition = 'none';
    let i = 0;
    const seq = [0,-10,10,-7,7,-4,4,0];
    const tick = () => {
      el.style.transform = `translateX(${seq[i]}px)`;
      if (++i < seq.length) setTimeout(tick, 52);
      else {
        el.style.transform = prev || '';
        el.style.transition = '';
      }
    };
    tick();
  }

  // Optional small vibration if available (phones/tablets)
  try { if (navigator.vibrate) navigator.vibrate(60); } catch(e){}
}

/* ====== Correct / wrong selection choreography ====== */
function handleSelection(el) {
  const nStr = el.textContent.trim();

  /* WRONG: shake + sound, then allow retry */
  if (nStr !== targetNumber) {
    playSound(wrongAudio);
    wrongFeedback(el);
    return;
  }

  /* CORRECT flow */
  const grid  = document.querySelector('.letter-grid');
  const strip = document.getElementById('topStrip');
  const found = nStr;

  // Freeze the tile's on-screen position *before* any layout changes
  const startRect = el.getBoundingClientRect();

  // Sound + lock interactions & fade out others
  playSound(correctAudio);
  grid.classList.add('no-input');
  grid.querySelectorAll('.letter-cell').forEach(cell => { if (cell !== el) cell.classList.add('dim'); });

  // Fade the strip but DO NOT collapse it yet (avoid layout shift)
  strip.classList.add('fade-out');

  // STEP 1: tile goes red for 1s
  el.classList.add('correct');
  setTimeout(() => {
    el.classList.remove('correct');

    // Stabilize colors on the original before cloning
    const dark = getComputedStyle(document.body).backgroundColor === 'rgb(0, 0, 0)';
    const bgColor = dark ? '#222' : '#fff';
    const textColor = dark ? '#fff' : '#000';
    el.style.backgroundColor = bgColor;
    el.style.color = textColor;

    // STEP 2: Glide to center & grow (original hidden during flight)
    glideTileToCenter(el, TIMING.glide, TIMING.grow, {bgColor, textColor}, startRect).then((clone) => {
      // Re-read number while big tile is centered (if TTS enabled)
      const ttsOn = !!ttsEnabled.checked || !!(window.eyegazeSettings?.ttsEnabled);
      if (ttsOn && found) speak(found);

      setTimeout(() => {
        if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
        grid.querySelectorAll('.letter-cell').forEach(cell => cell.classList.remove('dim'));
        el.style.opacity = '';
        el.style.backgroundColor = '';
        el.style.color = '';
        el.style.pointerEvents = '';
        grid.classList.remove('no-input');

        // Now that the animation is over, collapse the strip
        strip.classList.add('hidden');
        strip.classList.remove('fade-out');

        nextRound();
      }, TIMING.pauseAfterGrow);
    });

  }, TIMING.holdRed);
}

/* Glide & grow animation — pixel-anchored, using frozen startRect
   GROWTH IS NOW CLAMPED TO FIT VIEWPORT */
function glideTileToCenter(tile, glideMs = 1200, growMs = 700, forcedColors, startRect) {
  return new Promise(resolve => {
    const r  = startRect || tile.getBoundingClientRect();
    const cs = getComputedStyle(tile);

    const clone = tile.cloneNode(true);
    clone.className = 'flying-tile';

    // Match size/position to the *frozen* start rect
    clone.style.width  = r.width + 'px';
    clone.style.height = r.height + 'px';
    clone.style.left   = r.left + 'px';
    clone.style.top    = r.top  + 'px';
    clone.style.transform = 'translate3d(0,0,0) scale(1)';
    clone.style.transformOrigin = 'center center';

    // lock colors & appearance
    const bg = forcedColors?.bgColor || cs.backgroundColor;
    const fg = forcedColors?.textColor || cs.color;
    clone.style.backgroundColor = bg;
    clone.style.color           = fg;
    clone.style.borderRadius    = cs.borderRadius;
    clone.style.border          = cs.border;
    clone.style.boxShadow       = cs.boxShadow;
    clone.style.fontSize        = cs.fontSize;
    clone.style.lineHeight      = cs.lineHeight;
    const char = clone.querySelector('.cell-char');
    if (char) char.style.color = fg;

    document.body.appendChild(clone);

    // Hide original during flight
    tile.style.opacity = '0';
    tile.style.pointerEvents = 'none';

    const centerX = window.innerWidth  / 2;
    const centerY = window.innerHeight / 2;
    const dx = centerX - (r.left + r.width  / 2);
    const dy = centerY - (r.top  + r.height / 2);

    // Compute a safe target scale that fits within viewport (with margin)
    const margin = Math.max(16, Math.min(40, Math.round(Math.min(window.innerWidth, window.innerHeight) * 0.04)));
    const maxScaleW = (window.innerWidth  - margin * 2) / r.width;
    const maxScaleH = (window.innerHeight - margin * 2) / r.height;
    let targetScale = Math.min(2, maxScaleW, maxScaleH); // never exceed 2x
    targetScale = Math.max(1, targetScale);              // don't shrink below 1

    // Optional: make grow duration proportional to growth amount
    const growthFactor = Math.max(0, targetScale - 1);
    const adjustedGrowMs = Math.round(growMs * (0.4 + 0.6 * Math.min(1, growthFactor))); // shorter if little growth

    // Ensure first keyframe uses initial style (layout flush)
    void clone.getBoundingClientRect();

    // 1) Glide to center
    const a1 = clone.animate(
      [
        { transform: 'translate3d(0px, 0px, 0) scale(1)' },
        { transform: `translate3d(${dx}px, ${dy}px, 0) scale(1)` }
      ],
      { duration: glideMs, easing: 'cubic-bezier(.25,.8,.25,1)', fill: 'forwards' }
    );

    a1.onfinish = () => {
      // 2) Grow in place — but only as much as fits the viewport
      const a2 = clone.animate(
        [
          { transform: `translate3d(${dx}px, ${dy}px, 0) scale(1)` },
          { transform: `translate3d(${dx}px, ${dy}px, 0) scale(${targetScale})` }
        ],
        { duration: adjustedGrowMs, easing: 'cubic-bezier(.2,.7,.2,1)', fill: 'forwards' }
      );
      a2.onfinish = () => resolve(clone);
    };
  });
}

function playSound(audioEl) {
  const muted = !!(window.eyegazeSettings?.sfxMuted) || !!muteSFX.checked;
  const sfxSetting = window.eyegazeSettings?.sfxVolume;
  const uiVol = parseInt(sfxVol.value, 10);
  const volPercent = (typeof sfxSetting === 'number') ? sfxSetting : (isNaN(uiVol) ? 50 : uiVol);

  audioEl.volume = muted ? 0 : Math.max(0, Math.min(1, volPercent / 100));
  try { audioEl.currentTime = 0; audioEl.play(); } catch(e) {}

  // soft stop after ~2s
  setTimeout(() => { try { audioEl.pause(); audioEl.currentTime = 0; } catch(e){} }, 2000);
}
</script>
</body>
</html>
