<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8"/>
  <title data-fr="Personnaliser un pictogramme" data-en="Pictogram Customizer">Personnaliser un pictogramme</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <link rel="stylesheet" href="../../css/choix.css"/>
  <link rel="stylesheet" href="../../css/cvigenerator.css"/>

  <style>
    :root{ --accent:#009688; --line:#e6eaef; }
    html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#fff;color:#000;font-family:Arial,sans-serif}
    .app-container{display:flex;height:100vh;width:100%}

    /* Sidebar */
    #menu{
      width:30vw; min-width:260px; max-width:520px; padding:20px;
      background:#fff; color:#000; border-right:4px solid var(--accent);
      overflow-y:auto; box-sizing:border-box;
    }
    #menu h2{
      margin:0 0 1rem; color:var(--accent); font-size:1.5rem;
      border-bottom:2px solid var(--accent); padding-bottom:.5rem; text-align:center;
    }

    .group{ box-shadow:0 1px 4px rgba(0,0,0,.15); border-radius:6px; padding:1rem 1.2rem; background:#fff; margin:1rem 0; }
    .group h3{ margin:0 0 .6rem; color:#333; }
    .row{ display:flex; align-items:center; gap:.6rem; margin:.5rem 0; }
    .row input[type="text"], .row input[type="number"], .row select{
      flex:1; padding:.6rem .75rem; border:1px solid var(--line); border-radius:6px; background:#fff; color:#000;
    }
    .row input[type="color"]{ width:42px; height:32px; border:none; background:transparent; padding:0; }
    .row input[type="range"]{ flex:1; }
    .inline{ display:flex; align-items:center; justify-content:space-between; background:#eefaf8; border:1px solid #bfe7e1; padding:.55rem .7rem; border-radius:6px; }
    .export-btn{ display:inline-block; padding:10px 16px; margin:4px; font-size:1rem; background:#009688; color:#fff; border:none; border-radius:4px; cursor:pointer; }
    .export-btn.alt{ background:#fff; color:#009688; border:2px solid #009688; }

    /* Preview */
    #content{ flex:1; display:flex; justify-content:center; align-items:center; background:#f3f4f6; }
    #previewCanvas{ width:min(72vmin,860px); height:min(72vmin,860px); background:#fff; border:1px solid var(--line); border-radius:10px; }

    /* Floating toolbar */
    #toolbar{
      position:fixed; right:20px; bottom:20px; display:flex; gap:10px; flex-wrap:wrap;
      background:#fff; border:1px solid var(--line); border-radius:10px; padding:10px; box-shadow:0 8px 24px rgba(0,0,0,.08);
    }

    /* Modal */
    .modal{ display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); justify-content:center; align-items:flex-start; padding-top:5%; opacity:0; transition:opacity .25s ease; z-index:2000; pointer-events:none; }
    .modal.show{ display:flex; opacity:1; pointer-events:auto; }
    .modal-content{ background:#fff; color:#000; border:2px solid #009688; border-radius:6px; padding:16px; width:min(1100px,92vw); max-height:80vh; overflow:auto; }

    .gm-toolbar{ display:flex; gap:.5rem; align-items:center; margin-bottom:.6rem; flex-wrap:wrap; }
    .gm-grid{ --cell:120px; display:grid; grid-template-columns:repeat(auto-fill,minmax(var(--cell),1fr)); gap:10px; }
    .gm-item{ border:1px solid var(--line); border-radius:8px; background:#fff; aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; cursor:pointer; }
    .gm-item img{ width:100%; height:100%; object-fit:contain; }

    /* NEW: visual highlight when current image is found */
    .gm-item.is-selected { outline: 3px solid var(--accent); outline-offset: 2px; }

    #advPanel{ display:none; }

    /* Simple language toggle (optional; translationonly.js may also inject one) */
    #lang-toggle{
      position: fixed; top: 10px; right: 12px; z-index: 2500;
      display:flex; gap:6px; background:#ffffffcc; border:1px solid #e0e0e0; padding:6px 8px; border-radius:999px;
      font-size: 14px;
    }
    #lang-toggle button{
      border:none; background:transparent; cursor:pointer; padding:4px 8px; border-radius:999px;
    }
    #lang-toggle button.active{ background:#009688; color:#fff; }
  </style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
</head>
<body>

  <div class="app-container">
    <aside id="menu">
      <h2 data-fr="Personnaliser un pictogramme" data-en="Pictogram Customizer">Personnaliser un pictogramme</h2>

      <div class="group">
        <h3 data-fr="Image" data-en="Image">Image</h3>
        <div class="row" style="justify-content:center;">
          <button id="openGalleryBtn" class="export-btn" data-fr="Ouvrir la galerie du dossier" data-en="Open folder gallery">Ouvrir la galerie du dossier</button>
          <input id="uploadInput" type="file" accept="image/*" multiple style="display:none;">
          <button id="uploadBtn" class="export-btn alt" data-fr="Importer…" data-en="Upload…">Importer…</button>
        </div>
      </div>

      <div class="group">
        <h3 data-fr="Légendes" data-en="Captions">Légendes</h3>
        <div class="row">
          <input id="topLabelText" type="text"
                 placeholder="Texte du haut (noir, ~64px)"
                 data-fr-placeholder="Texte du haut (noir, ~64px)"
                 data-en-placeholder="Top text (black, ~64px)">
        </div>
        <div class="row">
          <input id="labelText" type="text"
                 placeholder="Texte du bas (noir, ~64px)"
                 data-fr-placeholder="Texte du bas (noir, ~64px)"
                 data-en-placeholder="Bottom text (black, ~64px)">
        </div>
      </div>

      <div class="group">
        <h3 data-fr="Exportation" data-en="Export">Exportation</h3>
        <div class="row" style="justify-content:center;">
          <button id="downloadBtn" class="export-btn" data-fr="Télécharger PNG" data-en="Download PNG">Télécharger PNG</button>
        </div>
      </div>

      <div class="toggle-container" style="margin-top:30px">
        <label class="teal-label">
          <input type="checkbox" id="toggleAdvanced">
          <span data-fr="Afficher les réglages avancés" data-en="Show advanced settings">Afficher les réglages avancés</span>
        </label>
      </div>

      <div id="advPanel">
        <!-- Background / Shape -->
        <div class="group">
          <h3 data-fr="Arrière-plan / Forme" data-en="Background / Shape">Arrière-plan / Forme</h3>

          <div class="row inline">
            <label class="teal-label">
              <input id="bgTransparent" type="checkbox">
              <span data-fr="Arrière-plan transparent" data-en="Transparent background">Arrière-plan transparent</span>
            </label>
          </div>

          <div class="row">
            <label>
              <span data-fr="Couleur" data-en="Color">Couleur</span>
              <input id="bgColor" type="color" value="#ffffff">
            </label>
            <label style="flex:1">
              <span data-fr="Forme" data-en="Shape">Forme</span>
              <select id="bgShape">
                <option value="none" data-fr="Aucune" data-en="None">Aucune</option>
                <option value="rounded" selected data-fr="Carré arrondi" data-en="Rounded square">Carré arrondi</option>
                <option value="circle" data-fr="Cercle" data-en="Circle">Cercle</option>
                <option value="roundedRect" data-fr="Rectangle arrondi" data-en="Rounded rectangle">Rectangle arrondi</option>
              </select>
            </label>
          </div>

          <div class="row">
            <label style="flex:1">
              <span data-fr="Rayon des coins (%)" data-en="Corner radius (%)">Rayon des coins (%)</span>
              <input id="cornerPct" type="range" min="0" max="50" value="22">
            </label>
            <label style="flex:1">
              <span data-fr="Marge (%)" data-en="Padding (%)">Marge (%)</span>
              <input id="paddingPct" type="range" min="0" max="40" value="10">
            </label>
          </div>

          <div class="row inline">
            <label class="teal-label">
              <input id="strokeOn" type="checkbox">
              <span data-fr="Bordure" data-en="Border">Bordure</span>
            </label>
          </div>

          <div class="row">
            <label>
              <span data-fr="Couleur" data-en="Color">Couleur</span>
              <input id="strokeColor" type="color" value="#000000">
            </label>
            <label style="flex:1">
              <span data-fr="Épaisseur (%)" data-en="Thickness (%)">Épaisseur (%)</span>
              <input id="strokePct" type="range" min="0" max="8" value="2">
            </label>
          </div>

          <div class="row inline">
            <label class="teal-label">
              <input id="shadowOn" type="checkbox">
              <span data-fr="Ombre" data-en="Shadow">Ombre</span>
            </label>
          </div>
        </div>

        <!-- Icon -->
        <div class="group">
          <h3 data-fr="Icône" data-en="Icon">Icône</h3>
          <div class="row">
            <label style="flex:1">
              <span data-fr="Teinte (%)" data-en="Tint (%)">Teinte (%)</span>
              <input id="tintPct" type="range" min="0" max="100" value="0">
            </label>
            <label>
              <span data-fr="Couleur" data-en="Color">Couleur</span>
              <input id="tintColor" type="color" value="#000000">
            </label>
          </div>
          <div class="row">
            <label style="flex:1">
              <span data-fr="Échelle (%)" data-en="Scale (%)">Échelle (%)</span>
              <input id="iconScalePct" type="range" min="40" max="110" value="100">
            </label>
          </div>
        </div>

        <!-- Text options -->
        <div class="group">
          <h3 data-fr="Options de texte" data-en="Text options">Options de texte</h3>
          <div class="row">
            <label>
              <span data-fr="Taille (px)" data-en="Size (px)">Taille (px)</span>
              <input id="labelSize" type="number" min="8" max="240" value="64">
            </label>
            <label>
              <span data-fr="Couleur" data-en="Color">Couleur</span>
              <input id="labelColor" type="color" value="#000000">
            </label>
          </div>

          <div class="row inline">
            <label class="teal-label">
              <input id="labelBandOn" type="checkbox" checked>
              <span data-fr="Bannière derrière le texte" data-en="Banner behind text">Bannière derrière le texte</span>
            </label>
          </div>

          <div class="row">
            <label>
              <span data-fr="Couleur de la bannière" data-en="Banner color">Couleur de la bannière</span>
              <input id="labelBandColor" type="color" value="#ffffff">
            </label>
            <label style="flex:1">
              <span data-fr="Marge de la bannière (%)" data-en="Banner padding (%)">Marge de la bannière (%)</span>
              <input id="labelBandPadPct" type="range" min="0" max="20" value="6">
            </label>
          </div>

          <div class="row">
            <label style="flex:1">
              <span data-fr="Décalage haut (%)" data-en="Top offset (%)">Décalage haut (%)</span>
              <input id="topOffsetPct" type="range" min="-10" max="60" value="-4">
            </label>
            <label style="flex:1">
              <span data-fr="Décalage bas (%)" data-en="Bottom offset (%)">Décalage bas (%)</span>
              <input id="bottomOffsetPct" type="range" min="-10" max="60" value="-4">
            </label>
          </div>
        </div>

        <div class="group">
          <h3 data-fr="Exportation (avancé)" data-en="Export (Advanced)">Exportation (avancé)</h3>
          <div class="row">
            <label style="flex:1">
              <span data-fr="Taille PNG (px)" data-en="PNG size (px)">Taille PNG (px)</span>
              <input id="sizePx" type="range" min="128" max="2048" step="128" value="512">
            </label>
            <span id="sizePxVal">512</span>
          </div>
          <div class="row" style="justify-content:center;">
            <button id="clearSavedBtn" class="export-btn alt" data-fr="Effacer les options enregistrées" data-en="Clear saved options">Effacer les options enregistrées</button>
          </div>
        </div>
      </div>
    </aside>

    <main id="content">
      <canvas id="previewCanvas" width="1024" height="1024" aria-label="Preview"></canvas>
      <div id="toolbar">
        <button id="clearBtn" class="export-btn alt" title="Clear image and text"
                data-fr="Effacer" data-en="Clear">Effacer</button>
      </div>
    </main>
  </div>

  <!-- Gallery modal -->
  <div id="galleryModal" class="modal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-label="Folder gallery">
      <h3 data-fr="Galerie du dossier" data-en="Folder gallery">Galerie du dossier</h3>
      <div class="gm-toolbar">
        <label style="min-width:220px;">
          <span data-fr="Catégorie" data-en="Category">Catégorie</span>
          <select id="gmCategory"></select>
        </label>
        <input id="gmSearch" type="text"
               placeholder="Filtrer…"
               data-fr-placeholder="Filtrer…"
               data-en-placeholder="Filter…">
        <label>
          <span data-fr="Taille des vignettes" data-en="Thumb size">Taille des vignettes</span>
          <input id="gmSize" type="range" min="90" max="220" value="120">
        </label>
        <button id="gmClose" class="export-btn" data-fr="Fermer" data-en="Close">Fermer</button>
      </div>
      <div id="gmGrid" class="gm-grid"></div>
    </div>
  </div>

  <script>
    // ===== Simple helper to toggle lang buttons and notify translationonly.js (if it listens) =====
    (function(){
      const root = document.documentElement;
      const toggle = document.getElementById('lang-toggle');
      if (!toggle) return;
      const btns = toggle.querySelectorAll('button[data-lang]');
      function setLang(l){
        root.setAttribute('lang', l);
        btns.forEach(b=>b.classList.toggle('active', b.dataset.lang===l));
        try { localStorage.setItem('lang', l); } catch(e){}
        // Let translationonly.js know, if it listens for this:
        window.dispatchEvent(new CustomEvent('langchange', { detail:{ lang:l }}));
      }
      // restore
      let saved = null;
      try { saved = localStorage.getItem('lang'); } catch(e){}
      if (saved === 'en' || saved === 'fr') setLang(saved); else setLang('fr');

      btns.forEach(b=> b.addEventListener('click', ()=> setLang(b.dataset.lang)));
    })();
  </script>

  <script>
    // ===== Canvas & elements =====
    const cvs = document.getElementById('previewCanvas');
    const ctx = cvs.getContext('2d');

    // Quick controls
    const topLabelText   = document.getElementById('topLabelText');
    const bottomLabelText= document.getElementById('labelText');
    const downloadBtn    = document.getElementById('downloadBtn');
    const clearSavedBtn  = document.getElementById('clearSavedBtn');
    const sizePx         = document.getElementById('sizePx');
    const sizePxVal      = document.getElementById('sizePxVal');

    // Advanced toggle + panel
    const toggleAdvanced = document.getElementById('toggleAdvanced');
    const advPanel       = document.getElementById('advPanel');

    // Advanced controls
    const bgTransparent  = document.getElementById('bgTransparent');
    const bgShape        = document.getElementById('bgShape');
    const bgColor        = document.getElementById('bgColor');
    const cornerPct      = document.getElementById('cornerPct');
    const paddingPct     = document.getElementById('paddingPct');
    const strokeOn       = document.getElementById('strokeOn');
    const strokeColor    = document.getElementById('strokeColor');
    const strokePct      = document.getElementById('strokePct');
    const shadowOn       = document.getElementById('shadowOn');
    const tintPct        = document.getElementById('tintPct');
    const tintColor      = document.getElementById('tintColor');
    const iconScalePct   = document.getElementById('iconScalePct');
    const labelSize      = document.getElementById('labelSize');
    const labelColor     = document.getElementById('labelColor');
    const labelBandOn    = document.getElementById('labelBandOn');
    const labelBandColor = document.getElementById('labelBandColor');
    const labelBandPadPct= document.getElementById('labelBandPadPct');
    const topOffsetPct   = document.getElementById('topOffsetPct');
    const bottomOffsetPct= document.getElementById('bottomOffsetPct');

    // Buttons
    const clearBtn       = document.getElementById('clearBtn');
    const openGalleryBtn = document.getElementById('openGalleryBtn');
    const uploadBtn      = document.getElementById('uploadBtn');
    const uploadInput    = document.getElementById('uploadInput');

    // Modal (simplified)
    const galleryModal   = document.getElementById('galleryModal');
    const gmGrid         = document.getElementById('gmGrid');
    const gmSearch       = document.getElementById('gmSearch');
    const gmSize         = document.getElementById('gmSize');
    const gmClose        = document.getElementById('gmClose');
    const gmCategory     = document.getElementById('gmCategory');

    // State
    let img = null;
    let exportSize = parseInt(sizePx?.value ?? 512,10);
    let manifest = null;
    let gridItems = [];
    const LS_KEY = 'pictosCustomizer:v2';
    const LS_CAT = 'pictosCustomizer:lastCategory';
    let currentImageMeta = { type:'none' };
    let categoryIndex = []; // [{key:'animaux', label:'animaux', files:[...]}]
    let currentCategoryKey = null; // null = "All"

    // ===== Defaults for a complete reset =====
    const DEFAULTS = {
      advOpen: false,
      exportSize: 512,
      quick: { topText:'', bottomText:'' },
      text: {
        size: 64, color:'#000000', bandOn:true, bandColor:'#ffffff',
        bandPadPct: 6, topOffsetPct: -4, bottomOffsetPct: -4,
      },
      bg: {
        transparent: false, color:'#ffffff', shape:'rounded',
        cornerPct: 22, paddingPct: 10, strokeOn:false,
        strokeColor:'#000000', strokePct: 2, shadowOn:false
      },
      icon: { tintPct:0, tintColor:'#000000', scalePct:100 },
      image: { type:'none' }
    };

    // ===== Helpers (drawing) =====
    function roundRectPath(ctx,x,y,w,h,r){
      const rr=Math.max(0,Math.min(r,Math.min(w,h)/2));
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
    function drawShape(ctx,shape,x,y,w,h,radiusPct){
      if(shape==='none'){ ctx.beginPath(); ctx.rect(x,y,w,h); ctx.closePath(); return; }
      if(shape==='circle'){
        const cx=x+w/2, cy=y+h/2, r=Math.min(w,h)/2;
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.closePath();
      } else {
        const rr=(Math.min(w,h)*(radiusPct/100));
        roundRectPath(ctx,x,y,w,h,rr);
      }
    }
    function labelBandHeight(ctx, text, px, bandPad){
      if(!text) return 0;
      ctx.save();
      ctx.font=`600 ${px}px Arial, sans-serif`;
      const m=ctx.measureText(text);
      const ascent=m.actualBoundingBoxAscent||px*.8;
      const descent=m.actualBoundingBoxDescent||px*.2;
      const textH=ascent+descent;
      const pad=px*bandPad;
      const bandH=textH+pad*2;
      ctx.restore();
      return bandH;
    }
    function drawLabelAtY(ctx, text, px, color, bandOn, bandColor, bandPad, x, y, w){
      if(!text) return 0;
      ctx.save();
      ctx.font=`600 ${px}px Arial, sans-serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      const m=ctx.measureText(text);
      const ascent=m.actualBoundingBoxAscent||px*.8;
      const descent=m.actualBoundingBoxDescent||px*.2;
      const textH=ascent+descent;
      const pad=px*bandPad;
      const bandH=textH+pad*2;
      if(bandOn){
        ctx.fillStyle=bandColor;
        roundRectPath(ctx, x, y, w, bandH, Math.min(16, bandH*0.3));
        ctx.fill();
      }
      ctx.fillStyle=color;
      ctx.fillText(text, x + w/2, y + bandH/2);
      ctx.restore();
      return bandH;
    }
    function drawTinted(ctx,image,dx,dy,dw,dh,color,alpha){
      ctx.save();
      ctx.drawImage(image,dx,dy,dw,dh);
      if(alpha>0){
        ctx.globalCompositeOperation='source-atop';
        ctx.globalAlpha=alpha;
        ctx.fillStyle=color;
        ctx.fillRect(dx,dy,dw,dh);
      }
      ctx.restore();
    }

    function render(size=cvs.width){
      cvs.width=cvs.height=size;
      ctx.clearRect(0,0,size,size);

      // Read UI
      const topText     = topLabelText.value.trim();
      const bottomText  = bottomLabelText.value.trim();
      const labelPx     = parseInt(labelSize.value||64,10);
      const labelCol    = labelColor.value || '#000000';

      const padPctVal   = parseFloat(paddingPct.value)/100;
      const corner      = parseFloat(cornerPct.value);
      const shape       = bgShape.value;
      const transparent = bgTransparent.checked;
      const strokeEnabled = strokeOn.checked;
      const strokeW     = (parseFloat(strokePct.value)/100) * size;
      const shadow      = shadowOn.checked;

      const bandOn      = labelBandOn.checked;
      const bandCol     = labelBandColor.value;
      const bandPad     = parseFloat(labelBandPadPct.value)/100;

      const topOffset   = (parseFloat(topOffsetPct.value)||0)/100 * size;
      const bottomOffset= (parseFloat(bottomOffsetPct.value)||0)/100 * size;

      const box = {x:0,y:0,w:size,h:size};

      // Background
      if(!transparent){
        ctx.fillStyle = bgColor.value || '#ffffff';
        ctx.fillRect(box.x, box.y, box.w, box.h);

        if(shadow && shape!=='none'){
          ctx.save();
          ctx.shadowColor='rgba(0,0,0,0.35)';
          ctx.shadowBlur=Math.max(2,size*0.02);
          ctx.shadowOffsetY=size*0.01;
          ctx.fillStyle = bgColor.value || '#ffffff';
          drawShape(ctx,shape,box.x,box.y,box.w,box.h,corner);
          ctx.fill();
          ctx.restore();
        }
      }

      // Frame (inside padding and border)
      const padPx = size * padPctVal;
      const strokeInset = (strokeEnabled && shape!=='none') ? Math.max(1, strokeW*0.5) : 0;
      const frame = {
        x: box.x + padPx + strokeInset,
        y: box.y + padPx + strokeInset,
        w: box.w - 2*(padPx + strokeInset),
        h: box.h - 2*(padPx + strokeInset)
      };

      // Clip to inner shape
      ctx.save();
      if (shape !== 'none'){
        drawShape(ctx, shape,
          box.x + strokeInset, box.y + strokeInset,
          box.w - 2*strokeInset, box.h - 2*strokeInset, corner);
        ctx.clip();
      }

      // Band heights
      const hTop = labelBandHeight(ctx, topText, labelPx, bandPad);
      const hBot = labelBandHeight(ctx, bottomText, labelPx, bandPad);

      // Place captions
      let topY = frame.y + topOffset;
      let botY = frame.y + frame.h - bottomOffset - hBot;

      if (topY + hTop > botY) {
        const mid = frame.y + frame.h/2;
        topY = mid - hTop;
        botY = mid;
      }

      if (topText)   drawLabelAtY(ctx, topText,   labelPx, labelCol, bandOn, bandCol, bandPad, frame.x, topY, frame.w);
      if (bottomText)drawLabelAtY(ctx, bottomText,labelPx, labelCol, bandOn, bandCol, bandPad, frame.x, botY, frame.w);

      // Image in remaining slot
      const slotTop = topText ? topY + hTop : frame.y;
      const slotBot = bottomText ? botY : frame.y + frame.h;
      const slotH   = Math.max(0, slotBot - slotTop);

      if (img && slotH > 0){
        const asp = img.width / img.height;
        let dw = frame.w;
        let dh = dw / asp;
        if (dh > slotH){ dh = slotH; dw = dh * asp; }
        const dx = frame.x + (frame.w - dw)/2;
        const dy = slotTop + (slotH - dh)/2;
        const a = parseFloat(tintPct.value)/100;
        drawTinted(ctx, img, dx, dy, dw, dh, tintColor.value, a);
      }

      ctx.restore();

      // Border
      if(strokeEnabled && shape!=='none'){
        ctx.save();
        ctx.lineWidth = Math.max(1, strokeW);
        ctx.strokeStyle = strokeColor.value;
        drawShape(ctx, shape, box.x + ctx.lineWidth/2, box.y + ctx.lineWidth/2, box.w - ctx.lineWidth, box.h - ctx.lineWidth, corner);
        ctx.stroke();
        ctx.restore();
      }
    }

    // ===== Persist simple state =====
    function readState(){
      return {
        advOpen: !!toggleAdvanced.checked,
        exportSize: parseInt(sizePx?.value ?? 512,10),
        quick: { topText: topLabelText.value || '', bottomText: bottomLabelText.value || '' },
        text: {
          size: parseInt(labelSize.value,10),
          color: labelColor.value,
          bandOn: !!labelBandOn.checked,
          bandColor: labelBandColor.value,
          bandPadPct: parseFloat(labelBandPadPct.value),
          topOffsetPct: parseFloat(topOffsetPct.value),
          bottomOffsetPct: parseFloat(bottomOffsetPct.value),
        },
        bg: {
          transparent: !!bgTransparent.checked,
          color: bgColor.value,
          shape: bgShape.value,
          cornerPct: parseFloat(cornerPct.value),
          paddingPct: parseFloat(paddingPct.value),
          strokeOn: !!strokeOn.checked,
          strokeColor: strokeColor.value,
          strokePct: parseFloat(strokePct.value),
          shadowOn: !!shadowOn.checked
        },
        icon: {
          tintPct: parseFloat(tintPct.value),
          tintColor: tintColor.value,
          scalePct: parseFloat(iconScalePct.value)
        },
        image: currentImageMeta
      };
    }
    function writeState(s){
      if (!s) return;
      toggleAdvanced.checked = !!s.advOpen;
      advPanel.style.display = toggleAdvanced.checked ? 'block' : 'none';

      if (Number.isFinite(s.exportSize)) {
        if (sizePx) sizePx.value = s.exportSize;
        exportSize = s.exportSize;
        if (sizePxVal) sizePxVal.textContent = s.exportSize;
      }

      if (s.quick){ topLabelText.value = s.quick.topText ?? ''; bottomLabelText.value = s.quick.bottomText ?? ''; }

      if (s.text){
        labelSize.value       = Number.isFinite(s.text.size) ? s.text.size : 64;
        labelColor.value      = s.text.color || '#000000';
        labelBandOn.checked   = !!s.text.bandOn;
        labelBandColor.value  = s.text.bandColor || '#ffffff';
        labelBandPadPct.value = Number.isFinite(s.text.bandPadPct) ? s.text.bandPadPct : 6;
        topOffsetPct.value    = Number.isFinite(s.text.topOffsetPct) ? s.text.topOffsetPct : 6;
        bottomOffsetPct.value = Number.isFinite(s.text.bottomOffsetPct) ? s.text.bottomOffsetPct : 6;
      }

      if (s.bg){
        bgTransparent.checked = !!s.bg.transparent;
        bgColor.value         = s.bg.color || '#ffffff';
        bgShape.value         = s.bg.shape || 'rounded';
        cornerPct.value       = Number.isFinite(s.bg.cornerPct) ? s.bg.cornerPct : 22;
        paddingPct.value      = Number.isFinite(s.bg.paddingPct) ? s.bg.paddingPct : 10;
        strokeOn.checked      = !!s.bg.strokeOn;
        strokeColor.value     = s.bg.strokeColor || '#000000';
        strokePct.value       = Number.isFinite(s.bg.strokePct) ? s.bg.strokePct : 2;
        shadowOn.checked      = !!s.bg.shadowOn;
      }

      if (s.icon){
        tintPct.value     = Number.isFinite(s.icon.tintPct) ? s.icon.tintPct : 0;
        tintColor.value   = s.icon.tintColor || '#000000';
        iconScalePct.value= Number.isFinite(s.icon.scalePct) ? s.icon.scalePct : 100;
      }

      currentImageMeta = s.image || { type:'none' };
    }

    function save(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(readState())); }catch(e){} }
    function load(){ try{ const raw=localStorage.getItem(LS_KEY); return raw?JSON.parse(raw):null; }catch(e){ return null; } }
    const debounce=(fn,ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
    const saveDebounced = debounce(save, 180);

    // ===== Init & bindings =====
    advPanel.style.display = 'none';
    toggleAdvanced.addEventListener('change', ()=>{ advPanel.style.display = toggleAdvanced.checked ? 'block' : 'none'; render(cvs.width); saveDebounced(); });

    function fitPreview(){
      const s=Math.min(window.innerWidth-360, window.innerHeight-100);
      const size=Math.max(256, Math.min(1024, Math.floor(s)));
      render(size);
    }
    window.addEventListener('resize', fitPreview);

    [
      sizePx, topLabelText, bottomLabelText,
      bgTransparent,bgShape,bgColor,cornerPct,paddingPct,
      strokeOn,strokeColor,strokePct,shadowOn,
      tintPct,tintColor,iconScalePct,
      labelSize,labelColor,labelBandOn,labelBandColor,labelBandPadPct,
      topOffsetPct,bottomOffsetPct
    ].forEach(el=>el && el.addEventListener('input', ()=>{ if (sizePx===el){ exportSize=parseInt(sizePx.value,10); sizePxVal.textContent=exportSize; } render(cvs.width); saveDebounced(); }));

    // Clear (image + texts only)
    clearBtn.addEventListener('click', ()=>{
      img = null; currentImageMeta = { type:'none' };
      topLabelText.value = ''; bottomLabelText.value = '';
      render(); saveDebounced();
    });

    // ----- TRUE full reset -----
    function resetToDefaults(){
      toggleAdvanced.checked = DEFAULTS.advOpen;
      advPanel.style.display = DEFAULTS.advOpen ? 'block' : 'none';

      if (sizePx){ sizePx.value = DEFAULTS.exportSize; sizePxVal.textContent = DEFAULTS.exportSize; }
      exportSize = DEFAULTS.exportSize;

      topLabelText.value = DEFAULTS.quick.topText;
      bottomLabelText.value = DEFAULTS.quick.bottomText;

      // Text
      labelSize.value       = DEFAULTS.text.size;
      labelColor.value      = DEFAULTS.text.color;
      labelBandOn.checked   = DEFAULTS.text.bandOn;
      labelBandColor.value  = DEFAULTS.text.bandColor;
      labelBandPadPct.value = DEFAULTS.text.bandPadPct;
      topOffsetPct.value    = DEFAULTS.text.topOffsetPct;
      bottomOffsetPct.value = DEFAULTS.text.bottomOffsetPct;

      // Background
      bgTransparent.checked = DEFAULTS.bg.transparent;
      bgColor.value         = DEFAULTS.bg.color;
      bgShape.value         = DEFAULTS.bg.shape;
      cornerPct.value       = DEFAULTS.bg.cornerPct;
      paddingPct.value      = DEFAULTS.bg.paddingPct;
      strokeOn.checked      = DEFAULTS.bg.strokeOn;
      strokeColor.value     = DEFAULTS.bg.strokeColor;
      strokePct.value       = DEFAULTS.bg.strokePct;
      shadowOn.checked      = DEFAULTS.bg.shadowOn;

      // Icon
      tintPct.value         = DEFAULTS.icon.tintPct;
      tintColor.value       = DEFAULTS.icon.tintColor;
      iconScalePct.value    = DEFAULTS.icon.scalePct;

      // Image + category
      img = null;
      currentImageMeta = { type:'none' };
      currentCategoryKey = null;
      if (gmCategory) gmCategory.value = '';

      try{
        localStorage.removeItem(LS_KEY);
        localStorage.removeItem(LS_CAT);
      }catch(e){}

      render(cvs.width);
    }

    if (clearSavedBtn) clearSavedBtn.addEventListener('click', ()=>{
      resetToDefaults();
      alert('All options reset to defaults.');
    });

    // ===== Gallery with categories =====
    function showModal(){ galleryModal.classList.add('show'); }
    function hideModal(){ galleryModal.classList.remove('show'); }
    // CHANGED: do NOT auto-restore (no auto-close flash)
    openGalleryBtn.onclick = ()=>{ showModal(); ensureManifestAndUI(false); };
    gmClose.onclick=hideModal;

    gmSize.oninput=()=>document.querySelector('.gm-grid').style.setProperty('--cell', gmSize.value+'px');
    gmSearch.oninput=()=>applyFiltersAndRender();

    gmCategory.addEventListener('change', ()=>{
      currentCategoryKey = gmCategory.value || null;
      try{ localStorage.setItem(LS_CAT, currentCategoryKey ?? ''); }catch(e){}
      applyFiltersAndRender();
    });

    // Pretty labels
    const pretty = (s)=> String(s).replaceAll('_',' ');

    async function fetchManifest(){
      const res=await fetch('../../images/pictos/index.json',{cache:'no-store'});
      if(!res.ok) throw new Error(res.status+' '+res.statusText);
      const data=await res.json();
      const rawBase = typeof data.base === 'string' ? data.base : '.';
      const base = new URL(rawBase, res.url).pathname;
      let cats = [];
      if (data.categories && typeof data.categories === 'object'){
        cats = Object.entries(data.categories).map(([key,val])=>{
          const files = Array.isArray(val)
            ? val.filter(Boolean)
            : Array.isArray(val?.items)
              ? val.items.map(it=> typeof it === 'string' ? it : it?.file).filter(Boolean)
              : [];
          const frLabel = (!Array.isArray(val) && val?.label?.fr) || (typeof val?.label === 'string' ? val.label : null);
          const enLabel = (!Array.isArray(val) && val?.label?.en) || (typeof val?.label === 'string' ? val.label : null);
          return {
            key,
            label: frLabel || enLabel || pretty(key),
            labels: { fr: frLabel, en: enLabel },
            files
          };
        }).filter(c=>c.files.length>0);
      } else if (Array.isArray(data.files)) {
        const files = data.files.filter(Boolean);
        cats = [{ key:'__all', label:'All', labels:{ fr:'Toutes', en:'All' }, files }];
      } else {
        throw new Error('Invalid manifest format');
      }
      return { base, categories: cats };
    }

    function populateCategorySelect(){
      const hasMultiple = categoryIndex.length > 1 || (categoryIndex.length === 1 && categoryIndex[0].key !== '__all');
      const options = [];
      if (hasMultiple){
        const opt = new Option('All', '', false, false);
        opt.setAttribute('data-fr','Toutes');
        opt.setAttribute('data-en','All');
        options.push(opt);
      }
      categoryIndex.forEach(c=>{
        const frLabel = c.labels?.fr || c.label;
        const enLabel = c.labels?.en || c.label;
        const baseLabel = `${frLabel} (${c.files.length})`;
        const opt = new Option(baseLabel, c.key, false, false);
        // mirror label in both langs (best effort)
        opt.setAttribute('data-fr', `${frLabel} (${c.files.length})`);
        opt.setAttribute('data-en', `${enLabel} (${c.files.length})`);
        options.push(opt);
      });
      gmCategory.innerHTML = '';
      options.forEach(o=>gmCategory.add(o));

      const savedCat = (localStorage.getItem(LS_CAT) || '').trim();
      if (savedCat && categoryIndex.some(c=>c.key===savedCat)){
        gmCategory.value = savedCat;
        currentCategoryKey = savedCat;
      } else {
        gmCategory.value = '';
        currentCategoryKey = null;
      }
    }

    function allFilesInCurrentScope(){
      if (!manifest) return [];
      if (!currentCategoryKey){
        const set = new Set();
        categoryIndex.forEach(c => c.files.forEach(f=>set.add(f)));
        return Array.from(set);
      }
      const cat = categoryIndex.find(c=>c.key===currentCategoryKey);
      return cat ? cat.files.slice() : [];
    }

    function applyFiltersAndRender(){
      const files = allFilesInCurrentScope();
      const base = manifest.base;
      const q = gmSearch.value.trim().toLowerCase();
      let list = files.map(fn=>({name:fn, src:base+fn}));
      if (q) list = list.filter(it=>it.name.toLowerCase().includes(q));
      renderGrid(list);
    }

    function renderGrid(list){
      gridItems = list;
      gmGrid.innerHTML='';
      list.forEach(item=>{
        const cell=document.createElement('button'); cell.className='gm-item'; cell.title=item.name;
        const im=document.createElement('img'); im.loading='lazy'; im.alt=item.name; im.src=item.src; cell.appendChild(im);
        cell.onclick=()=>{
          const imageEl=new Image(); imageEl.crossOrigin='anonymous';
          imageEl.onload=()=>{ img=imageEl; currentImageMeta = { type:'gallery', src:item.src, name:item.name }; render(); hideModal(); saveDebounced(); };
          imageEl.src=item.src;
        };
        gmGrid.appendChild(cell);
      });
    }

    async function ensureManifestAndUI(alsoTryRestore){
      try{
        if (!manifest){
          const data = await fetchManifest();
          manifest = { base: data.base };
          categoryIndex = data.categories;
          populateCategorySelect();
        }
        applyFiltersAndRender();

        // CHANGED: if we attempt a restore, only highlight and scroll to the current image; DO NOT close the modal
        if (alsoTryRestore && currentImageMeta?.type === 'gallery' && currentImageMeta.src){
          const idx = gridItems.findIndex(it => it.src === currentImageMeta.src);
          if (idx >= 0){
            requestAnimationFrame(()=>{
              const cell = gmGrid.children[idx];
              if (cell){
                cell.classList.add('is-selected');
                cell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
              }
            });
          }
        }
      }catch(err){
        console.error('Could not load manifest:', err);
        gmGrid.innerHTML = '<div style="padding:12px;color:#b00020;">Failed to load gallery manifest.</div>';
      }
    }

    // Upload local
    uploadBtn.onclick=()=>uploadInput.click();
    uploadInput.onchange=e=>{
      const f=e.target.files?.[0]; if(!f) return;
      const url=URL.createObjectURL(f);
      const im=new Image();
      im.onload=()=>{ img=im; currentImageMeta = { type:'local', name:f.name }; render(); URL.revokeObjectURL(url); saveDebounced(); };
      im.src=url;
    };

    // ===== Download PNG (restored) =====
    function triggerDownloadFromBlob(blob, baseName){
      const a=document.createElement('a');
      a.download=`${baseName}-${exportSize}.png`;
      a.href=URL.createObjectURL(blob);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(()=>URL.revokeObjectURL(a.href),1000);
    }

    function fallbackDataURL(baseName){
      const dataURL = cvs.toDataURL('image/png');
      const a=document.createElement('a');
      a.download=`${baseName}-${exportSize}.png`;
      a.href=dataURL;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    downloadBtn.addEventListener('click', ()=>{
      // Render at export size on the main canvas, grab PNG, then restore preview size
      const prev = cvs.width;
      const baseName = (bottomLabelText.value.trim() || topLabelText.value.trim() || 'pictogram')
        .toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9-_]/g,'');

      render(exportSize);

      if (cvs.toBlob){
        cvs.toBlob(blob=>{
          if (blob){ triggerDownloadFromBlob(blob, baseName); }
          else { fallbackDataURL(baseName); }
          // Restore preview
          render(prev);
        }, 'image/png');
      } else {
        // Fallback for older Safari/iOS
        fallbackDataURL(baseName);
        render(prev);
      }
    });

    // ===== Init =====
    (function init(){
      const saved = load();
      if (saved) writeState(saved);
      else writeState(DEFAULTS);

      const savedCat = (localStorage.getItem(LS_CAT) || '').trim();
      if (savedCat) currentCategoryKey = savedCat;

      if (saved?.image?.type === 'gallery' && saved.image.src){
        const imageEl=new Image(); imageEl.crossOrigin='anonymous';
        imageEl.onload=()=>{ img=imageEl; render(); };
        imageEl.onerror=()=>{ render(); };
        imageEl.src=saved.image.src;
      } else {
        render(); // initial
      }
      fitPreview();

      // If translationonly.js stores a preferred lang, apply it to the toggle
      try{
        const pref = localStorage.getItem('lang');
        if (pref === 'en' || pref === 'fr'){
          const ev = new CustomEvent('langchange', { detail:{ lang:pref }});
          window.dispatchEvent(ev);
          document.documentElement.setAttribute('lang', pref);
          const btns = document.querySelectorAll('#lang-toggle button[data-lang]');
          btns.forEach(b=> b.classList.toggle('active', b.dataset.lang===pref));
        }
      }catch(e){}
    })();
  </script>

  <!-- Translation helper (same as sur l’autre page) -->
  <script src="../../js/translationonly.js"></script>
</body>
</html>
