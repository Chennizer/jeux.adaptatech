<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-fr="Jeux météo automatiques" data-en="Automatic Weather Games">Jeux météo automatiques</title>
  <link rel="stylesheet" href="../../css/menu.css">
  <link rel="stylesheet" href="../../css/global.css">
  <link rel="stylesheet" href="../../css/layout.css">
  <link rel="stylesheet" href="../../css/components.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">
  <style>
    :root {
      --weather-accent: #009688;
      --weather-accent-dark: #006b63;
      --weather-highlight: #ff4d4d;
      --weather-card-bg: #ffffff;
      --weather-card-fg: #000000;
      --weather-card-border: rgba(255, 255, 255, 0.4);
    }

    body.weather-menu {
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      margin: 0;
      font-family: 'Arial', sans-serif;
    }

    main[hidden] {
      display: none;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: clamp(24px, 6vmin, 48px);
      padding: clamp(24px, 8vw, 60px);
      box-sizing: border-box;
    }

    .mode-banner {
      display: grid;
      gap: 12px;
      text-align: center;
      max-width: 780px;
    }

    .mode-chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 24px;
      border-radius: 999px;
      background: rgba(0, 150, 136, 0.18);
      color: #76fff0;
      letter-spacing: 0.08em;
      font-weight: 700;
      text-transform: uppercase;
      font-size: clamp(0.9rem, 2vmin, 1.1rem);
    }

    .mode-detail {
      margin: 0;
      font-size: clamp(1rem, 2.4vmin, 1.25rem);
      line-height: 1.4;
      color: rgba(255, 255, 255, 0.8);
    }

    .weather-grid {
      --card-size: clamp(220px, 32vmin, 360px);
      --gap: clamp(28px, 6vmin, 60px);
      display: grid;
      grid-template-columns: repeat(2, var(--card-size));
      grid-auto-rows: var(--card-size);
      gap: var(--gap);
      place-content: center;
      justify-items: center;
      align-items: center;
      width: 100%;
    }

    .weather-card {
      all: unset;
      position: relative;
      width: 100%;
      height: 100%;
      aspect-ratio: 1 / 1;
      background: var(--weather-card-bg);
      color: var(--weather-card-fg);
      border-radius: 16px;
      border: 3px solid var(--weather-card-border);
      overflow: hidden;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
    }

    @media (hover: hover) and (pointer: fine) {
      .weather-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 18px 36px rgba(0, 0, 0, 0.6);
        border-color: rgba(255, 255, 255, 0.65);
      }
    }

    .weather-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .tile-title {
      position: absolute;
      inset: auto 0 0;
      padding: 18px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.05) 0%, rgba(0, 0, 0, 0.85) 100%);
      color: #fff;
      text-align: center;
    }

    .tile-title h3 {
      margin: 0;
      font-size: clamp(1.1rem, 2.5vmin, 1.6rem);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .tile-title small {
      display: block;
      margin-top: 6px;
      font-size: clamp(0.85rem, 2vmin, 1rem);
      color: rgba(255, 255, 255, 0.8);
    }

    .weather-card.is-selected {
      border-color: var(--weather-highlight);
      box-shadow: 0 0 0 4px rgba(255, 77, 77, 0.4), 0 24px 40px rgba(0, 0, 0, 0.7);
    }

    .weather-card:focus-visible {
      outline: 4px solid rgba(0, 191, 255, 0.65);
      outline-offset: 4px;
    }

    .game-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      background: #000;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms ease;
    }

    .game-overlay[hidden] {
      display: none;
    }

    .game-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 18px;
      padding: clamp(16px, 4vmin, 30px);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.7) 100%);
      color: #fff;
      flex-wrap: wrap;
    }

    .overlay-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }

    .overlay-meta h2 {
      margin: 0;
      font-size: clamp(1.2rem, 3vmin, 2rem);
    }

    .overlay-meta p {
      margin: 0;
      font-size: clamp(1rem, 2.4vmin, 1.3rem);
      opacity: 0.8;
    }

    .overlay-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .overlay-hint {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.75);
    }

    .back-button {
      border: none;
      border-radius: 999px;
      padding: 12px 24px;
      background: rgba(255, 255, 255, 0.18);
      color: #ffffff;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      cursor: pointer;
      transition: background 160ms ease, transform 160ms ease;
    }

    .back-button:focus-visible {
      outline: 3px solid rgba(255, 255, 255, 0.5);
      outline-offset: 3px;
    }

    @media (hover: hover) and (pointer: fine) {
      .back-button:hover {
        background: rgba(255, 255, 255, 0.28);
        transform: translateY(-1px);
      }
    }

    iframe {
      flex: 1;
      border: none;
      width: 100%;
      background: #000;
    }

    /* Eyegaze-style start menu */
    #game-options.modal {
      transition: opacity 320ms ease;
    }

    #game-options.modal.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #game-options #control-panel-options {
      max-width: 840px;
      padding: clamp(24px, 6vmin, 40px);
      gap: clamp(20px, 4vmin, 32px);
    }

    #options-title-bar {
      display: grid;
      gap: 10px;
      text-align: center;
      margin-bottom: 10px;
    }

    #options-title-bar h2 {
      margin: 0;
      font-size: clamp(1.6rem, 3.5vmin, 2.2rem);
      color: #004d40;
    }

    #options-title-bar p {
      margin: 0;
      font-size: clamp(1rem, 2.2vmin, 1.2rem);
      color: #294936;
    }

    #options-inline-container {
      width: 100%;
      align-items: stretch;
    }

    #options-inline-container > .options-column {
      gap: 16px;
      padding: 0 clamp(6px, 1vw, 12px);
    }

    #options-inline-container > .options-column:first-child {
      align-items: flex-start;
    }

    .mode-heading {
      margin: 0 0 6px;
      font-size: clamp(1.1rem, 2.4vmin, 1.4rem);
      color: #004d40;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .mode-text {
      margin: 0;
      font-size: clamp(0.95rem, 2.1vmin, 1.1rem);
      color: #294936;
      line-height: 1.45;
    }

    .mode-card {
      width: 100%;
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: clamp(1rem, 2.4vmin, 1.15rem);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 700;
    }

    .mode-card .mode-action-label {
      font-size: clamp(0.9rem, 2vmin, 1rem);
      letter-spacing: 0.05em;
      text-transform: none;
      font-weight: 600;
    }

    .mode-card.is-active,
    .mode-card.selected {
      background-color: var(--weather-accent);
      box-shadow: 0 6px 18px rgba(0, 150, 136, 0.45);
    }

    .start-hint {
      margin: 0;
      color: #294936;
      font-size: clamp(0.9rem, 2vmin, 1.05rem);
    }

    #scanIntervalValue {
      font-weight: 700;
      color: #00695c;
    }

    @media (max-width: 900px) {
      .weather-grid {
        grid-template-columns: repeat(2, minmax(180px, 42vw));
        grid-auto-rows: minmax(180px, 42vw);
      }
    }

    @media (max-width: 600px) {
      .weather-grid {
        grid-template-columns: repeat(2, minmax(140px, 40vw));
        grid-auto-rows: minmax(140px, 40vw);
        gap: clamp(18px, 6vmin, 28px);
      }
    }
  </style>
</head>
<body class="menu weather-menu">
  <nav class="top-menu">
    <div class="top-menu-title" data-fr="Adaptatech" data-en="Adaptatech">Portail de jeux adaptés</div>
    <ul>
      <li><a href="../../index.html" data-fr="Accueil" data-en="Home">Accueil</a></li>
      <li><a href="../../contact/index.html" data-fr="Contact" data-en="Contact">Contact</a></li>
      <li>
        <a href="#" id="language-toggle" onclick="toggleLanguage(); return false;"></a>
      </li>
    </ul>
  </nav>

  <div id="game-options" class="modal" role="dialog" aria-modal="true">
    <div id="control-panel-options">
      <div id="options-title-bar">
        <h2 id="options-main-title" class="translate" data-fr="Jeux météo automatiques" data-en="Automatic weather games">Jeux météo automatiques</h2>
        <p id="options-subtitle" class="translate" data-fr="Sélectionne ton mode de navigation avant de commencer." data-en="Pick your navigation mode before starting.">Sélectionne ton mode de navigation avant de commencer.</p>
      </div>
      <div id="mode-divider"></div>
      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <h3 class="mode-heading translate" data-fr="Mode tactile" data-en="Touch mode">Mode tactile</h3>
            <p class="mode-text translate" data-fr="Utilise l'écran tactile ou la souris pour choisir un jeu." data-en="Use the touchscreen or mouse to choose a game.">Utilise l'écran tactile ou la souris pour choisir un jeu.</p>
          </div>
          <button class="button mode-card is-active" type="button"
                  data-index="0"
                  data-mode-id="touch"
                  data-label-fr="Mode tactile"
                  data-label-en="Touch mode"
                  data-description-fr="Utilise l'écran tactile ou la souris pour choisir un jeu."
                  data-description-en="Use the touchscreen or mouse to choose a game."
                  aria-pressed="true">
            <span class="translate" data-fr="Choisir ce mode" data-en="Use this mode">Choisir ce mode</span>
          </button>
        </div>
        <div class="options-column">
          <div class="option-item">
            <h3 class="mode-heading translate" data-fr="Mode choix multiples" data-en="Multiple choice mode">Mode choix multiples</h3>
            <p class="mode-text translate" data-fr="Appuie sur Entrée pour déplacer la sélection et sur Espace pour lancer le jeu en surbrillance." data-en="Press Enter to move the highlight and Space to launch the highlighted game.">Appuie sur Entrée pour déplacer la sélection et sur Espace pour lancer le jeu en surbrillance.</p>
          </div>
          <button class="button mode-card" type="button"
                  data-index="1"
                  data-mode-id="multiple"
                  data-label-fr="Mode choix multiples"
                  data-label-en="Multiple choice mode"
                  data-description-fr="Appuie sur Entrée pour déplacer la sélection et sur Espace pour lancer le jeu en surbrillance."
                  data-description-en="Press Enter to move the highlight and Space to launch the highlighted game."
                  aria-pressed="false">
            <span class="translate" data-fr="Choisir ce mode" data-en="Use this mode">Choisir ce mode</span>
          </button>
        </div>
        <div class="options-column">
          <div class="option-item">
            <h3 class="mode-heading translate" data-fr="Mode balayage" data-en="Scanning mode">Mode balayage</h3>
            <p class="mode-text translate" id="scanDescription" data-fr="La sélection avance automatiquement toutes les 10 secondes. Appuie sur Espace pour lancer le jeu en surbrillance." data-en="The highlight moves every 10 seconds. Press Space to start the highlighted game.">La sélection avance automatiquement toutes les 10 secondes. Appuie sur Espace pour lancer le jeu en surbrillance.</p>
          </div>
          <div class="option-item">
            <label for="scanInterval" class="teal-label">
              <span class="translate" data-fr="Intervalle de balayage" data-en="Scan interval">Intervalle de balayage</span>:
              <span id="scanIntervalValue">10</span> s
            </label>
            <input type="range" id="scanInterval" class="styled-slider" min="4" max="20" step="1" value="10">
          </div>
          <button class="button mode-card" type="button"
                  data-index="2"
                  data-mode-id="scan"
                  data-label-fr="Mode balayage"
                  data-label-en="Scanning mode"
                  data-description-fr="La sélection avance automatiquement toutes les 10 secondes. Appuie sur Espace pour lancer le jeu en surbrillance."
                  data-description-en="The highlight moves every 10 seconds. Press Space to start the highlighted game."
                  aria-pressed="false">
            <span class="translate" data-fr="Choisir ce mode" data-en="Use this mode">Choisir ce mode</span>
          </button>
        </div>
      </div>
      <div id="mode-divider"></div>
      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
      <p id="startHint" class="start-hint translate" data-fr="Le mode sélectionné sera utilisé pour naviguer dans les jeux météo." data-en="The selected mode will control how you browse the weather games.">Le mode sélectionné sera utilisé pour naviguer dans les jeux météo.</p>
    </div>
  </div>

  <main id="mainContent" hidden>
    <div class="mode-banner">
      <span id="modeChip" class="mode-chip" data-fr="Mode tactile" data-en="Touch mode">Mode tactile</span>
      <p id="modeDetails" class="mode-detail" data-fr="Utilise l'écran tactile ou la souris pour choisir un jeu." data-en="Use the touchscreen or mouse to choose a game.">Utilise l'écran tactile ou la souris pour choisir un jeu.</p>
    </div>

    <section id="weatherChooser" class="weather-grid" role="list">
      <button class="weather-card" type="button" role="listitem"
        data-index="0"
        data-src="../sunauto/index.html"
        data-title-fr="Soleil"
        data-title-en="Sun"
        data-description-fr="Ambiance lumineuse"
        data-description-en="Warm sunshine"
        aria-label="Soleil - Ambiance lumineuse">
        <img src="../../images/sun.png" alt="Icône de soleil">
        <div class="tile-title">
          <h3 data-fr="Soleil" data-en="Sun">Soleil</h3>
          <small data-fr="Ambiance lumineuse" data-en="Warm sunshine">Ambiance lumineuse</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="1"
        data-src="../cloudauto/index.html"
        data-title-fr="Nuages"
        data-title-en="Clouds"
        data-description-fr="Douce brise"
        data-description-en="Soft breeze"
        aria-label="Nuages - Douce brise">
        <img src="../../images/cloud.png" alt="Icône de nuage">
        <div class="tile-title">
          <h3 data-fr="Nuages" data-en="Clouds">Nuages</h3>
          <small data-fr="Douce brise" data-en="Soft breeze">Douce brise</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="2"
        data-src="../stormauto/index.html"
        data-title-fr="Pluie"
        data-title-en="Rain"
        data-description-fr="Orage relaxant"
        data-description-en="Relaxing storm"
        aria-label="Pluie - Orage relaxant">
        <img src="../../images/rain.png" alt="Icône de pluie">
        <div class="tile-title">
          <h3 data-fr="Pluie" data-en="Rain">Pluie</h3>
          <small data-fr="Orage relaxant" data-en="Relaxing storm">Orage relaxant</small>
        </div>
      </button>

      <button class="weather-card" type="button" role="listitem"
        data-index="3"
        data-src="../snowauto/index.html"
        data-title-fr="Neige"
        data-title-en="Snow"
        data-description-fr="Flocons scintillants"
        data-description-en="Shimmering snow"
        aria-label="Neige - Flocons scintillants">
        <img src="../../images/snow.png" alt="Icône de neige">
        <div class="tile-title">
          <h3 data-fr="Neige" data-en="Snow">Neige</h3>
          <small data-fr="Flocons scintillants" data-en="Shimmering snow">Flocons scintillants</small>
        </div>
      </button>
    </section>
  </main>

  <div class="game-overlay" id="gameOverlay" hidden>
    <div class="overlay-bar">
      <div class="overlay-meta">
        <h2 id="overlayTitle" data-fr="" data-en=""></h2>
        <p id="overlayDescription" data-fr="" data-en=""></p>
      </div>
      <div class="overlay-actions">
        <p class="overlay-hint" id="overlayHint" data-fr="Appuie sur Q pour revenir au menu ou sur Échap pour quitter le jeu." data-en="Press Q to return to the menu or Escape to quit the game.">Appuie sur Q pour revenir au menu ou sur Échap pour quitter le jeu.</p>
        <button class="back-button" id="backButton" type="button" data-fr="Retour" data-en="Back">Retour</button>
      </div>
    </div>
    <iframe id="gameFrame" title="Jeu météo automatique" allow="autoplay; fullscreen" allowfullscreen sandbox="allow-scripts allow-same-origin allow-pointer-lock allow-orientation-lock allow-popups" tabindex="-1"></iframe>
  </div>

  <button id="langToggle" class="floating-button lang-toggle" title="Changer la langue / Switch language">EN</button>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const langBtn = document.getElementById('langToggle');
      const siteLang = localStorage.getItem('siteLanguage') || 'fr';
      langBtn.textContent = siteLang === 'fr' ? 'EN' : 'FR';
      langBtn.addEventListener('click', () => {
        toggleLanguage();
        const updatedLang = localStorage.getItem('siteLanguage') || 'fr';
        langBtn.textContent = updatedLang === 'fr' ? 'EN' : 'FR';
      });
    });
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      fetch('../../footer.html')
        .then(response => response.text())
        .then(data => {
          document.body.insertAdjacentHTML('beforeend', data);
        });
    });
  </script>

  <script>
    (function() {
      const startModal = document.getElementById('game-options');
      const startButton = document.getElementById('startButton');
      const mainContent = document.getElementById('mainContent');
      const gameOverlay = document.getElementById('gameOverlay');
      const gameFrame = document.getElementById('gameFrame');
      const backButton = document.getElementById('backButton');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayDescription = document.getElementById('overlayDescription');
      const modeChip = document.getElementById('modeChip');
      const modeDetails = document.getElementById('modeDetails');
      const startHint = document.getElementById('startHint');
      const scanDescription = document.getElementById('scanDescription');
      const scanIntervalSlider = document.getElementById('scanInterval');
      const scanIntervalValue = document.getElementById('scanIntervalValue');
      const modeCards = Array.from(document.querySelectorAll('.mode-card'));
      const fsKey = 'weatherAutoFS';
      const cards = Array.from(document.querySelectorAll('.weather-card'));

      const getSiteLanguage = () => (localStorage.getItem('siteLanguage') || 'fr');

      const applyCurrentLanguage = element => {
        if (!element) return;
        const lang = getSiteLanguage();
        const attr = lang === 'fr' ? 'data-fr' : 'data-en';
        const text = element.getAttribute(attr);
        if (text) {
          element.textContent = text;
        }
      };

      const modes = [
        {
          id: 'touch',
          labelFr: 'Mode tactile',
          labelEn: 'Touch mode',
          descriptionFr: "Utilise l'écran tactile ou la souris pour choisir un jeu.",
          descriptionEn: 'Use the touchscreen or mouse to choose a game.'
        },
        {
          id: 'multiple',
          labelFr: 'Mode choix multiples',
          labelEn: 'Multiple choice mode',
          descriptionFr: 'Appuie sur Entrée pour déplacer la sélection. Appuie sur Espace pour lancer le jeu surligné.',
          descriptionEn: 'Press Enter to move the highlight. Press Space to launch the highlighted game.'
        },
        {
          id: 'scan',
          labelFr: 'Mode balayage',
          labelEn: 'Scanning mode',
          descriptionFr: 'La sélection avance automatiquement toutes les {seconds} secondes. Appuie sur Espace pour lancer le jeu en surbrillance.',
          descriptionEn: 'The highlight moves every {seconds} seconds. Press Space to start the highlighted game.'
        }
      ];

      let modeIndex = 0;
      let highlightIndex = 0;
      let scanTimer = null;
      let lastCard = null;
      let gameActive = false;
      let scanIntervalMs = parseInt(scanIntervalSlider?.value || '10', 10) * 1000;

      function focusGameFrame() {
        if (!gameActive) return;
        const tryFocus = () => {
          try {
            gameFrame.contentWindow?.focus();
          } catch {}
          if (typeof gameFrame.focus === 'function') {
            try {
              gameFrame.focus({ preventScroll: true });
            } catch {
              gameFrame.focus();
            }
          }
        };
        tryFocus();
        setTimeout(tryFocus, 120);
      }

      function hideStartModal() {
        if (!startModal) return;
        startModal.classList.add('hidden');
        setTimeout(() => {
          startModal.remove();
        }, 420);
      }

      async function enterFullscreen() {
        const el = document.documentElement;
        if (document.fullscreenElement === el) return true;
        const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
        if (!req) return false;
        try {
          await req.call(el);
          return true;
        } catch {
          return false;
        }
      }

      function setOverlayLabels(card) {
        overlayTitle.setAttribute('data-fr', card.dataset.titleFr || '');
        overlayTitle.setAttribute('data-en', card.dataset.titleEn || '');
        overlayDescription.setAttribute('data-fr', card.dataset.descriptionFr || '');
        overlayDescription.setAttribute('data-en', card.dataset.descriptionEn || '');
        applyCurrentLanguage(overlayTitle);
        applyCurrentLanguage(overlayDescription);
        if (typeof updateLanguage === 'function') {
          updateLanguage();
        }
      }

      function clearSelection() {
        cards.forEach(card => {
          card.classList.remove('is-selected');
          card.removeAttribute('aria-selected');
        });
      }

      function highlightCard(index) {
        if (!cards.length) return;
        const normalized = ((index % cards.length) + cards.length) % cards.length;
        clearSelection();
        const card = cards[normalized];
        if (card) {
          card.classList.add('is-selected');
          card.setAttribute('aria-selected', 'true');
        }
        highlightIndex = normalized;
      }

      function stopScanTimer() {
        if (scanTimer) {
          clearInterval(scanTimer);
          scanTimer = null;
        }
      }

      function startScanTimer() {
        stopScanTimer();
        scanTimer = setInterval(() => {
          advanceHighlight();
        }, scanIntervalMs);
      }

      function formatDescription(mode) {
        if (mode.id !== 'scan') return { fr: mode.descriptionFr, en: mode.descriptionEn };
        const seconds = Math.round(scanIntervalMs / 1000);
        return {
          fr: mode.descriptionFr.replace('{seconds}', seconds.toString()),
          en: mode.descriptionEn.replace('{seconds}', seconds.toString())
        };
      }

      function applyMode(newIndex) {
        modeIndex = ((newIndex % modes.length) + modes.length) % modes.length;
        const mode = modes[modeIndex];
        const descriptions = formatDescription(mode);

        if (modeChip) {
          modeChip.setAttribute('data-fr', mode.labelFr);
          modeChip.setAttribute('data-en', mode.labelEn);
          applyCurrentLanguage(modeChip);
        }

        if (modeDetails) {
          modeDetails.setAttribute('data-fr', descriptions.fr);
          modeDetails.setAttribute('data-en', descriptions.en);
          applyCurrentLanguage(modeDetails);
        }

        if (mode.id === 'scan' && scanDescription) {
          scanDescription.setAttribute('data-fr', descriptions.fr);
          scanDescription.setAttribute('data-en', descriptions.en);
          applyCurrentLanguage(scanDescription);
        }

        if (typeof updateLanguage === 'function') {
          updateLanguage();
        }

        stopScanTimer();
        if (!mainContent.hidden) {
          clearSelection();
          if (mode.id === 'multiple' || mode.id === 'scan') {
            highlightCard(0);
            if (mode.id === 'scan' && !gameActive) {
              startScanTimer();
            }
          }
        } else {
          clearSelection();
        }
      }

      function advanceHighlight() {
        if (!cards.length) return;
        const nextIndex = (highlightIndex + 1) % cards.length;
        highlightCard(nextIndex);
      }

      function updateModeCardStates() {
        const lang = getSiteLanguage();
        modeCards.forEach((card, index) => {
          const isActive = index === modeIndex;
          card.classList.toggle('is-active', isActive);
          card.classList.toggle('selected', isActive);
          card.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          const mode = modes[index];
          if (mode) {
            const descriptions = formatDescription(mode);
            const labelText = lang === 'fr' ? mode.labelFr : mode.labelEn;
            const descriptionText = lang === 'fr' ? descriptions.fr : descriptions.en;
            const composed = descriptionText ? `${labelText}. ${descriptionText}` : labelText;
            card.setAttribute('aria-label', composed);
            card.setAttribute('data-description-fr', descriptions.fr);
            card.setAttribute('data-description-en', descriptions.en);
          }
        });
      }

      function setSelectedMode(newIndex, options = {}) {
        applyMode(newIndex);
        updateModeCardStates();
        if (options.focus && modeCards.length) {
          const normalized = ((modeIndex % modeCards.length) + modeCards.length) % modeCards.length;
          const card = modeCards[normalized];
          if (card && typeof card.focus === 'function') {
            try {
              card.focus({ preventScroll: true });
            } catch {
              card.focus();
            }
          }
        }
      }

      function refreshLanguageDependentText() {
        if (modeChip) {
          applyCurrentLanguage(modeChip);
        }
        if (modeDetails) {
          applyCurrentLanguage(modeDetails);
        }
        if (startButton) {
          applyCurrentLanguage(startButton);
        }
        if (startHint) {
          applyCurrentLanguage(startHint);
        }
        if (scanDescription) {
          applyCurrentLanguage(scanDescription);
        }
        if (typeof updateLanguage === 'function') {
          updateLanguage();
        }
        updateModeCardStates();
      }

      async function showGame(card) {
        if (!card) return;
        lastCard = card;
        stopScanTimer();
        setOverlayLabels(card);
        const src = card.dataset.src;
        if (src) {
          gameFrame.src = src;
        }
        gameActive = true;
        sessionStorage.setItem(fsKey, '1');
        await enterFullscreen();
        gameOverlay.removeAttribute('hidden');
        requestAnimationFrame(() => {
          gameOverlay.classList.add('visible');
          focusGameFrame();
        });
      }

      function closeGame() {
        if (!gameActive) return;
        gameOverlay.classList.remove('visible');
        setTimeout(() => {
          if (!gameOverlay.classList.contains('visible')) {
            gameActive = false;
            gameOverlay.setAttribute('hidden', '');
            gameFrame.src = 'about:blank';
            const focusTarget = lastCard && mainContent.contains(lastCard) ? lastCard : cards[0];
            if (focusTarget && typeof focusTarget.focus === 'function') {
              try {
                focusTarget.focus({ preventScroll: true });
              } catch {
                focusTarget.focus();
              }
            }
            const mode = modes[modeIndex];
            if (mode && mode.id === 'scan') {
              startScanTimer();
            }
          }
        }, 240);
      }

      function selectHighlightedCard() {
        const card = cards[highlightIndex];
        if (card) {
          showGame(card);
        }
      }

      startButton.addEventListener('click', async () => {
        sessionStorage.setItem(fsKey, '1');
        await enterFullscreen();
        mainContent.hidden = false;
        hideStartModal();
        applyMode(modeIndex);
        updateModeCardStates();
        setTimeout(() => {
          const focusTarget = cards[highlightIndex] || cards[0];
          if (focusTarget && typeof focusTarget.focus === 'function') {
            try {
              focusTarget.focus({ preventScroll: true });
            } catch {
              focusTarget.focus();
            }
          }
        }, 200);
      });

      if (startModal) {
        startModal.addEventListener('keydown', event => {
          const key = event.key;
          if (!key) return;
          const target = event.target;
          if (target && target.tagName === 'INPUT' && target.type === 'range') {
            return;
          }
          if (key === 'ArrowRight' || key === 'ArrowDown') {
            event.preventDefault();
            setSelectedMode(modeIndex + 1, { focus: true });
          } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
            event.preventDefault();
            setSelectedMode(modeIndex - 1, { focus: true });
          }
        });
      }

      modeCards.forEach((card, index) => {
        card.addEventListener('click', () => {
          setSelectedMode(index);
        });

        card.addEventListener('keydown', event => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setSelectedMode(index);
            if (startButton && document.body.contains(startButton)) {
              try {
                startButton.focus({ preventScroll: true });
              } catch {
                startButton.focus();
              }
            }
          }
        });
      });

      cards.forEach(card => {
        card.addEventListener('click', () => {
          if (!mainContent.hidden) {
            if (modes[modeIndex].id !== 'touch') {
              highlightIndex = cards.indexOf(card);
              highlightCard(highlightIndex);
            }
            showGame(card);
          }
        });
      });

      backButton.addEventListener('click', () => {
        closeGame();
      });

      document.addEventListener('click', event => {
        const target = event.target;
        if (!target) return;
        if (target.id === 'language-toggle' || target.id === 'langToggle') {
          setTimeout(() => {
            refreshLanguageDependentText();
          }, 0);
        }
      });

      document.addEventListener('keydown', event => {
        if (!gameOverlay.hasAttribute('hidden')) {
          const key = event.key ? event.key.toLowerCase() : '';
          if (key === 'escape' || key === 'esc') {
            event.preventDefault();
            closeGame();
          } else if (key === 'q') {
            event.preventDefault();
            closeGame();
          }
          return;
        }

        if (mainContent.hidden) {
          return;
        }

        const mode = modes[modeIndex];
        if (mode.id === 'multiple') {
          if (event.key === 'Enter') {
            event.preventDefault();
            advanceHighlight();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            selectHighlightedCard();
          }
        } else if (mode.id === 'scan') {
          if (event.key === 'Enter') {
            event.preventDefault();
            advanceHighlight();
            startScanTimer();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            selectHighlightedCard();
          }
        }
      });

      gameOverlay.addEventListener('click', event => {
        if (event.target === gameOverlay) {
          closeGame();
        }
      });

      gameFrame.addEventListener('load', () => {
        if (!gameActive) return;
        try {
          const frameWindow = gameFrame.contentWindow;
          if (frameWindow) {
            const keyListener = event => {
              if (!gameActive) {
                frameWindow.removeEventListener('keydown', keyListener);
                return;
              }
              const key = event.key ? event.key.toLowerCase() : '';
              if (key === 'escape' || key === 'esc') {
                event.preventDefault();
                closeGame();
              } else if (key === 'q') {
                event.preventDefault();
                closeGame();
              }
            };
            frameWindow.addEventListener('keydown', keyListener);
          }
        } catch {}
        focusGameFrame();
      });

      if (scanIntervalSlider && scanIntervalValue) {
        scanIntervalSlider.addEventListener('input', () => {
          const seconds = parseInt(scanIntervalSlider.value, 10);
          scanIntervalValue.textContent = seconds;
          scanIntervalMs = seconds * 1000;
          if (modes[modeIndex].id === 'scan' && !mainContent.hidden && !gameActive) {
            startScanTimer();
          }
          applyMode(modeIndex);
          updateModeCardStates();
        });
      }

      setSelectedMode(0);
      refreshLanguageDependentText();
    })();
  </script>

  <script src="../../js/translationmain.js"></script>
</body>
</html>
