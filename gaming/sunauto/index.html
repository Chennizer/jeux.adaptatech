<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Soleil : Jeu Switch</title>

<!-- p5.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>

<link rel="stylesheet" href="../../css/otherswitch.css">
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#5aa9e6;}
  canvas{display:block;position:fixed;top:0;left:0;}
</style>
</head>
<body>
<script>
/* === AUDIO & ÉTAT ================================================= */
let gameStarted=false, gameOver=false;
const ambiencePath='../../sounds/sun/sunnyday.mp3';
const finishPath  ='../../sounds/sun/fanfare.mp3';
const rayPath     ='../../sounds/sun/sun1.mp3';
let ambience, raySound, finishSound;
let volMusic=.5, volSFX=.5;
let isSFXMuted=false, isMusicMuted=false;

/* === VISUEL ======================================================= */
const MAX_RAYS=8;
let rays=[], rayCount=0;
let sunRadius, innerR, longLen, shortLen, strokeW;
let basePulse=1, sunRot=0;

/* finale pilotée par la durée réelle du morceau */
let finalStage=0;              // 0=off, 1=en cours, 2=done
let finalScale=1;
let warmFlashAlpha=0;
let screenFlashAlpha=0, FLASH_INITIAL=80, FLASH_STEP=FLASH_INITIAL/120;
let finishStartMs=null;
let finishDurMs=6000;          // fallback
let finalProgress=0;           // 0..1

let lastTap=-Infinity, tapDelay=2000;
/* Mode: false = normal (par défaut), true = éclair (tous rayons d’un coup) */
let rapidMode=false;

/* décor */
let clouds=[], balloon, birds=[];
let balloonImg, birdImg;
let extraBalloons=[];          // ballons supplémentaires (finale)
let balloonsReleased=false;

/* confetti (boostés) */
let confetti=[];
let confettiMidBurstDone=false;
const CONFETTI_COLS=[[255,210,100],[255,177,66],[255,235,150],[255,196,100],[255,225,120]];

/* Buffers */
let skyBuffer;                 // ciel
let haloBuffer;                // halo autour du soleil

/* gestion du refresh du ciel (3) */
let lastSkyUpdateFrame = -999;

/* ---------- preload ---------- */
function preload(){
  ambience   = loadSound(ambiencePath);
  raySound   = loadSound(rayPath);
  finishSound= loadSound(finishPath);
  balloonImg = loadImage('../../images/sun/montgolfiere1.png');
  birdImg    = loadImage('../../images/sun/oiseau_vol.png');
}

/* ---------- setup ---------- */
function setup(){
  createCanvas(windowWidth,windowHeight);
  angleMode(RADIANS);
  for(let i=0;i<6;i++)
    clouds.push(new Cloud(random(width),random(30,height/2),
               random(80,250),random(40,120),random(0.5,2)));
  balloon = new Balloon(
    width+random(50,150), random(height/4,height/2-50),
    random(0.5,0.6), 0.25, 'horizontal');
  for(let i=0;i<3;i++) birds.push(new Bird());

  buildSkyBuffer(0);           // ciel initial (froid)
  computeSizes();
  buildHaloBuffer();           // halo pré-calculé (compact)
}

/* ---------- responsive sizes ---------- */
function computeSizes(){
  const base=min(width,height)*0.15;
  sunRadius=base;
  innerR   =base*1.2;
  longLen  =base*2.2;
  shortLen =base*2;
  strokeW  =base*0.08;
}

/* ---------- draw ---------- */
function draw(){
  if(!gameStarted){background(0);return;}

  // (3) Warm sky drift
  if(finalStage===1){
    if(frameCount - lastSkyUpdateFrame >= 6){
      buildSkyBuffer(finalProgress);
      lastSkyUpdateFrame = frameCount;
    }
  }
  image(skyBuffer, 0, 0);

  // éléments derrière le soleil
  birds.forEach(b=>{b.update();b.draw();});
  clouds.forEach(c=>{c.update();c.draw();});

  // halo + vignette (1)
  drawHaloAndVignette();

  // soleil et rayons (2)
  drawSun();

  // >>> Ballons devant le soleil <<
  balloon.update(); balloon.draw();
  extraBalloons.forEach(b=>{b.update();b.draw();});

  // confetti (7)
  updateAndDrawConfetti();

  if(warmFlashAlpha>1){
    noStroke(); fill(255,200,80,warmFlashAlpha);
    rect(0,0,width,height);
  }

  basePulse=1+0.05*sin(frameCount*0.03);
  if(rayCount===MAX_RAYS) handleFinalAnim();

  sunRot+=0.003;

  if(screenFlashAlpha>0){
    screenFlashAlpha=max(0,screenFlashAlpha-FLASH_STEP);
    noStroke(); fill(255,180,50,screenFlashAlpha);
    rect(0,0,width,height);
  }

  if (gameOver) {
    setTimeout(()=>{resetScene(); gameOver=false;}, 100);
  }
}

/* ---------- halo + vignette ---------- */
function buildHaloBuffer(){
  const sz = floor(min(width,height)*0.6); // compact
  haloBuffer = createGraphics(sz, sz);
  const g = haloBuffer;
  g.noStroke();
  const cx = sz/2, cy = sz/2, maxR = sz/2;
  for(let i=0;i<80;i++){
    const t = i/79;
    const a = 80*(1-t)*(1-t);
    g.fill(255, 220, 120, a);
    const r = maxR * t;
    g.ellipse(cx, cy, r*2, r*2);
  }
}

function drawHaloAndVignette(){
  const breathe = finalStage===1 ? (0.98 + 0.04 * sin(frameCount*0.03)) : (0.995 + 0.01*sin(frameCount*0.02));
  const tightness = 2.2;
  const s = (sunRadius * tightness) / (haloBuffer.width/2);
  const haloScale = s * breathe * (finalStage===1 ? lerp(1.0, 1.25, easeInOutCubic(constrain(finalProgress,0,1))) : 1.0);

  push();
  translate(width/2, height/2);
  scale(haloScale);
  imageMode(CENTER);
  image(haloBuffer, 0, 0);
  pop();

  // Vignette douce
  const vigStrength = finalStage===1 ? 70 : 30;
  const rings = 10;
  for(let i=0;i<rings;i++){
    const t = i/(rings-1);
    const alpha = vigStrength * (t*t);
    noFill(); stroke(0,0,0, alpha);
    strokeWeight( max(width,height) * 0.02 );
    ellipse(width/2, height/2, width*(1+ t*0.6), height*(1+ t*0.6));
  }
  noStroke();
}

/* ---------- Soleil + rayons + shimmer ---------- */
function drawSun(){
  push();
  translate(width/2,height/2);
  rotate(sunRot);
  scale(basePulse*(finalStage?finalScale:1));
  noStroke();
  fill(255,180,50);
  ellipse(0,0,sunRadius*2,sunRadius*2);

  stroke(255,210,100);
  strokeWeight(strokeW);
  for(const r of rays){
    const n1 = noise(r.seed, frameCount*0.01);
    const n2 = noise(r.seed+1000, frameCount*0.015);
    const angOff = radians(-3 + 6*n1);           // ±3°
    const lenJit = -3 + 6*n2;                    // ±3 px
    const a = r.angle + angOff;
    const tgt = r.targetLen + lenJit;

    r.currLen=lerp(r.currLen, tgt, 0.06);
    r.alpha  =lerp(r.alpha,255,0.12);
    stroke(255,210,100, r.alpha);
    line(innerR*cos(a),innerR*sin(a), r.currLen*cos(a),r.currLen*sin(a));
  }
  pop();
}

/* ---------- décor ---------- */
class Cloud{
  constructor(x,y,w,h,s){this.x=x;this.y=y;this.w=w;this.h=h;this.s=s;}
  update(){
    this.x-=this.s;
    if(this.x+this.w<0){
      Object.assign(this,{
        x:width+random(20,100),y:random(30,height/2),
        w:random(80,250),h:random(40,120),s:random(0.5,2)
      });
    }
  }
  draw(){
    noStroke(); fill(255,255,255,180);
    ellipse(this.x,this.y,this.w,this.h);
    ellipse(this.x-this.w*0.4,this.y+10,this.w*0.7,this.h*0.7);
    ellipse(this.x+this.w*0.4,this.y+10,this.w*0.7,this.h*0.7);
  }
}
class Balloon{
  constructor(x,y,v,sc,mode){this.x=x;this.y=y;this.v=v;this.sc=sc;this.mode=mode;}
  switchVertical(){
    this.mode='vertical';
    this.x=random(50,width-50);
    this.y=height+random(40,150);
    this.v=random(1.2,2);
  }
  update(){
    if(finalStage>=1 && this.mode==='horizontal') this.switchVertical();
    if(this.mode==='horizontal'){
      this.x-=this.v;
      if(this.x+balloonImg.width*this.sc<0){
        this.x=width+random(50,150);
        this.y=random(height/4,height/2-50);
        this.v=random(0.5,0.6);
      }
    }else{
      this.y-=this.v;
      if(this.y+balloonImg.height*this.sc<-40){
        this.y=height+random(40,150);
        this.x=random(50,width-50);
        this.v=random(1.2,2);
      }
    }
  }
  draw(){
    push();
    translate(this.x,this.y);
    scale(this.sc);
    imageMode(CENTER);
    image(balloonImg,0,0);
    pop();
  }
}
class Bird{
  constructor(){this.reset();}
  reset(){
    this.sc=0.05;
    this.x=-birdImg.width*this.sc-random(20,100);
    this.y=random(height/6,height/2);
    this.baseV=random(1,2);
    this.phase=random(TWO_PI);
  }
  update(){
    this.x+=this.baseV*(finalStage>=1?2:1);
    this.y+=0.25*sin(frameCount*0.05+this.phase);
    if(this.x>width+40) this.reset();
  }
  draw(){
    push();
    translate(this.x,this.y);
    scale(this.sc);
    imageMode(CENTER);
    image(birdImg,0,0);
    pop();
  }
}

/* ---------- Confetti ---------- */
function spawnConfetti(){
  const n = floor(random(50,80));
  if(confetti.length > 240) confetti.length = 160;

  for(let i=0;i<n;i++){
    const angle = random(TWO_PI);
    const radius = min(width,height)*0.10;
    const x = width/2 + cos(angle)*radius*random(0.15,1);
    const y = height/2 + sin(angle)*radius*random(0.15,1);

    const sp = random(1.8,3.2);
    const vx = (x - width/2) * 0.018 + random(-0.8,0.8);
    const vy = (y - height/2) * 0.018 - sp;

    const col = random(CONFETTI_COLS);
    const rot = random(TWO_PI);
    const rotSp = random(-0.06,0.06);

    const maxLife = floor(random(600,960));
    const size = random(14,28);
    const shape = random([ 'rect', 'tri' ]);

    confetti.push({ x,y,vx,vy, ax:0, ay:0.055, col, rot, rotSp,
      life:maxLife, maxLife, shape, size });
  }
}

function updateAndDrawConfetti(){
  if(confetti.length===0) return;

  for(let i=confetti.length-1;i>=0;i--){
    const p = confetti[i];
    p.vx += p.ax; p.vy += p.ay;
    p.x  += p.vx; p.y  += p.vy;
    p.vx *= 0.995; 
    p.vy *= 0.997;
    p.rot += p.rotSp;
    p.life -= 1;

    const t = constrain(p.life / p.maxLife, 0, 1);
    const alpha = 255 * (t*t);

    fill(p.col[0], p.col[1], p.col[2], alpha);
    noStroke();
    push(); translate(p.x, p.y); rotate(p.rot);
    if(p.shape==='rect'){
      rectMode(CENTER);
      rect(0,0,p.size, p.size*0.6);
    }else{
      triangle(-p.size*0.6, p.size*0.5, p.size*0.6, p.size*0.5, 0, -p.size*0.6);
    }
    pop();

    if(p.life<=0 || p.y>height+80) confetti.splice(i,1);
  }
}

/* ---------- animation finale (durée = durée du morceau) ---------- */
function handleFinalAnim(){
  if(finalStage===0){
    finalStage=1;
    startFinishSound();
    finishStartMs = millis();
    const dur = (finishSound && finishSound.duration && isFinite(finishSound.duration()))
                ? finishSound.duration()*1000 : null;
    finishDurMs = dur && dur>0 ? dur : 6000;
    finalProgress = 0;

    spawnConfetti();
    confettiMidBurstDone=false;
    if(!balloonsReleased){
      releaseExtraBalloons();
      balloonsReleased=true;
    }
  }

  if(finalStage===1){
    const elapsed = millis() - (finishStartMs ?? millis());
    finalProgress = constrain(elapsed / finishDurMs, 0, 1);

    if(!confettiMidBurstDone && finalProgress >= 0.48){
      spawnConfetti();
      confettiMidBurstDone = true;
    }

    const growEnd=0.20, shrinkStart=0.80;

    if(finalProgress < growEnd){
      const t = finalProgress / growEnd;
      finalScale = lerp(1.0, 1.6, t);
      warmFlashAlpha = lerp(0, 150, t);
    } else if (finalProgress < shrinkStart){
      finalScale = 1.6;
      const t = (finalProgress - growEnd) / (shrinkStart - growEnd);
      warmFlashAlpha = lerp(150, 0, t);
    } else {
      const t = (finalProgress - shrinkStart) / (1 - shrinkStart);
      finalScale = lerp(1.6, 1.0, t);
      warmFlashAlpha = 0;
    }

    const musicEnded = finishSound && !finishSound.isPlaying();
    if (finalProgress >= 1 || musicEnded){
      finalStage = 2;
      gameOver = true;
    }
  }
}

function startFinishSound(){
  ambience?.setVolume(isMusicMuted?0:volMusic*0.7, 0.2);
  finishSound.setVolume(isMusicMuted?0:volMusic);
  finishSound.play();
}

/* ---------- Lâcher de ballons (finale) ---------- */
function releaseExtraBalloons(){
  extraBalloons.length = 0;
  const n = floor(random(4,7));
  for(let i=0;i<n;i++){
    const b = new Balloon(random(60,width-60), height + random(40,200), random(1.1,1.9), random(0.18,0.28), 'vertical');
    b.delayStart = millis() + i*random(250,700);
    const baseUpdate = b.update.bind(b);
    b.update = function(){
      if(millis() < this.delayStart) return;
      baseUpdate();
    }
    extraBalloons.push(b);
  }
}

/* ---------- interaction ---------- */
function addAllRays(){
  for(let i=0;i<MAX_RAYS;i++){
    rays.push({
      angle: i*TWO_PI/MAX_RAYS,
      currLen: innerR,
      targetLen: (i%2 ? shortLen : longLen),
      alpha: 0,
      seed: random(10000)
    });
  }
  rayCount=MAX_RAYS;
  screenFlashAlpha=FLASH_INITIAL;
}
function addSingleRay(){
  const i=rayCount;
  rays.push({
    angle: i*TWO_PI/MAX_RAYS,
    currLen: innerR,
    targetLen: (i%2 ? shortLen : longLen),
    alpha: 0,
    seed: random(10000)
  });
  rayCount++;
  screenFlashAlpha=FLASH_INITIAL;
}
function trigger(){
  if(!gameStarted||gameOver||(finalStage>0 && !gameOver)) return;
  if(millis()-lastTap<tapDelay) return;
  lastTap=millis();
  if(rapidMode && rayCount===0){
    addAllRays();
  }else if(!rapidMode && rayCount<MAX_RAYS){
    addSingleRay();
  }
  if(!isSFXMuted && raySound){
    raySound.setVolume(volSFX);
    raySound.isLoaded()
      ? raySound.play()
      : raySound.once('loaded',()=>{ if(!isSFXMuted) raySound.play(); });
  }
}
function keyPressed(){
  // Assure le déverrouillage audio même si l’event load a été bloqué
  ensureAmbienceFromZero();
  if(key===' '&&gameStarted) trigger();
  if(keyCode===ENTER && gameStarted && (finalStage===0 || gameOver)){
    resetScene();
  }
}
/* p5 mobile/desktop gestures — pour iPad/iOS */
function mousePressed(){ ensureAmbienceFromZero(); }
function touchStarted(){ ensureAmbienceFromZero(); }

/* ---------- reset ---------- */
function resetScene(){
  rays=[];rayCount=0;
  finalStage=0;finalScale=1;warmFlashAlpha=0;
  screenFlashAlpha=0;finishStartMs=null;
  finalProgress=0;
  balloonsReleased=false;
  extraBalloons.length=0;
  confetti.length=0;
  confettiMidBurstDone=false;

  buildSkyBuffer(0);
  lastSkyUpdateFrame = -999;

  balloon.mode='horizontal';balloon.v=random(0.5,0.6);
}

/* ---------- AUDIO AUTO-START (robuste) ---------------------- */
function startAmbienceFromZero(){
  if(!ambience) return;
  ambience.setLoop(true);
  ambience.setVolume(isMusicMuted?0:volMusic);
  try{ ambience.stop(); }catch(e){}
  ambience.loop(0, 1, isMusicMuted?0:volMusic, 0); // (startTime, rate, amp, cueStart)
}
function ensureAmbienceFromZero(){
  try { if (typeof userStartAudio === 'function') userStartAudio(); } catch(e){}
  try { getAudioContext().resume(); } catch(e){}
  if(ambience?.isLoaded()){
    startAmbienceFromZero();
  }else{
    ambience?.once('loaded', startAmbienceFromZero);
  }
}

/* ---------- AUTO-START (sans overlay ni menu) ---------------- */
window.addEventListener('load', ()=>{
  // Démarre le jeu immédiatement
  gameStarted = true;

  // Tentative plein écran (peut être bloquée sans geste)
  const el=document.documentElement;
  try{ (el.requestFullscreen||el.webkitRequestFullscreen)?.call(el); }catch(e){}

  // Fit canvas + (re)build buffers
  const fit=()=>{ resizeCanvas(windowWidth,windowHeight); computeSizes(); buildSkyBuffer(0); buildHaloBuffer(); };
  fit(); window.addEventListener('resize', fit);

  // Essaye de lancer l'ambiance **depuis 0**
  ensureAmbienceFromZero();

  // Si l’autoplay est bloqué, relance au premier geste — toujours depuis 0
  const firstInteract = ()=>{
    ensureAmbienceFromZero();
    window.removeEventListener('pointerdown', firstInteract);
    window.removeEventListener('click', firstInteract);
    window.removeEventListener('keydown', firstInteract);
    window.removeEventListener('touchstart', firstInteract);
  };
  window.addEventListener('pointerdown', firstInteract, {once:true});
  window.addEventListener('click',       firstInteract, {once:true});
  window.addEventListener('keydown',     firstInteract, {once:true});
  window.addEventListener('touchstart',  firstInteract, {once:true, passive:true});
});

/* ---------- Sky buffer (3) ---------- */
function buildSkyBuffer(pWarm){
  if(!skyBuffer || skyBuffer.width!==width || skyBuffer.height!==height){
    skyBuffer = createGraphics(width, height);
  }
  const g = skyBuffer;
  const coldTop = [90,169,230];
  const coldBot = [130,209,240];
  const warmTop = [120,185,235];
  const warmBot = [255,220,160];
  const top = lerpRGB(coldTop, warmTop, easeInOutCubic(constrain(pWarm,0,1)));
  const bot = lerpRGB(coldBot, warmBot, easeInOutCubic(constrain(pWarm,0,1)));

  for (let y = 0; y < height; y++) {
    const t = y / height;
    const c = [
      floor( lerp(top[0], bot[0], t) ),
      floor( lerp(top[1], bot[1], t) ),
      floor( lerp(top[2], bot[2], t) )
    ];
    g.stroke(c[0], c[1], c[2]);
    g.line(0, y, width, y);
  }
}

/* ---------- Resize ---------- */
function windowResized(){
  if(gameStarted){
    resizeCanvas(windowWidth,windowHeight);
    computeSizes();
    buildSkyBuffer(finalStage===1 ? finalProgress : 0);
    buildHaloBuffer();
  }
}

/* ---------- Utils ---------- */
function lerpRGB(a,b,t){ return [ lerp(a[0],b[0],t), lerp(a[1],b[1],t), lerp(a[2],b[2],t) ]; }
function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - pow(-2*x+2,3)/2; }
</script>
<script>
(function(){
  const key = 'weatherAutoFS';
  if (sessionStorage.getItem(key) !== '1') return;
  sessionStorage.removeItem(key);

  const tryFullscreen = () => {
    if (document.fullscreenElement) return;
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
    if (!req) return;
    try {
      const result = req.call(el);
      if (result?.catch) result.catch(() => {});
    } catch {}
  };

  if (document.readyState === 'complete') {
    setTimeout(tryFullscreen, 0);
  } else {
    window.addEventListener('load', () => setTimeout(tryFullscreen, 0), { once: true });
  }

  window.addEventListener('pointerdown', () => {
    tryFullscreen();
  }, { once: true, passive: true });
})();
</script>

    <script src="../../js/home-button.js" defer></script>
</body>
</html>
