<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Eyegaze — Sensory Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    body.light { background:#fff; color:#000; }
    body.dark  { background:#000; color:#fff; }

    html, body { height:100%; margin:0; overflow:hidden; }
    canvas#c { position:fixed; inset:0; display:none; }

    #game-options.modal {
      display:flex; align-items:center; justify-content:center;
    }

    .value-badge{
      display:inline-block; min-width:2ch; padding:2px 6px; border-radius:8px;
      background:rgba(255,255,255,.12); color:#0b1a18; font-variant-numeric:tabular-nums
    }
    body.light .value-badge{ background:rgba(0,0,0,.08); color:inherit; }
  </style>
</head>
<body class="dark">
  <canvas id="c"></canvas>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title">Laboratoire Sensoriel</h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label">
              <input type="checkbox" id="muteSFX">
              <span>Désactiver les sons</span>
            </label>
          </div>
          <div class="option-item">
            <label for="sfxVol" class="teal-label">
              <span>Volume des sons:&nbsp;</span>
              <span id="sfxVolVal" class="value-badge">50</span>
            </label>
            <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="themeSelect" class="teal-label label-block">Mode</label>
            <select id="themeSelect" class="styled-select">
              <option value="light">Clair</option>
              <option value="dark" selected>Sombre</option>
            </select>
          </div>

          <div class="option-item">
            <label for="sceneSelect" class="teal-label label-block">Scène</label>
            <select id="sceneSelect" class="styled-select">
              <option value="aurora">Aurora</option>
              <option value="ripples">Ondes</option>
              <option value="fireworks" selected>Feux d’artifice</option>
              <option value="kaleido">Kaleido</option>
              <option value="fireflies">Lucioles</option>
              <option value="confetti">Confetti</option>
              <option value="nebula">Nébuleuse</option>
              <option value="jelly">Gelée</option>
              <option value="snow">Neige-Boule</option>
              <option value="sand">Sable Arc-en-ciel</option>
              <option value="magnet">Essaim Magnétique</option>
              <option value="glass">Vitrail</option>
              <option value="streamers">Rubans de Soie</option>
              <option value="laserharp">Harpe Laser</option>
              <option value="bubblepop">Bulle-Pop</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="intensitySlider" class="teal-label">
              <span>Intensité:&nbsp;</span>
              <span id="intensityVal" class="value-badge">50</span>
            </label>
            <input type="range" id="intensitySlider" class="styled-slider" min="0" max="100" value="50">
          </div>

          <div class="option-item">
            <label for="sizeSlider" class="teal-label">
              <span>Taille:&nbsp;</span>
              <span id="sizeVal" class="value-badge">105</span>
            </label>
            <input type="range" id="sizeSlider" class="styled-slider" min="10" max="200" value="105">
          </div>

          <div class="option-item">
            <label for="trailSlider" class="teal-label">
              <span>Traînée:&nbsp;</span>
              <span id="trailVal" class="value-badge">50</span>
            </label>
            <input type="range" id="trailSlider" class="styled-slider" min="0" max="100" value="50">
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button">Commencer</button>
    </div>
  </div>

  <script src="../../js/eyegaze-menu.js"></script>

  <script>
  const startButton = document.getElementById('startButton');
  const themeSel  = document.getElementById('themeSelect');
  const sceneSel  = document.getElementById('sceneSelect');

  const muteSFX   = document.getElementById('muteSFX');
  const sfxVol    = document.getElementById('sfxVol');
  const sfxVolVal = document.getElementById('sfxVolVal');

  const intSlider = document.getElementById('intensitySlider');
  const sizeSlider= document.getElementById('sizeSlider');
  const trailSlider= document.getElementById('trailSlider');
  const intVal    = document.getElementById('intensityVal');
  const sizeVal   = document.getElementById('sizeVal');
  const trailVal  = document.getElementById('trailVal');

  function reflectSliders(){
    sfxVolVal.textContent = sfxVol.value;
    intVal.textContent = intSlider.value;
    sizeVal.textContent = sizeSlider.value;
    trailVal.textContent = trailSlider.value;
  }
  [sfxVol,intSlider,sizeSlider,trailSlider].forEach(el=>el.addEventListener('input', reflectSliders));
  reflectSliders();

  function applyTheme(){
    document.body.classList.remove('light','dark');
    document.body.classList.add(themeSel.value === 'light' ? 'light' : 'dark');
  }
  themeSel.addEventListener('change', applyTheme);
  applyTheme();
  sceneSel.addEventListener('change', () => {
  MUSIC.setScene(sceneSel.value);
  // (optional) clearToBg(true); // if you want a hard clear on scene switch
    });

  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d', { alpha:false });
  let W = innerWidth, H = innerHeight;
  cvs.width = W; cvs.height = H;

  // ---- Dead border + idle pause state ----
  let borderPx = Math.max(1, Math.round(innerWidth * 0.01)); // ~1vw
  let edgeEnteredAt = null; 
  function updateBorder(){ borderPx = Math.max(1, Math.round(innerWidth * 0.01)); }
  function inActiveArea(x, y){
    return x >= borderPx && x <= (W - borderPx) && y >= borderPx && y <= (H - borderPx);
  }
function recomputePaused(){
  const t = performance.now();

  // Idle pause: 5s of no movement anywhere
  const idle = (t - lastMoveT) >= 5000;

  // Edge logic with 3s grace
  const atEdge = !inActiveArea(mouse.x, mouse.y);

  if (atEdge) {
    // just entered the edge zone? start the grace timer
    if (edgeEnteredAt === null) edgeEnteredAt = t;
  } else {
    // left the edge zone — clear the grace timer
    edgeEnteredAt = null;
  }

  const edgeGraceElapsed = edgeEnteredAt !== null && (t - edgeEnteredAt) >= 3000; // 3s

  // Pause if idle OR if we've been at the edge for >= 3s
  const newPaused = idle || edgeGraceElapsed;

  if (newPaused !== paused){
    paused = newPaused;
    // Optional: clearToBg(true);
  }
}
/* =========================
   GLOBAL MUSIC — per-scene playlists, shuffle, loop, crossfade
   ========================= */
const MUSIC = (function(){
  // --- config: declare playlists per scene (fill as you add songs)
  // If tracks need extensions, include them (e.g., ".mp3").
  const PLAYLISTS = {
    aurora: [
      "../../songs/space/space1.mp3",
      "../../songs/space/spacebest1.mp3",
      "../../songs/space/spacebest4.mp3",
    ],
    // add more scenes when ready:
    // ripples: ["../../songs/water/w1.mp3","../../songs/water/w2.mp3"],
    // laserharp: [...],
  };

  // master behavior
  const CFG = {
    crossfadeSec: 0.6,
    sceneXfadeSec: 0.8,
    baseMusicScale: 0.7,     // music <= SFX
    mutePauseThreshold: 0.003,
  };

  // internal state
  let primed = false;
  let wanted = true     // global desire (we'll compute sceneHasPlaylist && scene == current && !paused)
  let scene = null;
  let sceneHasPlaylist = false;

  // two-tag crossfader
  const ch = [
    { el: null, gain: 0, list: [], order: [], i: 0, name:"A" },
    { el: null, gain: 0, list: [], order: [], i: 0, name:"B" },
  ];
  let active = 0; // index of currently audible channel
  let pendingXfade = 0; // seconds left in current crossfade

  function makeAudio(){
    const a = new Audio();
    a.loop = false;
    a.preload = "auto";
    a.crossOrigin = "anonymous";
    a.volume = 0;
    return a;
  }

  function ensure(){
    if (!ch[0].el) ch[0].el = makeAudio();
    if (!ch[1].el) ch[1].el = makeAudio();
  }

  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; }
    return arr;
  }

  function buildOrder(list){
    return shuffle(Array.from({length:list.length}, (_,i)=>i));
  }

  function currentChannel(){ return ch[active]; }
  function idleChannel(){ return ch[1-active]; }

  function setPlaylistForBoth(list){
    ch[0].list = list;
    ch[0].order = buildOrder(list);
    ch[0].i = 0;

    ch[1].list = list;
    ch[1].order = buildOrder(list);
    ch[1].i = 0;
  }

  function nextIdx(c){
    if (!c.list.length) return 0;
    c.i = (c.i + 1) % c.order.length;
    return c.i;
  }

  function pickSrc(c){
    if (!c.list.length) return "";
    const k = c.order[c.i] ?? 0;
    return c.list[k];
  }

  function loadInto(c){
    if (!c.list.length) return;
    const src = pickSrc(c);
    c.el.src = src;
    // play() only if we’re wanted; otherwise will auto-start during tick when volume ramps > 0
    const p = c.el.play();
    if (p && p.catch){ /* ignore autoplay errors; tick() will retry when primed/wanted */ }
    c.el.onended = ()=>{ nextIdx(c); loadInto(c); };
    c.el.onerror = ()=>{ nextIdx(c); loadInto(c); };
  }

  function prime(){ primed = true; ensure(); }

  function setScene(name){
    scene = name;
    const list = PLAYLISTS[name] || [];
    sceneHasPlaylist = list.length > 0;

    ensure();

    // If no playlist, stop desire; if yes, prepare both channels
    if (!sceneHasPlaylist){
      wanted = false;
      // fade out quickly; tick() will mute/pause
      return;
    }

    setPlaylistForBoth(list);

    // start new playback on idle channel, then crossfade
    const idle = idleChannel();
    nextIdx(idle); // de-sync from active a bit
    loadInto(idle);
    pendingXfade = CFG.sceneXfadeSec;
  }

  // External toggle if you want to disable music globally (rarely needed)
  function want(on){ wanted = !!on; }

  // The main tick: called each frame
  function tick(dt){
    if (!primed) return;

    ensure();

    // Determine if music should be audible now
    const sceneWants = !!scene && sceneHasPlaylist && (ui.mode.value === scene);

    const shouldPlay = sceneWants && !paused && wanted !== false; // wanted defaults true unless explicitly turned off

    // Calculate base target volume from SFX slider + mute
    const sfx = currentSfxGain();        // 0..1
    const targetBase = shouldPlay ? Math.min(1, sfx * CFG.baseMusicScale) : 0;

    // crossfade logic (also used for automatic track changes)
    if (pendingXfade > 0){
      const step = Math.min(pendingXfade, dt);
      pendingXfade -= step;
      // ramp active down, idle up
      const a = currentChannel();
      const b = idleChannel();
      const t = 1 - (pendingXfade / (sceneWants ? CFG.sceneXfadeSec : CFG.crossfadeSec));
      a.gain = (1 - t) * targetBase;
      b.gain = t * targetBase;

      // start idle playback if needed
      if (shouldPlay && b.el.paused && targetBase > 0){
        const p = b.el.play(); if (p && p.catch){ /* ignore */ }
      }

      // volumes
      a.el.volume = a.gain;
      b.el.volume = b.gain;

      if (pendingXfade <= 0){
        // swap actives
        active = 1 - active;
        // pause the now-idle channel if we’re near silent
        const id = idleChannel();
        id.gain = 0; id.el.volume = 0;
        if (!sceneWants || targetBase === 0) id.el.pause();
      }
    } else {
      // steady-state: maintain volume toward target
      const a = currentChannel();
      const b = idleChannel();

      // bring active toward target
      a.gain = lerp(a.gain, targetBase, 1 - Math.pow(0.08, dt*60));
      a.el.volume = a.gain;

      // keep idle silent
      b.gain = lerp(b.gain, 0, 1 - Math.pow(0.08, dt*60));
      b.el.volume = b.gain;

      // start playing if needed
      if (shouldPlay && a.el.paused && targetBase > 0){
        const p = a.el.play(); if (p && p.catch){ /* ignore */ }
      }
      // pause when fully muted
      if (!shouldPlay && a.el.volume < CFG.mutePauseThreshold && !a.el.paused) a.el.pause();
    }

    // If an active track is about to end, pre-roll next on idle and start crossfade
    const a = currentChannel();
    if (shouldPlay && a.el.duration && !isNaN(a.el.duration)){
      const remain = a.el.duration - a.el.currentTime;
      if (remain < Math.max(0.25, CFG.crossfadeSec * 0.9) && pendingXfade <= 0){
        const b = idleChannel();
        // prepare different next track on idle channel
        nextIdx(b);
        loadInto(b);
        pendingXfade = CFG.crossfadeSec;
      }
    }
  }

  // Keep volume in sync with UI changes
  sfxVol.addEventListener('input', ()=>{/* target computed in tick */});
  muteSFX.addEventListener('change', ()=>{/* target computed in tick */});

  return {
    prime,
    setScene,
    want,        // optional global override
    tick,
    // for convenience, to add/modify playlists at runtime:
    setPlaylist(sceneName, tracksArray){
      PLAYLISTS[sceneName] = tracksArray.slice();
      if (scene === sceneName){
        setScene(sceneName); // rebuild if currently on scene
      }
    }
  };
})();

  addEventListener('resize', ()=>{
    W=innerWidth; H=innerHeight; cvs.width=W; cvs.height=H;
    updateBorder();
    if (typeof resizeGlass === 'function') resizeGlass();
    if (typeof resizeLaser === 'function') resizeLaser();
    if (typeof caSandOnResize === 'function') caSandOnResize();
    if (typeof auroraResize === 'function') auroraResize();
    if (typeof snowResize === 'function') snowResize();
    if (typeof magnetResize === 'function') magnetResize();
    if (typeof ribbonsResize === 'function') ribbonsResize();
  });

  let menuOpen = true;
  cvs.style.display = 'none';

  let ac=null;
  function ensureAC(){ if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)(); return ac; }

  function currentSfxGain(){
    const vol = (parseInt(sfxVol.value,10)||50)/100;
    return (muteSFX.checked?0:1) * vol;
  }

  function playPing(f=440, len=0.2, gain=0.05){
    if (menuOpen) return;
    try{
      ensureAC();
      const master = currentSfxGain();
      if (master <= 0) return;
      const o=ac.createOscillator(), g=ac.createGain(), hp=ac.createBiquadFilter();
      hp.type='highpass'; hp.frequency.value=300;
      o.type='sine'; o.frequency.value=f;
      g.gain.value = gain * master;
      o.connect(hp).connect(g).connect(ac.destination);
      const t = ac.currentTime;
      o.start(t);
      g.gain.setValueAtTime(g.gain.value, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t+len);
      o.stop(t+len+0.02);
    }catch(e){}
  }

  const ui = {
    get mode(){ return sceneSel; },
    get intensity(){ return intSlider; },
    get size(){ return sizeSlider; },
    get trail(){ return trailSlider; }
  };

  let paused=false;
  let mouse = { x:W/2, y:H/2, vx:0, vy:0, speed:0, down:false };
  let last  = { x:mouse.x, y:mouse.y, t:performance.now() };
  let lastMoveT = performance.now();
  let dwellMs = 0;
  let now = performance.now();

  addEventListener('mousemove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const nx=e.clientX, ny=e.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
    recomputePaused();
  }, {passive:true});

  addEventListener('touchmove', (e)=>{
    const t=performance.now(), dt=(t-last.t)/1000;
    const touch=e.touches[0]; if(!touch) return;
    const nx=touch.clientX, ny=touch.clientY;
    mouse.vx=(nx-last.x)/(dt||1); mouse.vy=(ny-last.y)/(dt||1);
    mouse.speed=Math.hypot(mouse.vx,mouse.vy);
    mouse.x=nx; mouse.y=ny; last.x=nx; last.y=ny; last.t=t;
    lastMoveT = t;
    recomputePaused();
  }, {passive:true});

  addEventListener('pointerdown', ()=>{ mouse.down=true; lastMoveT = performance.now(); playPing(700,0.08,0.05); });
  addEventListener('pointerup',   ()=>{ mouse.down=false; });

  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  const mapTrail = ()=> {
    const t = Number(ui.trail.value)/100;
    const shaped = Math.pow(1 - t, 2.2);
    return clamp(0.01 + shaped*0.98, 0.01, 0.99);
  };
  const mapIntensity = ()=> {
    const t = Number(ui.intensity.value)/100;
    return clamp(Math.pow(t, 1.6), 0, 1);
  };
  const mapSize = ()=> {
    const s = Number(ui.size.value);
    const t = (s - 10) / 190;
    const shaped = Math.pow(t, 1.35);
    return 8 + shaped * 420;
  };
  const sizeNorm = ()=> clamp((Number(ui.size.value)-10)/190, 0, 1);

  function mapSizeJelly(){
    const s = Number(ui.size.value);
    const sEff = 10 + (s - 10) * (50/90);
    const t = (sEff - 10) / 190;
    const shaped = Math.pow(t, 1.35);
    return 8 + shaped * 420;
  }

  const dwellFactor=()=> clamp(dwellMs/1200,0,1);
  let lastDwellStage=0;
  function dwellJustCrossed(ms){
    const stage = dwellMs >= ms ? 1 : 0;
    const crossed = stage > lastDwellStage;
    lastDwellStage = stage;
    return crossed;
  }
  function clearToBg(hard=false){
    const isLight = document.body.classList.contains('light');
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = hard ? (isLight ? '#fff' : '#000')
                         : (isLight ? `rgba(255,255,255,${mapTrail()})` : `rgba(0,0,0,${mapTrail()})`);
    ctx.fillRect(0,0,W,H);
  }

/* =========================
   AURORA (snappier, no halo)
   ========================= */

// Quick quality hint (safe if you don't have perfScale/frameMsAvg)
function _auroraQuality(){
  const ps  = (typeof perfScale   !== 'undefined') ? perfScale   : 1;
  const fma = (typeof frameMsAvg  !== 'undefined') ? frameMsAvg  : 16;
  const qFromFps  = clamp(1 - Math.max(0, (fma - 16)/16)*0.5, 0.6, 1);
  return Math.min(ps, qFromFps);
}

// Compact FBM (4 octaves)
function fbm(x, t=0){
  let v=0, a=0.5, f=1.0;
  for (let i=0;i<4;i++){ v += a*Math.sin(x*f+t*(0.35+i*0.07)+i*1.3); a*=0.5; f*=1.8; }
  return v;
}

const AUR = { t:0, hueBase:140, stars:[], ribbons:[] };

function auroraInit(){
  const q = _auroraQuality();

  // Slightly fewer stars for perf; quicker parallax later
  const n = Math.floor((W*H) * (1/26000) * (0.7 + 0.6*q));
  AUR.stars = Array.from({length:n}, () => ({
    x:Math.random()*W, y:Math.random()*H, z:Math.random(), a:0.22+Math.random()*0.45
  }));

  // 2–3 ribbons; base params a bit leaner
  const ribs = (q > 0.8 ? 3 : 2);
  AUR.ribbons.length = 0;
  for (let i=0;i<ribs;i++){
    AUR.ribbons.push({
      amp:   70 + i*24,                  // ↓ a touch for stability at high follow
      thick: 46 + i*10,
      hue:   (AUR.hueBase + (i===0?40:i===1?0:-40)+360)%360,
      speed: 0.55 + i*0.18,
      alpha: 0.12 + i*0.06,
      warp:  0.90 + i*0.12,
      offsetY: 0.60 - i*0.08,
      jitter: 0.8 + i*0.25
    });
  }
}
function auroraResize(){ auroraInit(); }
auroraInit();

// Stars — stronger pointer parallax & slight velocity skew
function drawStars(dt, boost=1){
  ctx.globalCompositeOperation = 'screen';
  const parX = (mouse.x - W*0.5) * 0.06;   // ↑ follow
  const parY = (mouse.y - H*0.5) * 0.03;
  const velSkewX = mouse.vx * 0.00005;
  for (let i=0;i<AUR.stars.length;i++){
    const s = AUR.stars[i];
    s.x += (mouse.vx*0.000015 + velSkewX) * (0.3 + s.z);
    if (s.x < -5) s.x = W+5; if (s.x > W+5) s.x = -5;
    const px = s.x - parX * s.z;
    const py = s.y - parY * s.z;
    const r = 0.6 + s.z*1.4;
    ctx.fillStyle = `hsla(200,100%,${68+26*s.z}%,${s.a*boost})`;
    ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
  }
}

// Ribbons — much stronger pointer influence (pos + vel) and tighter sampling near cursor
function drawCurtainRibbon(rib, t, intensity){
  const q = _auroraQuality();

  // Follow the pointer more aggressively
  const followY = 0.26 + 0.30*intensity;      // ↑ vertical chase
  const baseY   = H * rib.offsetY + (mouse.y - H*0.5) * followY;

  // Adapt step; denser near cursor for “stickiness”
  const baseStep = Math.max(10, Math.round(W / (90 + 140*q)));
  const cx = mouse.x;
  const upper=[]; const lower=[];

  // Bend & phase sensitivity
  const phaseShift = (mouse.x/W - 0.5) * 1.8;  // ↑ phase follow
  const velPullX   = mouse.vx * 0.025;         // velocity drags the curtain
  const velBend    = clamp(mouse.vx/800, -1.2, 1.2);

  for (let x=0; x<=W; ){
    // locally refine near cursor (cheaper than full dense mesh)
    const near = Math.max(0, 1 - Math.abs(x - cx) / (W*0.35));
    const step = Math.max(8, baseStep * (1 - 0.55*near));
    const u = x / W;

    const n = fbm(u*6*rib.warp + rib.jitter*0.6 + phaseShift, t*rib.speed);
    const amp = rib.amp * (0.9 + 0.8*intensity) * (1 + dwellFactor()*0.12);

    // Proximity bend now stronger and sharper
    const dx = (x - cx);
    const prox = Math.max(0, 1 - Math.abs(dx) / (W*0.55));
    const proxShaped = prox*prox; // sharper
    const bend = ( - (dx / W) * amp * 0.75 * proxShaped * (0.7 + intensity) ) + velBend * 22 * prox;

    const y = baseY + n*amp + Math.sin(u*3 + t*0.3)*amp*0.05 + bend;
    const thick = rib.thick * (0.9 + 0.7*intensity) * (0.9 + 0.25*Math.abs(n));

    // Velocity skews the ribbon laterally for “catch-up”
    const skew = velPullX * (0.15 + 0.6*proxShaped);
    const xx = x + skew;

    upper.push([xx, y - thick]);
    lower.push([xx, y + thick]);

    x += step;
  }

  const hue = (rib.hue + 20*Math.sin(t*0.15))%360;
  const alpha = rib.alpha * (0.95 + 0.3*intensity) * q;

  // Body
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = `hsla(${hue}, 95%, 60%, ${alpha})`;
  ctx.beginPath();
  for (let i=0;i<upper.length;i++){ const [x,y]=upper[i]; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  for (let i=lower.length-1;i>=0;i--){ const [x,y]=lower[i]; ctx.lineTo(x, y); }
  ctx.closePath(); ctx.fill();

  // Inner wash (single pass)
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = 0.22 * q;
  ctx.beginPath();
  for (let i=0;i<upper.length;i++){
    const [x,yU]=upper[i]; const yL = lower[i][1];
    ctx.lineTo(x, yU + 0.58*(yL - yU));
  }
  for (let i=lower.length-1;i>=0;i--){
    const [x,yL]=lower[i]; const yU = upper[i][1];
    ctx.lineTo(x, yL - 0.58*(yL - yU));
  }
  ctx.closePath(); ctx.fill();
  ctx.globalAlpha = 1;
}

function renderAurora(dt){
  const q = _auroraQuality();
  AUR.t += dt; AUR.hueBase = (AUR.hueBase + 12*dt) % 360;

  // Cheap fade
  ctx.globalCompositeOperation='source-over';
  ctx.globalAlpha = mapTrail()*0.9;
  ctx.fillStyle = document.body.classList.contains('light') ? '#fff' : '#000';
  ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 1;

  const intensity = mapIntensity();
  drawStars(dt, 0.95 + 0.4*intensity);

  for (let i=0;i<AUR.ribbons.length;i++){
    const rib=AUR.ribbons[i]; rib.hue=(rib.hue+6*dt)%360;
    drawCurtainRibbon(rib, AUR.t + i*0.12, intensity);
  }

  // NOTE: Removed big dwell halo around the pointer
}
/* =========================
/* =========================
   RIPPLES — subtle ambient background + farther, richer rings
   Notes:
   - Background stays independent of the pointer (slow drifting blobs).
   - Rings/halos now travel farther, live longer, and glow a bit stronger.
   - Hook: call ripplesResize() on window resize and renderRipples(dt) in the scene.
========================= */

/* ---------- Rings / Halos ---------- */
const ripples = [];
const halos   = [];
let rippleCooldown = 0;
let waterT = 0;

function emitRipple(x, y, power=1){
  // Travel farther: boost radial speed & base width with size slider
  const sN   = sizeNorm();
  const sp   = (54 + 42*mapIntensity()) * (1.15 + 0.35*sN);
  const hue  = 198 + Math.random()*22;
  const sat  = 92;
  const lite = 50 + power*4;
  ripples.push({
    x, y, r:0,
    vr: sp * (0.9 + Math.random()*0.22),
    width: 5.5 + mapSize()*0.06 + power*2.5 + (0.6 + 0.8*sN),
    life: 1.0, hue, sat, lite,
    phase: Math.random()*Math.PI*2
  });
}
function emitHalo(x, y, strength=1){
  const hue = 200 + Math.random()*16;
  halos.push({
    x, y, r:24,
    vr: (160 + 280*mapIntensity()) * (0.7 + 0.6*Math.random()),
    a: 0.28 * strength, hue
  });
}

/* ---------- Minimal ambient background (independent of pointer) ---------- */
const AMBIENT = { blobs: [], t: 0 };

function ripplesResize(){
  const isLight = document.body.classList.contains('light');
  const baseR = Math.max(W, H) * (isLight ? 0.9 : 1.1); // larger in dark mode

  AMBIENT.blobs = [
    makeBlob(baseR,       195, isLight ? 62 : 36, 0.065, 0.045, 0.00),
    makeBlob(baseR * 1.15,208, isLight ? 58 : 32, 0.052, 0.038, 2.10),
    makeBlob(baseR * 1.30,188, isLight ? 66 : 40, 0.040, 0.032, 4.20),
  ];

  function makeBlob(r, hue, lite, fx, fy, seed){
    return {
      r, hue, lite,
      alpha: isLight ? 0.035 : 0.028,
      ax: fx, ay: fy,
      phx: seed + Math.random()*0.5,
      phy: seed + Math.random()*0.5,
      cx: W*0.5,
      cy: H*0.5
    };
  }
}
ripplesResize();

function drawAmbientBackground(dt){
  AMBIENT.t += dt;

  // theme-aware soft clear honoring Trail slider
  ctx.globalCompositeOperation='source-over';
  const isLight = document.body.classList.contains('light');
  ctx.fillStyle = isLight
    ? `rgba(255,255,255,${mapTrail()})`
    : `rgba(0,0,0,${mapTrail()})`;
  ctx.fillRect(0,0,W,H);

  // faint drifting blobs
  ctx.globalCompositeOperation = 'screen';
  for (let i=0;i<AMBIENT.blobs.length;i++){
    const b = AMBIENT.blobs[i];
    const x = b.cx + Math.sin(AMBIENT.t*b.ax + b.phx) * (W*0.18);
    const y = b.cy + Math.sin(AMBIENT.t*b.ay + b.phy) * (H*0.16);
    const pulse = 1 + 0.03*Math.sin((AMBIENT.t + i)*0.35);
    const R = b.r * pulse;
    const L = b.lite + 4*Math.sin((AMBIENT.t + i*0.7)*0.25);

    const g = ctx.createRadialGradient(x, y, R*0.25, x, y, R);
    g.addColorStop(0.0, `hsla(${b.hue|0}, 70%, ${Math.min(95, L+4)|0}%, ${b.alpha})`);
    g.addColorStop(0.65, `hsla(${(b.hue+10)|0}, 70%, ${L|0}%, ${b.alpha*0.6})`);
    g.addColorStop(1.0, `hsla(${(b.hue+24)|0}, 70%, ${Math.max(0, L-10)|0}%, 0)`);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x, y, R, 0, Math.PI*2); ctx.fill();
  }
}

/* ---------- Full render ---------- */
function renderRipples(dt){
  waterT += dt;

  // Optional movement/dwell emission
  const speedN = clamp(mouse.speed/1200, 0, 1);
  rippleCooldown = Math.max(0, rippleCooldown - dt);
  if (speedN > 0.10 && rippleCooldown <= 0){
    emitRipple(mouse.x, mouse.y, 0.25 + speedN*0.55);
    rippleCooldown = 0.04 + (0.10*(1-mapIntensity()));
  }
  if (dwellJustCrossed(650)){
    playPing(520,0.16,0.05);
    for (let i=0;i<2;i++) emitRipple(mouse.x, mouse.y, 1.1);
    emitHalo(mouse.x, mouse.y, 0.9);
  }

  // 1) Subtle, independent background
  drawAmbientBackground(dt);

  // 2) Halos
  for (let i=halos.length-1;i>=0;i--){
    const h = halos[i];
    h.r  += h.vr*dt;
    h.a  *= Math.pow(0.975 - 0.15*dt, 1.0);
    if (h.a < 0.02 || h.r > Math.max(W,H)*1.2){ halos.splice(i,1); continue; }
    const g = ctx.createRadialGradient(h.x, h.y, h.r*0.15, h.x, h.y, h.r);
    g.addColorStop(0.0, `hsla(${h.hue}, 90%, 65%, ${0.10*h.a})`);
    g.addColorStop(0.6, `hsla(${h.hue+8}, 90%, 55%, ${0.08*h.a})`);
    g.addColorStop(1.0, `hsla(${h.hue+30}, 90%, 45%, 0)`);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(h.x, h.y, h.r, 0, Math.PI*2); ctx.fill();
  }

  // 3) Rings (travel farther + more effect)
  for (let i=ripples.length-1;i>=0;i--){
    const r = ripples[i];

    r.r    += r.vr*dt;
    // Slower decay so they persist longer (was 0.985 - 0.20*dt)
    r.life *= Math.pow(0.990 - 0.16*dt, 1 + 0.6*mapIntensity());

    const alive = clamp(r.life, 0, 1);
    // Let them travel beyond screen diagonal before culling
    if (alive < 0.02 || r.r > Math.hypot(W,H)*1.5){ ripples.splice(i,1); continue; }

    r.phase += dt*(0.8 + 0.6*mapIntensity());
    const shimmer = 1 + 0.18*Math.sin(r.phase) + 0.08*Math.sin(waterT*1.7 + i*0.6);
    // Slightly stronger width as rings age to keep visibility
    const w = (r.width * (0.78 + 0.55*alive)) * shimmer;

    // Outer glow (wider radii than before)
    ctx.globalCompositeOperation = 'screen';
    const glowR1 = r.r*1.00, glowR2 = r.r*1.35;
    const g1 = ctx.createRadialGradient(r.x, r.y, glowR1*0.45, r.x, r.y, glowR1);
    g1.addColorStop(0, `hsla(${r.hue}, ${r.sat}%, ${r.lite+8}%, ${0.09*alive})`);
    g1.addColorStop(1, `hsla(${r.hue+10}, ${r.sat}%, ${r.lite-6}%, 0)`);
    ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(r.x, r.y, glowR1, 0, Math.PI*2); ctx.fill();

    const g2 = ctx.createRadialGradient(r.x, r.y, glowR2*0.55, r.x, r.y, glowR2);
    g2.addColorStop(0, `hsla(${r.hue+12}, ${r.sat}%, ${r.lite}%, ${0.07*alive})`);
    g2.addColorStop(1, `hsla(${r.hue+28}, ${r.sat}%, ${r.lite-10}%, 0)`);
    ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(r.x, r.y, glowR2, 0, Math.PI*2); ctx.fill();

    // Main bright rings
    ctx.globalCompositeOperation='lighter';
    const hues   = [ r.hue-10, r.hue, r.hue+12 ];
    const alphas = [ alive*0.22, alive*0.46, alive*0.22 ]; // a bit stronger
    const radii  = [ r.r*0.988, r.r, r.r*1.012 ];

    for (let k=0;k<3;k++){
      ctx.strokeStyle = `hsla(${hues[k]}, ${r.sat}%, ${r.lite}%, ${alphas[k]})`;
      ctx.lineWidth   = Math.max(1.2, w * (k===1?1.05:0.75));
      ctx.beginPath();
      ctx.arc(r.x, r.y, Math.max(0.1, radii[k]), 0, Math.PI*2);
      ctx.stroke();
    }

    // Echo ring (more visible and farther in)
    const echoAlpha = 0.18 * alive;
    if (echoAlpha > 0.01){
      ctx.strokeStyle = `hsla(${r.hue+6}, ${r.sat}%, ${r.lite-4}%, ${echoAlpha})`;
      ctx.lineWidth   = Math.max(1, w*0.60);
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r*0.65, 0, Math.PI*2);
      ctx.stroke();
    }
  }
}

  /* =========================
     FIREWORKS
     ========================= */
  const fwParts = [];
  let fwHueBase = 0;
  let fwMoveCooldown = 0;
  let fwAutoCooldown = 0;

  function fwSpawnBurst(x, y, power=1, style='peony'){
    const sN = sizeNorm();
    const sPow = Math.pow(sN, 1.15);
    const base = 16 + Math.floor(28*mapIntensity());
    const count = Math.floor(base * (0.5 + 2.7*sPow) * power);

    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const speedBase = 1.8 + Math.random()*2.8;
      const speed = speedBase * (0.7 + 1.6*sPow);
      let vx = Math.cos(a)*speed, vy = Math.sin(a)*speed;

      if (style==='ring'){
        const ringR = (2.2 + Math.random()*1.2) * (0.8 + 1.4*sPow);
        vx = Math.cos(a)*ringR; vy = Math.sin(a)*ringR;
      } else if (style==='willow'){
        const willowS = (1.3 + Math.random()*1.1) * (0.7 + 1.4*sPow);
        vx = Math.cos(a)*willowS*0.85; vy = Math.sin(a)*willowS*0.6 - (0.8 + 0.6*sPow);
      }

      const hue = (fwHueBase + (Math.random()*40 - 20) + i)%360;
      fwParts.push({
        x, y, px:x, py:y,
        vx, vy,
        drag: 0.986,
        gy: 0.02,
        life: (0.6 + Math.random()*0.6) * (0.8 + 1.6*sPow),
        age: 0,
        size: (0.7 + Math.random()*1.2) * (0.8 + 2.6*sPow),
        hue,
        light: 60 + Math.random()*10,
        sat: 95
      });
    }
    if (power > 1.1) playPing(420+Math.random()*280, 0.15, 0.05);
  }

  function renderFireworks(dt){
    fwHueBase = (fwHueBase + 60*dt) % 360;

    const isLight = document.body.classList.contains('light');
    const fade = isLight ? `rgba(255,255,255,${mapTrail()*0.85})` : `rgba(0,0,0,${mapTrail()*0.82})`;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = fade; ctx.fillRect(0,0,W,H);

    fwMoveCooldown = Math.max(0, fwMoveCooldown - dt);
    fwAutoCooldown = Math.max(0, fwAutoCooldown - dt);
    const speedN = clamp(mouse.speed/1200, 0, 1);
    const sN = sizeNorm();

    if (speedN > 0.25 && fwMoveCooldown === 0){
      const pow = 0.8 + 0.8*speedN*mapIntensity();
      const style = (Math.random() < 0.25) ? 'ring' : (Math.random()<0.15 ? 'willow' : 'peony');
      fwSpawnBurst(mouse.x, mouse.y, pow, style);
      fwMoveCooldown = (0.08 + 0.10*(1-mapIntensity())) * (0.85 + 0.3*(1-sN));
    }
    if (dwellJustCrossed(600)){
      fwSpawnBurst(mouse.x, mouse.y, 1.2 + 0.9*mapIntensity(), (Math.random()<0.3?'ring':'peony'));
    }
    if (fwAutoCooldown === 0 && Math.random() < 0.02*mapIntensity()*(0.7 + 0.8*sN)){
      fwSpawnBurst(mouse.x + (Math.random()-0.5)*60, mouse.y + (Math.random()-0.5)*40, 0.9 + 0.6*sN, 'peony');
      fwAutoCooldown = 0.25 * (0.9 + 0.6*(1-sN));
    }

    ctx.globalCompositeOperation='lighter';
    ctx.lineCap='round';
    for (let i=fwParts.length-1;i>=0;i--){
      const p = fwParts[i];
      p.age += dt;
      if (p.age >= p.life){ fwParts.splice(i,1); continue; }

      p.vx *= Math.pow(p.drag, dt*60);
      p.vy = p.vy*Math.pow(p.drag, dt*60) + p.gy*(dt*60);
      p.px = p.x; p.py = p.y;
      p.x += p.vx*(dt*60);
      p.y += p.vy*(dt*60);

      const t = p.age / p.life;
      const alpha = Math.max(0, (1 - t) * (0.65 - 0.25*t));

      const strokeScale = 0.7 + 2.2*sN;
      ctx.strokeStyle = `hsla(${p.hue}, ${p.sat}%, ${p.light}%, ${alpha})`;
      ctx.lineWidth   = Math.max(1, (p.size * (1 - 0.5*t)) * strokeScale);
      ctx.beginPath(); ctx.moveTo(p.px, p.py); ctx.lineTo(p.x, p.y); ctx.stroke();

      const glowAlpha = alpha * (0.6 + 0.8*sN);
      ctx.fillStyle = `hsla(${(p.hue+10)%360}, ${p.sat}%, ${Math.min(90, p.light+15)}%, ${glowAlpha})`;
      const glowR = Math.max(1, p.size * (0.6 + 2.0*sN));
      ctx.beginPath(); ctx.arc(p.x, p.y, glowR*0.6, 0, Math.PI*2); ctx.fill();
    }

    const cap = Math.floor(900 + 1200*sizeNorm());
    if (fwParts.length > cap) fwParts.splice(0, fwParts.length - cap);
  }

  /* =========================
     KALEIDO
     ========================= */
  let hueBase = 0;
  let kaleidoAngle=0;
  function renderKaleido(dt){
    const segs=8, r=mapSize()*0.8; kaleidoAngle += dt*0.4;
    clearToBg(false);
    const cx=W/2, cy=H/2, dx=mouse.x-cx, dy=mouse.y-cy;
    const baseHue=(performance.now()*0.02)%360, w=7+mapIntensity()*18;
    ctx.globalCompositeOperation='lighter'; ctx.lineCap='round'; ctx.lineJoin='round';
    for (let i=0;i<segs;i++){
      const a=(i/segs)*Math.PI*2 + kaleidoAngle;
      const x = cx + (dx*Math.cos(a) - dy*Math.sin(a));
      const y = cy + (dx*Math.sin(a) + dy*Math.cos(a));
      const h=(baseHue + i*(360/segs))%360;
      ctx.strokeStyle=`hsla(${h},85%,65%,0.5)`; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(lerp(cx,x,0.55), lerp(cy,y,0.55)); ctx.lineTo(x,y); ctx.stroke();
      ctx.fillStyle=`hsla(${(h+40)%360},85%,60%,0.25)`; ctx.beginPath(); ctx.arc(x,y, r*0.28, 0, Math.PI*2); ctx.fill();
    }
    if (dwellMs>600){
      const s=r*(1+0.12*Math.sin(performance.now()*0.006));
      ctx.strokeStyle=`hsla(${(baseHue+120)%360},90%,75%,0.35)`; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(cx,cy,s,0,Math.PI*2); ctx.stroke();
    }
  }

  /* =========================
     FIREFLIES
     ========================= */
  const fireflies = Array.from({length:50},()=>({ x: Math.random()*W, y: Math.random()*H, vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6, glow: Math.random()*0.6 }));
  function renderFireflies(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    const attract = 15*mapIntensity();
    fireflies.forEach(f=>{
      f.vx += (Math.random()-0.5)*0.05; f.vy += (Math.random()-0.5)*0.05;
      f.vx += (mouse.x - f.x)/W * attract*dt; f.vy += (mouse.y - f.y)/H * attract*dt;
      f.vx = clamp(f.vx, -1.2, 1.2); f.vy = clamp(f.vy, -1.2, 1.2);
      f.x += f.vx; f.y += f.vy;
      if (f.x<-10) f.x=W+10; if (f.x>W+10) f.x=-10; if (f.y<-10) f.y=H+10; if (f.y>H+10) f.y=-10;
      const d = Math.hypot(mouse.x-f.x, mouse.y-f.y), charge = clamp(1 - d/220, 0, 1);
      f.glow = clamp(f.glow + (charge*1.6 - 0.4)*dt, 0.1, 1.4);
      const h = (200 + f.glow*100)%360, r = 2 + f.glow*4 + mapSize()*0.05;
      ctx.fillStyle = `hsla(${h},90%,65%,${0.6*f.glow})`; ctx.beginPath(); ctx.arc(f.x, f.y, r, 0, Math.PI*2); ctx.fill();
    });
    if (dwellJustCrossed(800)){ playPing(660,0.15,0.045); fireflies.forEach(f=> f.glow = Math.max(f.glow, 1.2)); }
  }

  /* =========================
     CONFETTI
     ========================= */
  const confettis = Array.from({length:220},()=>resetPiece({}));
  function resetPiece(p){
    p.x=Math.random()*W; p.y=Math.random()*H; p.vx=(Math.random()-0.5)*0.7; p.vy=Math.random()*0.6+0.2;
    p.size=2+Math.random()*4; p.h=Math.random()*360; p.spin=(Math.random()-0.5)*0.15; return p;
  }
  function renderConfetti(dt){
    clearToBg(false);
    const windX = clamp(mouse.vx/400, -1.5, 1.5) * (0.5 + mapIntensity());
    const windY = 0.15 + (dwellMs>600 ? 0.25 : 0);
    ctx.globalCompositeOperation='lighter';
    confettis.forEach(p=>{
      const dx = mouse.x - p.x, dy = mouse.y - p.y, pull = 0.02*mapIntensity();
      p.vx += windX*dt + dx*pull*dt; p.vy += windY*dt + dy*pull*dt;
      p.x += p.vx; p.y += p.vy; p.h += p.spin;
      ctx.fillStyle = `hsla(${(p.h)%360},90%,60%,0.8)`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
      if (p.x<-20||p.x>W+20||p.y<-20||p.y>H+20) resetPiece(p);
    });
    if (dwellJustCrossed(700)){
      playPing(550,0.12,0.04);
      for(let i=0;i<50;i++){ const q=resetPiece({}); q.x=mouse.x; q.y=mouse.y; q.vx=(Math.random()-0.5)*3.2; q.vy=Math.random()*-1.8; confettis.push(q); }
      if (confettis.length>400) confettis.splice(0, confettis.length-400);
    }
  }

  /* =========================
     NÉBULEUSE
     ========================= */
  let nebulaHue = 0;
  function renderNebula(dt){
    nebulaHue = (nebulaHue + 18*dt) % 360;
    clearToBg(false);
    if (!AUR.stars || AUR.stars.length === 0) auroraInit();
    drawStars(dt, 1.35);
    ctx.globalCompositeOperation='lighter';
    const layers = 3 + Math.floor(mapIntensity()*3);
    for (let i=0;i<layers;i++){
      const s = mapSize()*(0.8 + i*0.35), h = (nebulaHue + i*40) % 360;
      const g = ctx.createRadialGradient(mouse.x, mouse.y, s*0.1, mouse.x, mouse.y, s);
      g.addColorStop(0, `hsla(${h},85%,60%,0.18)`);
      g.addColorStop(0.6, `hsla(${(h+30)%360},85%,50%,0.08)`);
      g.addColorStop(1, `hsla(${(h+60)%360},85%,45%,0)`);
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, s, 0, Math.PI*2); ctx.fill();
    }
    if (dwellMs>650){
      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(nebulaHue+150)%360},90%,75%,0.4)`;
      ctx.lineWidth = 1.5;
      const m = 6;
      for (let i=0;i<m;i++){
        const a=(i/m)*Math.PI*2 + performance.now()*0.0015, r=mapSize()*1.1;
        ctx.beginPath(); ctx.arc(mouse.x + Math.cos(a)*r, mouse.y + Math.sin(a)*r, r*0.15, 0, Math.PI*2); ctx.stroke();
      }
    }
  }

  /* =========================
     GELÉE
     ========================= */
  const blobs = Array.from({length:6}, ()=>({
    x: W*(0.2+0.6*Math.random()),
    y: H*(0.2+0.6*Math.random()),
    r: 40+Math.random()*80,
    hue: Math.random()*360,
    vx:0, vy:0
  }));
  function renderJelly(dt){
    clearToBg(false);
    const intensity = mapIntensity();
    const pull = 18*intensity;
    const damping = 0.99;
    const gravity = 0.012;
    const sizeJ = mapSizeJelly();

    blobs.forEach(b=>{
      const dx = mouse.x - b.x, dy = mouse.y - b.y;
      b.vx += dx * pull * 0.00018;
      b.vy += dy * pull * 0.00018 + gravity;
      b.vx *= damping; b.vy *= damping;
      b.x += b.vx; b.y += b.vy;
      if (b.x < -120) b.x = W+120; else if (b.x > W+120) b.x = -120;
      if (b.y < -120) b.y = H+120; else if (b.y > H+120) b.y = -120;
    });

    const parts = blobs.map(b=>{
      const speed = Math.hypot(b.vx, b.vy);
      const squish = clamp(1 + speed*0.03, 1, 1.5) * (1 + dwellFactor()*0.15);
      const rx = b.r * squish * (sizeJ/95);
      const ry = b.r * (2 - squish) * (sizeJ/95);
      const R  = (rx + ry) * 0.5;
      const h  = (b.hue + performance.now()*0.02)%360;
      return { b, rx, ry, R, h, squish };
    });

    for (let iter=0; iter<2; iter++){
      for (let i=0; i<parts.length; i++){
        for (let j=i+1; j<parts.length; j++){
          const pi = parts[i], pj = parts[j];
          const ax = pi.b.x, ay = pi.b.y;
          const bx = pj.b.x, by = pj.b.y;
          let dx = bx - ax, dy = by - ay;
          let d = Math.hypot(dx,dy);
          if (d === 0){ dx = (Math.random()-0.5)*0.001; dy=(Math.random()-0.5)*0.001; d = Math.hypot(dx,dy); }
          const minD = (pi.R + pj.R) * 0.95;
          if (d < minD){
            const push = (minD - d) * 0.5;
            const nx = dx / d, ny = dy / d;
            pi.b.x -= nx*push; pi.b.y -= ny*push;
            pj.b.x += nx*push; pj.b.y += ny*push;
            pi.b.vx *= 0.9; pi.b.vy *= 0.9;
            pj.b.vx *= 0.9; pj.b.vy *= 0.9;
          }
        }
      }
    }

    const links = [];
    for (let i=0;i<parts.length;i++){
      let bestJ=-1, bestD=1e9;
      for (let j=0;j<parts.length;j++){
        if (j===i) continue;
        const di = Math.hypot(parts[j].b.x - parts[i].b.x, parts[j].b.y - parts[i].b.y);
        if (di < bestD){ bestD=di; bestJ=j; }
      }
      if (bestJ>=0){
        const span = (parts[i].R + parts[bestJ].R) * 0.8;
        if (bestD < span) links.push([i, bestJ, bestD, span]);
      }
    }
    links.sort((A,B)=>A[2]-B[2]);
    if (links.length > 12) links.length = 12;

    ctx.lineJoin='round'; ctx.lineCap='round';
    parts.forEach(p=>{
      const b = p.b;
      ctx.globalCompositeOperation='multiply';
      const sx = b.x + b.vx*4, sy = b.y + b.vy*4;
      const sg = ctx.createRadialGradient(sx, sy, Math.min(p.rx,p.ry)*0.2, sx, sy, Math.max(p.rx,p.ry)*1.05);
      sg.addColorStop(0, 'rgba(0,0,0,0.10)');
      sg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = sg;
      ctx.beginPath(); ctx.ellipse(sx, sy, p.rx*1.02, p.ry*1.02, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.fill();
    });

    parts.forEach(p=>{
      const b = p.b;
      ctx.globalCompositeOperation='lighter';
      const g = ctx.createRadialGradient(b.x, b.y, Math.min(p.rx,p.ry)*0.28, b.x, b.y, Math.max(p.rx,p.ry));
      g.addColorStop(0.00, `hsla(${p.h},95%,58%,0.60)`);
      g.addColorStop(0.55, `hsla(${(p.h+30)%360},95%,50%,0.32)`);
      g.addColorStop(1.00, `hsla(${(p.h+60)%360},90%,45%,0.0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.ellipse(b.x, b.y, p.rx, p.ry, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.fill();

      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(p.h+40)%360},95%,80%,0.35)`;
      ctx.lineWidth = Math.max(1.2, 1.5 + sizeJ*0.01);
      ctx.beginPath(); ctx.ellipse(b.x, b.y, p.rx*0.98, p.ry*0.98, Math.atan2(b.vy, b.vx), 0, Math.PI*2); ctx.stroke();

      const glx = b.x - p.rx*0.28, gly = b.y - p.ry*0.28;
      const glr = Math.min(p.rx,p.ry)*0.22;
      const gl = ctx.createRadialGradient(glx, gly, glr*0.2, glx, gly, glr);
      gl.addColorStop(0, 'rgba(255,255,255,0.25)');
      gl.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gl;
      ctx.beginPath(); ctx.arc(glx, gly, glr, 0, Math.PI*2); ctx.fill();
    });

    ctx.globalCompositeOperation='screen';
    links.forEach(link=>{
      const i = link[0], j = link[1], d = link[2], span = link[3];
      const a = parts[i], b = parts[j];
      const t = clamp(1 - d/span, 0, 1);
      if (t <= 0) return;
      const midH = ((a.h + b.h)*0.5) % 360;
      ctx.strokeStyle = `hsla(${midH},95%,70%,${0.08 + 0.22*t*(0.6+0.4*mapIntensity())})`;
      ctx.lineWidth = 2 + t * (2 + mapSizeJelly()*0.02);
      const mx = (a.b.x + b.b.x) * 0.5;
      const my = (a.b.y + b.b.y) * 0.5;
      const cx = mx + (mouse.x - mx) * 0.02 * t;
      const cy = my + (mouse.y - my) * 0.02 * t;
      ctx.beginPath();
      ctx.moveTo(a.b.x, a.b.y);
      ctx.quadraticCurveTo(cx, cy, b.b.x, b.b.y);
      ctx.stroke();
    });

    if (dwellJustCrossed(900)){
      playPing(330,0.12,0.05);
      blobs.forEach(b=>{ b.vx*=0.6; b.vy*=-0.8; b.hue = (b.hue+15)%360; });
    }
  }

  /* =========================
     SNOW — simplified & reactive
     ========================= */
  const SNOW = {
    layers: [[],[],[]],
    ground: { cell: 6, cols: 0, h: null },
    frameCounter: 0
  };

  function snowResize(){
    const c = SNOW.ground.cell;
    SNOW.ground.cols = Math.max(4, Math.floor(W / c));
    SNOW.ground.h = new Float32Array(SNOW.ground.cols);
    SNOW.ground.h.fill(0);
    initSnowFlakes();
  }

  function initSnowFlakes(){
    SNOW.layers.forEach(a=>a.length=0);
    const density = 0.00006;
    const N = clamp(Math.floor(W*H*density*(0.7 + 0.9*mapIntensity())), 180, 900);
    const counts = [Math.floor(N*0.35), Math.floor(N*0.40), N];
    for (let i=0;i<counts[0];i++) SNOW.layers[0].push(makeFlake(0.35));
    for (let i=0;i<counts[1];i++) SNOW.layers[1].push(makeFlake(0.65));
    for (let i=0;i<counts[2];i++) SNOW.layers[2].push(makeFlake(0.95));
  }

  function makeFlake(depth){
    const z = depth;
    const baseR = 0.8 + 2.2*z + sizeNorm()*1.4*z;
    const speed = (0.10 + 0.50*z) * (0.75 + 0.6*mapIntensity());
    return {
      x: Math.random()*W,
      y: Math.random()*H,
      z,
      r: baseR,
      vx: (Math.random()-0.5)*0.06*z,
      vy: speed,
      phase: Math.random()*Math.PI*2,
      swayAmp: 0.15 + 0.9*z
    };
  }
  function resetFlake(f, burst=false){
    f.x = Math.random()*W;
    f.y = (-20) - Math.random()*40;
    f.vx = (Math.random()-0.5)*0.08*f.z + (burst? (Math.random()-0.5)*0.6 : 0);
    f.vy = (0.10 + 0.50*f.z) * (0.75 + 0.6*mapIntensity()) + (burst? -0.3 : 0);
    f.phase = Math.random()*Math.PI*2;
  }

  function groundDeposit(x, amount){
    const G = SNOW.ground;
    const i = clamp(Math.floor(x / G.cell), 0, G.cols-1);
    G.h[i] += amount;
  }

  function groundDiffuseCheap(){
    const G = SNOW.ground;
    for (let i=1;i<G.cols-1;i++){
      const avg = (G.h[i-1]+G.h[i]+G.h[i+1]) / 3;
      G.h[i] = lerp(G.h[i], avg, 0.25);
    }
  }

  function drawSky(){
    ctx.globalCompositeOperation='source-over';
    const isLight = document.body.classList.contains('light');
    const g = ctx.createLinearGradient(0,0,0,H);
    if (isLight){
      g.addColorStop(0, 'rgba(225,235,255,1)');
      g.addColorStop(1, 'rgba(245,250,255,1)');
    } else {
      g.addColorStop(0, 'rgba(12,18,28,1)');
      g.addColorStop(1, 'rgba(16,24,36,1)');
    }
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawGround(){
    const {h, cols, cell} = SNOW.ground;
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = 'rgba(255,255,255,0.96)';
    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let i=0;i<cols;i++){
      const x = i*cell;
      ctx.lineTo(x, H - h[i]);
    }
    ctx.lineTo(W, H - h[cols-1]);
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();
  }

  function renderSnow(dt){
    clearToBg(false);
    drawSky();

    const intensity = mapIntensity();
    const sN = sizeNorm();

    const windX = mouse.vx * 0.0016 * (0.6 + 1.0*intensity);
    const windY = mouse.vy * 0.0012 * (0.4 + 0.8*intensity);

    const radius = 180 + 140*sN;
    const invR = 1 / Math.max(1, radius);
    const pullBase = (mouse.down ? 0.9 : 0.6) * (0.4 + 1.2*intensity);

    const layerAlphas = [0.35, 0.55, 0.85];

    for (let L=0; L<3; L++){
      const arr = SNOW.layers[L];
      const alpha = layerAlphas[L];
      ctx.globalCompositeOperation='source-over';
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.beginPath();

      for (let i=0;i<arr.length;i++){
        const f = arr[i];

        f.phase += dt*(0.5 + 0.8*f.z);
        const sway = Math.sin(f.phase) * f.swayAmp;

        const dx = mouse.x - f.x;
        const dy = mouse.y - f.y;
        const d  = Math.hypot(dx,dy);
        const t  = clamp(1 - d*invR, 0, 1);
        const pull = (pullBase) * (t*t);

        f.vx += sway*0.02*dt + windX*(0.4 + 0.8*f.z) + (dx * pull * 0.06);
        f.vy += (0.03 + 0.10*f.z) + windY*(0.3 + 0.7*f.z) + (dy * pull * 0.06) - (t*0.06);

        const drag = 1 - (0.08 + 0.04*f.z)*dt;
        f.vx *= drag; f.vy *= drag;

        f.x += f.vx; f.y += f.vy;

        if (f.x < -8) f.x = W+8; else if (f.x > W+8) f.x = -8;

        const G = SNOW.ground;
        const col = clamp(Math.floor(f.x / G.cell), 0, G.cols-1);
        const surfaceY = H - G.h[col];
        if (f.y + f.r >= surfaceY){
          groundDeposit(f.x, clamp(f.r*0.5, 0.4, 2));
          resetFlake(f);
        }

        if (f.y > H + 40) resetFlake(f);

        ctx.moveTo(f.x + f.r, f.y);
        ctx.arc(f.x, f.y, Math.max(0.7, f.r), 0, Math.PI*2);
      }
      ctx.fill();
    }

    if ((SNOW.frameCounter++ & 7) === 0) groundDiffuseCheap();

    drawGround();

    if (dwellJustCrossed(800)){
      playPing(880,0.16,0.04);
      const arr = SNOW.layers[2];
      for (let k=0;k<20;k++){
        const nf = makeFlake(0.95);
        nf.x = mouse.x + (Math.random()-0.5)*40;
        nf.y = mouse.y + (Math.random()-0.5)*40;
        nf.vx += (Math.random()-0.5)*0.6 + windX*20;
        nf.vy += (Math.random()-0.5)*0.4 + windY*20 - 0.2;
        arr.push(nf);
      }
      if (arr.length > 600) arr.splice(0, arr.length-600);
    }
  }

  /* =========================
     SAND (Cellular)
     ========================= */
  const SAND_CELL = (()=> {
    const state = { cellSize:3, cols:0, rows:0, grid:null, palette:[], lastHueBase:0 };
    function allocGrid(){
      state.cols = Math.floor(W / state.cellSize);
      state.rows = Math.floor(H / state.cellSize);
      state.grid = new Int16Array(state.cols * state.rows);
      state.grid.fill(-1);
      state.palette = new Array(360);
      for (let h=0; h<360; h++){ state.palette[h] = `hsla(${h},95%,60%,1)`; }
    }
    function idx(x,y){ return y*state.cols + x; }
    function inBounds(x,y){ return (x>=0 && x<state.cols && y>=0 && y<state.rows); }
    function caSandReset(){ allocGrid(); }
    function caSandOnResize(){ allocGrid(); }
    function caEmitSand(px, py, n){
      const cs = state.cellSize;
      const cx = Math.floor(px / cs);
      const cy = Math.floor(py / cs);
      for (let i=0;i<n;i++){
        const rx = cx + Math.floor((Math.random()*5)-2);
        const ry = cy + Math.floor((Math.random()*5)-2);
        if (!inBounds(rx, ry)) continue;
        const id = idx(rx, ry);
        if (state.grid[id] === -1){
          const hue = ((state.lastHueBase + Math.floor(Math.random()*40)) % 360)|0;
          state.grid[id] = hue;
        }
      }
    }
    function caStep(windBias){
      const C = state.cols; const R = state.rows;
      const leftFirst = windBias < 0 ? true : windBias > 0 ? false : (Math.random() < 0.5);
      for (let y=R-2; y>=0; y--){
        const xStartLeft = (Math.random() < 0.5);
        if (xStartLeft){
          for (let x=0; x<C; x++){
            const i = y*C + x; const hue = state.grid[i]; if (hue === -1) continue;
            const iD = i + C;
            if (state.grid[iD] === -1){ state.grid[i] = -1; state.grid[iD] = hue; continue; }
            const tryDiag = leftFirst ? [-1,1] : [1,-1];
            for (let k=0;k<2;k++){
              const nx = x + tryDiag[k], ny = y + 1;
              if (nx<0 || nx>=C) continue;
              const ii = ny*C + nx;
              if (state.grid[ii] === -1){ state.grid[i] = -1; state.grid[ii] = hue; break; }
            }
          }
        } else {
          for (let x=C-1; x>=0; x--){
            const i = y*C + x; const hue = state.grid[i]; if (hue === -1) continue;
            const iD = i + C;
            if (state.grid[iD] === -1){ state.grid[i] = -1; state.grid[iD] = hue; continue; }
            const tryDiag = leftFirst ? [-1,1] : [1,-1];
            for (let k=0;k<2;k++){
              const nx = x + tryDiag[k], ny = y + 1;
              if (nx<0 || nx>=C) continue;
              const ii = ny*C + nx;
              if (state.grid[ii] === -1){ state.grid[i] = -1; state.grid[ii] = hue; break; }
            }
          }
        }
      }
    }
    function caDraw(){
      const cs = state.cellSize; const C = state.cols, R = state.rows;
      const isLight = document.body.classList.contains('light');
      ctx.globalCompositeOperation='source-over';
      ctx.fillStyle = isLight ? '#ffffff' : '#000000';
      ctx.fillRect(0,0,W,H);
      for (let y=0; y<R; y++){
        let x=0;
        while (x<C){
          const h = state.grid[y*C + x];
          if (h === -1){ x++; continue; }
          let run = 1;
          while (x+run < C && state.grid[y*C + (x+run)] === h) run++;
          ctx.fillStyle = state.palette[h];
          ctx.fillRect(x*cs, y*cs, run*cs, cs);
          x += run;
        }
      }
    }
    function caRender(dt){
      state.lastHueBase = (state.lastHueBase + 60*dt) % 360;
      const baseRate = 4 + Math.floor(12 * mapIntensity());
      const dwellBoost = dwellMs>600 ? 4 : 0;
      const toSpawn = baseRate + dwellBoost;
      caEmitSand(mouse.x, mouse.y, toSpawn + Math.floor(mouse.speed/250));
      const windBias = clamp(mouse.vx/1000, -1, 1);
      const subSteps = 2;
      for (let s=0; s<subSteps; s++) caStep(windBias);
      caDraw();
      if (dwellJustCrossed(700)) playPing(700,0.12,0.05);
    }
    return { caSandReset, caSandOnResize, caRender };
  })();
  function caSandOnResize(){ SAND_CELL.caSandOnResize(); } (function(){ SAND_CELL.caSandReset(); })();

  /* =========================
     ESSAIM MAGNÉTIQUE
     ========================= */
  const MAG = {
    pins: [],
    t: 0
  };

  function magnetTargetCount(){ return Math.floor(160 + 500 * sizeNorm()); }
  function makePin(){ return { x: Math.random()*W, y: Math.random()*H, vx: 0, vy: 0 }; }
  function magnetResize(){ MAG.pins.forEach(p=>{ p.x = clamp(p.x,0,W); p.y = clamp(p.y,0,H); }); }
  function ensureMagnetPins(){
    const target = magnetTargetCount();
    const cur = MAG.pins.length;
    if (cur < target){ for (let i=0;i<target-cur;i++) MAG.pins.push(makePin()); }
    else if (cur > target){ MAG.pins.splice(0, cur-target); }
  }

  function renderMagnet(dt){
    ensureMagnetPins();
    clearToBg(false);

    const sN = sizeNorm();
    const intensity = mapIntensity();
    const sep = 28 + 140*sN;
    const soft = 120;
    const polarity = (dwellMs>600) ? -1 : 1;

    const ang = Math.atan2(mouse.vy||0.0001, mouse.vx||0.0001);
    const axis = (mouse.speed>25) ? ang : -Math.PI/2;
    const hx = Math.cos(axis), hy = Math.sin(axis);

    const pxN = mouse.x + hx*sep*0.5, pyN = mouse.y + hy*sep*0.5;
    const pxS = mouse.x - hx*sep*0.5, pyS = mouse.y - hy*sep*0.5;
    const q = 1 * polarity;

    ctx.globalCompositeOperation='screen';
    const gN = ctx.createRadialGradient(pxN,pyN,sep*0.1, pxN,pyN, sep*0.9);
    gN.addColorStop(0, 'hsla(0,100%,60%,0.45)');
    gN.addColorStop(1, 'hsla(0,100%,60%,0)');
    ctx.fillStyle=gN; ctx.beginPath(); ctx.arc(pxN,pyN,sep*0.9,0,Math.PI*2); ctx.fill();

    const gS = ctx.createRadialGradient(pxS,pyS,sep*0.1, pxS,pyS, sep*0.9);
    gS.addColorStop(0, 'hsla(210,100%,60%,0.45)');
    gS.addColorStop(1, 'hsla(210,100%,60%,0)');
    ctx.fillStyle=gS; ctx.beginPath(); ctx.arc(pxS,pyS,sep*0.9,0,Math.PI*2); ctx.fill();

    const lines = 10;
    ctx.strokeStyle = `hsla(${polarity>0?30:200},100%,75%,${0.18+0.28*intensity})`;
    ctx.lineWidth = 1 + 1.8*sN;
    ctx.beginPath();
    for (let i=0;i<lines;i++){
      const a = (i/lines)*Math.PI*2 + MAG.t*0.4;
      const r1 = sep*0.25, r2 = sep*(1.0 + 0.2*Math.sin(MAG.t*0.8+i));
      const x1 = mouse.x + Math.cos(a)*r1, y1 = mouse.y + Math.sin(a)*r1;
      const cx = mouse.x + Math.cos(a+Math.PI/2)*r2*0.5;
      const cy = mouse.y + Math.sin(a+Math.PI/2)*r2*0.5;
      ctx.moveTo(pxN,pyN); ctx.quadraticCurveTo(cx,cy,pxS,pyS);
      ctx.moveTo(x1,y1);   ctx.quadraticCurveTo(cx,cy,pxS,pyS);
    }
    ctx.stroke();

    const baseK = 240 + 560*intensity;
    const boost  = mouse.down ? 1.5 : 1.0;
    const swirl  = 0.6 + 2.2*intensity;
    const windX = mouse.vx * 0.0006, windY = mouse.vy * 0.00045;

    ctx.globalCompositeOperation='lighter';
    ctx.lineCap='round';
    const segLen = 8 + 20*sN;
    const maxSpeed = 14 + 50*intensity;
    const damp = 0.965 - 0.08*intensity + (mouse.down?-0.02:0);

    for (let i=0;i<MAG.pins.length;i++){
      const p = MAG.pins[i];

      let ax=0, ay=0;

      let dx = pxN - p.x, dy = pyN - p.y;
      let r2 = dx*dx + dy*dy + soft;
      let invR = 1/Math.sqrt(r2);
      let invR3 = invR*invR*invR;
      ax +=  baseK*boost * (+q) * dx * invR3;
      ay +=  baseK*boost * (+q) * dy * invR3;

      dx = pxS - p.x; dy = pyS - p.y;
      r2 = dx*dx + dy*dy + soft;
      invR = 1/Math.sqrt(r2);
      invR3 = invR*invR*invR;
      ax +=  baseK*boost * (-q) * dx * invR3;
      ay +=  baseK*boost * (-q) * dy * invR3;

      const cx = mouse.x - p.x, cy = mouse.y - p.y;
      const c2 = cx*cx + cy*cy + soft;
      const cInv = 1/Math.sqrt(c2);
      ax += swirl * (-cy*cInv) * 0.35;
      ay += swirl * ( cx*cInv) * 0.35;

      ax += windX + (Math.random()-0.5)*0.0005;
      ay += windY + (Math.random()-0.5)*0.0005;

      p.vx = (p.vx + ax*dt*600) * damp;
      p.vy = (p.vy + ay*dt*600) * damp;
      const sp = Math.hypot(p.vx,p.vy);
      if (sp>maxSpeed){ const s=maxSpeed/sp; p.vx*=s; p.vy*=s; }

      const px0 = p.x - p.vx*segLen*0.04;
      const py0 = p.y - p.vy*segLen*0.04;
      const spN = clamp(sp/(maxSpeed||1),0,1);
      const hue = polarity>0 ? (10 + spN*100) % 360 : (200 + spN*100) % 360;
      ctx.strokeStyle = `hsla(${hue},100%,70%,${0.30 + 0.55*spN})`;
      ctx.lineWidth = 0.7 + 2.0*sN*spN;
      ctx.beginPath();
      ctx.moveTo(px0,py0); ctx.lineTo(p.x,p.y); ctx.stroke();

      p.x += p.vx; p.y += p.vy;
      if (p.x < -5) p.x = W+5; else if (p.x > W+5) p.x = -5;
      if (p.y < -5) p.y = H+5; else if (p.y > H+5) p.y = -5;
    }

    MAG.t += dt;
  }

  /* =========================
     VITRAIL + glassy chimes
     ========================= */
  let glassAudio = null;
  let glassGlobalCooldown = 0;
  function glassEnsureAudio(){
    if (menuOpen) return;
    ensureAC();
    if (!glassAudio){
      const master = ac.createGain();
      master.gain.value = 0.22 * currentSfxGain();
      master.connect(ac.destination);
      glassAudio = { master };
    } else {
      glassAudio.master.gain.value = 0.22 * currentSfxGain();
    }
  }
  function glassPling(hz=900, panPos=0, vel=0.7){
    if (menuOpen) return;
    glassEnsureAudio();
    const masterScale = currentSfxGain();
    if (masterScale <= 0) return;

    const t = ac.currentTime;
    const o1 = ac.createOscillator(); o1.type='sine'; o1.frequency.setValueAtTime(hz, t);
    const o2 = ac.createOscillator(); o2.type='triangle'; o2.frequency.setValueAtTime(hz*2, t);
    const mod = ac.createOscillator(); mod.type='sine'; mod.frequency.value = 6 + 10*Math.random();
    const modGain = ac.createGain(); modGain.gain.value = 12 + 18*vel;
    mod.connect(modGain);
    modGain.connect(o1.detune);
    modGain.connect(o2.detune);

    const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 600; hp.Q.value = 0.7;
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = hz; bp.Q.value = 6;
    const sh = ac.createWaveShaper();
    sh.curve = new Float32Array([ -1, -0.2, 0, 0.2, 1 ]);

    const g  = ac.createGain();
    const p  = (ac.createStereoPanner ? ac.createStereoPanner() : null);
    const peak = 0.6 * vel * masterScale;

    const A=0.004, D=0.18, R=0.35;
    const t0=t;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(peak, t0+A);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak*0.05), t0+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+A+D+R);

    o1.connect(hp); o2.connect(hp);
    hp.connect(bp); bp.connect(sh); sh.connect(g);
    if (p) { g.connect(p); p.pan.value = clamp(panPos,-1,1); p.connect(glassAudio.master); }
    else { g.connect(glassAudio.master); }

    o1.start(t0); o2.start(t0); mod.start(t0);
    o1.stop(t0+A+D+R+0.05); o2.stop(t0+A+D+R+0.05); mod.stop(t0+A+D+R+0.05);
  }

  let glassCells=[], glassCols=20, glassRows=12;
  function resizeGlass(){
    glassCells=[];
    const cw=W/glassCols, ch=H/glassRows;
    for(let y=0;y<glassRows;y++){
      for(let x=0;x<glassCols;x++){
        glassCells.push({
          x:x*cw, y:y*ch, w:cw, h:ch,
          hue:Math.random()*360,
          pop:0, vpop:0, prevPop:0, cool:0
        });
      }
    }
  }
  resizeGlass();

  function renderGlass(dt){
    clearToBg(false);

    const intensity = mapIntensity();
    const sN = sizeNorm();

    const radius = 240 + 220*sN;
    const invR = 1 / Math.max(1, radius);

    const stiffness = 6 + 20*intensity;
    const damping   = Math.pow(0.32 + 0.58*(1-intensity), dt*60);

    const maxScaleBoost = 0.18 + 0.22*sN;
    const maxLightBoost = 78 * (0.5 + 0.8*intensity);

    const isLight = document.body.classList.contains('light');
    const baseL = isLight ? 86 : 14;

    glassGlobalCooldown = Math.max(0, glassGlobalCooldown - dt);

    ctx.globalCompositeOperation='source-over';
    for (let i=0;i<glassCells.length;i++){
      const c = glassCells[i];
      const cx = c.x + c.w/2;
      const cy = c.y + c.h/2;

      const dx = mouse.x - cx;
      const dy = mouse.y - cy;
      const d  = Math.hypot(dx,dy);
      const n  = clamp(1 - d*invR, 0, 1);

      const target = Math.pow(n, 1.2 + 1.2*intensity) * (mouse.down ? 1.15 : 1.0);

      const accel = (target - c.pop) * stiffness;
      c.vpop += accel * dt;
      c.vpop *= (1 - damping);
      c.pop  += c.vpop;

      c.cool = Math.max(0, c.cool - dt);
      const dPop = c.pop - c.prevPop;
      const trigger = (c.pop > 0.38) && (dPop > 0.02 + 0.04*intensity) && (c.cool===0) && (glassGlobalCooldown===0);
      if (trigger){
        const hueN = ((c.hue%360)+360)/360;
        const hz = 700 + hueN*1000;
        const pan = (cx/W)*2 - 1;
        const vel = clamp(0.4 + 0.6*(c.pop) + 0.2*clamp(mouse.speed/1400,0,1), 0.2, 1.0);
        glassPling(hz, pan, vel);
        c.cool = 0.08 + 0.08*(1-intensity);
        glassGlobalCooldown = 0.02;
      }
      c.prevPop = c.pop;

      const scale = 1 + maxScaleBoost * c.pop;
      const lift  = 2 + 10 * c.pop;
      const L = baseL + maxLightBoost * c.pop;
      const sat = 85;

      ctx.globalCompositeOperation='multiply';
      const sg = ctx.createRadialGradient(cx, cy+lift, Math.min(c.w,c.h)*0.15, cx, cy+lift, Math.max(c.w,c.h)*0.75);
      sg.addColorStop(0, 'rgba(0,0,0,0.10)');
      sg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = sg;
      const sw = c.w*scale, sh = c.h*scale;
      ctx.fillRect(cx - sw/2, cy - sh/2 + lift, sw, sh);

      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle = `hsla(${c.hue},85%,${L}%,0.96)`;
      ctx.fillRect(cx - sw/2, cy - sh/2, sw, sh);

      ctx.globalCompositeOperation='screen';
      ctx.strokeStyle = `hsla(${(c.hue+40)%360},90%,${Math.min(92, L+10)}%,${0.35 + 0.35*c.pop})`;
      ctx.lineWidth = Math.max(1, 1.2 + 2.2*c.pop);
      ctx.strokeRect(cx - sw/2+0.7, cy - sh/2+0.7, sw-1.4, sh-1.4);

      if (c.pop > 0.55){
        const r = Math.min(c.w,c.h)*0.18*scale;
        const glx = cx - sw*0.28, gly = cy - sh*0.28;
        const gl = ctx.createRadialGradient(glx, gly, r*0.25, glx, gly, r);
        gl.addColorStop(0, 'rgba(255,255,255,0.28)');
        gl.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gl;
        ctx.beginPath(); ctx.arc(glx, gly, r, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  /* =========================
     STREAMERS — Rubans de Soie
     Hundreds of small saturated ribbons + natural wind/rustle + GAZE WOOSH
     ========================= */

  const RIB2 = { list: [], t: 0 };

  const RCFG = {
    segsMin: 5,
    segsMax: 8,
    widthMin: 3.0,
    widthMax: 7.0,
    gravity: 380,          // px/s^2
    airDrag: 0.0022,
    friction: 0.996,
    restLen: 12,           // base segment length
    swayAmp: 22,
    swayHzMin: 0.15,
    swayHzMax: 0.35,
    windAmp: 36,
    gazeRBase: 95,
    gazeDamp: 0.77,
    gazePull: 16,
    respawnPad: 60
  };

  function ribbonsInit(){
    RIB2.list.length = 0;
    const n = Math.floor(140 + 260 * sizeNorm()); // hundreds; scales with Taille
    for (let i=0;i<n;i++) RIB2.list.push(spawnRibbonSmall());
  }

  function ribbonsResize(){
    for (const r of RIB2.list){
      for (const p of r.pts){
        p.x = clamp(p.x, -50, W+50);
        p.y = clamp(p.y, -H-100, H+100);
      }
    }
  }

  function spawnRibbonSmall(){
    const segs = Math.floor(RCFG.segsMin + Math.random()*(RCFG.segsMax-RCFG.segsMin+1));
    const scl  = 0.85 + 0.7*sizeNorm();
    const rest = RCFG.restLen * scl;
    const x0   = Math.random()*W;
    const y0   = -Math.random()*H*0.5 - 20;

    const pts = [];
    for (let i=0;i<segs;i++){
      const x = x0 + (Math.random()-0.5)*2;
      const y = y0 - i*rest*0.92;
      pts.push({ x, y, px:x, py:y });
    }
    return {
      pts,
      rest,
      width: lerp(RCFG.widthMin, RCFG.widthMax, Math.random()) * (0.8 + 0.6*sizeNorm()),
      hue: (Math.random()*360)|0,
      sat: 92 + Math.random()*6,
      light: 52 + Math.random()*6,
      swayHz: lerp(RCFG.swayHzMin, RCFG.swayHzMax, Math.random()),
      swayPhase: Math.random()*Math.PI*2,
      swayAmp: RCFG.swayAmp * (0.7 + 0.8*Math.random()),
      wind: (Math.random()-0.5)*RCFG.windAmp,
      _sndT: 0 // per-ribbon sound cooldown timestamp
    };
  }

  function stepRibbonSmall(r, dt){
    const pts = r.pts, N = pts.length;
    const g   = RCFG.gravity;
    const fr  = Math.pow(RCFG.friction, dt*60);
    const intensity = mapIntensity();

    const t = RIB2.t + r.swayPhase;
    const sway = Math.sin(t*2*Math.PI*r.swayHz) * r.swayAmp * (0.7 + 0.9*intensity);

    const gazeR  = (RCFG.gazeRBase * (0.8 + 0.7*sizeNorm())) * (0.8 + 0.9*intensity);
    const gazeR2 = gazeR*gazeR;

    for (let i=0;i<N;i++){
      const p = pts[i];
      let vx = (p.x - p.px);
      let vy = (p.y - p.py);

      const w = (1 - i/(N-1));
      vy += g * dt*dt;
      vx += (sway * w + r.wind*0.25) * dt;

      const sp2 = vx*vx + vy*vy;
      if (sp2 > 0){
        const drag = 1 - Math.min(0.4, RCFG.airDrag * sp2);
        vx *= drag; vy *= drag;
      }

      const dx = mouse.x - p.x, dy = mouse.y - p.y, d2 = dx*dx + dy*dy;
      if (d2 < gazeR2){
        const n = 1 - (d2 / gazeR2);
        vx *= RCFG.gazeDamp; vy *= RCFG.gazeDamp;
        vx += dx * (RCFG.gazePull * n) * dt*dt;
        vy += dy * (RCFG.gazePull * n) * dt*dt;
      }

      p.px = p.x; p.py = p.y;
      p.x += vx * fr; p.y += vy * fr;
    }

    for (let it=0; it<2; it++){
      for (let i=0;i<N-1;i++){
        const a = pts[i], b = pts[i+1];
        let dx = b.x - a.x, dy = b.y - a.y;
        let d = Math.hypot(dx,dy) || 1;
        const diff = (d - r.rest) / d;
        const corr = 0.5 * diff;
        a.x += dx * corr; a.y += dy * corr;
        b.x -= dx * corr; b.y -= dy * corr;
      }
    }

    let below = 0;
    for (let i=0;i<N;i++){ if (pts[i].y > H + RCFG.respawnPad) below++; }
    if (below === N){
      const x0 = Math.random()*W, y0 = -20 - Math.random()*H*0.4;
      for (let i=0;i<N;i++){
        const x = x0 + (Math.random()-0.5)*2;
        const y = y0 - i*r.rest*0.9;
        pts[i].x=x; pts[i].y=y; pts[i].px=x; pts[i].py=y;
      }
      r.swayPhase = Math.random()*Math.PI*2;
      r.wind = (Math.random()-0.5)*RCFG.windAmp;
      r._sndT = performance.now();
    }
  }

  function drawRibbonSmall(r){
    const pts = r.pts, N = r.pts.length;
    if (N<2) return;

    const hue = r.hue, sat = r.sat|0, L = r.light|0;
    const w   = r.width;

    // saturated body
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${L}%, 0.92)`;
    ctx.lineWidth   = w;
    ctx.lineCap     = 'round';
    ctx.lineJoin    = 'round';
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i=1;i<N;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();

    // soft highlight (subtle, not white bars)
    ctx.globalCompositeOperation = 'lighter';
    ctx.strokeStyle = `hsla(${(hue+30)%360}, 95%, 70%, 0.25)`;
    ctx.lineWidth   = Math.max(1, w*0.35);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i=1;i<N;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();
  }

  // --- Sound system -------------------------------------------------------

  const RIBSND = {
    inited: false,
    master: null,
    // one shared noise source feeding two chains:
    // 1) ambient wind, 2) gaze-woosh
    wind:  { gain: null, bp: null, hp: null, target: 0, cur: 0 },
    woosh: { gain: null, bp: null, hp: null, target: 0, cur: 0 },
    src: null,
    rustleLimiter: { active: 0, max: 6 },
    lastDwellBoost: 0,
    cooldownMs: 90
  };

  function ribbonsSoundEnsure(){
    if (menuOpen) return;
    ensureAC();
    if (RIBSND.inited){
      RIBSND.master.gain.value = 0.28 * currentSfxGain();
      return;
    }

    // Master
    const master = ac.createGain();
    master.gain.value = 0.28 * currentSfxGain();
    master.connect(ac.destination);
    RIBSND.master = master;

    // Looping noise buffer
    const noiseBuf = ac.createBuffer(1, ac.sampleRate * 2, ac.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i] = (Math.random()*2 - 1) * 0.6;
    const src = ac.createBufferSource(); src.buffer = noiseBuf; src.loop = true;
    RIBSND.src = src;

    // Chain 1: ambient wind
    const hp1 = ac.createBiquadFilter(); hp1.type='highpass'; hp1.frequency.value = 120; hp1.Q.value = 0.7;
    const bp1 = ac.createBiquadFilter(); bp1.type='bandpass'; bp1.frequency.value = 900; bp1.Q.value  = 0.8;
    const g1  = ac.createGain(); g1.gain.value = 0.0;

    // Chain 2: gaze-woosh (brighter, more “air”)
    const hp2 = ac.createBiquadFilter(); hp2.type='highpass'; hp2.frequency.value = 320; hp2.Q.value = 0.8;
    const bp2 = ac.createBiquadFilter(); bp2.type='bandpass'; bp2.frequency.value = 1400; bp2.Q.value = 0.9;
    const g2  = ac.createGain(); g2.gain.value = 0.0;

    // Connect both chains from the same noise source
    src.connect(hp1).connect(bp1).connect(g1).connect(master);
    src.connect(hp2).connect(bp2).connect(g2).connect(master);
    src.start();

    RIBSND.wind  = { gain:g1, bp:bp1, hp:hp1, target:0.0, cur:0.0 };
    RIBSND.woosh = { gain:g2, bp:bp2, hp:hp2, target:0.0, cur:0.0 };
    RIBSND.inited = true;
  }

  // brief rustle burst on strong local bend / speed (kept subtle)
  function ribbonsPlayRustle(screenX=0.5, vel=0.6){
    if (menuOpen) return;
    if (RIBSND.rustleLimiter.active >= RIBSND.rustleLimiter.max) return;
    const mscale = currentSfxGain();
    if (mscale <= 0) return;

    ribbonsSoundEnsure();

    const t = ac.currentTime;
    const dur = 0.18 + 0.10*Math.random();
    const frames = Math.max(1, Math.floor(ac.sampleRate * dur));
    const buf = ac.createBuffer(1, frames, ac.sampleRate);
    const ch = buf.getChannelData(0);
    for (let i=0;i<frames;i++){
      const n = (Math.random()*2-1);
      ch[i] = (i>0 ? 0.98*ch[i-1] + 0.02*n : n) * 0.9;
    }
    const src = ac.createBufferSource(); src.buffer = buf;

    const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 800 + 500*Math.random();
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.Q.value = 1.2;
    const g  = ac.createGain();
    const pan = (ac.createStereoPanner ? ac.createStereoPanner() : null);

    const peak = 0.08 + 0.22*vel;            // dialed down so woosh leads
    const A=0.008, D=0.08, R=0.16;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(peak*mscale, t+A);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak*0.25*mscale), t+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t+A+D+R);

    const f0 = 1500 + 700*Math.random();
    bp.frequency.setValueAtTime(f0, t);
    bp.frequency.linearRampToValueAtTime(f0 * (0.8 + 0.4*Math.random()), t + dur*0.6);

    src.connect(hp).connect(bp).connect(g);
    if (pan) { g.connect(pan); pan.pan.value = clamp(screenX*2-1, -1, 1); pan.connect(RIBSND.master); }
    else { g.connect(RIBSND.master); }

    src.start(t);
    src.stop(t + dur + 0.05);

    RIBSND.rustleLimiter.active++;
    src.onended = ()=>{ RIBSND.rustleLimiter.active = Math.max(0, RIBSND.rustleLimiter.active - 1); };
  }

  function ribbonsWindSet(target){
    if (!RIBSND.inited) return;
    RIBSND.wind.target = clamp(target, 0, 1);
  }
  function ribbonsWooshSet(target){
    if (!RIBSND.inited) return;
    RIBSND.woosh.target = clamp(target, 0, 1);
  }
  function ribbonsSoundTick(dt){
    if (!RIBSND.inited) return;

    // Smooth follow (same for wind & woosh)
    const follow = (cur, tgt) => lerp(cur, tgt, 1 - Math.pow(0.12, dt*60));

    // Ambient wind (field activity)
    RIBSND.wind.cur = follow(RIBSND.wind.cur, RIBSND.wind.target);
    RIBSND.wind.gain.gain.setTargetAtTime(0.08 * RIBSND.wind.cur * currentSfxGain(), ac.currentTime, 0.05);
    const windF = 850 + 500*RIBSND.wind.cur;
    RIBSND.wind.bp.frequency.setTargetAtTime(windF, ac.currentTime, 0.12);

    // Gaze woosh (captured ribbons)
    RIBSND.woosh.cur = follow(RIBSND.woosh.cur, RIBSND.woosh.target);
    // louder & brighter than wind; quick attack, slower release feel
    RIBSND.woosh.gain.gain.setTargetAtTime(0.16 * RIBSND.woosh.cur * currentSfxGain(), ac.currentTime, 0.03);
    const wooshF = 1200 + 1800*RIBSND.woosh.cur;
    RIBSND.woosh.bp.frequency.setTargetAtTime(wooshF, ac.currentTime, 0.06);
    RIBSND.woosh.hp.frequency.setTargetAtTime(300 + 400*RIBSND.woosh.cur, ac.currentTime, 0.06);
  }

  // --- Render loop (visuals + sound hooks) -------------------------------

  let ribDwellPulse = 1.0;

  function renderStreamers(dt){
    // background trail respecting theme
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = document.body.classList.contains('light')
      ? `rgba(255,255,255,${mapTrail()})`
      : `rgba(0,0,0,${mapTrail()})`;
    ctx.fillRect(0,0,W,H);

    RIB2.t += dt * (0.6 + 0.8*mapIntensity());
    ribbonsSoundEnsure();

    // (Removed beep) — gentle visual pulse only
    if (dwellJustCrossed(750)){
      ribDwellPulse = 1.08;
      if (RIBSND.inited) RIBSND.lastDwellBoost = 0.6; // nudges ambient wind
    }
    ribDwellPulse = lerp(ribDwellPulse, 1.0, 0.06);

    let activity = 0;
    let captured = 0;

    const nowMs = performance.now();
    const gazeR  = (RCFG.gazeRBase * (0.8 + 0.7*sizeNorm())) * (0.8 + 0.9*mapIntensity());
    const gazeR2 = gazeR * gazeR;

    for (const r of RIB2.list){
      const orig = r.swayAmp;
      r.swayAmp = orig * ribDwellPulse;

      // head position before step (for speed measure)
      const h0 = r.pts[0]; const hx0 = h0.x, hy0 = h0.y;

      stepRibbonSmall(r, dt);
      drawRibbonSmall(r);

      // motion & curvature
      const hx1 = r.pts[0].x, hy1 = r.pts[0].y;
      const hvx = (hx1 - hx0) / (dt || 1/60);
      const hvy = (hy1 - hy0) / (dt || 1/60);
      const hsp = Math.hypot(hvx, hvy);

      const mid = (r.pts.length/2 | 0);
      const a = r.pts[Math.max(0, mid-1)], b = r.pts[mid], c = r.pts[Math.min(r.pts.length-1, mid+1)];
      const abx = b.x - a.x, aby = b.y - a.y;
      const bcx = c.x - b.x, bcy = c.y - b.y;
      const curv = Math.abs(abx*bcy - aby*bcx) / ((Math.hypot(abx,aby)*Math.hypot(bcx,bcy)) || 1);

      activity += clamp(hsp/300, 0, 1) * 0.4 + clamp(curv*3, 0, 1) * 0.6;

      // captured by gaze? (use middle point)
      const dx = mouse.x - b.x, dy = mouse.y - b.y, d2 = dx*dx + dy*dy;
      const inGaze = d2 < gazeR2;
      if (inGaze) captured++;

      // optional subtle rustle (kept low, not beepy)
      if (RIBSND.inited && (nowMs - r._sndT >= RIBSND.cooldownMs)){
        const bendHit = curv > 0.22;
        const speedHit = hsp > 260;
        if (bendHit || speedHit || (inGaze && curv>0.12)){
          const screenX = clamp(b.x / W, 0, 1);
          const vel = clamp( (hsp/700) + (curv*0.6), 0.12, 0.8 );
          ribbonsPlayRustle(screenX, vel);
          r._sndT = nowMs;
        }
      }

      r.swayAmp = orig;
    }

    // Ambient wind loudness from global activity
    const field = clamp(activity / Math.max(1, RIB2.list.length), 0, 1);
    let windTarget = 0.15 + field * (0.75 * (0.4 + 0.8*mapIntensity()));
    if (RIBSND.lastDwellBoost > 0){
      windTarget += RIBSND.lastDwellBoost * 0.15;
      RIBSND.lastDwellBoost = Math.max(0, RIBSND.lastDwellBoost - dt*1.8);
    }
    ribbonsWindSet(windTarget);

    // GAZE WOOSH: grows with #captured ribbons (nonlinear for feel)
    const capNormBase = 40 * (0.7 + 0.6*sizeNorm()); // how many ribbons to “fill” woosh
    const wooshTarget = Math.sqrt( clamp(captured / Math.max(1, capNormBase), 0, 1) );
    ribbonsWooshSet(wooshTarget);

    ribbonsSoundTick(dt);
  }

  // Initialize ribbons
  ribbonsInit();




  /* =========================
     HARPE LASER (unchanged)
     ========================= */
  let laserCols=11;
  const laserGap = ()=> W / (laserCols + 1);
  let harpPalette = Array.from({ length: laserCols }, (_, i) => (i * (360 / laserCols)) | 0);
  let harpBeams=[], beamDwell=[], beamCooldown=[], beamHold=[], beamVoice=[];
  function initLaserArrays(){
    harpPalette = Array.from({length:laserCols},(_,i)=>(i*(360/laserCols))|0);
    harpBeams = Array.from({length:laserCols},(_,i)=>({energy:0,rippleT:0,rippleY:H/2,hue:harpPalette[i]}));
    beamDwell=new Array(laserCols).fill(0);
    beamCooldown=new Array(laserCols).fill(0);
    beamHold=new Array(laserCols).fill(false);
    beamVoice=new Array(laserCols).fill(null);
  }
  initLaserArrays();

  function harpEnsureAudio(){
    if (menuOpen) return;
    ensureAC();
    if (!harpEnsureAudio.master){
      const master=ac.createGain(); master.gain.value = (parseInt(sfxVol.value,10)||50)/100 * (muteSFX.checked?0:1) * 0.24;
      const delay = ac.createDelay(); delay.delayTime.value=0.18;
      const fb = ac.createGain(); fb.gain.value=0.38;
      delay.connect(fb).connect(delay);
      delay.connect(master);
      master.connect(ac.destination);
      harpEnsureAudio.master=master; harpEnsureAudio.delay=delay;
    }
  }
  function harpNote(i){
    const pent=[0,2,4,7,9]; const base=220;
    const si=i%pent.length, oct=Math.floor(i/pent.length);
    return base * Math.pow(2, (pent[si] + 12*oct)/12);
  }
  const sparks = [];
  function harpPluck(i, y, velocity=1){
    if (menuOpen) return;
    harpEnsureAudio();
    const f=harpNote(i), det=(Math.random()*14-7), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=det;
    const g=ac.createGain(); const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2200+1800*velocity;
    const A=0.005, D=0.08, S=0.25*velocity, R=0.35+0.25*(1-velocity);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(0.9*velocity, t+A);
    g.gain.exponentialRampToValueAtTime(Math.max(S,0.08), t+A+D);
    g.gain.exponentialRampToValueAtTime(0.0001, t+A+D+R);
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t); o1.stop(t+A+D+R+0.02); o2.stop(t+A+D+R+0.02);
    const b=harpBeams[i]; b.energy=Math.min(1, b.energy + 0.6*velocity); b.rippleT=0; b.rippleY=y;
    for(let k=0;k<12;k++){
      sparks.push({x:(i+1)*laserGap(), y, vx:(Math.random()-0.5)*2.4, vy:(Math.random()-0.5)*2.4, life:26+Math.random()*18, h:(b.hue+10+Math.random()*40)%360});
    }
  }
  function startVoice(i){
    if (menuOpen) return;
    harpEnsureAudio();
    if (beamVoice[i]) return;
    const f=harpNote(i), t=ac.currentTime;
    const o1=ac.createOscillator(); o1.type='sine'; o1.frequency.value=f;
    const o2=ac.createOscillator(); o2.type='triangle'; o2.frequency.value=f; o2.detune.value=-6;
    const g=ac.createGain(); g.gain.value=0.0001;
    const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1400;
    o1.connect(g); o2.connect(g); g.connect(lp); lp.connect(harpEnsureAudio.delay); lp.connect(harpEnsureAudio.master);
    o1.start(t); o2.start(t);
    g.gain.linearRampToValueAtTime(0.18 + 0.10*mapIntensity(), t + 0.08);
    beamVoice[i]={o1,o2,g,lp,baseF:f,t0:t};
  }
  function stopVoice(i){
    const v=beamVoice[i]; if(!v||!ac){ beamVoice[i]=null; return; }
    const t=ac.currentTime;
    try{
      v.g.gain.cancelScheduledValues(t);
      v.g.gain.setValueAtTime(v.g.gain.value, t);
      v.g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
      v.o1.stop(t+0.22); v.o2.stop(t+0.22);
    }catch(e){}
    beamVoice[i]=null;
  }
  function updateVoice(i){
    const v=beamVoice[i]; if(!v||!ac) return;
    const t=ac.currentTime, e=harpBeams[i].energy;
    const vib=0.25+0.35*mapIntensity(), amt=7+10*mapIntensity(), phase=(t-v.t0);
    const mod=Math.sin(phase*2*Math.PI*vib)*amt;
    v.o1.frequency.setValueAtTime(v.baseF,t); v.o2.frequency.setValueAtTime(v.baseF,t);
    v.o2.detune.setValueAtTime(mod,t);
    v.lp.frequency.setValueAtTime(1200 + 1200*e, t);
    const targetGain = 0.14 + 0.10*mapIntensity();
    v.g.gain.setTargetAtTime(targetGain, t, 0.08);
  }
  function resizeLaser(){
    if (harpBeams.length !== laserCols) initLaserArrays();
    for (let i=0;i<harpBeams.length;i++) harpBeams[i].rippleY = Math.min(harpBeams[i].rippleY, H);
  }
  function renderLaser(dt){
    clearToBg(false);
    const gap=laserGap(); const lineBase=10 + mapSize()*0.14;
    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap; const nearRadius=34 + lineBase*1.7;
      const near = Math.abs(mouse.x - x) < nearRadius;
      const stationary = mouse.speed < 60;
      const velocity = clamp(mouse.speed/1400, 0.05, 1);
      if (near && velocity>0.25){
        harpPluck(i, mouse.y, velocity);
        lastMoveT = performance.now();
        beamCooldown[i]=160; beamHold[i]=false; stopVoice(i);
      }
      beamCooldown[i]=Math.max(0, beamCooldown[i]-dt*1000);
      if (near){
        beamDwell[i]+=dt*1000;
        const dwellThreshold=450;
        if (!beamHold[i] && stationary && beamDwell[i]>=dwellThreshold && beamCooldown[i]===0){
          const vel=0.72+0.28*mapIntensity();
          harpPluck(i, mouse.y, vel); beamHold[i]=true; startVoice(i);
        }
      } else {
        if (beamHold[i]) stopVoice(i);
        beamDwell[i]=0; beamHold[i]=false;
      }
    }

    for (let i=0;i<laserCols;i++){
      const x=(i+1)*gap, b=harpBeams[i];
      const decay = beamHold[i] ? 0.96 : 0.82;
      b.energy *= Math.pow(decay, dt*60);
      b.rippleT += dt;
      if (beamHold[i]){ b.energy = lerp(b.energy, 0.85, 0.12); updateVoice(i); }

      ctx.globalCompositeOperation='screen';
      const e=b.energy; const hue=(b.hue + Math.sin((performance.now()*0.001+i)*0.7)*6)%360;

      const grad=ctx.createLinearGradient(x,0,x,H);
      grad.addColorStop(0.0, `hsla(${(hue+6)%360},100%,55%,${0.35+0.20*e})`);
      grad.addColorStop(0.5, `hsla(${hue},100%,52%,${0.65+0.30*e})`);
      grad.addColorStop(1.0, `hsla(${(hue+12)%360},100%,55%,${0.35+0.20*e})`);
      const w=Math.max(2, lineBase * (beamHold[i] ? 1.8 : (1 + 1.3*e)));
      ctx.strokeStyle=grad; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      ctx.strokeStyle=`hsla(${hue},100%,50%,${0.22+0.25*e})`; ctx.lineWidth=w*1.9;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();

      const waveAmp=(10+mapSize()*0.028)*e*(beamHold[i]?0.35:1.0);
      const waveFreq=0.02+0.035*mapIntensity();
      ctx.strokeStyle=`hsla(${(hue+200)%360},100%,80%,${0.55+0.35*e})`;
      ctx.lineWidth=Math.max(1.5, w*0.22);
      ctx.beginPath();
      for (let y=0;y<=H;y+=7){
        const off = Math.sin((y + performance.now()*0.6)*waveFreq)*waveAmp;
        ctx.lineTo(x+off, y);
      }
      ctx.stroke();

      if (e>0.02){
        const speed=480 + 420*mapIntensity();
        const r=Math.max(10,(b.rippleT*speed) % (H*1.2));
        ctx.strokeStyle=`hsla(${(hue+60)%360},100%,70%,${(beamHold[i]?0.28:0.42)*e})`;
        ctx.lineWidth=2.2;
        ctx.beginPath();
        ctx.arc(x, b.rippleY, r*(0.12+0.12*e), 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  /* =========================
     BUBBLE-POP (unchanged)
     ========================= */
  const bubbles = Array.from({length:70},()=>({x:Math.random()*W,y:H+Math.random()*200,r:8+Math.random()*22,vx:(Math.random()-0.5)*0.2,vy:-(0.4+Math.random()*0.6),charge:0,h:Math.random()*360}));
  function renderBubblePop(dt){
    clearToBg(false);
    ctx.globalCompositeOperation='lighter';
    for(let i=bubbles.length-1;i>=0;i--){
      const b=bubbles[i];
      if (b.cool===undefined) b.cool=0;
      if (b.phase===undefined) b.phase=0;
      if (b.maxCharge===undefined) b.maxCharge=2.0;
      const d=Math.hypot(mouse.x-b.x, mouse.y-b.y);
      const near=clamp(1 - d/160, 0, 1);
      const baseGrow=(near*2.2 - 0.18)*dt;
      const dwellBoost=(dwellMs>600 ? 0.8*near*dt : 0);
      b.charge = clamp((b.charge||0) + baseGrow + dwellBoost, 0, b.maxCharge);
      b.phase += dt*(0.8 + b.charge*0.6);
      const pulse=1 + 0.04*Math.sin(b.phase*2.7);
      const growth=1 + Math.pow(b.charge,1.25)*2.6;
      const R=b.r*growth*pulse;
      const g=ctx.createRadialGradient(b.x,b.y,R*0.4,b.x,b.y,R*1.2);
      g.addColorStop(0,`hsla(${b.h},90%,70%,${0.10+0.25*near})`);
      g.addColorStop(1,`hsla(${(b.h+60)%360},90%,45%,0)`);
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=`hsla(${b.h},90%,70%,${0.22+0.5*near})`;
      ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=`hsla(${(b.h+40)%360},90%,85%,0.9)`; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.arc(b.x - R*0.35, b.y - R*0.35, R*0.32, 0, Math.PI*2); ctx.stroke();
      b.x += b.vx + (mouse.x-b.x)*0.00035*mapIntensity();
      b.y += b.vy - (mouse.y-b.y)*0.00025*mapIntensity();
      if (b.y<-R-20){ b.y=H+40; b.x=Math.random()*W; b.vx=(Math.random()-0.5)*0.2; b.vy=-(0.4+Math.random()*0.6); b.charge=0; b.cool=0; }
      const canPop=(b.cool<=0) && (b.charge>=1.7) && (near>0.6);
      if (canPop){
        playPing(740,0.12,0.06);
        for(let k=0;k<22;k++){
          sparks.push({x:b.x,y:b.y,vx:Math.cos(k*Math.PI/11)*(2.2+Math.random()*1.6),vy:Math.sin(k*Math.PI/11)*(2.2+Math.random()*1.6),life:40+Math.random()*20,h:(b.h+Math.random()*50)%360});
        }
        for(let d2=0; d2<8; d2++){
          sparks.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*4.5,vy:(Math.random()-0.5)*4.5,life:28,h:(b.h+20)%360});
        }
        ctx.globalCompositeOperation='screen';
        ctx.strokeStyle=`hsla(${(b.h+20)%360},95%,80%,0.8)`; ctx.lineWidth=2.2;
        ctx.beginPath(); ctx.arc(b.x,b.y,R*1.1,0,Math.PI*2); ctx.stroke();
        b.charge=0.15; b.cool=0.25;
      }
      if (b.cool>0) b.cool -= dt;
    }
  }

   function tick(t){
    const dt = clamp((t - now)/1000, 0, 0.05);
    now = t;
    dwellMs = t - lastMoveT;
    MUSIC.tick(dt);

    recomputePaused();

    if (menuOpen || paused){
      return requestAnimationFrame(tick);
    }

    switch (ui.mode.value){
      case 'aurora':    renderAurora(dt);     break;
      case 'ripples':   renderRipples(dt);    break;
      case 'fireworks': renderFireworks(dt);  break;
      case 'kaleido':   renderKaleido(dt);    break;
      case 'fireflies': renderFireflies(dt);  break;
      case 'confetti':  renderConfetti(dt);   break;
      case 'nebula':    renderNebula(dt);     break;
      case 'jelly':     renderJelly(dt);      break;
      case 'snow':      renderSnow(dt);       break;
      case 'sand':      SAND_CELL.caRender(dt); break;
      case 'magnet':    renderMagnet(dt);     break;
      case 'glass':     renderGlass(dt);      break;
      case 'streamers': renderStreamers(dt);  break;
      case 'laserharp': renderLaser(dt);      break;
      case 'bubblepop': renderBubblePop(dt);  break;
    }
    requestAnimationFrame(tick);
  }

  (function seedBlueBg(){
    ctx.fillStyle = 'hsl(210, 70%, 8%)';
    ctx.fillRect(0,0,W,H);
  })();

  updateBorder();
  snowResize();
  requestAnimationFrame(tick);

  startButton.addEventListener('click', () => {
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen();
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if (el.msRequestFullscreen) el.msRequestFullscreen();

    document.getElementById('game-options').style.display = 'none';
    cvs.style.display = 'block';
    menuOpen = false;
    MUSIC.prime();                 // <-- NEW
    MUSIC.setScene(sceneSel.value); 

    cvs.addEventListener('pointerdown', ()=>{ playPing(523,0.08,0.03); }, {once:true});
  });
  </script>
</body>
</html>