<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title class="translate" data-fr="Danse des lucioles" data-en="Firefly Bloom" data-ja="ホタルのダンス">Danse des lucioles</title>

  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    :root {
      --firefly-teal: #00bfa5;
      --firefly-deep: #0a1c1f;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 30% 30%, #0c2a33, #040b10 55%);
      color: #e8f7f1;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
    }

    #langToggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 99999;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 2px solid var(--firefly-teal);
      background: #061115;
      color: var(--firefly-teal);
      font-weight: 700;
      cursor: pointer;
      user-select: none;
    }

    #hud {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 2px solid rgba(0, 191, 165, 0.35);
      background: rgba(0, 15, 19, 0.55);
      color: #d5fff4;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(6px);
    }

    #statusTitle {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    #statusSubtitle {
      opacity: 0.85;
      font-size: 14px;
    }

    #gameCanvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #gazePointer {
      position: fixed;
      width: 44px;
      height: 44px;
      margin-left: -22px;
      margin-top: -22px;
      border-radius: 50%;
      border: 3px solid rgba(255, 75, 75, 0.9);
      box-shadow: 0 0 22px rgba(255, 75, 75, 0.65), 0 0 38px rgba(255, 75, 75, 0.35);
      pointer-events: none;
      mix-blend-mode: screen;
      z-index: 12;
      transition: transform 0.16s ease, opacity 0.18s ease;
      transform: scale(0.98);
      opacity: 0;
      background: radial-gradient(circle, rgba(255, 75, 75, 0.35) 0%, rgba(255, 75, 75, 0.08) 70%, transparent 90%);
    }

    body.playing #gazePointer {
      opacity: 1;
    }

    body.playing canvas {
      cursor: none;
    }

    .dwell-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      pointer-events: none;
    }

    /* Keep the existing menu styling */
    #game-options.modal {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #control-panel-options {
      padding: 14px 20px 20px;
    }

    #options-inline-container {
      margin-top: 12px;
    }

    #mode-divider {
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

  <div id="game-options" class="modal">
    <div id="options-title-bar">
      <h2 id="options-main-title" class="translate"
          data-fr="Danse des lucioles"
          data-en="Firefly Bloom"
          data-ja="ホタルのダンス">Danse des lucioles</h2>
    </div>

    <div id="control-panel-options">
      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label for="circleCount" class="teal-label">
              <span class="translate" data-fr="Nombre de bulles" data-en="Number of bubbles" data-ja="バブルの数">Nombre de bulles</span> :
              <span id="circleCountVal">4</span>
            </label>
            <input type="range" id="circleCount" class="styled-slider" min="2" max="8" value="4">
          </div>
          <div class="option-item">
            <label for="circleSize" class="teal-label">
              <span class="translate" data-fr="Taille des cercles" data-en="Circle size" data-ja="円の大きさ">Taille des cercles</span> :
              <span id="circleSizeVal">120</span> px
            </label>
            <input type="range" id="circleSize" class="styled-slider" min="90" max="180" value="120">
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="dwellTime" class="teal-label">
              <span class="translate" data-fr="Temps de fixation" data-en="Dwell time" data-ja="注視時間">Temps de fixation</span> :
              <span id="dwellTimeVal">1500</span> ms
            </label>
            <input type="range" id="dwellTime" class="styled-slider" min="500" max="4000" step="100" value="1500">
          </div>
          <div class="option-item">
            <label for="fireflyBurst" class="teal-label">
              <span class="translate" data-fr="Lucioles libérées" data-en="Fireflies released" data-ja="放たれるホタル">Lucioles libérées</span> :
              <span id="fireflyBurstVal">12</span>
            </label>
            <input type="range" id="fireflyBurst" class="styled-slider" min="6" max="24" value="12">
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label class="teal-label" for="trailToggle">
              <input type="checkbox" id="trailToggle" checked>
              <span class="translate" data-fr="Traînée lumineuse" data-en="Glow trails" data-ja="光の軌跡">Traînée lumineuse</span>
            </label>
          </div>
          <div class="option-item">
            <label class="teal-label" for="calmMode">
              <input type="checkbox" id="calmMode">
              <span class="translate" data-fr="Mode calme (mouvements doux)" data-en="Calm mode (gentle motion)" data-ja="ゆったりモード">Mode calme</span>
            </label>
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start" data-ja="開始">Commencer</button>
    </div>
  </div>

  <div id="hud">
    <div id="statusTitle" class="translate" data-fr="Attrape les bulles" data-en="Catch the orbs" data-ja="光るバブルを見つめて">Attrape les bulles</div>
    <div id="statusSubtitle" class="translate" data-fr="Fixe-les jusqu'à ce qu'elles libèrent leurs lucioles." data-en="Dwell until each orb bursts into fireflies." data-ja="見つめるとホタルが飛び出すよ。">Fixe-les jusqu'à ce qu'elles libèrent leurs lucioles.</div>
  </div>

  <canvas id="gameCanvas"></canvas>
  <div id="gazePointer" aria-hidden="true"></div>

  <script src="../../js/eyegaze-menu.js"></script>
  <script src="../../js/translationmain.js"></script>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const pointerEl = document.getElementById('gazePointer');

    const circleCountInput = document.getElementById('circleCount');
    const circleCountVal = document.getElementById('circleCountVal');
    const circleSizeInput = document.getElementById('circleSize');
    const circleSizeVal = document.getElementById('circleSizeVal');
    const dwellTimeInput = document.getElementById('dwellTime');
    const dwellTimeVal = document.getElementById('dwellTimeVal');
    const fireflyBurstInput = document.getElementById('fireflyBurst');
    const fireflyBurstVal = document.getElementById('fireflyBurstVal');
    const trailToggle = document.getElementById('trailToggle');
    const calmMode = document.getElementById('calmMode');
    const startButton = document.getElementById('startButton');
    const langToggle = document.getElementById('langToggle');

    const statusTitle = document.getElementById('statusTitle');
    const statusSubtitle = document.getElementById('statusSubtitle');
    let lastRemaining = null;

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });

    const pointer = { x: -1000, y: -1000, tx: -1000, ty: -1000, inside: false };

    canvas.addEventListener('pointermove', (e) => {
      const rect = canvas.getBoundingClientRect();
      pointer.tx = (e.clientX - rect.left) * (canvas.width / rect.width);
      pointer.ty = (e.clientY - rect.top) * (canvas.height / rect.height);
      pointer.inside = true;
    });

    canvas.addEventListener('pointerleave', () => {
      pointer.inside = false;
      pointer.tx = -1000;
      pointer.ty = -1000;
    });

    const circles = [];
    const fireflies = [];
    const burstColors = ['#7CF7E1', '#FFDE6F', '#FF8CC6', '#7DB2FF', '#C3FF8F', '#F7A35C'];

    let celebrationTimer = 0;
    let celebrationActive = false;
    let celebrationMode = null;
    let gameStarted = false;
    let lastTime = performance.now();

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function spawnCircle() {
      const radius = parseInt(circleSizeInput.value, 10);
      const margin = radius + 30;
      let x = rand(margin, width - margin);
      let y = rand(margin, height - margin);
      let tries = 0;
      while (tries < 20) {
        const overlaps = circles.some(c => {
          const dist = Math.hypot(c.x - x, c.y - y);
          return dist < (c.r + radius + 20);
        });
        if (!overlaps) break;
        x = rand(margin, width - margin);
        y = rand(margin, height - margin);
        tries++;
      }
      circles.push({
        x, y, r: radius,
        color: burstColors[Math.floor(Math.random() * burstColors.length)],
        focus: 0,
        exploded: false,
        ring: 0
      });
    }

    function spawnCircles() {
      circles.length = 0;
      celebrationActive = false;
      celebrationMode = null;
      celebrationTimer = 0;
      lastRemaining = null;
      const count = parseInt(circleCountInput.value, 10);
      for (let i = 0; i < count; i++) {
        spawnCircle();
      }
    }

    function explodeCircle(circle) {
      circle.exploded = true;
      const burst = parseInt(fireflyBurstInput.value, 10);
      for (let i = 0; i < burst; i++) {
        const angle = rand(0, Math.PI * 2);
        const speed = calmMode.checked ? rand(70, 160) : rand(160, 280);
        fireflies.push({
          x: circle.x,
          y: circle.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: Infinity,
          age: 0,
          glow: rand(16, 28),
          color: circle.color,
          lively: true,
          baseSpeed: speed,
          heading: angle,
          wanderTimer: rand(0.35, 0.9),
          flickerSpeed: rand(2, 4),
          flutterPhase: rand(0, Math.PI * 2),
          trail: []
        });
      }
    }

    function buildSmileTargets(count) {
      const cx = width / 2;
      const cy = height / 2;
      const faceR = Math.min(width, height) * 0.22;
      const eyeR = faceR * 0.12;
      const eyeOffsetX = faceR * 0.42;
      const eyeOffsetY = faceR * -0.22;
      const mouthR = faceR * 0.62;
      const mouthStart = Math.PI * 1.15; // 207°
      const mouthEnd = Math.PI * 1.85;   // 333°

      const eyes = [];
      const eyePoints = 12;
      for (let i = 0; i < eyePoints; i++) {
        const ang = (i / eyePoints) * Math.PI * 2;
        const ex = Math.cos(ang) * eyeR;
        const ey = Math.sin(ang) * eyeR;
        eyes.push({ x: cx - eyeOffsetX + ex, y: cy + eyeOffsetY + ey });
        eyes.push({ x: cx + eyeOffsetX + ex, y: cy + eyeOffsetY + ey });
      }

      const mouth = [];
      const mouthPoints = 30;
      for (let i = 0; i < mouthPoints; i++) {
        const t = i / (mouthPoints - 1);
        const ang = mouthStart + (mouthEnd - mouthStart) * t;
        mouth.push({
          x: cx + Math.cos(ang) * mouthR,
          y: cy + Math.sin(ang) * mouthR
        });
      }

      const ring = [];
      const ringPoints = 36;
      for (let i = 0; i < ringPoints; i++) {
        const ang = (i / ringPoints) * Math.PI * 2;
        ring.push({
          x: cx + Math.cos(ang) * faceR,
          y: cy + Math.sin(ang) * faceR * 0.95
        });
      }

      const priority = [...eyes, ...mouth, ...ring];
      const selected = [];

      if (count <= priority.length) {
        for (let i = 0; i < count; i++) {
          const idx = Math.floor(i * (priority.length / count));
          selected.push(priority[idx]);
        }
      } else {
        selected.push(...priority);
        while (selected.length < count) {
          selected.push({
            x: cx + rand(-faceR * 0.35, faceR * 0.35),
            y: cy + rand(-faceR * 0.2, faceR * 0.25)
          });
        }
      }

      return selected;
    }

    function launchCelebration() {
      if (!fireflies.length) {
        spawnCircles();
        return;
      }

      celebrationActive = true;
      celebrationMode = 'smile';
      celebrationTimer = 3.8;
      const targets = buildSmileTargets(fireflies.length);

      fireflies.forEach((f, i) => {
        const target = targets[i % targets.length];
        f.swirl = false;
        f.lively = true;
        f.targetX = target.x + rand(-6, 6);
        f.targetY = target.y + rand(-6, 6);
        f.targetTimer = celebrationTimer;
        f.heading = Math.atan2(f.targetY - f.y, f.targetX - f.x);
        const boost = calmMode.checked ? 110 : 190;
        f.baseSpeed = Math.max(f.baseSpeed || boost, boost);
        f.flutterPhase = rand(0, Math.PI * 2);
      });
    }

    function updateFireflies(dt) {
      for (let i = fireflies.length - 1; i >= 0; i--) {
        const f = fireflies[i];
        f.age += dt;
        const damp = calmMode.checked ? 0.985 : 0.97;
        f.vx *= damp;
        f.vy *= damp;

        const targeting = celebrationMode === 'smile' && f.targetTimer > 0;
        if (targeting) {
          f.targetTimer -= dt;
          const dx = f.targetX - f.x;
          const dy = f.targetY - f.y;
          const dist = Math.max(12, Math.hypot(dx, dy));
          const targetSpeed = (calmMode.checked ? 90 : 160) * (1 + 0.08 * Math.sin(f.age * 3 + f.flutterPhase));
          const desiredVx = (dx / dist) * targetSpeed;
          const desiredVy = (dy / dist) * targetSpeed;
          const steer = calmMode.checked ? 1.05 : 1.5;
          f.vx += (desiredVx - f.vx) * steer * dt;
          f.vy += (desiredVy - f.vy) * steer * dt;

          const buzz = calmMode.checked ? 14 : 26;
          const tangentX = -dy / dist;
          const tangentY = dx / dist;
          f.vx += tangentX * buzz * dt;
          f.vy += tangentY * buzz * dt;
        } else {
          f.wanderTimer -= dt;
          if (f.wanderTimer <= 0) {
            f.heading += rand(-1.2, 1.2);
            f.wanderTimer = calmMode.checked ? rand(0.8, 1.4) : rand(0.45, 1.05);
          }

          if (f.lively) {
            const flutter = calmMode.checked ? 0.22 : 0.35;
            const targetSpeed = (calmMode.checked ? f.baseSpeed * 0.55 : f.baseSpeed * 0.85) *
              (1 + flutter * Math.sin(f.flutterPhase + f.age * (calmMode.checked ? 1.4 : 2.6)));
            const desiredVx = Math.cos(f.heading) * targetSpeed;
            const desiredVy = Math.sin(f.heading) * targetSpeed;
            const chase = calmMode.checked ? 0.55 : 0.75;
            f.vx += (desiredVx - f.vx) * chase * dt;
            f.vy += (desiredVy - f.vy) * chase * dt;

            const wiggle = calmMode.checked ? 16 : 30;
            f.vx += rand(-wiggle, wiggle) * dt;
            f.vy += rand(-wiggle, wiggle) * dt;
          }

          if (f.swirl) {
            const cx = width / 2;
            const cy = height / 2;
            const dx = f.x - cx;
            const dy = f.y - cy;
            const dist = Math.max(40, Math.hypot(dx, dy));
            f.vx += (-dy / dist) * 24 * dt;
            f.vy += (dx / dist) * 24 * dt;
          }
        }

        f.x += f.vx * dt;
        f.y += f.vy * dt;

        if (f.x < -60 || f.x > width + 60 || f.y < -60 || f.y > height + 60) {
          if (f.x < -60) f.x = width + 60;
          if (f.x > width + 60) f.x = -60;
          if (f.y < -60) f.y = height + 60;
          if (f.y > height + 60) f.y = -60;
          f.trail.length = 0;
        }

        if (trailToggle.checked) {
          f.trail.push({ x: f.x, y: f.y, t: f.age });
          if (f.trail.length > 12) f.trail.shift();
        }

      }
    }

    function drawFireflies() {
      fireflies.forEach(f => {
        if (trailToggle.checked) {
          for (let i = 0; i < f.trail.length - 1; i++) {
            const a = f.trail[i];
            const b = f.trail[i + 1];
            const segmentLen = Math.hypot(b.x - a.x, b.y - a.y);
            if (segmentLen > 220) continue; // avoid wrap artifacts
            const alpha = Math.max(0, 1 - (f.age - a.t) / f.life);
            ctx.strokeStyle = `${f.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }

        const lifeAlpha = Math.max(0.3, 1 - f.age / Math.max(f.life, 1)); // keep a gentle glow
        const flicker = 0.8 + 0.35 * Math.sin(f.age * f.flickerSpeed * 2 + f.flutterPhase);
        const glow = f.glow * (calmMode.checked ? 0.9 : 1.2) * flicker;
        const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, glow);
        gradient.addColorStop(0, `${f.color}cc`);
        gradient.addColorStop(1, `${f.color}00`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(f.x, f.y, glow, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * lifeAlpha})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawCircles() {
      circles.forEach(c => {
        if (c.exploded) return;
        const focusScale = 1 + c.focus * 0.75;
        const glowBoost = 1 + c.focus * 1.05;
        const radius = c.r * focusScale;
        const gradient = ctx.createRadialGradient(
          c.x - radius * 0.2,
          c.y - radius * 0.2,
          radius * 0.05,
          c.x,
          c.y,
          radius * 1.2
        );
        gradient.addColorStop(0, `#ffffff${Math.floor(80 + 80 * c.focus).toString(16).padStart(2, '0')}`);
        gradient.addColorStop(1, `${c.color}f0`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(c.x, c.y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Dwell ring
        if (c.focus > 0) {
          ctx.strokeStyle = '#ffffffdd';
          ctx.lineWidth = 8 + c.focus * 7;
          ctx.beginPath();
          ctx.arc(c.x, c.y, radius + 18, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * c.focus);
          ctx.stroke();
        }

        // subtle pulse
        ctx.strokeStyle = `${c.color}aa`;
        ctx.lineWidth = 3.5;
        ctx.beginPath();
        ctx.arc(c.x, c.y, radius + 20 * glowBoost * Math.abs(Math.sin(performance.now() / 600)), 0, Math.PI * 2);
        ctx.stroke();
      });
    }

    function updateCircles(dt) {
      if (!gameStarted) return;
      const dwell = parseInt(dwellTimeInput.value, 10) / 1000;
      circles.forEach(c => {
        if (c.exploded) return;
        const over = pointer.inside && Math.hypot(pointer.x - c.x, pointer.y - c.y) <= c.r;
        if (over) {
          c.focus = Math.min(1, c.focus + dt / dwell);
          if (c.focus >= 1) {
            explodeCircle(c);
          }
        } else {
          c.focus = Math.max(0, c.focus - dt * 0.75);
        }
      });

      const remaining = circles.filter(c => !c.exploded).length;
      if (remaining !== lastRemaining) {
        statusTitle.dataset.fr = remaining > 0 ? 'Attrape les bulles' : 'Spectacle de lucioles !';
        statusTitle.dataset.en = remaining > 0 ? 'Catch the orbs' : 'Firefly show!';
        statusTitle.dataset.ja = remaining > 0 ? '光るバブルを見つめて' : 'ホタルのショー！';
        statusSubtitle.dataset.fr = remaining > 0
          ? `Plus que ${remaining} bulle${remaining > 1 ? 's' : ''}.`
          : 'Regarde les lucioles danser.';
        statusSubtitle.dataset.en = remaining > 0
          ? `${remaining} orb${remaining > 1 ? 's' : ''} left.`
          : 'Watch the fireflies dance.';
        statusSubtitle.dataset.ja = remaining > 0
          ? `${remaining}個のバブルが残っています。`
          : 'ホタルのダンスを見よう。';

        updateLanguage();
        lastRemaining = remaining;
      }

      if (remaining === 0 && !celebrationActive) {
        launchCelebration();
      }
    }

    function renderBackground() {
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#03121a');
      gradient.addColorStop(1, '#00050a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      for (let i = 0; i < 40; i++) {
        const size = Math.sin((lastTime * 0.001 + i) % Math.PI) * 1.5 + 1.5;
        ctx.beginPath();
        ctx.arc((i * 97) % width, (i * 53) % height, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function gameLoop(ts) {
      const dt = Math.min(0.05, (ts - lastTime) / 1000);
      lastTime = ts;

      const smoothing = Math.min(1, dt * 12);
      pointer.x += (pointer.tx - pointer.x) * smoothing;
      pointer.y += (pointer.ty - pointer.y) * smoothing;
      pointerEl.style.transform = `translate(${pointer.x}px, ${pointer.y}px)`;

      renderBackground();
      if (gameStarted) {
        updateCircles(dt);
        updateFireflies(dt);
        drawCircles();
        drawFireflies();
      }

      if (celebrationActive) {
        celebrationTimer -= dt;
        if (celebrationTimer <= 0) {
          celebrationActive = false;
          celebrationMode = null;
          fireflies.forEach(f => {
            f.swirl = false;
            f.targetTimer = 0;
          });
          spawnCircles();
        }
      }

      requestAnimationFrame(gameLoop);
    }

    langToggle.addEventListener('click', () => {
      toggleLanguage();
    });

    function startGame() {
      document.body.classList.add('playing');
      document.getElementById('game-options').style.display = 'none';
      document.getElementById('hud').style.display = 'none';
      langToggle.style.display = 'none';
      statusTitle.textContent = '';
      statusSubtitle.textContent = '';
      fireflies.length = 0;
      gameStarted = true;
      spawnCircles();
    }

    function updateValueLabels() {
      circleCountVal.textContent = circleCountInput.value;
      circleSizeVal.textContent = circleSizeInput.value;
      dwellTimeVal.textContent = dwellTimeInput.value;
      fireflyBurstVal.textContent = fireflyBurstInput.value;
    }

    circleCountInput.addEventListener('input', updateValueLabels);
    circleSizeInput.addEventListener('input', updateValueLabels);
    dwellTimeInput.addEventListener('input', updateValueLabels);
    fireflyBurstInput.addEventListener('input', updateValueLabels);

    startButton.addEventListener('click', startGame);

    updateLanguage();
    updateValueLabels();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
