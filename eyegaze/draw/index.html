<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Draw Within the Lines ‚Äî Eyegaze Menu + Upload Mask</title>

<link rel="stylesheet" href="../../css/games.css" />
<link rel="stylesheet" href="../../css/choiceeyegaze.css" />

<style>
  :root{
    --bg:#0b0f14; --edge:#e2e8f0; --ui-scale:1;
    --sidebar-w: clamp(96px, calc(120px * var(--ui-scale)), 180px);
    --sidebar-pad-x: clamp(8px, calc(12px * var(--ui-scale)), 16px);
    --sidebar-pad-y: clamp(8px, calc(12px * var(--ui-scale)), 16px);
    --swatch-size:84px; --swatch-gap:12px; --palette-cols:1;
    --swatch-border: clamp(3px, calc(5px * var(--ui-scale)), 6px);
    --swatch-outline: clamp(3px, calc(5px * var(--ui-scale)), 6px);
    --brush-btn: clamp(36px, calc(44px * var(--ui-scale)), 56px);
    --brush-gap: clamp(8px, calc(12px * var(--ui-scale)), 16px);
    --save-btn: clamp(36px, calc(44px * var(--ui-scale)), 56px);
    --save-radius: clamp(8px, calc(10px * var(--ui-scale)), 12px);
    --cursor-outline: clamp(1px, calc(2px * var(--ui-scale)), 3px);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  body.light{background:#fff;color:#000} body.dark{background:#000;color:#fff}

  /* Menu toggle (same button style) */
  #langToggle{ position:fixed; top:10px; right:10px; z-index:99999; display:inline-flex; gap:6px;
    padding:6px 10px; border-radius:10px; border:2px solid #009688; background:#fff; color:#009688;
    font-weight:700; cursor:pointer; user-select:none; }
  body.dark #langToggle{ background:#111; color:#14b8a6; border-color:#14b8a6 }

  /* Sidebar (like your other game) */
  #sidebar{ position:fixed; left:0; top:0; bottom:0; z-index:20; width:var(--sidebar-w); display:none;
    flex-direction:column; gap:clamp(12px, calc(14px * var(--ui-scale)), 18px);
    padding:var(--sidebar-pad-y) var(--sidebar-pad-x); background:#fff; color:#000; border-right:1px solid #e6e6e6; box-shadow:0 0 18px rgba(0,0,0,.05); }
  #palette{ flex:1; display:grid; grid-template-columns:repeat(var(--palette-cols), var(--swatch-size));
    grid-auto-rows:var(--swatch-size); gap:var(--swatch-gap); justify-content:center; align-content:start; padding-inline:8px; overflow:hidden; }
  .swatch{ width:var(--swatch-size); height:var(--swatch-size); border-radius:50%; border:var(--swatch-border) solid #fff;
    box-shadow:0 1px 6px rgba(0,0,0,.22) inset, 0 3px 10px rgba(0,0,0,.12); transition:.12s; position:relative; overflow:hidden; }
  .swatch.active{ transform:scale(1.03) }
  .swatch.active::before{ content:""; position:absolute; inset:calc(var(--swatch-outline) + 2px);
    border:var(--swatch-outline) solid #111; border-radius:50%; pointer-events:none }
  #brushSizes{ display:flex; flex-direction:column; align-items:center; gap:var(--brush-gap) }
  .brushBtn{ width:var(--brush-btn); height:var(--brush-btn); border-radius:50%; border:2px solid #aaa; background:#f8f8f8;
    display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 1px 3px rgba(0,0,0,.1) inset; }
  .brushBtn span{ display:block; border-radius:50%; background:#333 }
  .brushBtn.small span{width:6px;height:6px} .brushBtn.medium span{width:16px;height:16px} .brushBtn.large span{width:28px;height:28px}
  .brushBtn.active{ border-color:#333; background:#ececec }
  #modeRow{ display:flex; gap:8px; justify-content:center }
  .modeBtn{ padding:6px 10px; border-radius:10px; border:1px solid #ddd; background:#fafafa; color:#000; font:600 12px/1 system-ui,Arial; cursor:pointer }
  .modeBtn.active{ border-color:#333; background:#ececec }
  #saveBtn{ appearance:none; width:var(--save-btn); height:var(--save-btn); border-radius:var(--save-radius);
    border:1px solid #ddd; background:#fafafa; color:#000; align-self:center; cursor:pointer }

  /* Stage + canvases (key: fill the stage) */
  .stage{ position:relative; height:100vh; background:radial-gradient(1200px 600px at 60% -10%, #1a2330 0%, #0b0f14 60%, #080c11 100%) }
  #ink,#outline{ position:absolute; inset:0; width:100%; height:100% } /* ensure non-zero CSS size */
  #outline{ pointer-events:none }
  .badge{ position:absolute; top:12px; right:12px; background:#0b1520; border:1px solid rgba(255,255,255,.1); padding:6px 10px; border-radius:999px; font-size:12px }
  .stage.hidden{ visibility:hidden }

  /* Menu layout (only theme, colors, upload) */
  #options-inline-container{ gap:18px }
</style>
</head>
<body class="dark">
<button id="langToggle">FR / EN</button>

<!-- ===== Menu ===== -->
<div id="game-options" class="modal">
  <div id="options-title-bar"><h2 id="options-main-title">Draw within the outline</h2></div>
  <div id="control-panel-options">
    <div id="mode-divider"></div>
    <div id="options-inline-container">
      <div class="options-column">
        <div class="option-item">
          <label for="themeSelect" class="teal-label label-block">Theme</label>
          <select id="themeSelect" class="styled-select">
            <option value="light">Light</option>
            <option value="dark" selected>Dark</option>
          </select>
        </div>
      </div>
      <div class="options-column">
        <div class="option-item">
          <label for="paletteSizeSelect" class="teal-label label-block">Number of colors</label>
          <select id="paletteSizeSelect" class="styled-select">
            <option value="4">4 colors</option>
            <option value="7" selected>7 colors</option>
            <option value="13">13 colors</option>
          </select>
        </div>
      </div>
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label label-block">Upload outline (PNG/SVG)</label>
          <input id="outlineFile" type="file" accept="image/png, image/svg+xml" class="styled-input" />
          <small>Opaque area = drawable area. You‚Äôll see a translucent preview.</small>
        </div>
      </div>
    </div>
    <div id="mode-divider"></div>
    <button id="startButton" class="button">Start</button>
  </div>
</div>

<!-- ===== Sidebar ===== -->
<aside id="sidebar">
  <div id="palette"></div>
  <div id="brushSizes">
    <div class="brushBtn small"  data-size="small"  title="Small"><span></span></div>
    <div class="brushBtn medium active" data-size="medium" title="Medium"><span></span></div>
    <div class="brushBtn large"  data-size="large"  title="Large"><span></span></div>
  </div>
  <div id="modeRow">
    <button class="modeBtn active" id="modeDraw">‚úèÔ∏è Draw</button>
    <button class="modeBtn"        id="modeErase">üßΩ Erase</button>
  </div>
  <button id="saveBtn" type="button" title="Save PNG">üíæ</button>
</aside>

<!-- ===== Stage ===== -->
<main class="stage hidden" id="stage">
  <div class="badge">Canvas demo</div>
  <canvas id="ink" width="1400" height="900" aria-label="Ink layer"></canvas>
  <canvas id="outline" width="1400" height="900" aria-label="Outline layer"></canvas>
</main>

<!-- cursor preview -->
<div id="cursorPreview" style="position:fixed;left:0;top:0;width:20px;height:20px;border-radius:50%;pointer-events:none;z-index:15;mix-blend-mode:multiply;transform:translate(-50%,-50%);opacity:.65;outline:2px solid rgba(0,0,0,.18)"></div>

<script>
/* ===== Theme toggle ===== */
const langToggle=document.getElementById('langToggle');
function setTheme(t){ document.body.classList.remove('light','dark'); document.body.classList.add(t==='dark'?'dark':'light'); }
langToggle.addEventListener('click',()=> setTheme(document.body.classList.contains('dark')?'light':'dark'));

/* ===== Canvases & sizing (identical logic to the first working file) ===== */
const ink=document.getElementById('ink');
const out=document.getElementById('outline');
const ic=ink.getContext('2d');
const oc=out.getContext('2d');
const stage=document.getElementById('stage');

function fitCanvasToStage(){
  // 1) use visible CSS size of stage
  const cssW=stage.clientWidth||window.innerWidth;
  const cssH=stage.clientHeight||window.innerHeight;
  ink.style.width=out.style.width=cssW+'px';
  ink.style.height=out.style.height=cssH+'px';

  // 2) map to device pixels with DPR and set transforms
  const dpr=Math.max(1,window.devicePixelRatio||1);
  const w=Math.max(1,Math.round(cssW*dpr));
  const h=Math.max(1,Math.round(cssH*dpr));
  if(ink.width!==w||ink.height!==h){ ink.width=w; ink.height=h; ic.setTransform(dpr,0,0,dpr,0,0); }
  if(out.width!==w||out.height!==h){ out.width=w; out.height=h; oc.setTransform(dpr,0,0,dpr,0,0); }
}

function drawFallbackGuide(){
  const rect=out.getBoundingClientRect();
  const p=new Path2D(); const pad=Math.min(rect.width,rect.height)*0.12; const r=Math.min(rect.width,rect.height)*0.18;
  const x=pad,y=pad,w=rect.width-2*pad,h=rect.height-2*pad;
  p.moveTo(x+r,y); p.arcTo(x+w,y,x+w,y+h,r); p.arcTo(x+w,y+h,x,y+h,r); p.arcTo(x,y+h,x,y,r); p.arcTo(x,y,x+w,y,r); p.closePath();
  oc.clearRect(0,0,out.width,out.height);
  oc.save(); oc.fillStyle='white'; oc.globalAlpha=0.08; oc.fill(p);
  oc.globalAlpha=1; oc.lineWidth=6; oc.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge')||'#e2e8f0'; oc.stroke(p); oc.restore();
}

/* ===== Mask pipeline (upload only) ===== */
let userMask=null;
const maskCanvas=document.createElement('canvas');
const maskCtx=maskCanvas.getContext('2d');
let maskImageData=null;

function computeFit(destW,destH,imgW,imgH){
  const r=imgW/imgH, R=destW/destH;
  const w=R>r?destH*r:destW, h=R>r?destH:destW/r;
  const x=(destW-w)/2, y=(destH-h)/2;
  return {x,y,w,h};
}
function rebuildMaskCache(){
  if(!userMask){ maskImageData=null; return; }
  maskCanvas.width=out.width; maskCanvas.height=out.height;

  // IMPORTANT: re-derive dpr from canvas vs CSS rect so drawing coords in CSS px match
  const rect=out.getBoundingClientRect();
  const dpr = out.width / Math.max(1, rect.width);
  maskCtx.setTransform(dpr,0,0,dpr,0,0);
  maskCtx.clearRect(0,0,rect.width,rect.height);

  const fit=computeFit(rect.width,rect.height,userMask.naturalWidth,userMask.naturalHeight);
  maskCtx.drawImage(userMask,fit.x,fit.y,fit.w,fit.h);

  // Try to cache alpha (safe when not CORS-tainted). If tainted, we still draw fine using maskCanvas directly.
  try{
    const img=maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height);
    const d=img.data;
    for(let i=0;i<d.length;i+=4){ const a=d[i+3]; d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=a; }
    maskCtx.putImageData(img,0,0);
    maskImageData=img;
  }catch{ maskImageData=null; }
}
function redrawMaskGuide(){
  oc.clearRect(0,0,out.width,out.height);
  if(!userMask){ drawFallbackGuide(); return; }
  const rect=out.getBoundingClientRect();
  const fit=computeFit(rect.width,rect.height,userMask.naturalWidth,userMask.naturalHeight);
  // Align oc‚Äôs transform with CSS px like above (oc already has DPR transform)
  oc.save();
  oc.globalAlpha=0.6;
  oc.drawImage(userMask,fit.x,fit.y,fit.w,fit.h);
  oc.globalAlpha=1;
  oc.lineWidth=2; oc.strokeStyle='rgba(0,0,0,.35)'; oc.strokeRect(fit.x,fit.y,fit.w,fit.h);
  oc.restore();
}
function loadUserMaskFromURL(url,revoke=false){
  const img=new Image(); img.crossOrigin='anonymous'; // OK for blob URLs; safe for same-origin files
  img.onload=()=>{ if(revoke) URL.revokeObjectURL(url); userMask=img; fitCanvasToStage(); rebuildMaskCache(); redrawMaskGuide(); };
  img.onerror=()=>{ if(revoke) URL.revokeObjectURL(url); alert('Could not load image. Use a PNG/SVG from same origin or choose another file.'); };
  img.src=url;
}
async function loadUserMaskFromFile(file){
  const url=URL.createObjectURL(file);
  loadUserMaskFromURL(url,true);
}

/* Upload input */
const outlineFileEl=document.getElementById('outlineFile');
outlineFileEl.addEventListener('change',(e)=>{ const f=e.target.files?.[0]; if(!f) return; loadUserMaskFromFile(f); });

/* ===== Drawing (unchanged logic) ===== */
let drawing=false, prev=null, erasing=false, sizeMode='medium', currentColor='#000';
const supportsPathClip=(function(){ try{ const c=document.createElement('canvas').getContext('2d'); const p=new Path2D(); p.rect(0,0,1,1); c.save(); c.clip(p); c.restore(); return true; }catch(e){ return false; } })();
const scratch=document.createElement('canvas'); const sc=scratch.getContext('2d');
function syncScratch(){ scratch.width=ink.width; scratch.height=ink.height; sc.setTransform(ic.getTransform()); sc.clearRect(0,0,scratch.width,scratch.height); }
function getPos(e){ const r=ink.getBoundingClientRect(); if(e.touches&&e.touches[0]) return {x:e.touches[0].clientX-r.left,y:e.touches[0].clientY-r.top}; return {x:(e.clientX||e.x)-r.left,y:(e.clientY||e.y)-r.top}; }
function brushSize(){ return sizeMode==='small'?8:(sizeMode==='large'?34:18); }
function begin(e){ drawing=true; prev=getPos(e); e.preventDefault(); }
function end(){ drawing=false; prev=null; }
function draw(e){
  if(!drawing) return;
  const cur=getPos(e); const size=brushSize();
  if(userMask){
    sc.save(); sc.lineCap='round'; sc.lineJoin='round'; sc.lineWidth=size; sc.globalCompositeOperation='source-over';
    sc.strokeStyle=erasing?'#000':currentColor;
    sc.beginPath(); sc.moveTo(prev.x,prev.y); sc.lineTo(cur.x,cur.y); sc.stroke();
    sc.globalCompositeOperation='destination-in'; sc.drawImage(maskCanvas,0,0);
    sc.restore();
    ic.save(); ic.globalCompositeOperation=erasing?'destination-out':'source-over'; ic.drawImage(scratch,0,0); ic.restore();
    sc.clearRect(0,0,scratch.width,scratch.height);
  } else {
    if(supportsPathClip){
      oc.save(); oc.clip(new Path2D()); oc.restore(); // no-op; we rely on fallback guide only for now
    }
  }
  prev=cur; e.preventDefault();
}
ink.addEventListener('pointerdown',begin); window.addEventListener('pointerup',end);
window.addEventListener('pointercancel',end); window.addEventListener('pointerout',e=>{ if(e.target===ink) end(); });
window.addEventListener('pointermove',draw,{passive:false});
ink.addEventListener('touchstart',begin,{passive:false}); window.addEventListener('touchend',end,{passive:false});
window.addEventListener('touchmove',draw,{passive:false});

/* ===== Palette (4 / 7 / 13) ===== */
const PALETTE_13=["#000000","#FF6B6B","#F94144","#FFD166","#F9C74F","#06D6A0","#90BE6D","#43AA8B","#118AB2","#3A86FF","#9B59B6","#8338EC","#FF9F1C"];
const sidebar=document.getElementById('sidebar'), paletteEl=document.getElementById('palette');
function pickColors(n){ if(n>=13) return PALETTE_13.slice(0,13); if(n==7) return ["#000000","#FF6B6B","#FFD166","#06D6A0","#118AB2","#9B59B6","#FF9F1C"]; if(n==4) return ["#000000","#FF6B6B","#06D6A0","#3A86FF"]; return PALETTE_13.slice(0,n); }
function buildPalette(n){
  while(paletteEl.firstChild) paletteEl.removeChild(paletteEl.firstChild);
  let colors=pickColors(n);
  if(document.body.classList.contains('dark')) colors[0]="#FFFFFF";
  colors.forEach(col=>{ const b=document.createElement('button'); b.className='swatch'; b.style.background=col; b.dataset.color=col; b.onclick=()=>{ document.querySelectorAll('.swatch').forEach(s=>s.classList.toggle('active',s===b)); currentColor=col; }; paletteEl.appendChild(b); });
  const sw=paletteEl.querySelector('.swatch'); if(sw) sw.click();
  layoutPalette();
}
function layoutPalette(){
  const n=paletteEl.children.length; if(!n) return;
  const padY=parseFloat(getComputedStyle(sidebar).paddingTop)+parseFloat(getComputedStyle(sidebar).paddingBottom);
  const padX=parseFloat(getComputedStyle(sidebar).paddingLeft)+parseFloat(getComputedStyle(sidebar).paddingRight);
  const reserve=document.getElementById('brushSizes').offsetHeight + document.getElementById('modeRow').offsetHeight + document.getElementById('saveBtn').offsetHeight + 32;
  const availH=Math.max(0, sidebar.clientHeight - padY - reserve);
  const availW=Math.max(0, sidebar.clientWidth  - padX);
  const gap=12;
  const fit=(cols,min,max)=>{ const rows=Math.ceil(n/cols); const sH=Math.floor((availH-(rows-1)*gap)/rows); const sW=Math.floor((availW-(cols-1)*gap)/cols); let s=Math.min(sH,sW); if(!Number.isFinite(s)) s=min; s=Math.max(min,Math.min(max,s)); return {s,cols}; };
  let L=fit(1,24,52); if(L.s<=25 && n>6) L=fit(2,24,52);
  sidebar.style.setProperty('--palette-cols', String(L.cols));
  sidebar.style.setProperty('--swatch-size', L.s+'px');
  sidebar.style.setProperty('--swatch-gap', gap+'px');
  const border=Math.max(2, Math.round(L.s*.06));
  sidebar.style.setProperty('--swatch-border', border+'px');
  sidebar.style.setProperty('--swatch-outline', border+'px');
}

/* ===== Brush + mode + cursor ===== */
document.querySelectorAll('.brushBtn').forEach(b=> b.addEventListener('click',()=>{ document.querySelectorAll('.brushBtn').forEach(x=>x.classList.toggle('active',x===b)); sizeMode=b.dataset.size; }));
document.getElementById('modeDraw').onclick=()=>{ erasing=false; modeDraw.classList.add('active'); modeErase.classList.remove('active'); }
document.getElementById('modeErase').onclick=()=>{ erasing=true;  modeErase.classList.add('active'); modeDraw.classList.remove('active'); }
const cursorEl=document.getElementById('cursorPreview');
function sidebarW(){ return sidebar.getBoundingClientRect().width; }
function updateCursor(x,y){ if(x<sidebarW()){ cursorEl.style.opacity=0; return; } cursorEl.style.opacity=.65; cursorEl.style.left=x+'px'; cursorEl.style.top=y+'px'; const d=brushSize(); cursorEl.style.width=d+'px'; cursorEl.style.height=d+'px'; cursorEl.style.background=erasing?'#fff':currentColor; }
addEventListener('mousemove',e=>updateCursor(e.clientX,e.clientY),{passive:true});
addEventListener('touchmove',e=>{ const t=e.touches[0]; if(t) updateCursor(t.clientX,t.clientY); },{passive:true});

/* ===== Save ===== */
function exportPNG(){ const m=document.createElement('canvas'); m.width=ink.width; m.height=ink.height; const mc=m.getContext('2d'); mc.setTransform(ic.getTransform()); mc.drawImage(out,0,0); mc.drawImage(ink,0,0); return m.toDataURL('image/png'); }
document.getElementById('saveBtn').onclick=()=>{ const a=document.createElement('a'); a.href=exportPNG(); a.download='drawing.png'; a.click(); };

/* ===== Menu wiring ===== */
const themeSelect=document.getElementById('themeSelect');
const paletteSizeSelect=document.getElementById('paletteSizeSelect');
const startButton=document.getElementById('startButton');
const gameOptions=document.getElementById('game-options');
const sidebarEl=document.getElementById('sidebar');

themeSelect.onchange=()=> setTheme(themeSelect.value);
paletteSizeSelect.onchange=()=>{ if(!stage.classList.contains('hidden')) buildPalette(parseInt(paletteSizeSelect.value,10)||7); };

startButton.onclick=()=>{
  setTheme(themeSelect.value);
  gameOptions.style.display='none';
  sidebarEl.style.display='flex';
  stage.classList.remove('hidden');

  // Exact order that guarantees non-zero rects:
  fitCanvasToStage();
  drawFallbackGuide();
  buildPalette(parseInt(paletteSizeSelect.value,10)||7);
  syncScratch();

  // One more frame to be 100% sure, then (re)build mask preview
  requestAnimationFrame(()=>{ fitCanvasToStage(); rebuildMaskCache(); redrawMaskGuide(); });
};

addEventListener('resize', ()=>{ if(stage.classList.contains('hidden')) return; fitCanvasToStage(); rebuildMaskCache(); redrawMaskGuide(); }, {passive:true});

/* Initial (menu visible) */
setTheme('dark');
</script>
</body>
</html>
