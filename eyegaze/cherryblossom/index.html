<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cherry Blossom Cut — Silhouette Forest</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: #fff;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    #game {
      display: block;
      width: 100vw; height: 100vh;
      cursor: crosshair;
      background: #fff;
    }
    #startOverlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: rgba(255,255,255,0.9);
      z-index: 10;
    }
    #startBtn {
      padding: 14px 22px;
      border: 2px solid #d40000; color: #d40000; background: #fff;
      border-radius: 12px; font-size: 18px; font-weight: 700;
      box-shadow: 0 6px 24px rgba(0,0,0,0.08);
      cursor: pointer;
    }
    #startBtn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="startOverlay">
    <button id="startBtn">Start • Fullscreen</button>
  </div>
  <canvas id="game"></canvas>

  <script>
  (() => {
    /* =======================
       CONFIG
    ======================= */
    const IMG_SRC = "../../images/cherryblossom.png";
    const SLASH_SOUND = "../../sounds/blade.mp3";

    // Large blossoms, fewer on screen
    const SPAWN_EVERY_MS = 1400;
    const FALL_SPEED_MIN = 40;
    const FALL_SPEED_MAX = 95;
    const BLOSSOM_SIZE_MIN = 72 * 3;
    const BLOSSOM_SIZE_MAX = 138 * 3;
    const HOVER_CUT_RADIUS = 52;
    const SHARD_SPREAD_SPEED = 190;
    const SHARD_ROT_SPEED = 1.2;
    const SHARD_FADE_TIME = 0.85;
    const MAX_FALLING = 5;

    // Silhouette Forest (Concept 1)
    // Two parallax layers of trees: far & near
    const FOREST_LAYERS = [
      { count: 6, speed: 0.05, trunkTint: "rgba(90,40,50,0.35)", canopyTint: "rgba(235,120,150,0.25)", trunkW: [16,28], trunkH: [0.28,0.36], canopyR: [50,110], yBand: [0.68,0.78] },
      { count: 5, speed: 0.10, trunkTint: "rgba(70,30,40,0.55)",  canopyTint: "rgba(235,120,150,0.35)", trunkW: [22,34], trunkH: [0.34,0.44], canopyR: [60,130], yBand: [0.72,0.82] },
    ];
    const CANOPIES_PER_TREE = [3, 4]; // min, max circles per tree

    /* =======================
       SETUP
    ======================= */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width  = window.innerWidth;
    let H = canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      buildForest();
    });

    const img = new Image();
    img.src = IMG_SRC;

    // preload slash sound
    const slashAudio = new Audio(SLASH_SOUND);
    slashAudio.volume = 0.6;
    function playSlash() {
      const s = slashAudio.cloneNode(true);
      s.volume = slashAudio.volume;
      s.play().catch(()=>{});
    }

    // pointer
    const pointer = { x: -9999, y: -9999, inside: false };
    canvas.addEventListener('pointermove', e => {
      const rect = canvas.getBoundingClientRect();
      pointer.x = (e.clientX - rect.left) * (canvas.width / rect.width);
      pointer.y = (e.clientY - rect.top)  * (canvas.height / rect.height);
      pointer.inside = true;
    });
    canvas.addEventListener('pointerleave', () => pointer.inside = false);

    const blossoms = [];
    const shards = [];
    const rand = (a, b) => a + Math.random() * (b - a);
    const randi = (a, b) => Math.floor(rand(a, b + 1));
    const nowSec = () => performance.now()/1000;

    /* =======================
       FOREST (generated)
    ======================= */
    // Each layer has trees; each tree has trunk rect + a few canopy circles.
    const forest = []; // [{speed, offsetX, trees:[{x, trunkW, trunkH, yBase, canopies:[{x,y,r}]}]}]

    function buildForest() {
      forest.length = 0;

      for (const layer of FOREST_LAYERS) {
        const L = { speed: layer.speed, offsetX: rand(0, W), trees: [], trunkTint: layer.trunkTint, canopyTint: layer.canopyTint };
        for (let i = 0; i < layer.count; i++) {
          const x = rand(0, W);
          const trunkW = rand(layer.trunkW[0], layer.trunkW[1]);
          const trunkH = rand(layer.trunkH[0], layer.trunkH[1]) * H;
          const yBase  = rand(layer.yBand[0], layer.yBand[1]) * H; // base where trunk stands
          const canopies = [];
          const cNum = randi(CANOPIES_PER_TREE[0], CANOPIES_PER_TREE[1]);

          for (let c = 0; c < cNum; c++) {
            const r = rand(layer.canopyR[0], layer.canopyR[1]);
            // Cluster around the trunk top
            const cx = x + rand(-r*0.6, r*0.6);
            const cy = (yBase - trunkH) + rand(-r*0.2, r*0.3);
            canopies.push({ x: cx, y: cy, r });
          }

          L.trees.push({ x, trunkW, trunkH, yBase, canopies });
        }
        // Spread trees across width (sort by x for consistent gaps)
        L.trees.sort((a,b)=>a.x-b.x);
        forest.push(L);
      }
    }

    buildForest();

    /* =======================
       GAME ENTITIES
    ======================= */
    function spawnBlossom() {
      if (!img.complete) return;
      const size = rand(BLOSSOM_SIZE_MIN, BLOSSOM_SIZE_MAX);
      const aspect = img.width / img.height || 1;
      const w = aspect >= 1 ? size*aspect : size;
      const h = aspect >= 1 ? size : size/aspect;
      blossoms.push({
        x: rand(w * 0.5, W - w * 0.5),
        y: -h - rand(0, 100),
        w, h,
        angle: rand(-Math.PI, Math.PI),
        rot: rand(-0.5, 0.5),
        vy: rand(FALL_SPEED_MIN, FALL_SPEED_MAX),
        vx: rand(-12, 12),
        cut: false
      });
    }

    function cutBlossom(b) {
      playSlash();
      const leftRect  = { sx: 0, sy: 0, sw: img.width/2, sh: img.height };
      const rightRect = { sx: img.width/2, sy: 0, sw: img.width/2, sh: img.height };
      const tw = b.w, th = b.h, tBorn = nowSec();
      shards.push({clip:leftRect,x:b.x-tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx:-SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot:-SHARD_ROT_SPEED,born:tBorn,life:SHARD_FADE_TIME});
      shards.push({clip:rightRect,x:b.x+tw/4,y:b.y,w:tw/2,h:th,angle:b.angle,vx:SHARD_SPREAD_SPEED*0.75,vy:-SHARD_SPREAD_SPEED*0.25,rot:SHARD_ROT_SPEED,born:tBorn,life:SHARD_FADE_TIME});
      b.cut = true;
    }

    let lastT = performance.now(), spawnTimer = 0, started = false;

    function tick(tMs) {
      if (!started) return;
      const dt = Math.min(0.033, (tMs - lastT) / 1000);
      lastT = tMs;

      // spawns
      spawnTimer += dt * 1000;
      if (spawnTimer > SPAWN_EVERY_MS && blossoms.length < MAX_FALLING) {
        spawnTimer = 0;
        spawnBlossom();
      }

      updateBackground(dt);
      updateBlossoms(dt);
      updateShards(dt);
      render();

      requestAnimationFrame(tick);
    }

    /* =======================
       BACKGROUND UPDATE/DRAW
    ======================= */
    function updateBackground(dt) {
      // horizontal parallax drift
      for (const L of forest) {
        L.offsetX = (L.offsetX - L.speed * 20 * dt) % W;
      }
    }

    function drawForestLayer(L) {
      ctx.save();
      ctx.translate(-L.offsetX, 0);

      // draw twice for seamless wrap
      for (let wrap = 0; wrap < 2; wrap++) {
        for (const t of L.trees) {
          // trunk
          ctx.fillStyle = L.trunkTint;
          ctx.fillRect(t.x, t.yBase - t.trunkH, t.trunkW, t.trunkH);

          // simple branches (two short diagonals) — very subtle
          ctx.save();
          ctx.strokeStyle = L.trunkTint;
          ctx.lineWidth = Math.max(1, t.trunkW * 0.12);
          ctx.beginPath();
          // left branch
          ctx.moveTo(t.x + t.trunkW*0.6, t.yBase - t.trunkH*0.65);
          ctx.lineTo(t.x - t.trunkW*1.2, t.yBase - t.trunkH*0.78);
          // right branch
          ctx.moveTo(t.x + t.trunkW*0.6, t.yBase - t.trunkH*0.48);
          ctx.lineTo(t.x + t.trunkW*2.0, t.yBase - t.trunkH*0.62);
          ctx.stroke();
          ctx.restore();

          // canopy (flat circles)
          ctx.fillStyle = L.canopyTint;
          for (const c of t.canopies) {
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
            ctx.fill();
          }
        }
        ctx.translate(W, 0);
      }
      ctx.restore();
    }

    function drawBackground() {
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, W, H);

      // slight bottom ground line (very soft)
      const groundGrad = ctx.createLinearGradient(0, H*0.84, 0, H);
      groundGrad.addColorStop(0, "rgba(0,0,0,0)");
      groundGrad.addColorStop(1, "rgba(0,0,0,0.06)");
      ctx.fillStyle = groundGrad;
      ctx.fillRect(0, H*0.84, W, H*0.16);

      // draw far to near
      drawForestLayer(forest[0]);
      drawForestLayer(forest[1]);

      // faint top vignette to frame petals
      const v = ctx.createLinearGradient(0, 0, 0, H*0.4);
      v.addColorStop(0.0, "rgba(0,0,0,0.05)");
      v.addColorStop(1.0, "rgba(0,0,0,0)");
      ctx.fillStyle = v;
      ctx.fillRect(0, 0, W, H*0.4);
    }

    /* =======================
       GAME RENDER/UPDATE
    ======================= */
    function updateBlossoms(dt) {
      for (let i = blossoms.length-1; i>=0; i--) {
        const b = blossoms[i];
        b.y += b.vy * dt;
        b.x += b.vx * dt;
        b.angle += b.rot * dt;
        const dx = pointer.x - b.x, dy = pointer.y - b.y;
        if (pointer.inside && !b.cut && dx*dx+dy*dy<=HOVER_CUT_RADIUS*HOVER_CUT_RADIUS) cutBlossom(b);
        if (b.cut || b.y - b.h/2 > H+40) blossoms.splice(i, 1);
      }
    }

    function updateShards(dt) {
      const t = nowSec();
      for (let i = shards.length-1; i>=0; i--) {
        const s = shards[i];
        s.x += s.vx * dt; s.y += s.vy * dt; s.vy += 420*dt; s.angle += s.rot * dt;
        if (t - s.born > s.life) shards.splice(i, 1);
      }
    }

    function render() {
      drawBackground();
      // Whole blossoms
      for (const b of blossoms) {
        ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle);
        ctx.drawImage(img,-b.w/2,-b.h/2,b.w,b.h); ctx.restore();
      }
      // Shards
      const t = nowSec();
      for (const s of shards) {
        const alpha = Math.max(0,1-(t-s.born)/s.life);
        ctx.save(); ctx.globalAlpha = alpha;
        ctx.translate(s.x,s.y); ctx.rotate(s.angle);
        ctx.drawImage(img,s.clip.sx,s.clip.sy,s.clip.sw,s.clip.sh,-s.w/2,-s.h/2,s.w,s.h);
        ctx.restore();
      }
    }

    /* ===== FULLSCREEN START ===== */
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    async function enterFullscreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    }

    startBtn.addEventListener('click', async () => {
      try { await enterFullscreen(); } catch(e) {}
      startOverlay.style.display = 'none';
      started = true;
      lastT = performance.now();
      if (img.complete) requestAnimationFrame(tick);
      else img.onload = () => requestAnimationFrame(tick);
    });
  })();
  </script>
</body>
</html>
