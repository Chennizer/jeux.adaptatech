<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title class="translate" data-fr="Dessiner dans les lignes" data-en="Draw within the lines">Dessiner dans les lignes</title>

  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />

  <style>
    :root {
      --page-bg: #0b0f14;
      --stage-bg: radial-gradient(1200px 600px at 60% -10%, #1a2330 0%, #0b0f14 60%, #080c11 100%);
      --panel-bg: rgba(15, 23, 42, 0.8);
      --panel-border: rgba(148, 163, 184, 0.25);
      --panel-shadow: 0 24px 60px rgba(8, 15, 26, 0.55);
      --teal: #009688;
      --teal-dark: #00796b;
    }

    body {
      background: var(--page-bg);
      color: #e2e8f0;
      font-family: "Segoe UI", system-ui, sans-serif;
      height: 100vh;
      margin: 0;
      overflow: hidden;
    }

    #langToggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 100000;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 2px solid var(--teal);
      background: #fff;
      color: var(--teal);
      font-weight: 700;
      cursor: pointer;
      user-select: none;
    }

    body.dark #langToggle {
      background: #111;
      color: #14b8a6;
      border-color: #14b8a6;
    }

    #game-options.modal {
      display: flex;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: flex-start;
      padding-top: 4vh;
      z-index: 90000;
    }

    #control-panel-options {
      background: rgba(255, 255, 255, 0.98);
      color: #0f172a;
      border-radius: 16px;
      border: 2px solid rgba(0, 150, 136, 0.25);
      box-shadow: 0 24px 80px rgba(15, 23, 42, 0.35);
      padding: 24px;
      width: min(960px, 94vw);
      max-width: 960px;
    }

    #options-title-bar h2 {
      margin: 0;
      text-align: center;
      color: var(--teal);
    }

    #mode-divider {
      background-color: rgba(0, 150, 136, 0.35);
    }

    #options-inline-container {
      margin-top: 20px;
    }

    #options-inline-container > .options-column {
      gap: 18px;
      padding: 0 12px;
    }

    #options-inline-container .option-item {
      width: 100%;
    }

    .option-item .value-tag {
      display: inline-block;
      margin-left: 8px;
      font-weight: 600;
      color: var(--teal-dark);
    }

    .styled-select {
      width: 100%;
    }

    .styled-slider {
      width: 100%;
    }

    .image-picker {
      position: relative;
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 6px;
    }

    .carousel-arrow {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: rgba(0, 150, 136, 0.18);
      color: var(--teal);
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s;
    }

    .carousel-arrow:hover {
      background: rgba(0, 150, 136, 0.35);
    }

    #pickerTrack {
      display: flex;
      gap: 10px;
      flex: 1;
      overflow-x: auto;
      scroll-snap-type: x mandatory;
      padding: 6px 4px;
    }

    #pickerTrack::-webkit-scrollbar {
      height: 6px;
    }

    #pickerTrack::-webkit-scrollbar-thumb {
      background: rgba(15, 23, 42, 0.25);
      border-radius: 999px;
    }

    .carousel-item {
      width: 88px;
      height: 88px;
      border-radius: 10px;
      border: 2px solid transparent;
      background: rgba(15, 23, 42, 0.06);
      box-shadow: 0 3px 10px rgba(15, 23, 42, 0.08);
      display: flex;
      align-items: center;
      justify-content: center;
      scroll-snap-align: center;
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    .carousel-item:hover {
      transform: translateY(-2px);
    }

    .carousel-item.selected {
      border-color: var(--teal);
      box-shadow: 0 6px 16px rgba(0, 150, 136, 0.25);
    }

    .carousel-item img,
    .carousel-item canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .picker-upload {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }

    .picker-btn {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      background: var(--teal);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0, 150, 136, 0.25);
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .picker-btn:hover {
      background: var(--teal-dark);
      transform: translateY(-1px);
    }

    .picker-preview {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .picker-preview img {
      width: 120px;
      height: 120px;
      object-fit: contain;
      border-radius: 14px;
      border: 2px solid rgba(15, 23, 42, 0.18);
      background: #fff;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.16);
      padding: 12px;
    }

    .option-hint {
      font-size: 0.8rem;
      text-align: center;
      color: rgba(15, 23, 42, 0.65);
    }

    .game-container {
      position: relative;
      display: none;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    .draw-layout {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: minmax(240px, 320px) 1fr;
    }

    .tool-panel {
      background: var(--panel-bg);
      border-right: 1px solid var(--panel-border);
      backdrop-filter: blur(12px);
      padding: 18px 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: var(--panel-shadow);
      z-index: 10;
    }

    .tool-panel h3 {
      margin: 0;
      font-size: 1.1rem;
      color: #f8fafc;
    }

    .tool-panel .control {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .tool-panel label {
      font-weight: 600;
      color: #cbd5f5;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .tool-panel input[type="range"] {
      width: 100%;
    }

    .tool-panel input[type="color"],
    .tool-panel select {
      width: 100%;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(226, 232, 240, 0.2);
      background: rgba(15, 23, 42, 0.65);
      color: #f8fafc;
      font-size: 0.95rem;
    }

    .tool-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .tool-actions button {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(226, 232, 240, 0.18);
      background: rgba(15, 23, 42, 0.6);
      color: #e2e8f0;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .tool-actions button:hover {
      background: rgba(14, 116, 144, 0.45);
      transform: translateY(-1px);
    }

    .canvas-stage {
      position: relative;
      background: var(--stage-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #ink,
    #outline {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      max-width: 100%;
    }

    .stage-badge {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(11, 21, 32, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    #menuButton {
      position: absolute;
      left: 18px;
      bottom: 18px;
      z-index: 20;
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      background: rgba(15, 23, 42, 0.78);
      color: #f8fafc;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid rgba(148, 163, 184, 0.35);
      transition: background 0.2s ease, transform 0.2s ease;
    }

    #menuButton:hover {
      background: rgba(14, 116, 144, 0.55);
      transform: translateY(-1px);
    }

    details.picker-tests {
      margin-top: 20px;
      border: 1px solid rgba(0, 150, 136, 0.35);
      border-radius: 12px;
      padding: 10px 14px;
      background: rgba(236, 254, 255, 0.35);
      color: #0f172a;
    }

    details.picker-tests summary {
      font-weight: 600;
      cursor: pointer;
    }

    #testResults {
      margin-top: 10px;
      font-size: 0.85rem;
      line-height: 1.4;
    }

    #testResults .ok {
      color: #15803d;
    }

    #testResults .bad {
      color: #b91c1c;
    }

    .empty-msg {
      display: grid;
      place-items: center;
      color: rgba(15, 23, 42, 0.55);
      font-weight: 600;
      width: 100%;
    }

    @media (max-width: 980px) {
      .draw-layout {
        grid-template-columns: 1fr;
      }
      .tool-panel {
        position: absolute;
        left: 12px;
        top: 12px;
        width: 220px;
        border-radius: 16px;
      }
      #menuButton {
        left: auto;
        right: 18px;
      }
    }

    @media (max-width: 640px) {
      #control-panel-options {
        padding: 18px 16px;
      }
      #options-inline-container {
        grid-template-columns: 1fr !important;
      }
      #options-inline-container > .options-column {
        border-right: none !important;
        padding: 0 !important;
      }
      .image-picker {
        justify-content: center;
      }
      #pickerTrack {
        justify-content: center;
      }
    }
  </style>

  <script src="../../js/cviPngArray.js" defer></script>
</head>
<body class="light">
  <button id="langToggle" class="translate" data-fr="FR / EN" data-en="EN / FR">FR / EN</button>

  <div id="game-options" class="modal" style="display: flex;">
    <div id="control-panel-options">
      <div id="options-title-bar">
        <h2 id="options-main-title" class="translate" data-fr="Dessiner dans les lignes" data-en="Draw within the lines">Dessiner dans les lignes</h2>
      </div>

      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <!-- Column 1: Tools -->
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label" for="setupBrush">
              <span class="translate" data-fr="Taille du pinceau" data-en="Brush size">Taille du pinceau</span>
              <span class="value-tag" id="setupBrushVal">18</span> px
            </label>
            <input type="range" id="setupBrush" class="styled-slider" min="3" max="64" value="18" />
          </div>

          <div class="option-item">
            <label class="teal-label" for="setupColor">
              <span class="translate" data-fr="Couleur du pinceau" data-en="Brush color">Couleur du pinceau</span>
            </label>
            <input type="color" id="setupColor" value="#ff7a59" />
          </div>

          <div class="option-item">
            <label class="teal-label" for="setupMode">
              <span class="translate" data-fr="Mode" data-en="Mode">Mode</span>
            </label>
            <select id="setupMode" class="styled-select">
              <option value="draw" class="translate" data-fr="Dessiner" data-en="Draw">Dessiner</option>
              <option value="erase" class="translate" data-fr="Effacer" data-en="Erase">Effacer</option>
            </select>
          </div>
        </div>

        <!-- Column 2: Image picker -->
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label label-block translate" for="pickerCategory" data-fr="Bibliothèque d'images" data-en="Image library">Bibliothèque d'images</label>
            <select id="pickerCategory" class="styled-select"></select>
          </div>

          <div class="option-item">
            <div class="image-picker">
              <button id="pickerPrev" class="carousel-arrow" aria-label="◀" type="button">◀</button>
              <div id="pickerTrack"></div>
              <button id="pickerNext" class="carousel-arrow" aria-label="▶" type="button">▶</button>
            </div>
          </div>

          <div class="option-item picker-upload" id="pickerUploadBar" style="display: none;">
            <input id="outlineFile" type="file" accept="image/png, image/svg+xml" hidden />
            <button id="pickerUploadBtn" type="button" class="picker-btn translate" data-fr="Téléverser un contour" data-en="Upload outline">Téléverser un contour</button>
          </div>

          <div class="option-item picker-preview">
            <img id="pickerPreview" alt="outline preview" src="" />
            <p id="pickerStatus" class="option-hint"></p>
          </div>
        </div>

        <!-- Column 3: Mask options + dwell -->
        <div class="options-column">
          <div class="option-item">
            <label class="teal-label" for="fitMode">
              <span class="translate" data-fr="Ajustement de l'image" data-en="Image fit">Ajustement de l'image</span>
            </label>
            <select id="fitMode" class="styled-select">
              <option value="contain" class="translate" data-fr="Adapter (conserver les proportions)" data-en="Contain (keep ratio)">Adapter (conserver les proportions)</option>
              <option value="cover" class="translate" data-fr="Recouvrir" data-en="Cover">Recouvrir</option>
              <option value="stretch" class="translate" data-fr="Étendre" data-en="Stretch">Étendre</option>
            </select>
          </div>

          <div class="option-item">
            <label class="teal-label" for="maskSource">
              <span class="translate" data-fr="Source du masque" data-en="Mask source">Source du masque</span>
            </label>
            <select id="maskSource" class="styled-select">
              <option value="alpha" class="translate" data-fr="Alpha (opaque = intérieur)" data-en="Alpha (opaque = inside)">Alpha (opaque = intérieur)</option>
              <option value="luma" class="translate" data-fr="Luminance (blanc = intérieur)" data-en="Luma (white = inside)">Luminance (blanc = intérieur)</option>
              <option value="alpha-invert" class="translate" data-fr="Alpha inversé" data-en="Alpha inverted">Alpha inversé</option>
            </select>
          </div>

          <div class="option-item">
            <label class="teal-label" for="dwellTimeSlider">
              <span class="translate" data-fr="Temps de fixation" data-en="Dwell time">Temps de fixation</span>
              <span class="value-tag" id="dwellTimeVal">1500</span> ms
            </label>
            <input type="range" id="dwellTimeSlider" class="styled-slider" min="500" max="5000" step="100" value="1500" />
          </div>

          <details class="picker-tests">
            <summary class="translate" data-fr="Diagnostics" data-en="Diagnostics">Diagnostics</summary>
            <div class="option-item" style="margin-top: 10px;">
              <button id="runTests" type="button" class="picker-btn translate" data-fr="Lancer les tests" data-en="Run tests">Lancer les tests</button>
            </div>
            <div id="testResults">No tests run yet.</div>
          </details>
        </div>
      </div>

      <div id="mode-divider"></div>
      <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
    </div>
  </div>

  <div class="game-container">
    <div class="draw-layout">
      <aside class="tool-panel">
        <h3 class="translate" data-fr="Outils" data-en="Tools">Outils</h3>
        <div class="control">
          <label for="brushSlider">
            <span class="translate" data-fr="Taille" data-en="Size">Taille</span>
            <span id="brushValue">18</span> px
          </label>
          <input type="range" id="brushSlider" min="3" max="64" value="18" />
        </div>
        <div class="control">
          <label for="brushColor" class="translate" data-fr="Couleur" data-en="Color">Couleur</label>
          <input type="color" id="brushColor" value="#ff7a59" />
        </div>
        <div class="control">
          <label for="brushMode" class="translate" data-fr="Mode" data-en="Mode">Mode</label>
          <select id="brushMode">
            <option value="draw" class="translate" data-fr="Dessiner" data-en="Draw">Dessiner</option>
            <option value="erase" class="translate" data-fr="Effacer" data-en="Erase">Effacer</option>
          </select>
        </div>
        <div class="tool-actions">
          <button id="clearCanvas" type="button" class="translate" data-fr="Tout effacer" data-en="Clear">Tout effacer</button>
          <button id="downloadCanvas" type="button" class="translate" data-fr="Sauvegarder" data-en="Save">Sauvegarder</button>
        </div>
      </aside>

      <main class="canvas-stage">
        <div class="stage-badge translate" data-fr="Zone de dessin" data-en="Drawing area">Zone de dessin</div>
        <canvas id="ink" width="1400" height="900" aria-label="Calque d'encre"></canvas>
        <canvas id="outline" width="1400" height="900" aria-label="Calque de contour"></canvas>
        <button id="menuButton" type="button" class="translate" data-fr="Menu" data-en="Menu">Menu</button>
      </main>
    </div>
  </div>

  <script src="../../js/translationonly.js"></script>
  <script src="../../js/eyegaze-menu.js"></script>

  <script>
    const LS_LANG_KEY = 'siteLanguage';

    function getLang() {
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr') {
          return saved;
        }
      } catch (e) {}
      return document.documentElement.lang === 'en' ? 'en' : 'fr';
    }

    function setLang(lang) {
      const safe = lang === 'en' ? 'en' : 'fr';
      document.documentElement.lang = safe;
      try {
        localStorage.setItem(LS_LANG_KEY, safe);
      } catch (e) {}
      document.querySelectorAll('.translate').forEach(el => {
        const fr = el.getAttribute('data-fr');
        const en = el.getAttribute('data-en');
        if (safe === 'fr' && fr != null) el.textContent = fr;
        if (safe === 'en' && en != null) el.textContent = en;
      });
      updatePickerStatus();
    }

    function initLang() {
      let initial = 'fr';
      try {
        const saved = localStorage.getItem(LS_LANG_KEY);
        if (saved === 'en' || saved === 'fr') {
          initial = saved;
        } else {
          initial = document.documentElement.lang === 'en' ? 'en' : 'fr';
          localStorage.setItem(LS_LANG_KEY, initial);
        }
      } catch (e) {
        initial = document.documentElement.lang === 'en' ? 'en' : 'fr';
      }
      setLang(initial);
    }

    const ink = document.getElementById('ink');
    const out = document.getElementById('outline');
    const ic = ink.getContext('2d');
    const oc = out.getContext('2d');

    let resizePending = false;
    function fitCanvas(cnv) {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = cnv.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width * dpr));
      const h = Math.max(1, Math.round(rect.height * dpr));
      if (cnv.width !== w || cnv.height !== h) {
        cnv.width = w;
        cnv.height = h;
        const ctx = cnv.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }

    function resizeAllImmediate() {
      fitCanvas(ink);
      fitCanvas(out);
      drawOutline();
      syncScratch();
      rebuildMaskCache();
    }

    function requestResize() {
      if (resizePending) return;
      resizePending = true;
      requestAnimationFrame(() => {
        resizePending = false;
        resizeAllImmediate();
      });
    }

    const ro = new ResizeObserver(() => {
      requestResize();
    });
    ro.observe(out);

    const overlay = document.getElementById('game-options');
    const gameContainer = document.querySelector('.game-container');
    const startButton = document.getElementById('startButton');
    const menuButton = document.getElementById('menuButton');
    const langToggle = document.getElementById('langToggle');

    const brushSetup = document.getElementById('setupBrush');
    const brushSetupVal = document.getElementById('setupBrushVal');
    const colorSetup = document.getElementById('setupColor');
    const modeSetup = document.getElementById('setupMode');

    const brushSlider = document.getElementById('brushSlider');
    const brushValue = document.getElementById('brushValue');
    const colorPicker = document.getElementById('brushColor');
    const modeSelect = document.getElementById('brushMode');
    const clearBtn = document.getElementById('clearCanvas');
    const downloadBtn = document.getElementById('downloadCanvas');

    const fitModeEl = document.getElementById('fitMode');
    const maskSourceEl = document.getElementById('maskSource');
    const outlineFileEl = document.getElementById('outlineFile');

    const pickerCategory = document.getElementById('pickerCategory');
    const pickerTrack = document.getElementById('pickerTrack');
    const pickerPrev = document.getElementById('pickerPrev');
    const pickerNext = document.getElementById('pickerNext');
    const pickerPreview = document.getElementById('pickerPreview');
    const pickerStatus = document.getElementById('pickerStatus');
    const pickerUploadBtn = document.getElementById('pickerUploadBtn');
    const pickerUploadBar = document.getElementById('pickerUploadBar');

    const runTestsBtn = document.getElementById('runTests');
    const testResults = document.getElementById('testResults');

    const builtInShapes = [
      { id: 'blob', name: { fr: 'Forme organique', en: 'Organic shape' }, thumb: null },
      { id: 'star', name: { fr: 'Étoile', en: 'Star' }, thumb: null },
      { id: 'heart', name: { fr: 'Cœur', en: 'Heart' }, thumb: null },
      { id: 'rect', name: { fr: 'Rectangle arrondi', en: 'Rounded rectangle' }, thumb: null }
    ];

    function generateShapeThumb(shape) {
      const size = 120;
      const cnv = document.createElement('canvas');
      cnv.width = size;
      cnv.height = size;
      const ctx = cnv.getContext('2d');
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, size, size);
      ctx.translate(size / 2, size / 2);
      ctx.fillStyle = '#38bdf8';
      ctx.strokeStyle = '#38bdf8';
      ctx.lineWidth = 8;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      if (shape === 'blob') {
        ctx.moveTo(0, -36);
        ctx.bezierCurveTo(34, -36, 48, -6, 48, 0);
        ctx.bezierCurveTo(48, 34, 24, 48, 0, 48);
        ctx.bezierCurveTo(-30, 48, -48, 30, -48, 0);
        ctx.bezierCurveTo(-48, -32, -14, -44, 0, -36);
      } else if (shape === 'star') {
        const spikes = 5;
        const outer = 48;
        const inner = 22;
        let rot = Math.PI / 2 * 3;
        ctx.moveTo(0, -outer);
        for (let i = 0; i < spikes; i++) {
          ctx.lineTo(Math.cos(rot) * outer, Math.sin(rot) * outer);
          rot += Math.PI / spikes;
          ctx.lineTo(Math.cos(rot) * inner, Math.sin(rot) * inner);
          rot += Math.PI / spikes;
        }
      } else if (shape === 'heart') {
        ctx.moveTo(0, -18);
        ctx.bezierCurveTo(30, -58, 68, -6, 0, 48);
        ctx.bezierCurveTo(-68, -6, -30, -58, 0, -18);
      } else if (shape === 'rect') {
        const r = 28;
        const w = 84;
        const h = 64;
        ctx.moveTo(-w / 2 + r, -h / 2);
        ctx.lineTo(w / 2 - r, -h / 2);
        ctx.quadraticCurveTo(w / 2, -h / 2, w / 2, -h / 2 + r);
        ctx.lineTo(w / 2, h / 2 - r);
        ctx.quadraticCurveTo(w / 2, h / 2, w / 2 - r, h / 2);
        ctx.lineTo(-w / 2 + r, h / 2);
        ctx.quadraticCurveTo(-w / 2, h / 2, -w / 2, h / 2 - r);
        ctx.lineTo(-w / 2, -h / 2 + r);
        ctx.quadraticCurveTo(-w / 2, -h / 2, -w / 2 + r, -h / 2);
      }
      ctx.closePath();
      ctx.fill();
      return cnv.toDataURL();
    }

    builtInShapes.forEach(shape => {
      shape.thumb = generateShapeThumb(shape.id);
    });

    const CATEGORY_UPLOADS = 'uploads';
    const categoryOrder = [];
    const categoryMap = new Map();

    function ensureCategory(id, labelFr, labelEn, allowUpload = false, position = 'end') {
      if (categoryMap.has(id)) return categoryMap.get(id);
      const cat = { id, labelFr, labelEn, allowUpload, items: [] };
      if (position === 'beforeUploads') {
        const uploadIndex = categoryOrder.findIndex(c => c.id === CATEGORY_UPLOADS);
        if (uploadIndex >= 0) {
          categoryOrder.splice(uploadIndex, 0, cat);
        } else {
          categoryOrder.push(cat);
        }
      } else {
        categoryOrder.push(cat);
      }
      categoryMap.set(id, cat);
      return cat;
    }

    ensureCategory('builtins', 'Formes intégrées', 'Built-in shapes', false, 'beforeUploads');
    categoryMap.get('builtins').items = builtInShapes.map(s => ({
      type: 'shape',
      shape: s.id,
      thumb: s.thumb,
      labelFr: s.name.fr,
      labelEn: s.name.en
    }));
    ensureCategory(CATEGORY_UPLOADS, 'Mes images', 'My images', true, 'end');

    const pickerState = { category: 'builtins', selectedIndex: 0 };
    let pngCategoriesLoaded = false;

    function getItems(catId) {
      const cat = categoryMap.get(catId);
      return cat ? cat.items : [];
    }

    function renderCategoryOptions() {
      const current = pickerState.category;
      pickerCategory.innerHTML = '';
      categoryOrder.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.classList.add('translate');
        option.setAttribute('data-fr', cat.labelFr);
        option.setAttribute('data-en', cat.labelEn);
        option.textContent = getLang() === 'fr' ? cat.labelFr : cat.labelEn;
        pickerCategory.appendChild(option);
      });
      if (!categoryMap.has(current)) {
        pickerState.category = categoryOrder[0] ? categoryOrder[0].id : 'builtins';
      }
      pickerCategory.value = pickerState.category;
      updateUploadVisibility();
    }

    function updateUploadVisibility() {
      const cat = categoryMap.get(pickerState.category);
      pickerUploadBar.style.display = cat && cat.allowUpload ? 'flex' : 'none';
    }

    function updatePreview(item) {
      if (!item) {
        pickerPreview.src = '';
        pickerPreview.style.visibility = 'hidden';
        pickerPreview.alt = '';
        return;
      }
      pickerPreview.src = item.thumb;
      pickerPreview.alt = item.labelEn || '';
      pickerPreview.style.visibility = 'visible';
    }

    function updatePickerStatus() {
      if (!pickerStatus) return;
      const lang = getLang();
      const items = getItems(pickerState.category);
      let msg;
      if (!items.length) {
        msg = lang === 'fr'
          ? 'Aucune image dans cette catégorie. Téléversez un contour ou changez de catégorie.'
          : 'No images in this category. Upload an outline or choose another category.';
      } else {
        msg = lang === 'fr'
          ? `${items.length} image(s) disponibles dans cette catégorie.`
          : `${items.length} image(s) available in this category.`;
      }
      if (!pngCategoriesLoaded) {
        msg += lang === 'fr'
          ? ' La bibliothèque optionnelle se chargera si elle est disponible.'
          : ' The optional library will load if available.';
      } else if (window.PNG_ARRAY && window.PNG_ARRAY.length) {
        msg += lang === 'fr'
          ? ` (${window.PNG_ARRAY.length} contours préchargés.)`
          : ` (${window.PNG_ARRAY.length} preset outlines.)`;
      }
      pickerStatus.textContent = msg;
    }

    function applySelection(item) {
      if (!item) {
        userMask = null;
        maskImageData = null;
        drawOutline();
        return;
      }
      if (item.type === 'shape') {
        currentShape = item.shape;
        userMask = null;
        maskImageData = null;
        drawOutline();
      } else {
        userMask = null;
        maskImageData = null;
        loadUserMaskFromURL(item.src);
      }
    }

    function renderCarousel() {
      const items = getItems(pickerState.category);
      pickerTrack.innerHTML = '';
      pickerTrack.scrollTo({ left: 0 });
      if (!items.length) {
        const empty = document.createElement('div');
        empty.className = 'empty-msg translate';
        empty.setAttribute('data-fr', 'Aucune image');
        empty.setAttribute('data-en', 'No images');
        empty.textContent = getLang() === 'fr' ? 'Aucune image' : 'No images';
        pickerTrack.appendChild(empty);
        updatePreview(null);
        updatePickerStatus();
        return;
      }
      if (pickerState.selectedIndex >= items.length) {
        pickerState.selectedIndex = 0;
      }
      items.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = 'carousel-item';
        const img = document.createElement('img');
        img.src = item.thumb;
        img.alt = item.labelEn || '';
        div.appendChild(img);
        if (idx === pickerState.selectedIndex) {
          div.classList.add('selected');
        }
        div.addEventListener('click', () => {
          pickerTrack.querySelectorAll('.carousel-item.selected').forEach(el => el.classList.remove('selected'));
          div.classList.add('selected');
          pickerState.selectedIndex = idx;
          applySelection(items[idx]);
          updatePreview(items[idx]);
          updatePickerStatus();
        });
        pickerTrack.appendChild(div);
      });
      const selected = items[pickerState.selectedIndex];
      applySelection(selected);
      updatePreview(selected);
      updatePickerStatus();
    }

    function integratePngArray() {
      if (pngCategoriesLoaded) return;
      if (!window.PNG_ARRAY || !Array.isArray(window.PNG_ARRAY) || !window.PNG_ARRAY.length) return;
      const grouped = new Map();
      window.PNG_ARRAY.forEach(item => {
        if (!item || !item.category || !item.file) return;
        const key = `preset:${item.category}`;
        if (!grouped.has(key)) grouped.set(key, []);
        grouped.get(key).push(item);
      });
      const entries = Array.from(grouped.entries()).sort((a, b) => a[0].localeCompare(b[0]));
      entries.forEach(([key, items]) => {
        const label = items[0]?.category || key.replace('preset:', '');
        const cat = ensureCategory(key, label, label, false, 'beforeUploads');
        cat.items = items
          .slice()
          .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
          .map(entry => ({
            type: 'preset',
            src: entry.file,
            thumb: entry.file,
            labelFr: entry.name || entry.file,
            labelEn: entry.name || entry.file
          }));
      });
      pngCategoriesLoaded = true;
      renderCategoryOptions();
      renderCarousel();
      updatePickerStatus();
    }

    function handleUploadFiles(files) {
      files.forEach(file => {
        if (!file || !file.type || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = e => {
          const dataUrl = e.target?.result;
          if (!dataUrl) return;
          const cat = ensureCategory(CATEGORY_UPLOADS, 'Mes images', 'My images', true, 'end');
          const item = {
            type: 'upload',
            src: dataUrl,
            thumb: dataUrl,
            labelFr: file.name,
            labelEn: file.name
          };
          cat.items.push(item);
          pickerState.category = CATEGORY_UPLOADS;
          pickerState.selectedIndex = cat.items.length - 1;
          renderCategoryOptions();
          renderCarousel();
        };
        reader.readAsDataURL(file);
      });
      outlineFileEl.value = '';
    }

    pickerCategory.addEventListener('change', () => {
      pickerState.category = pickerCategory.value;
      pickerState.selectedIndex = 0;
      updateUploadVisibility();
      renderCarousel();
    });

    pickerPrev.addEventListener('click', () => {
      pickerTrack.scrollBy({ left: -pickerTrack.clientWidth * 0.9, behavior: 'smooth' });
    });
    pickerNext.addEventListener('click', () => {
      pickerTrack.scrollBy({ left: pickerTrack.clientWidth * 0.9, behavior: 'smooth' });
    });

    pickerUploadBtn.addEventListener('click', () => {
      outlineFileEl.click();
    });

    outlineFileEl.addEventListener('change', e => {
      const files = Array.from(e.target.files || []);
      handleUploadFiles(files);
    });

    function syncBrush(value) {
      const v = Math.round(Number(value));
      if (Number(brushSetup.value) !== v) brushSetup.value = v;
      if (Number(brushSlider.value) !== v) brushSlider.value = v;
      brushSetupVal.textContent = v;
      brushValue.textContent = v;
    }

    function syncColor(value) {
      if (colorSetup.value !== value) colorSetup.value = value;
      if (colorPicker.value !== value) colorPicker.value = value;
    }

    function syncMode(value) {
      if (modeSetup.value !== value) modeSetup.value = value;
      if (modeSelect.value !== value) modeSelect.value = value;
    }

    brushSetup.addEventListener('input', () => syncBrush(brushSetup.value));
    brushSlider.addEventListener('input', () => syncBrush(brushSlider.value));
    colorSetup.addEventListener('input', () => syncColor(colorSetup.value));
    colorPicker.addEventListener('input', () => syncColor(colorPicker.value));
    modeSetup.addEventListener('change', () => syncMode(modeSetup.value));
    modeSelect.addEventListener('change', () => syncMode(modeSelect.value));

    clearBtn.addEventListener('click', () => {
      ic.clearRect(0, 0, ink.width, ink.height);
    });

    downloadBtn.addEventListener('click', () => {
      const url = mergeForExport();
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drawing.png';
      a.click();
    });

    fitModeEl.addEventListener('change', () => {
      rebuildMaskCache();
      redrawMaskGuide();
    });

    maskSourceEl.addEventListener('change', () => {
      rebuildMaskCache();
      redrawMaskGuide();
    });

    startButton.addEventListener('click', () => {
      overlay.style.display = 'none';
      gameContainer.style.display = 'block';
      requestResize();
    });

    menuButton.addEventListener('click', () => {
      overlay.style.display = 'flex';
    });

    let currentShape = 'blob';
    let shapePath = null;

    function makePath(kind, w, h) {
      const p = new Path2D();
      const pad = Math.min(w, h) * 0.12;
      const cx = w / 2;
      const cy = h / 2;
      if (kind === 'rect') {
        const r = Math.min(w, h) * 0.18;
        const x = pad;
        const y = pad;
        const rw = w - 2 * pad;
        const rh = h - 2 * pad;
        roundRectPath(p, x, y, rw, rh, r);
      } else if (kind === 'blob') {
        const rx = w * 0.32;
        const ry = h * 0.28;
        blobPath(p, cx, cy, rx, ry);
      } else if (kind === 'star') {
        starPath(p, cx, cy, Math.min(w, h) * 0.36, 5);
      } else if (kind === 'heart') {
        heartPath(p, cx, cy, Math.min(w, h) * 0.36);
      }
      return p;
    }

    function roundRectPath(p, x, y, w, h, r) {
      p.moveTo(x + r, y);
      p.arcTo(x + w, y, x + w, y + h, r);
      p.arcTo(x + w, y + h, x, y + h, r);
      p.arcTo(x, y + h, x, y, r);
      p.arcTo(x, y, x + w, y, r);
      p.closePath();
    }

    function blobPath(p, cx, cy, rx, ry) {
      p.moveTo(cx, cy - ry);
      p.bezierCurveTo(cx + rx * 0.6, cy - ry, cx + rx, cy - ry * 0.2, cx + rx, cy);
      p.bezierCurveTo(cx + rx, cy + ry * 0.6, cx + rx * 0.4, cy + ry, cx, cy + ry);
      p.bezierCurveTo(cx - rx * 0.6, cy + ry, cx - rx, cy + ry * 0.2, cx - rx, cy);
      p.bezierCurveTo(cx - rx, cy - ry * 0.6, cx - rx * 0.4, cy - ry, cx, cy - ry);
      p.closePath();
    }

    function starPath(p, cx, cy, r, spikes) {
      const step = Math.PI / spikes;
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy - r;
      p.moveTo(cx, cy - r);
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * r;
        y = cy + Math.sin(rot) * r;
        p.lineTo(x, y);
        rot += step;
        x = cx + Math.cos(rot) * r * 0.5;
        y = cy + Math.sin(rot) * r * 0.5;
        p.lineTo(x, y);
        rot += step;
      }
      p.closePath();
    }

    function heartPath(p, cx, cy, s) {
      const top = cy - s * 0.25;
      p.moveTo(cx, top);
      p.bezierCurveTo(cx + s * 0.5, top - s * 0.6, cx + s, cy - s * 0.05, cx, cy + s * 0.75);
      p.bezierCurveTo(cx - s, cy - s * 0.05, cx - s * 0.5, top - s * 0.6, cx, top);
      p.closePath();
    }

    function drawOutline() {
      const rect = out.getBoundingClientRect();
      shapePath = makePath(currentShape, rect.width, rect.height);
      oc.clearRect(0, 0, out.width, out.height);
      if (userMask) {
        redrawMaskGuide();
      } else if (shapePath) {
        oc.save();
        oc.fillStyle = 'white';
        oc.globalAlpha = 0.06;
        oc.fill(shapePath);
        oc.globalAlpha = 1;
        oc.lineWidth = 6;
        oc.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--edge') || '#e2e8f0';
        oc.stroke(shapePath);
        oc.restore();
      }
    }

    let userMask = null;
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    let maskImageData = null;

    function loadUserMaskFromURL(url, revoke = false) {
      const img = new Image();
      img.onload = () => {
        if (revoke) URL.revokeObjectURL(url);
        userMask = img;
        rebuildMaskCache();
        drawOutline();
      };
      img.onerror = () => {
        if (revoke) URL.revokeObjectURL(url);
        alert('Could not load image. Try a PNG or SVG.');
      };
      img.src = url;
    }

    function computeFit(destW, destH, imgW, imgH, mode) {
      if (mode === 'stretch') return { x: 0, y: 0, w: destW, h: destH };
      const r = imgW / imgH;
      const R = destW / destH;
      if (mode === 'cover') {
        const w = R > r ? destW : destH * r;
        const h = R > r ? destW / r : destH;
        const x = (destW - w) / 2;
        const y = (destH - h) / 2;
        return { x, y, w, h };
      } else {
        const w = R > r ? destH * r : destW;
        const h = R > r ? destH : destW / r;
        const x = (destW - w) / 2;
        const y = (destH - h) / 2;
        return { x, y, w, h };
      }
    }

    function rebuildMaskCache() {
      if (!userMask) {
        maskImageData = null;
        return;
      }
      maskCanvas.width = out.width;
      maskCanvas.height = out.height;
      maskCtx.setTransform(oc.getTransform());
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      maskCtx.drawImage(userMask, fit.x, fit.y, fit.w, fit.h);

      const img = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
      const data = img.data;
      const mode = maskSourceEl.value;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];
        let alpha = a;
        if (mode === 'luma') {
          const y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          alpha = y;
        } else if (mode === 'alpha-invert') {
          alpha = 255 - a;
        }
        data[i] = 255;
        data[i + 1] = 255;
        data[i + 2] = 255;
        data[i + 3] = alpha;
      }
      maskCtx.putImageData(img, 0, 0);
      maskImageData = img;
    }

    function redrawMaskGuide() {
      oc.clearRect(0, 0, out.width, out.height);
      if (!userMask) {
        if (shapePath) {
          oc.save();
          oc.fillStyle = 'white';
          oc.globalAlpha = 0.06;
          oc.fill(shapePath);
          oc.globalAlpha = 1;
          oc.lineWidth = 6;
          oc.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--edge') || '#e2e8f0';
          oc.stroke(shapePath);
          oc.restore();
        }
        return;
      }
      const rect = out.getBoundingClientRect();
      const fit = computeFit(rect.width, rect.height, userMask.naturalWidth, userMask.naturalHeight, fitModeEl.value);
      oc.save();
      oc.globalAlpha = 0.25;
      oc.drawImage(userMask, fit.x, fit.y, fit.w, fit.h);
      oc.restore();
    }

    let drawing = false;
    let prev = null;

    const supportsPathClip = (() => {
      try {
        const c = document.createElement('canvas').getContext('2d');
        const p = new Path2D();
        p.rect(0, 0, 1, 1);
        c.save();
        c.clip(p);
        c.restore();
        return true;
      } catch (e) {
        return false;
      }
    })();

    const scratch = document.createElement('canvas');
    const sc = scratch.getContext('2d');

    function syncScratch() {
      scratch.width = ink.width;
      scratch.height = ink.height;
      sc.setTransform(ic.getTransform());
      sc.clearRect(0, 0, scratch.width, scratch.height);
    }

    function getPos(e) {
      const r = ink.getBoundingClientRect();
      if (e.touches && e.touches[0]) {
        return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top };
      }
      return { x: (e.clientX || e.x) - r.left, y: (e.clientY || e.y) - r.top };
    }

    function begin(e) {
      drawing = true;
      prev = getPos(e);
      e.preventDefault();
    }

    function end() {
      drawing = false;
      prev = null;
    }

    function draw(e) {
      if (!drawing) return;
      const cur = getPos(e);
      const size = Number(brushSlider.value);
      const color = colorPicker.value;
      const erasing = modeSelect.value === 'erase';

      if (userMask) {
        sc.save();
        sc.lineCap = 'round';
        sc.lineJoin = 'round';
        sc.lineWidth = size;
        sc.globalCompositeOperation = 'source-over';
        sc.strokeStyle = erasing ? '#000' : color;
        sc.beginPath();
        sc.moveTo(prev.x, prev.y);
        sc.lineTo(cur.x, cur.y);
        sc.stroke();
        sc.globalCompositeOperation = 'destination-in';
        sc.drawImage(maskCanvas, 0, 0);
        sc.restore();

        ic.save();
        ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
        ic.drawImage(scratch, 0, 0);
        ic.restore();
        sc.clearRect(0, 0, scratch.width, scratch.height);
      } else {
        if (!shapePath) return;
        if (supportsPathClip) {
          ic.save();
          ic.clip(shapePath);
          ic.lineCap = 'round';
          ic.lineJoin = 'round';
          ic.lineWidth = size;
          ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
          ic.strokeStyle = erasing ? 'rgba(0,0,0,1)' : color;
          ic.beginPath();
          ic.moveTo(prev.x, prev.y);
          ic.lineTo(cur.x, cur.y);
          ic.stroke();
          ic.restore();
        } else {
          if (!maskImageData) {
            maskCanvas.width = out.width;
            maskCanvas.height = out.height;
            maskCtx.setTransform(oc.getTransform());
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            maskCtx.fillStyle = '#fff';
            maskCtx.fill(shapePath);
            maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
          }
          sc.save();
          sc.lineCap = 'round';
          sc.lineJoin = 'round';
          sc.lineWidth = size;
          sc.globalCompositeOperation = 'source-over';
          sc.strokeStyle = erasing ? '#000' : color;
          sc.beginPath();
          sc.moveTo(prev.x, prev.y);
          sc.lineTo(cur.x, cur.y);
          sc.stroke();
          sc.globalCompositeOperation = 'destination-in';
          sc.putImageData(maskImageData, 0, 0);
          sc.restore();
          ic.save();
          ic.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
          ic.drawImage(scratch, 0, 0);
          ic.restore();
          sc.clearRect(0, 0, scratch.width, scratch.height);
        }
      }

      prev = cur;
      e.preventDefault();
    }

    ink.addEventListener('pointerdown', begin);
    window.addEventListener('pointerup', end);
    window.addEventListener('pointercancel', end);
    window.addEventListener('pointerout', e => {
      if (e.target === ink) end();
    });
    window.addEventListener('pointermove', draw, { passive: false });
    ink.addEventListener('touchstart', begin, { passive: false });
    window.addEventListener('touchend', end, { passive: false });
    window.addEventListener('touchmove', draw, { passive: false });

    function mergeForExport() {
      const merge = document.createElement('canvas');
      merge.width = ink.width;
      merge.height = ink.height;
      const mc = merge.getContext('2d');
      mc.setTransform(ic.getTransform());
      mc.drawImage(out, 0, 0);
      mc.drawImage(ink, 0, 0);
      return merge.toDataURL('image/png');
    }

    runTestsBtn?.addEventListener('click', runSelfTests);

    function runSelfTests() {
      const results = [];
      try {
        results.push(['API: Path2D exists', typeof Path2D === 'function']);
        results.push(['API: Have clip(Path2D) OR fallback mask', typeof ic.clip === 'function' || true]);

        const c = document.createElement('canvas');
        c.width = 100;
        c.height = 100;
        const ctx = c.getContext('2d');
        const rect = new Path2D();
        rect.rect(20, 20, 60, 60);
        try {
          ctx.save();
          ctx.clip(rect);
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(0, 10);
          ctx.lineTo(100, 10);
          ctx.stroke();
          ctx.restore();
        } catch (e) {}
        const pxOutside = ctx.getImageData(10, 10, 1, 1).data[3];
        results.push(['Clip: outside does not render', pxOutside === 0]);
        try {
          ctx.save();
          ctx.clip(rect);
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(10, 50);
          ctx.lineTo(90, 50);
          ctx.stroke();
          ctx.restore();
        } catch (e) {}
        const pxInside = ctx.getImageData(50, 50, 1, 1).data[3];
        results.push(['Clip: inside renders', pxInside > 0]);

        const ctx2 = document.createElement('canvas').getContext('2d');
        ctx2.canvas.width = 100;
        ctx2.canvas.height = 100;
        try {
          ctx2.save();
          ctx2.clip(rect);
        } catch (e) {}
        ctx2.fillStyle = '#fff';
        ctx2.fillRect(20, 20, 60, 60);
        ctx2.restore?.();
        ctx2.save?.();
        try {
          ctx2.clip(rect);
        } catch (e) {}
        ctx2.globalCompositeOperation = 'destination-out';
        ctx2.lineWidth = 8;
        ctx2.strokeStyle = 'rgba(0,0,0,1)';
        ctx2.beginPath();
        ctx2.moveTo(20, 50);
        ctx2.lineTo(80, 50);
        ctx2.stroke();
        ctx2.restore?.();
        const erased = ctx2.getImageData(50, 50, 1, 1).data[3];
        results.push(['Erase: destination-out clears pixels', erased === 0]);

        const fc = document.createElement('canvas');
        fc.width = 100;
        fc.height = 100;
        const fctx = fc.getContext('2d');
        const fScratch = document.createElement('canvas');
        fScratch.width = 100;
        fScratch.height = 100;
        const fsc = fScratch.getContext('2d');
        const fRect = new Path2D();
        fRect.rect(20, 20, 60, 60);
        fsc.save();
        fsc.strokeStyle = '#fff';
        fsc.lineWidth = 6;
        fsc.beginPath();
        fsc.moveTo(0, 10);
        fsc.lineTo(100, 10);
        fsc.stroke();
        fsc.globalCompositeOperation = 'destination-in';
        fsc.fillStyle = '#fff';
        fsc.fill(fRect);
        fsc.restore();
        fctx.drawImage(fScratch, 0, 0);
        const fOutside = fctx.getImageData(10, 10, 1, 1).data[3];
        results.push(['Mask fallback: outside does not render', fOutside === 0]);
        fsc.clearRect(0, 0, 100, 100);
        fsc.save();
        fsc.strokeStyle = '#fff';
        fsc.lineWidth = 6;
        fsc.beginPath();
        fsc.moveTo(10, 50);
        fsc.lineTo(90, 50);
        fsc.stroke();
        fsc.globalCompositeOperation = 'destination-in';
        fsc.fillStyle = '#fff';
        fsc.fill(fRect);
        fsc.restore();
        fctx.clearRect(0, 0, 100, 100);
        fctx.drawImage(fScratch, 0, 0);
        const fInside = fctx.getImageData(50, 50, 1, 1).data[3];
        results.push(['Mask fallback: inside renders', fInside > 0]);

        const testInk = document.createElement('canvas');
        testInk.width = 50;
        testInk.height = 50;
        const ti = testInk.getContext('2d');
        const testOut = document.createElement('canvas');
        testOut.width = 50;
        testOut.height = 50;
        const to = testOut.getContext('2d');
        ti.fillStyle = '#fff';
        ti.fillRect(10, 10, 10, 10);
        to.strokeStyle = '#fff';
        to.strokeRect(5, 5, 20, 20);
        const merged = (() => {
          const merge = document.createElement('canvas');
          merge.width = 50;
          merge.height = 50;
          const mc = merge.getContext('2d');
          mc.drawImage(testOut, 0, 0);
          mc.drawImage(testInk, 0, 0);
          return mc.getImageData(12, 12, 1, 1).data[3];
        })();
        results.push(['Export: merged image contains pixels', merged > 0]);

        const fake = [
          { name: 'a', file: 'a.png', category: 'x' },
          { name: 'b', file: 'b.png', category: 'y' },
          { name: 'c', file: 'c.png', category: 'x' }
        ];
        const cats = [...new Set(fake.map(x => x.category))].sort();
        results.push(['Presets: unique categories computed', cats.join(',') === 'x,y']);
        const inX = fake.filter(x => x.category === 'x').map(x => x.name).sort().join(',');
        results.push(['Presets: items filter by category', inX === 'a,c']);
      } catch (err) {
        results.push([`Exception during tests: ${err?.message || err}`, false]);
      }

      testResults.innerHTML = results
        .map(([name, ok]) => ok ? `<div class="ok">✔ ${name}</div>` : `<div class="bad">✖ ${name}</div>`)
        .join('');
    }

    syncBrush(brushSlider.value);
    syncColor(colorPicker.value);
    syncMode(modeSelect.value);

    renderCategoryOptions();
    renderCarousel();
    updatePickerStatus();

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(integratePngArray, 0);
    } else {
      window.addEventListener('DOMContentLoaded', () => setTimeout(integratePngArray, 0));
    }

    setTimeout(() => {
      if (!pngCategoriesLoaded) integratePngArray();
    }, 1500);

    langToggle?.addEventListener('click', () => {
      setLang(getLang() === 'fr' ? 'en' : 'fr');
    });

    initLang();
    initEyegazeMenu();
  </script>
</body>
</html>
