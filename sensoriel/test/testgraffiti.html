<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Centered Tag Style Graffiti</title>

  <!-- Shared switch-game styling -->
  <link rel="stylesheet" href="../../css/otherswitch.css">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap');

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Roboto', sans-serif;
    }

    /* Wrapper for camera shake, always filling viewport */
    #scene-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      will-change: transform;
    }

    #wall-canvas,
    #game-canvas,
    #fx-canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
    }
    #wall-canvas { z-index: 0; }
    #game-canvas { z-index: 1; }
    #fx-canvas  { z-index: 2; pointer-events: none; }

    /* Landing overlay */
    #promptOverlay {
      position: fixed;
      inset: 0;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      text-align: center;
      background: #000;
      padding: clamp(24px, 4vw, 72px);
      padding-top: clamp(60px, 20vh, 140px);
      gap: clamp(18px, 3vw, 32px);
    }

    #promptOverlay h1 {
      margin: 0;
      font-size: clamp(30px, 5vw, 80px);
      color: #00bfff;
      text-shadow: 0 0 18px rgba(0,191,255,0.6);
      font-family: 'Permanent Marker', cursive;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 2px;
      transform: skew(-6deg);
    }

    #promptOverlay p {
      margin: 0;
      font-size: clamp(1rem, 2.1vw, 1.35rem);
      line-height: 1.5;
      max-width: min(640px, 90vw);
      opacity: 0.95;
    }

    #startButton {
      padding: clamp(14px, 2.2vw, 22px) clamp(40px, 6vw, 60px);
      font-size: clamp(1.1rem, 2.4vw, 1.5rem);
      border: none;
      border-radius: 16px;
      background: #1982c4;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.02em;
      box-shadow: 0 14px 36px rgba(25, 130, 196, 0.5);
      transition: filter 0.2s ease, transform 0.1s ease;
    }

    #startButton:hover {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }

    #user-input {
      font-size: clamp(22px, 3vw, 40px);
      padding: 12px 18px;
      width: 60%;
      max-width: 480px;
      text-align: center;
      background: #111;
      border: 3px solid #00bfff;
      color: #fff;
      border-radius: 20px;
      outline: none;
      text-transform: uppercase;
      box-shadow: 0 0 10px rgba(0,191,255,0.5);
      margin-top: 4px;
    }

    #user-input::placeholder {
      color: #888;
    }

    .instruction {
      margin-top: 8px;
      color: #ccc;
      font-size: clamp(13px, 1.3vw, 18px);
      max-width: 520px;
      line-height: 1.4;
      margin-left: auto;
      margin-right: auto;
    }

    /* Ambiance selector container */
    #musicSelect {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #musicSelect p {
      margin: 0;
      color: #00bfff;
      font-size: clamp(0.95rem, 1.8vw, 1.1rem);
    }

    /* Ambiance buttons styled like Standard / Contemplative */
    #musicModeSelect {
      display: flex;
      flex-wrap: wrap;
      gap: clamp(10px, 2vw, 20px);
      justify-content: center;
    }

    #musicModeSelect button {
      min-width: 11rem;
      padding: clamp(12px, 1.6vw, 18px) clamp(18px, 3vw, 30px);
      border: none;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      font-size: clamp(0.95rem, 1.8vw, 1.1rem);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.05s ease;
    }

    #musicModeSelect button.active {
      background: #00bfff;
      color: #000;
      font-weight: 700;
    }

    #musicModeSelect button:focus-visible {
      outline: 2px solid #00bfff;
      outline-offset: 3px;
    }

    /* Settings icon */
    #settings-icon {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
      background-color: rgba(0,0,0,0.7);
      transition: transform 0.3s ease, background-color 0.3s ease;
      z-index: 1100;
    }
    #settings-icon:hover {
      transform: rotate(90deg);
      background-color: rgba(0,0,0,0.9);
    }

    /* Settings menu */
    #menu {
      position: fixed;
      top: 60px;
      right: -300px;
      width: 270px;
      background: rgba(0,0,0,0.85);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: right 0.3s ease, opacity 0.3s ease;
      opacity: 0;
      color: #fff;
      overflow-y: auto;
      max-height: calc(100vh - 80px);
      z-index: 2000;
    }
    #menu.show {
      right: 10px;
      opacity: 1;
    }
    #menu h2, #menu h3 {
      margin-top: 15px;
      margin-bottom: 8px;
      color: #00bfff;
      font-weight: 500;
    }
    #menu h2 { font-size: 20px; text-align: center; }
    #menu h3 { font-size: 16px; }

    #menu label {
      display: flex;
      flex-direction: column;
      margin: 20px 0;
      font-size: 13px;
    }
    #menu label:hover { color: #00bfff; }

    #menu label.inline {
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      background: #008080;
      padding: 5px 8px;
      border-radius: 4px;
    }
    #menu label.inline span { margin: 0; }

    #menu input[type="range"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 100%;
      background: transparent;
      margin-top: 5px;
    }
    #menu input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: #008080;
      border-radius: 2px;
    }
    #menu input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #008080;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px;
    }
    #menu input[type="range"]::-moz-range-track {
      height: 4px;
      background: #008080;
      border-radius: 2px;
    }
    #menu input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: #008080;
      border-radius: 50%;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <div id="scene-wrapper">
    <canvas id="wall-canvas"></canvas>
    <canvas id="game-canvas"></canvas>
    <canvas id="fx-canvas"></canvas>
  </div>

  <!-- Landing: text in middle, images chosen automatically around -->
  <div id="promptOverlay">
    <h1>WILD STYLE TAGS</h1>

    <div id="musicSelect">
      <p>Ambiance :</p>
      <div id="musicModeSelect">
        <button data-music="punk" class="active">PUNK ROCK</button>
        <button data-music="hiphop">HIP HOP</button>
      </div>
    </div>

    <input type="text" id="user-input" placeholder="YOUR TAG" maxlength="15" autocomplete="off">

    <button id="startButton">BEGIN</button>
    <p class="instruction">
      SPACE / click: spray your tag, then spray the icons around (multiple presses per icon, by diagonal bands).<br>
      ENTER at the end: flash the police lights.
    </p>
  </div>

  <!-- Settings icon & menu -->
  <div id="settings-icon"
       title="Settings"
       class="translate"
       data-fr="⚙️" data-en="⚙️" data-ja="⚙️">⚙️</div>

  <div id="menu">
    <h2 class="translate"
        data-fr="Options"
        data-en="Options"
        data-ja="オプション">Options</h2>

    <h3 class="translate"
        data-fr="Musique &amp; son"
        data-en="Music &amp; Sound"
        data-ja="音楽と効果音">
      Musique &amp; son
    </h3>

    <label class="inline">
      <span class="translate"
            data-fr="Désactiver la musique"
            data-en="Disable music"
            data-ja="音楽をミュート">Désactiver la musique</span>
      <input type="checkbox" id="muteMusic">
    </label>

    <label>
      <span class="translate"
            data-fr="Volume musique"
            data-en="Music volume"
            data-ja="音楽の音量">Volume musique</span>
      <span id="musicVolVal">50</span>
      <input type="range" id="musicVol" min="0" max="100" value="50">
    </label>

    <label class="inline">
      <span class="translate"
            data-fr="Désactiver les effets"
            data-en="Disable SFX"
            data-ja="効果音をミュート">Désactiver les effets</span>
      <input type="checkbox" id="muteSFX">
    </label>

    <label>
      <span class="translate"
            data-fr="Volume effets"
            data-en="SFX volume"
            data-ja="効果音の音量">Volume effets</span>
      <span id="sfxVolVal">50</span>
      <input type="range" id="sfxVol" min="0" max="100" value="50">
    </label>
  </div>

  <script>
    const gameCanvas = document.getElementById('game-canvas');
    const wallCanvas = document.getElementById('wall-canvas');
    const fxCanvas   = document.getElementById('fx-canvas');
    const ctx  = gameCanvas.getContext('2d');
    const wCtx = wallCanvas.getContext('2d');
    const fxCtx = fxCanvas.getContext('2d');

    const sceneWrapper = document.getElementById('scene-wrapper');

    const overlay = document.getElementById('promptOverlay');
    const inputField = document.getElementById('user-input');
    const startBtn = document.getElementById('startButton');

    const musicButtons = document.querySelectorAll('#musicModeSelect button');

    // Settings menu elements
    const settingsIcon = document.getElementById('settings-icon');
    const menu = document.getElementById('menu');
    const muteMusicCheckbox = document.getElementById('muteMusic');
    const musicVolSlider = document.getElementById('musicVol');
    const musicVolVal = document.getElementById('musicVolVal');
    const muteSFXCheckbox = document.getElementById('muteSFX');
    const sfxVolSlider = document.getElementById('sfxVol');
    const sfxVolVal = document.getElementById('sfxVolVal');

    let currentMusicStyle = 'punk';

    // Stage: 'text' -> 'images' -> 'finished'
    let stage = 'text';

    let width, height, audioCtx, sprayNode;
    let copLightsRunning = false;
    let lightsStarted = false;

    // approx presses per full image
    const PRESSES_PER_MASK = 4;

    // Music playlists
    const PLAYLISTS = {
      punk: [
        '../../songs/grafiti/grafitipunkrock1.mp3'
      ],
      hiphop: [
        '../../songs/grafiti/grafitihiphop1.mp3'
      ]
    };

    let currentMusic = null;
    let currentTrackIndex = 0;
    let gameStarted = false;

    // Global audio prefs
    let isMusicMuted = false;
    let isSFXMuted = false;
    let volMusic = 0.5;  // 0–1
    let volSFX = 0.5;    // 0–1

    // Image pool for icons around
    const IMAGE_POOL = [
      '../../images/cvipng/cvi2.png',
      '../../images/turntable.png',
      '../../images/cvipng/cviant.png',
      '../../images/cvipng/cviboccia.png'
      // add more here if needed
    ];

    // --- HIGHLY STYLIZED ALPHABET ---
    const alphabet = {
      'A': [[{x:0.1,y:1.1}, {x:0.5,y:-0.1}, {x:0.9,y:1.1}], [{x:0.2,y:0.6}, {x:0.8,y:0.5}]],
      'B': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.1,y:0}], [{x:0.1,y:0}, {x:0.9,y:0.2}, {x:0.1,y:0.5}], [{x:0.1,y:0.5}, {x:1.0,y:0.8}, {x:0.1,y:1.1}]],
      'C': [[{x:0.9,y:0.2}, {x:0.5,y:-0.1}, {x:0.1,y:0.5}, {x:0.5,y:1.1}, {x:0.9,y:0.8}]],
      'D': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.1,y:0}], [{x:0.1,y:0}, {x:1.0,y:0.5}, {x:0.1,y:1.1}]],
      'E': [[{x:0.9,y:0}, {x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.9,y:1.1}], [{x:0.1,y:0.5}, {x:0.8,y:0.5}]],
      'F': [[{x:0.1,y:1.1}, {x:0.15,y:0}, {x:0.9,y:0}], [{x:0.1,y:0.5}, {x:0.8,y:0.5}]],
      'G': [[{x:0.9,y:0.2}, {x:0.5,y:-0.1}, {x:0.0,y:0.5}, {x:0.5,y:1.1}, {x:0.9,y:0.8}, {x:0.9,y:0.5}, {x:0.6,y:0.5}]],
      'H': [[{x:0.1,y:0}, {x:0.15,y:1.1}], [{x:0.9,y:0}, {x:0.85,y:1.1}], [{x:0.1,y:0.5}, {x:0.9,y:0.5}]],
      'I': [[{x:0.5,y:0}, {x:0.5,y:1.1}], [{x:0.3,y:0}, {x:0.7,y:0}], [{x:0.3,y:1.1}, {x:0.7,y:1.1}]],
      'J': [[{x:0.7,y:0}, {x:0.7,y:0.8}, {x:0.5,y:1.1}, {x:0.2,y:0.9}]],
      'K': [[{x:0.1,y:0}, {x:0.15,y:1.1}], [{x:0.9,y:0}, {x:0.1,y:0.6}, {x:1.0,y:1.1}]],
      'L': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.9,y:1.1}]],
      'M': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.5,y:0.7}, {x:0.9,y:-0.1}, {x:0.9,y:1.1}]],
      'N': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:1.1}, {x:0.9,y:-0.1}]],
      'O': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}]],
      'P': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:0.25}, {x:0.1,y:0.5}]],
      'Q': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}], [{x:0.6,y:0.7}, {x:1.0,y:1.1}]],
      'R': [[{x:0.1,y:1.1}, {x:0.1,y:-0.1}, {x:0.9,y:0.25}, {x:0.1,y:0.5}, {x:0.9,y:1.1}]],
      'S': [[{x:0.9,y:0.1}, {x:0.1,y:0.1}, {x:0.0,y:0.5}, {x:1.0,y:0.5}, {x:0.9,y:0.9}, {x:0.1,y:0.9}]],
      'T': [[{x:0.5,y:-0.1}, {x:0.5,y:1.1}], [{x:0.1,y:0}, {x:0.9,y:0}]],
      'U': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.85,y:1.1}, {x:0.9,y:0}]],
      'V': [[{x:0.1,y:0}, {x:0.5,y:1.1}, {x:0.9,y:0}]],
      'W': [[{x:0.1,y:0}, {x:0.15,y:1.1}, {x:0.5,y:0.6}, {x:0.85,y:1.1}, {x:0.9,y:0}]],
      'X': [[{x:0.1,y:0}, {x:0.9,y:1.1}], [{x:0.9,y:0}, {x:0.1,y:1.1}]],
      'Y': [[{x:0.1,y:0}, {x:0.5,y:0.6}], [{x:0.9,y:0}, {x:0.5,y:0.6}, {x:0.5,y:1.1}]],
      'Z': [[{x:0.1,y:0}, {x:0.9,y:0}, {x:0.1,y:1.1}, {x:0.9,y:1.1}]],
      ' ': [],
      '1': [[{x:0.3,y:0}, {x:0.5,y:0}, {x:0.5,y:1.1}], [{x:0.3,y:1.1}, {x:0.7,y:1.1}]],
      '2': [[{x:0.2,y:0.2}, {x:0.8,y:0.2}, {x:0.8,y:0.5}, {x:0.2,y:1.1}, {x:0.9,y:1.1}]],
      '3': [[{x:0.2,y:0}, {x:0.8,y:0}, {x:0.4,y:0.5}, {x:0.8,y:0.5}, {x:0.8,y:1.1}, {x:0.2,y:1.1}]],
      '4': [[{x:0.8,y:1.1}, {x:0.8,y:0}], [{x:0.8,y:0.6}, {x:0.1,y:0.6}, {x:0.5,y:0}]],
      '5': [[{x:0.8,y:0}, {x:0.2,y:0}, {x:0.2,y:0.4}, {x:0.8,y:0.6}, {x:0.2,y:1.1}]],
      '6': [[{x:0.8,y:0}, {x:0.2,y:0.5}, {x:0.2,y:1.1}, {x:0.8,y:1.1}, {x:0.8,y:0.5}, {x:0.2,y:0.5}]],
      '7': [[{x:0.1,y:0}, {x:0.9,y:0}, {x:0.4,y:1.1}]],
      '8': [[{x:0.5,y:0.5}, {x:0.2,y:0.2}, {x:0.8,y:0.2}, {x:0.5,y:0.5}, {x:0.2,y:0.8}, {x:0.8,y:0.8}, {x:0.5,y:0.5}]],
      '9': [[{x:0.8,y:0.5}, {x:0.2,y:0.5}, {x:0.2,y:0}, {x:0.8,y:0}, {x:0.8,y:1.1}]],
      '0': [[{x:0.5,y:-0.1}, {x:0.9,y:0.5}, {x:0.5,y:1.1}, {x:0.1,y:0.5}, {x:0.5,y:-0.1}]]
    };

    const colorCombos = [
      { top: '#FF4500', bottom: '#FFD700' },
      { top: '#00BFFF', bottom: '#F0F8FF' },
      { top: '#FF1493', bottom: '#FFB6C1' },
      { top: '#32CD32', bottom: '#ADFF2F' },
      { top: '#9400D3', bottom: '#DA70D6' },
      { top: '#FF8C00', bottom: '#FFFF00' }
    ];

    // Text mode state
    let isSpraying = false;
    let targetText = "TAGS";
    let textCharIndex = 0;
    let currentWordRow = 0;
    let maxWordRows = 3;

    let currentStrokes = [];
    let currentStrokeIndex = 0;
    let currentPointIndex = 0;

    let currentStyle = null;
    let letterDrawOrigin = { x: 0, y: 0 };
    let letterHeightScale = 0;
    let currentWordWidth = 0;
    let wordStartX = 0;
    let charSkew = 0;
    let charScaleFactor = 1;
    let startYOffset = 0;
    let fixedRowHeight = 0;

    // For centering rows
    let rowCharCounts = [];
    let rowStartXs = [];
    let charRowIndices = [];
    let lastCharRow = 0;

    // Image masks around center
    let selectedMasks = [];
    let maskIndex = 0;

    // --- FULLSCREEN HELPER ---
    function enterFullscreen(element) {
      if (element.requestFullscreen) {
        element.requestFullscreen();
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      }
    }

    // --- CAMERA SHAKE ---
    function shakeCamera(duration = 1000, magnitude = 12) {
      const start = performance.now();

      function frame(now) {
        const elapsed = now - start;
        const t = Math.min(elapsed / duration, 1);
        const damping = 1 - t;

        const offsetX = (Math.random() * 2 - 1) * magnitude * damping;
        const offsetY = (Math.random() * 2 - 1) * magnitude * damping;

        sceneWrapper.style.transform = `translate(${offsetX}px, ${offsetY}px)`;

        if (t < 1) {
          requestAnimationFrame(frame);
        } else {
          sceneWrapper.style.transform = 'translate(0, 0)';
        }
      }

      requestAnimationFrame(frame);
    }

    // --- WALL / layout ---
    function generateWall() {
      width = window.innerWidth;
      height = window.innerHeight;
      [wallCanvas, gameCanvas, fxCanvas].forEach(c => {
        c.width = width;
        c.height = height;
      });

      fixedRowHeight = Math.min(width, height) * 0.24;

      const baseLetterHeight = fixedRowHeight * 0.8;
      const approxLetterWidth = baseLetterHeight * 0.75;

      const leftMargin = width * 0.03;
      const rightLimit = width * 0.97;
      const usableWidth = rightLimit - leftMargin;
      const maxCharsPerRow = Math.max(1, Math.floor(usableWidth / approxLetterWidth));

      const totalChars = (targetText || "").length;
      const rowsNeeded = Math.max(1, Math.ceil(totalChars / maxCharsPerRow));
      maxWordRows = rowsNeeded;

      const totalTextHeight = fixedRowHeight * maxWordRows;
      startYOffset = (height - totalTextHeight) / 2;

      rowCharCounts = [];
      charRowIndices = [];
      rowStartXs = [];

      let idx = 0;
      for (let r = 0; r < maxWordRows; r++) {
        const remaining = totalChars - idx;
        const count = Math.max(0, Math.min(maxCharsPerRow, remaining));
        rowCharCounts.push(count);

        for (let i = 0; i < count; i++) {
          charRowIndices[idx + i] = r;
        }
        idx += count;
      }

      const avgGap = approxLetterWidth * 0.18;
      for (let r = 0; r < maxWordRows; r++) {
        const count = rowCharCounts[r] || 0;
        let rowWidth = 0;
        if (count > 0) {
          rowWidth = count * approxLetterWidth + (count - 1) * avgGap;
        }
        rowStartXs[r] = (width - rowWidth) / 2;
      }

      textCharIndex = 0;
      currentWordRow = 0;
      currentWordWidth = 0;
      wordStartX = 0;
      lastCharRow = 0;
      currentStrokes = [];
      currentStrokeIndex = 0;
      currentPointIndex = 0;
      letterDrawOrigin.x = 0;
      letterDrawOrigin.y = 0;
      ctx.clearRect(0, 0, width, height);
      fxCtx.clearRect(0, 0, width, height);

      // Paint brick wall
      wCtx.fillStyle = '#2b1b17';
      wCtx.fillRect(0, 0, width, height);

      const brickW = 100;
      const brickH = 50;

      for (let y = 0; y < height; y += brickH) {
        const offset = (y / brickH % 2 === 0) ? 0 : brickW / 2;

        for (let x = -brickW; x < width; x += brickW) {
          const bx = x + offset;
          const by = y;
          const bw = brickW - 4;
          const bh = brickH - 4;

          let r = 165 + Math.floor(Math.random() * 25);
          let g = 95  + Math.floor(Math.random() * 20);
          let b = 70  + Math.floor(Math.random() * 15);

          const brightnessJitter = (Math.random() - 0.5) * 18;
          r = Math.max(0, Math.min(255, r + brightnessJitter));
          g = Math.max(0, Math.min(255, g + brightnessJitter));
          b = Math.max(0, Math.min(255, b + brightnessJitter));

          const grad = wCtx.createLinearGradient(bx, by, bx + bw, by + bh);
          grad.addColorStop(0,   `rgb(${r + 12}, ${g + 8}, ${b + 6})`);
          grad.addColorStop(0.5, `rgb(${r}, ${g}, ${b})`);
          grad.addColorStop(1,   `rgb(${r - 14}, ${g - 10}, ${b - 8})`);

          wCtx.fillStyle = grad;
          wCtx.fillRect(bx, by, bw, bh);

          wCtx.fillStyle = 'rgba(40, 25, 20, 0.35)';
          wCtx.fillRect(bx, by + bh - 2, bw, 2);
          wCtx.fillRect(bx + bw - 2, by + 2, 2, bh - 4);

          const pitCount = 4 + Math.floor(Math.random() * 4);
          for (let i = 0; i < pitCount; i++) {
            const px = bx + 6 + Math.random() * (bw - 12);
            const py = by + 6 + Math.random() * (bh - 12);
            const pitSize = 1 + Math.random() * 2;

            wCtx.fillStyle = 'rgba(40, 25, 20, 0.45)';
            wCtx.fillRect(px, py, pitSize, pitSize);
          }
        }
      }

      const noiseCount = Math.floor((width * height) / 1400);
      for (let i = 0; i < noiseCount; i++) {
        const nx = Math.random() * width;
        const ny = Math.random() * height;
        const size = 1 + Math.random() * 2;

        wCtx.fillStyle = 'rgba(0, 0, 0, 0.12)';
        wCtx.fillRect(nx, ny, size, size);

        if (Math.random() < 0.12) {
          wCtx.fillStyle = 'rgba(255, 230, 210, 0.10)';
          wCtx.fillRect(nx, ny, size, size);
        }
      }

      const grad = wCtx.createRadialGradient(
        width / 2, height / 2, height / 3,
        width / 2, height / 2, height
      );
      grad.addColorStop(0, 'rgba(0,0,0,0.12)');
      grad.addColorStop(1, 'rgba(0,0,0,0.80)');
      wCtx.fillStyle = grad;
      wCtx.fillRect(0, 0, width, height);
    }

    function handleResize() {
      generateWall();
    }

    window.addEventListener('resize', handleResize);

    // --- AUDIO (effects, SFX toggling) ---
    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function startSpraySound() {
      if (!audioCtx || isSFXMuted || volSFX <= 0) return;
      const bufferSize = audioCtx.sampleRate * 2;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      noise.loop = true;

      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;

      const gain = audioCtx.createGain();
      const BASE_SPRAY_GAIN = 0.18;
      gain.gain.value = BASE_SPRAY_GAIN * volSFX;

      noise.connect(filter).connect(gain).connect(audioCtx.destination);
      noise.start();
      sprayNode = { source: noise, gain: gain };
    }

    function stopSpraySound() {
      if (sprayNode) {
        sprayNode.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
        sprayNode.source.stop(audioCtx.currentTime + 0.2);
        sprayNode = null;
      }
    }

    function playPopSound() {
      if (!audioCtx || isSFXMuted || volSFX <= 0) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const baseGain = 0.5 * volSFX;

      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(baseGain, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }

    // --- MUSIC HELPERS ---
    function stopMusic() {
      if (currentMusic) {
        currentMusic.pause();
        currentMusic = null;
      }
    }

    function startMusicForCurrentStyle() {
      stopMusic();
      if (isMusicMuted) return;
      const playlist = PLAYLISTS[currentMusicStyle];
      if (!playlist || !playlist.length) return;

      currentTrackIndex = 0;
      currentMusic = new Audio(playlist[currentTrackIndex]);
      currentMusic.volume = volMusic;

      if (playlist.length === 1) {
        currentMusic.loop = true;
      } else {
        currentMusic.addEventListener('ended', () => {
          if (isMusicMuted) return;
          const pl = PLAYLISTS[currentMusicStyle];
          if (!pl || !pl.length) return;
          currentTrackIndex = (currentTrackIndex + 1) % pl.length;
          currentMusic = new Audio(pl[currentTrackIndex]);
          currentMusic.volume = volMusic;
          currentMusic.play().catch(() => {});
        });
      }

      currentMusic.play().catch(() => {});
    }

    // --- TEXT MODE HELPERS ---
    function calculateLetterPosition() {
      const baseRowHeight = fixedRowHeight;
      const baseLetterHeight = baseRowHeight * 0.8;

      letterHeightScale = baseLetterHeight * (1 + (Math.random() - 0.5) * 0.15);
      const effectiveLetterWidth = letterHeightScale * 0.65;

      charSkew = (Math.random() - 0.5) * 0.3;
      charScaleFactor = 1 + (Math.random() - 0.5) * 0.1;

      const rowIndex = charRowIndices[textCharIndex] ?? 0;
      const isFirstInRow = (textCharIndex === 0) || (rowIndex !== lastCharRow);

      if (isFirstInRow) {
        const verticalOffset = baseRowHeight * 0.1;
        const startX = rowStartXs[rowIndex] ?? (width * 0.03);

        letterDrawOrigin.y = (rowIndex * baseRowHeight)
          + (baseRowHeight - letterHeightScale) / 2
          + verticalOffset
          + startYOffset;

        if (rowIndex === 0 && letterDrawOrigin.y < height * 0.01) {
          letterDrawOrigin.y = height * 0.01;
        }

        letterDrawOrigin.x = startX;
        wordStartX = startX;
      } else {
        const prevChar = targetText[textCharIndex - 1];
        let prevLetterActualWidth = effectiveLetterWidth * charScaleFactor;
        if (prevChar === 'I' || prevChar === '1') prevLetterActualWidth *= 0.6;
        if (prevChar === 'M' || prevChar === 'W') prevLetterActualWidth *= 1.2;

        const baseGap = effectiveLetterWidth * 0.18;
        const jitter = effectiveLetterWidth * (Math.random() * 0.04 - 0.02);
        letterDrawOrigin.x = letterDrawOrigin.x + prevLetterActualWidth + baseGap + jitter;

        const bounceRange = letterHeightScale * 0.1;
        letterDrawOrigin.y += (Math.random() - 0.5) * bounceRange;

        const rowBottomLimit = (rowIndex + 1) * baseRowHeight - (baseRowHeight * 0.1) + startYOffset;
        if (letterDrawOrigin.y + letterHeightScale * charScaleFactor > rowBottomLimit) {
          letterDrawOrigin.y = rowBottomLimit - letterHeightScale * charScaleFactor;
        }
      }

      lastCharRow = rowIndex;
    }

    function getAbsPoint(pt) {
      let x = pt.x * letterHeightScale * charScaleFactor * 0.6 + (pt.y * charSkew * letterHeightScale * 0.45);
      let y = pt.y * letterHeightScale * charScaleFactor;

      return {
        x: letterDrawOrigin.x + x,
        y: letterDrawOrigin.y + y
      };
    }

    function createLetterGradient(topColor, bottomColor) {
      const topY = letterDrawOrigin.y;
      const botY = letterDrawOrigin.y + letterHeightScale * charScaleFactor;
      const grad = ctx.createLinearGradient(0, topY, 0, botY);
      grad.addColorStop(0, topColor);
      grad.addColorStop(1, bottomColor);
      return grad;
    }

    function drawOutline() {
      const outlineThickness = letterHeightScale * 0.08;
      ctx.globalCompositeOperation = 'destination-over';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = outlineThickness;
      ctx.strokeStyle = 'black';

      currentStrokes.forEach(stroke => {
        ctx.beginPath();
        stroke.forEach((pt, i) => {
          const abs = getAbsPoint(pt);
          if (i === 0) ctx.moveTo(abs.x, abs.y);
          else ctx.lineTo(abs.x, abs.y);
        });
        ctx.stroke();
      });

      ctx.globalCompositeOperation = 'source-over';
    }

    function drawDrips() {
      ctx.strokeStyle = currentStyle.bottom;
      ctx.lineWidth = letterHeightScale * 0.035;
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.85;

      currentStrokes.flat().forEach(pt => {
        if (Math.random() > 0.7) {
          const abs = getAbsPoint(pt);
          const dripLength = letterHeightScale * (0.25 + Math.random() * 0.45);
          const dripOffset = letterHeightScale * 0.04;
          ctx.beginPath();
          ctx.moveTo(abs.x, abs.y + dripOffset);
          ctx.lineTo(abs.x + (Math.random()-0.5)*10, abs.y + dripOffset + dripLength);
          ctx.stroke();
        }
      });
      ctx.globalAlpha = 1.0;
    }

    function drawSplatter(x, y, color) {
      const splatterRadius = letterHeightScale * (0.25 + Math.random() * 0.35);
      const numParticles = 10 + Math.random() * 12;
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.45;

      for (let i = 0; i < numParticles; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * splatterRadius;
        const px = x + Math.cos(angle) * distance;
        const py = y + Math.sin(angle) * distance;
        const radius = 0.8 + Math.random() * 3;
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    }

    async function sprayBetween(start, end, duration, gradient) {
      return new Promise(resolve => {
        const startTime = performance.now();
        startSpraySound();
        let lastProgress = 0;

        function animate(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);

          const bubbleThickness = letterHeightScale * 0.22;

          const steps = 5;
          for (let i = 0; i < steps; i++) {
            const t = lastProgress + (progress - lastProgress) * (i / steps);
            const baseX = start.x + (end.x - start.x) * t;
            const baseY = start.y + (end.y - start.y) * t;

            const dotCount = 5;
            for (let j = 0; j < dotCount; j++) {
              const r = Math.random() * bubbleThickness * 0.5;
              const angle = Math.random() * Math.PI * 2;
              const jitterX = (Math.random() - 0.5) * 3;
              const jitterY = (Math.random() - 0.5) * 3;
              const px = baseX + Math.cos(angle) * r + jitterX;
              const py = baseY + Math.sin(angle) * r + jitterY;

              ctx.fillStyle = gradient;
              ctx.globalAlpha = 0.25 + Math.random() * 0.25;
              const radius = 0.7 + Math.random() * (bubbleThickness * 0.07);
              ctx.beginPath();
              ctx.arc(px, py, radius, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          ctx.globalAlpha = 0.9;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineWidth = bubbleThickness * 0.4;
          ctx.strokeStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(start.x + (end.x - start.x) * lastProgress,
                     start.y + (end.y - start.y) * lastProgress);
          ctx.lineTo(start.x + (end.x - start.x) * progress,
                     start.y + (end.y - start.y) * progress);
          ctx.stroke();

          ctx.globalAlpha = 1.0;
          lastProgress = progress;

          if (progress < 1) requestAnimationFrame(animate);
          else {
            stopSpraySound();
            resolve();
          }
        }
        requestAnimationFrame(animate);
      });
    }

    // --- COP LIGHTS FX ---
    function startCopLights() {
      if (copLightsRunning || lightsStarted) return;
      copLightsRunning = true;
      lightsStarted = true;

      const totalFlashes = 6;
      const flashDuration = 700;
      const totalDuration = totalFlashes * flashDuration;

      let startTime = null;

      function frame(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;

        if (elapsed >= totalDuration) {
          fxCtx.clearRect(0, 0, width, height);
          copLightsRunning = false;

          shakeCamera(1000, 12);
          setTimeout(() => {
            generateWall();
          }, 1000);

          return;
        }

        fxCtx.clearRect(0, 0, width, height);

        const flashIndex = Math.floor(elapsed / flashDuration);
        const tInFlash = (elapsed % flashDuration) / flashDuration;

        const isRed = (flashIndex % 2 === 0);

        let intensity = Math.sin(tInFlash * Math.PI);
        intensity = Math.max(0, Math.min(1, intensity));

        const baseAlpha = 0.18;
        const extraAlpha = 0.35;
        const alpha = baseAlpha + extraAlpha * intensity;

        fxCtx.save();
        fxCtx.globalCompositeOperation = 'screen';

        const marginFactor = 0.25;
        const startX = isRed ? -width * marginFactor : width * (1 + marginFactor);
        const endX   = isRed ? width * (1 + marginFactor) : -width * marginFactor;
        const centerX = startX + (endX - startX) * tInFlash;

        const centerY = height * 0.22;
        const radius = Math.max(width, height) * 0.45;

        const colorMain = isRed
          ? `rgba(255, 60, 60, ${alpha})`
          : `rgba(60, 120, 255, ${alpha})`;

        const colorSoft = isRed
          ? `rgba(255, 60, 60, ${alpha * 0.4})`
          : `rgba(60, 120, 255, ${alpha * 0.4})`;

        const radial = fxCtx.createRadialGradient(
          centerX, centerY, radius * 0.05,
          centerX, centerY, radius
        );
        radial.addColorStop(0.0, colorMain);
        radial.addColorStop(0.25, colorMain);
        radial.addColorStop(1.0, 'rgba(0,0,0,0)');
        fxCtx.fillStyle = radial;
        fxCtx.fillRect(0, 0, width, height);

        const horiz = fxCtx.createLinearGradient(0, centerY, width, centerY);
        if (isRed) {
          horiz.addColorStop(0.0, colorSoft);
          horiz.addColorStop(0.4, 'rgba(255,60,60,0.06)');
          horiz.addColorStop(0.7, 'rgba(255,60,60,0.02)');
          horiz.addColorStop(1.0, 'rgba(0,0,0,0)');
        } else {
          horiz.addColorStop(0.0, 'rgba(0,0,0,0)');
          horiz.addColorStop(0.3, 'rgba(60,120,255,0.02)');
          horiz.addColorStop(0.6, 'rgba(60,120,255,0.06)');
          horiz.addColorStop(1.0, colorSoft);
        }
        fxCtx.fillStyle = horiz;
        fxCtx.fillRect(0, 0, width, height);

        const vGrad = fxCtx.createLinearGradient(0, 0, 0, height);
        vGrad.addColorStop(0,   'rgba(0, 0, 0, 0.0)');
        vGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.0)');
        vGrad.addColorStop(1.0, 'rgba(0, 0, 0, 0.35)');
        fxCtx.fillStyle = vGrad;
        fxCtx.fillRect(0, 0, width, height);

        fxCtx.restore();

        requestAnimationFrame(frame);
      }

      requestAnimationFrame(frame);
    }

    // --- TEXT MODE MAIN ---
    async function triggerTextLetter() {
      if (copLightsRunning) return;
      if (isSpraying) return;
      if (textCharIndex >= targetText.length) {
        stage = 'images';
        return;
      }

      isSpraying = true;

      if (currentStrokes.length === 0) {
        let char = targetText[textCharIndex];
        let strokes = alphabet[char] || alphabet['?'];

        calculateLetterPosition();
        currentStyle = colorCombos[textCharIndex % colorCombos.length];

        if (strokes && strokes.length > 0) {
          currentStrokes = strokes;
          currentStrokeIndex = 0;
          currentPointIndex = 0;

          const p1 = getAbsPoint(currentStrokes[0][0]);
          const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);

          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(p1.x, p1.y, letterHeightScale * 0.16, 0, Math.PI*2);
          ctx.fill();

          currentPointIndex = 1;
          isSpraying = false;
          return;
        } else {
          textCharIndex++;
          letterDrawOrigin.x += fixedRowHeight * 0.7 * 0.5;
          isSpraying = false;
          if (textCharIndex >= targetText.length) {
            stage = 'images';
          }
          return;
        }
      }

      let currentStrokePoints = currentStrokes[currentStrokeIndex];

      if (currentPointIndex < currentStrokePoints.length) {
        const pStart = getAbsPoint(currentStrokePoints[currentPointIndex-1]);
        const pEnd = getAbsPoint(currentStrokePoints[currentPointIndex]);
        const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);

        await sprayBetween(pStart, pEnd, 400, grad);
        currentPointIndex++;
      }

      if (currentPointIndex >= currentStrokePoints.length) {
        currentStrokeIndex++;
        currentPointIndex = 1;

        if (currentStrokeIndex < currentStrokes.length) {
          const pNewStart = getAbsPoint(currentStrokes[currentStrokeIndex][0]);
          const grad = createLetterGradient(currentStyle.top, currentStyle.bottom);
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(pNewStart.x, pNewStart.y, letterHeightScale * 0.16, 0, Math.PI*2);
          ctx.fill();
        }
      }

      if (currentStrokeIndex >= currentStrokes.length) {
        playPopSound();
        drawOutline();
        drawDrips();

        const splatX = letterDrawOrigin.x + (letterHeightScale * 0.4 * charScaleFactor);
        const splatY = letterDrawOrigin.y + (letterHeightScale * charScaleFactor);
        drawSplatter(splatX, splatY, currentStyle.bottom);

        currentStrokes = [];
        textCharIndex++;

        if (textCharIndex >= targetText.length) {
          stage = 'images';
        }
      }

      isSpraying = false;
    }

    // --- IMAGE MASKS AROUND CENTER ---
    function paintMaskPoint(pt, gradient, clusterRadiusBase) {
      if (!pt) return;
      const dotsPerPoint = 3;
      for (let d = 0; d < dotsPerPoint; d++) {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * clusterRadiusBase;
        const px = pt.x + Math.cos(angle) * r;
        const py = pt.y + Math.sin(angle) * r;
        ctx.fillStyle = gradient;
        ctx.globalAlpha = 0.4 + Math.random() * 0.3;
        ctx.beginPath();
        ctx.arc(px, py, clusterRadiusBase * 0.7, 0, Math.PI * 2);
        ctx.fill();
      }

      if (Math.random() < 0.05) {
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = gradient;
        ctx.lineCap = 'round';
        ctx.lineWidth = clusterRadiusBase * 0.5;
        ctx.beginPath();
        ctx.moveTo(pt.x, pt.y);
        const driftX = (Math.random() - 0.5) * clusterRadiusBase * 1.2;
        const dripLength = clusterRadiusBase * (2 + Math.random() * 3);
        ctx.lineTo(pt.x + driftX, pt.y + dripLength);
        ctx.stroke();
      }

      ctx.globalAlpha = 1.0;
    }

    function loadImageMaskForPath(src, index, total) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const offCanvas = document.createElement('canvas');
          const offCtx = offCanvas.getContext('2d');
          offCanvas.width = img.width;
          offCanvas.height = img.height;
          offCtx.drawImage(img, 0, 0);

          const imgData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);

          const centerX0 = img.width / 2;
          const centerY0 = img.height / 2;

          const maxDim = Math.max(img.width, img.height);
          const baseSize = Math.min(width, height) * 0.25;
          const scale = baseSize / maxDim;

          const radius = Math.min(width, height) * 0.35;
          const angleBase = (index / total) * Math.PI * 2;
          const jitter = (Math.random() - 0.5) * (Math.PI / 6);
          const angle = angleBase + jitter;

          const cx = width  / 2 + Math.cos(angle) * radius;
          const cy = height / 2 + Math.sin(angle) * radius;

          const step = 2;
          const bands = [[], [], []];
          let minY = Infinity, maxY = -Infinity;

          for (let y = 0; y < imgData.height; y += step) {
            for (let x = 0; x < imgData.width; x += step) {
              const idx = (y * imgData.width + x) * 4;
              const alpha = imgData.data[idx + 3];
              if (alpha > 50) {
                const rx = (x - centerX0) * scale;
                const ry = (y - centerY0) * scale;
                const fx = cx + rx;
                const fy = cy + ry;

                const normalizedX = (x - centerX0) / maxDim; // ~[-0.5, 0.5]
                let bandIndex;
                if (normalizedX < -0.15) bandIndex = 0;        // left
                else if (normalizedX > 0.15) bandIndex = 2;   // right
                else bandIndex = 1;                           // center

                bands[bandIndex].push({ x: fx, y: fy });

                if (fy < minY) minY = fy;
                if (fy > maxY) maxY = fy;
              }
            }
          }

          // Sort each band diagonally (x + y) to get a diagonal sweep
          for (let b = 0; b < 3; b++) {
            bands[b].sort((p1, p2) => (p1.x + p1.y) - (p2.x + p2.y));
          }

          const style = colorCombos[Math.floor(Math.random() * colorCombos.length)];

          resolve({
            bands,                        // [left, middle, right]
            style,
            bounds: { minY, maxY },
            bandPaintedCounts: [0, 0, 0],
            bandStepSizes: [0, 0, 0],
            bandIndex: 0,                 // 0 = left, then middle, then right
            painting: false,
            done: false
          });
        };
        img.onerror = reject;
        img.src = src;
      });
    }

    async function prepareImageMasks() {
      selectedMasks = [];
      maskIndex = 0;

      const n = 4 + Math.floor(Math.random() * 3); // 4–6
      const pool = IMAGE_POOL.slice();

      // shuffle pool
      for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }

      const chosen = pool.slice(0, Math.min(n, pool.length));
      const total = chosen.length;

      for (let i = 0; i < total; i++) {
        try {
          const mask = await loadImageMaskForPath(chosen[i], i, total);
          selectedMasks.push(mask);
        } catch (e) {
          console.error('Error loading mask image', chosen[i], e);
        }
      }
    }

    // Animate a slice of a band diagonally over time (robust indices)
    function animateBandSlice(mask, bandIdx, startIndex, endIndex, gradient, clusterRadiusBase) {
      return new Promise(resolve => {
        const bandPoints = mask.bands[bandIdx] || [];
        const maxLen = bandPoints.length;
        const clampedStart = Math.min(Math.max(startIndex, 0), maxLen);
        const clampedEnd   = Math.min(Math.max(endIndex,   0), maxLen);
        const totalToPaint = Math.max(0, clampedEnd - clampedStart);

        if (totalToPaint <= 0 || maxLen === 0) {
          resolve();
          return;
        }

        const duration = 600; // ms for a slice
        const sliceStartTime = performance.now();

        initAudio();
        startSpraySound();

        let lastPainted = clampedStart;

        function frame(now) {
          const elapsed = now - sliceStartTime;
          const t = Math.min(elapsed / duration, 1);
          const target = clampedStart + Math.floor(totalToPaint * t);
          const safeTarget = Math.min(target, maxLen);

          for (let i = lastPainted; i < safeTarget; i++) {
            const pt = bandPoints[i];
            if (!pt) continue;
            paintMaskPoint(pt, gradient, clusterRadiusBase);
          }

          mask.bandPaintedCounts[bandIdx] = safeTarget;
          lastPainted = safeTarget;

          if (t < 1 && safeTarget < maxLen) {
            requestAnimationFrame(frame);
          } else {
            stopSpraySound();
            resolve();
          }
        }

        requestAnimationFrame(frame);
      });
    }

    // Each press paints a diagonally sweeping chunk; progression is left → middle → right
    function triggerImageMask() {
      if (copLightsRunning) return;
      if (maskIndex >= selectedMasks.length) {
        stage = 'finished';
        return;
      }

      const mask = selectedMasks[maskIndex];
      if (!mask) {
        maskIndex++;
        if (maskIndex >= selectedMasks.length) stage = 'finished';
        return;
      }

      if (mask.painting || mask.done) {
        if (mask.done) {
          maskIndex++;
          if (maskIndex >= selectedMasks.length) stage = 'finished';
        }
        return;
      }

      // Find next band that still has points
      while (mask.bandIndex < 3 && mask.bands[mask.bandIndex].length === 0) {
        mask.bandIndex++;
      }
      if (mask.bandIndex >= 3) {
        mask.done = true;
        mask.painting = false;
        maskIndex++;
        if (maskIndex >= selectedMasks.length) stage = 'finished';
        return;
      }

      mask.painting = true;

      const bandIdx = mask.bandIndex;
      const bandPoints = mask.bands[bandIdx];
      const totalBandPoints = bandPoints.length;

      if (totalBandPoints === 0) {
        mask.bandIndex++;
        mask.painting = false;
        if (mask.bandIndex >= 3) {
          mask.done = true;
          maskIndex++;
          if (maskIndex >= selectedMasks.length) stage = 'finished';
        }
        return;
      }

      if (!mask.bandStepSizes[bandIdx] || mask.bandStepSizes[bandIdx] <= 0) {
        const approxPressesPerBand = Math.max(1, Math.floor(PRESSES_PER_MASK / 3));
        mask.bandStepSizes[bandIdx] = Math.max(
          1,
          Math.ceil(totalBandPoints / approxPressesPerBand)
        );
      }

      const startIndex = mask.bandPaintedCounts[bandIdx] || 0;
      const endIndex = Math.min(startIndex + mask.bandStepSizes[bandIdx], totalBandPoints);

      const clusterRadiusBase = Math.min(width, height) * 0.004;
      const gradient = ctx.createLinearGradient(0, mask.bounds.minY, 0, mask.bounds.maxY);
      gradient.addColorStop(0, mask.style.top);
      gradient.addColorStop(1, mask.style.bottom);

      animateBandSlice(mask, bandIdx, startIndex, endIndex, gradient, clusterRadiusBase)
        .then(() => {
          // After animation ended for this slice
          if (mask.bandPaintedCounts[bandIdx] >= totalBandPoints) {
            // finished this band -> move to next
            mask.bandIndex++;
            playPopSound();

            // Skip empty bands if any
            while (mask.bandIndex < 3 && mask.bands[mask.bandIndex].length === 0) {
              mask.bandIndex++;
            }

            if (mask.bandIndex >= 3) {
              mask.done = true;
              mask.painting = false;
              maskIndex++;
              if (maskIndex >= selectedMasks.length) {
                stage = 'finished';
              }
            } else {
              mask.painting = false;
            }
          } else {
            // still some of this band left for next press
            mask.painting = false;
          }
        })
        .catch(() => {
          mask.painting = false;
        });
    }

    // --- INIT ---
    generateWall();

    // Music style toggle (Punk / Hip hop)
    musicButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        musicButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMusicStyle = btn.dataset.music;
        if (!isMusicMuted && gameStarted) {
          startMusicForCurrentStyle();
        }
      });
    });

    // START button
    startBtn.addEventListener('click', async () => {
      gameStarted = true;
      initAudio();
      stage = 'text';
      lightsStarted = false;

      enterFullscreen(document.documentElement);

      overlay.style.opacity = 0;
      setTimeout(() => overlay.style.display = 'none', 500);

      settingsIcon.style.display = 'flex';

      startMusicForCurrentStyle();

      const txt = inputField.value.toUpperCase().trim();
      if (txt.length > 0) {
        targetText = txt.replace(/[^A-Z0-9 ]/g, '').substring(0, 15);
        if (targetText.length === 0) targetText = "TAGS";
      }

      generateWall();
      ctx.clearRect(0, 0, width, height);

      // Prepare the images around the center
      await prepareImageMasks();

      textCharIndex = 0;
      currentWordRow = 0;
      currentWordWidth = 0;
      wordStartX = 0;
      currentStrokes = [];
      currentStrokeIndex = 0;
      currentPointIndex = 0;
    });

    const handleInput = (e) => {
      if (!gameStarted) return;

      if (e.type === 'keydown') {
        if (e.code === 'Space' || e.code === 'Enter') {
          e.preventDefault();
        } else {
          return;
        }
      }
      if (e.type === 'touchstart') e.preventDefault();

      if (stage === 'finished') {
        // At the end, ENTER triggers police lights
        if (e.type === 'keydown' && e.code === 'Enter') {
          startCopLights();
        }
        return;
      }

      // While not finished, SPACE/ENTER/mouse/touch all act as "spray"
      if (stage === 'text') {
        triggerTextLetter();
      } else if (stage === 'images') {
        triggerImageMask();
      }
    };

    document.addEventListener('keydown', handleInput);
    document.addEventListener('mousedown', handleInput);
    document.addEventListener('touchstart', handleInput, {passive:false});

    window.addEventListener('beforeunload', stopMusic);

    // SETTINGS MENU LOGIC
    settingsIcon.addEventListener('click', (e) => {
      e.stopPropagation();
      menu.classList.toggle('show');
    });

    document.addEventListener('click', (e) => {
      if (!menu.contains(e.target) && e.target !== settingsIcon) {
        menu.classList.remove('show');
      }
    });

    // Music volume slider
    musicVolSlider.addEventListener('input', (e) => {
      const val = parseInt(e.target.value, 10);
      volMusic = val / 100;
      musicVolVal.textContent = val;
      if (currentMusic && !isMusicMuted) {
        currentMusic.volume = volMusic;
      }
    });

    // SFX volume slider
    sfxVolSlider.addEventListener('input', (e) => {
      const val = parseInt(e.target.value, 10);
      volSFX = val / 100;
      sfxVolVal.textContent = val;
      if (sprayNode && sprayNode.gain) {
        const BASE_SPRAY_GAIN = 0.18;
        sprayNode.gain.gain.value = isSFXMuted ? 0 : BASE_SPRAY_GAIN * volSFX;
      }
    });

    // Music mute toggle
    muteMusicCheckbox.addEventListener('change', (e) => {
      isMusicMuted = e.target.checked;
      if (isMusicMuted) {
        stopMusic();
      } else if (gameStarted) {
        startMusicForCurrentStyle();
      }
    });

    // SFX mute toggle
    muteSFXCheckbox.addEventListener('change', (e) => {
      isSFXMuted = e.target.checked;
      if (isSFXMuted) {
        if (sprayNode && sprayNode.gain) {
          sprayNode.gain.gain.value = 0;
        }
      } else {
        if (sprayNode && sprayNode.gain) {
          const BASE_SPRAY_GAIN = 0.18;
          sprayNode.gain.gain.value = BASE_SPRAY_GAIN * volSFX;
        }
      }
    });

    // Prevent page scroll with space/enter
    window.addEventListener('keydown', e => {
      if (e.code === 'Space' || e.code === 'Enter') {
        e.preventDefault();
      }
    }, { passive: false });
  </script>
</body>
</html>
