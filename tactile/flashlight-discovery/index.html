<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exploration lampe torche (tactile)</title>
  <link rel="stylesheet" href="../../css/games.css" />
  <link rel="stylesheet" href="../../css/choiceeyegaze.css" />
  <style>
    body {
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #game-options {
      position: fixed;
      inset: 0;
      z-index: 20;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.9);
      padding: 16px;
    }

    #control-panel-options {
      width: min(980px, 95vw);
      background: #fff;
      color: #222;
      border-radius: 20px;
      padding: 22px;
      box-shadow: 0 12px 44px rgba(0, 0, 0, 0.5);
    }

    #options-title-bar h2 {
      margin: 0;
      text-align: center;
      color: #009688;
      font-size: 1.6rem;
    }

    .menu-note {
      margin: 10px 0 0;
      text-align: center;
      font-size: 0.98rem;
      line-height: 1.35;
    }

    .value-readout {
      color: #009688;
      font-weight: 700;
      margin: 4px 0;
    }

    .styled-slider { width: 90%; }
    .options-column { gap: 10px; }
    .options-column:first-child { align-items: flex-start !important; }

    #startButton {
      display: block;
      margin: 8px auto 0;
      min-width: 220px;
    }

    #scene {
      position: fixed;
      inset: 0;
      display: none;
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
      touch-action: none;
      cursor: none;
    }

    #objectsLayer {
      position: absolute;
      inset: 0;
      z-index: 3;
    }

    .hidden-object {
      position: absolute;
      width: var(--size, 100px);
      height: var(--size, 100px);
      object-fit: contain;
      pointer-events: none;
      opacity: 0;
      filter: brightness(1.02) saturate(1.02);
      transition: opacity 70ms linear;
    }

    #overlay {
      position: absolute;
      inset: 0;
      z-index: 2;
      pointer-events: none;
      opacity: 1;
      transition: opacity 3.8s ease-in-out;
      background:
        radial-gradient(
          circle var(--flashlight-size, 180px) at var(--flashlight-x, 50%) var(--flashlight-y, 50%),
          rgba(255, 255, 255, 0.06) 0%,
          rgba(0, 0, 0, 0.12) 24%,
          rgba(0, 0, 0, 0.92) 55%,
          rgba(0, 0, 0, 0.985) 100%
        );
    }

    #scene.completed #overlay {
      opacity: 0;
    }

    #pointer {
      display: none;
    }

    #hint {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.58);
      color: #fff;
      padding: 8px 14px;
      border-radius: 10px;
      font-size: 0.95rem;
      z-index: 5;
    }

    #rewardOverlay {
      position: absolute;
      inset: 0;
      display: none;
      z-index: 6;
      pointer-events: none;
      background:
        radial-gradient(circle at center, rgba(255, 255, 255, 0.42) 0%, rgba(255, 255, 255, 0) 35%),
        conic-gradient(from 0deg, rgba(255, 224, 102, 0.24), rgba(123, 211, 255, 0.24), rgba(191, 123, 255, 0.24), rgba(255, 224, 102, 0.24));
      mix-blend-mode: screen;
      animation: rewardSpin 6s linear infinite, rewardBreath 2.2s ease-in-out infinite alternate;
    }

    #rewardOverlay::before,
    #rewardOverlay::after {
      content: "";
      position: absolute;
      inset: 10%;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.38);
      filter: blur(0.4px);
      animation: ringFloat 2.8s ease-in-out infinite alternate;
    }

    #rewardOverlay::after {
      inset: 22%;
      animation-duration: 3.7s;
      border-color: rgba(255, 255, 255, 0.26);
    }

    #rewardOverlay.show {
      display: block;
    }

    @keyframes rewardSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes rewardBreath {
      from { opacity: 0.35; }
      to { opacity: 0.78; }
    }

    @keyframes ringFloat {
      from { transform: scale(0.92); }
      to { transform: scale(1.06); }
    }
  </style>
</head>
<body>
  <div id="game-options">
    <div id="control-panel-options">
      <div id="options-title-bar">
        <h2>Exploration lampe torche (prototype)</h2>
      </div>
      <p class="menu-note">Concept en une étape : déplacez votre doigt/souris pour révéler des PNG d'animaux cachés dans la scène.</p>

      <div id="mode-divider"></div>

      <div id="options-inline-container">
        <div class="options-column">
          <div class="option-item">
            <label for="flashlightSize" class="teal-label label-block">Taille de la lampe</label>
            <div class="value-readout"><span id="flashlightSizeValue">180</span> px</div>
            <input id="flashlightSize" class="styled-slider" type="range" min="80" max="320" value="180" />
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="themeSelect" class="teal-label label-block">Thème</label>
            <select id="themeSelect" class="styled-select">
              <option value="africa">Afrique</option>
            </select>
          </div>
          <div class="option-item">
            <label for="modeSelect" class="teal-label label-block">Mode</label>
            <select id="modeSelect" class="styled-select">
              <option value="free">Free play</option>
              <option value="find">Find</option>
            </select>
          </div>
        </div>

        <div class="options-column">
          <div class="option-item">
            <label for="imageCount" class="teal-label label-block">Nombre d'images</label>
            <select id="imageCount" class="styled-select">
              <option>4</option>
              <option selected>6</option>
              <option>8</option>
              <option>10</option>
            </select>
          </div>
          <div class="option-item">
            <label for="imageSize" class="teal-label label-block">Taille des images</label>
            <div class="value-readout"><span id="imageSizeValue">100</span> px</div>
            <input id="imageSize" class="styled-slider" type="range" min="60" max="180" value="100" />
          </div>
        </div>
      </div>

      <div id="mode-divider"></div>

      <button id="startButton" class="button">Commencer</button>
    </div>
  </div>

  <main id="scene" aria-label="Scène d'exploration tactile">
    <div id="objectsLayer"></div>
    <div id="overlay"></div>
    <div id="pointer"></div>
    <div id="hint">Touchez ou déplacez la souris pour chercher les animaux cachés.</div>
    <div id="rewardOverlay" aria-hidden="true"></div>
  </main>

  <script>
    const SCENE_BY_THEME = {
      africa: [
        '../../images/africanbackground1.webp',
        '../../images/africanbackground2.webp',
        '../../images/africanbackground3.webp'
      ]
    };

    const FALLBACK_ANIMALS = [
      'elephant.png', 'lion.png', 'zebra.png', 'giraffe.png', 'monkey.png', 'hippo.png', 'snake.png', 'bird.png'
    ];

    const optionsModal = document.getElementById('game-options');
    const scene = document.getElementById('scene');
    const objectsLayer = document.getElementById('objectsLayer');
    const rewardOverlay = document.getElementById('rewardOverlay');
    const startButton = document.getElementById('startButton');
    const flashlightSizeInput = document.getElementById('flashlightSize');
    const flashlightSizeValue = document.getElementById('flashlightSizeValue');
    const themeSelect = document.getElementById('themeSelect');
    const modeSelect = document.getElementById('modeSelect');
    const imageCountSelect = document.getElementById('imageCount');
    const imageSizeInput = document.getElementById('imageSize');
    const imageSizeValue = document.getElementById('imageSizeValue');

    let flashlightX = window.innerWidth / 2;
    let flashlightY = window.innerHeight / 2;
    let targetFlashlightX = flashlightX;
    let targetFlashlightY = flashlightY;
    let animationFrameId = null;
    let animalsPool = null;
    let foundKeys = new Set();
    let sceneIndexByTheme = { africa: -1 };
    let roundTransitioning = false;

    flashlightSizeInput.addEventListener('input', () => {
      flashlightSizeValue.textContent = flashlightSizeInput.value;
      updateObjectVisibility();
    });

    imageSizeInput.addEventListener('input', () => {
      imageSizeValue.textContent = imageSizeInput.value;
    });

    function shuffle(arr) {
      const clone = [...arr];
      for (let i = clone.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [clone[i], clone[j]] = [clone[j], clone[i]];
      }
      return clone;
    }

    function getNextSceneForTheme(theme) {
      const list = SCENE_BY_THEME[theme] || [];
      if (list.length === 0) return null;
      const currentIndex = sceneIndexByTheme[theme] ?? -1;
      const nextIndex = (currentIndex + 1) % list.length;
      sceneIndexByTheme[theme] = nextIndex;
      return list[nextIndex];
    }

    async function loadAnimalPngs() {
      if (animalsPool) return animalsPool;

      try {
        const response = await fetch('../../images/pictos/index.json');
        if (!response.ok) throw new Error('index.json unavailable');
        const data = await response.json();
        const animaux = data?.categories?.animaux?.items ?? [];
        animalsPool = animaux
          .map(item => item.file)
          .filter(name => typeof name === 'string' && name.toLowerCase().endsWith('.png'));
      } catch (error) {
        console.warn('Fallback animals list used:', error);
        animalsPool = FALLBACK_ANIMALS;
      }

      return animalsPool;
    }

    function placeObjects(files, sizePx) {
      objectsLayer.innerHTML = '';
      const w = window.innerWidth;
      const h = window.innerHeight;

      files.forEach((file, idx) => {
        const img = document.createElement('img');
        img.className = 'hidden-object';
        img.src = `../../images/pictos/${file}`;
        img.alt = file.replace('.png', '');
        img.dataset.key = `${file}-${idx}`;
        img.style.setProperty('--size', `${sizePx}px`);

        const margin = 30;
        const x = margin + Math.random() * Math.max(1, (w - sizePx - margin * 2));
        const y = margin + Math.random() * Math.max(1, (h - sizePx - margin * 2));

        img.style.left = `${x}px`;
        img.style.top = `${y}px`;
        img.style.transform = `rotate(${(Math.random() * 18) - 9}deg)`;
        img.style.zIndex = `${idx + 1}`;
        img.onerror = () => img.remove();
        objectsLayer.appendChild(img);
      });

      updateObjectVisibility();
    }

    function finishFindRoundIfComplete(total) {
      if (roundTransitioning || modeSelect.value !== 'find') return;
      if (total > 0 && foundKeys.size >= total) {
        roundTransitioning = true;
        rewardOverlay.classList.add('show');

        scene.classList.add('completed');

        setTimeout(async () => {
          rewardOverlay.classList.remove('show');
          scene.classList.remove('completed');
          await startRound(true);
          roundTransitioning = false;
        }, 6200);
      }
    }

    function updateObjectVisibility() {
      const lightRadius = Number(flashlightSizeInput.value);
      const revealRadius = Math.max(30, lightRadius * 0.7);
      const mode = modeSelect.value;
      const images = objectsLayer.querySelectorAll('.hidden-object');

      images.forEach((img) => {
        const left = img.offsetLeft;
        const right = left + img.offsetWidth;
        const top = img.offsetTop;
        const bottom = top + img.offsetHeight;

        const nearestX = Math.max(left, Math.min(flashlightX, right));
        const nearestY = Math.max(top, Math.min(flashlightY, bottom));
        const dx = flashlightX - nearestX;
        const dy = flashlightY - nearestY;
        const distance = Math.hypot(dx, dy);
        const isRevealed = distance <= revealRadius;
        const key = img.dataset.key;

        if (mode === 'find') {
          if (isRevealed && key) foundKeys.add(key);
          img.style.opacity = foundKeys.has(key) ? '1' : '0';
        } else {
          img.style.opacity = isRevealed ? '1' : '0';
        }
      });

      finishFindRoundIfComplete(images.length);
    }

    function renderFlashlightPosition() {
      const smoothing = 0.22;
      flashlightX += (targetFlashlightX - flashlightX) * smoothing;
      flashlightY += (targetFlashlightY - flashlightY) * smoothing;

      if (Math.abs(targetFlashlightX - flashlightX) < 0.25) flashlightX = targetFlashlightX;
      if (Math.abs(targetFlashlightY - flashlightY) < 0.25) flashlightY = targetFlashlightY;

      const x = `${((flashlightX / window.innerWidth) * 100).toFixed(2)}%`;
      const y = `${((flashlightY / window.innerHeight) * 100).toFixed(2)}%`;
      scene.style.setProperty('--flashlight-x', x);
      scene.style.setProperty('--flashlight-y', y);

      updateObjectVisibility();

      animationFrameId = requestAnimationFrame(renderFlashlightPosition);
    }

    function updateFlashlightPosition(clientX, clientY) {
      targetFlashlightX = clientX;
      targetFlashlightY = clientY;
    }

    scene.addEventListener('pointermove', (event) => {
      updateFlashlightPosition(event.clientX, event.clientY);
    });

    scene.addEventListener('pointerdown', (event) => {
      updateFlashlightPosition(event.clientX, event.clientY);
    });

    window.addEventListener('resize', () => {
      flashlightX = window.innerWidth / 2;
      flashlightY = window.innerHeight / 2;
      targetFlashlightX = flashlightX;
      targetFlashlightY = flashlightY;
    });

    async function enterFullscreenOnStart() {
      if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
        try {
          await document.documentElement.requestFullscreen();
        } catch (error) {
          console.warn('Fullscreen request was denied or failed:', error);
        }
      }
    }

    async function startRound(useNextScene = false) {
      const theme = themeSelect.value;
      const imageCount = Number(imageCountSelect.value);
      const imageSize = Number(imageSizeInput.value);
      const flashlightSize = Number(flashlightSizeInput.value);
      const mode = modeSelect.value;

      if (!useNextScene || mode !== 'find') {
        sceneIndexByTheme[theme] = -1;
      }

      const nextScene = getNextSceneForTheme(theme);
      if (nextScene) {
        scene.style.backgroundImage = `url('${nextScene}')`;
      }

      scene.style.setProperty('--flashlight-size', `${flashlightSize}px`);

      const allAnimals = await loadAnimalPngs();
      const selected = shuffle(allAnimals).slice(0, imageCount);

      foundKeys = new Set();
      rewardOverlay.classList.remove('show');
      scene.classList.remove('completed');
      placeObjects(selected, imageSize);
    }

    startButton.addEventListener('click', async () => {
      await enterFullscreenOnStart();

      optionsModal.style.display = 'none';
      scene.style.display = 'block';

      flashlightX = window.innerWidth / 2;
      flashlightY = window.innerHeight / 2;
      targetFlashlightX = flashlightX;
      targetFlashlightY = flashlightY;

      await startRound(false);

      if (animationFrameId === null) {
        animationFrameId = requestAnimationFrame(renderFlashlightPosition);
      }
    });
  </script>
</body>
</html>
