<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gentle Bees</title>
  <style>
    :root {
      --sky: #f0f7ff;
      --meadow: #e5f6e0;
      --sun: #ffd166;
      --text: #0f172a;
      --button: #f97316;
      --button-dark: #ea580c;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Atkinson Hyperlegible", "Segoe UI", system-ui, sans-serif;
      background: linear-gradient(180deg, var(--sky) 0%, #eaf7ff 35%, var(--meadow) 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    main {
      position: relative;
      flex: 1;
      display: flex;
      align-items: stretch;
      justify-content: center;
      overflow: hidden;
    }

    #scene {
      flex: 1;
      width: 100%;
      height: 100%;
      display: block;
    }

    .action-area {
      position: absolute;
      left: 50%;
      bottom: clamp(1rem, 4vw, 2rem);
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 5;
      pointer-events: none;
    }

    .action-button {
      border: none;
      border-radius: 999px;
      width: clamp(4rem, 10vw, 5.5rem);
      aspect-ratio: 1 / 1;
      background: radial-gradient(circle at 30% 30%, #ffd891 0%, #f59e0b 45%, #f97316 100%);
      box-shadow: 0 18px 40px rgba(234, 88, 12, 0.28);
      cursor: pointer;
      transition: transform 150ms ease, box-shadow 150ms ease;
      position: relative;
      pointer-events: auto;
    }

    .action-button::before,
    .action-button::after {
      content: "";
      position: absolute;
      inset: 25%;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 35%, #fff6d5 0%, #fef08a 45%, #f59e0b 100%);
      filter: drop-shadow(0 6px 8px rgba(0, 0, 0, 0.12));
      transform: rotate(-8deg);
    }

    .action-button::after {
      inset: 38%;
      background: radial-gradient(circle at 40% 35%, #fde68a 0%, #f59e0b 80%);
      transform: rotate(18deg);
      mix-blend-mode: multiply;
    }

    .action-button:active,
    .action-button:focus-visible {
      outline: none;
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 12px 28px rgba(234, 88, 12, 0.22);
    }
  </style>
</head>
<body>
  <main>
    <canvas id="scene" aria-label="Bee meadow" role="img"></canvas>

    <div class="action-area">
      <button class="action-button" id="sendButton" aria-label="Send the bees"></button>
    </div>
  </main>

  <script>
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");
    const button = document.getElementById("sendButton");

    const bees = [];
    const pollenBursts = [];
    const honeyCells = [];
    const honeyGrid = [];
    let builtCells = 0;
    let pendingBuilds = 0;
    let flowers = [];
    let actionLocked = false;
    let lastSceneSize = { w: 1, h: 1 };

    function resizeCanvas() {
      const { width, height } = canvas.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      canvas.width = width * ratio;
      canvas.height = height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      setupHoneyGrid(true);
      if (flowers.length === 0) {
        flowers = createFlowers();
      } else {
        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);
        const scaleX = w / lastSceneSize.w;
        const scaleY = h / lastSceneSize.h;
        flowers = flowers.map((f) => ({
          x: f.x * scaleX,
          y: f.y * scaleY,
          sway: f.sway,
        }));
        lastSceneSize = { w, h };
      }
    }

    const resizeObserver = new ResizeObserver(resizeCanvas);
    resizeObserver.observe(canvas);
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const chime = audioCtx.createOscillator();
    const chimeGain = audioCtx.createGain();
    chime.type = "sine";
    chime.frequency.value = 660;
    chimeGain.gain.value = 0;
    chime.connect(chimeGain).connect(audioCtx.destination);
    chime.start();

    function playChime() {
      audioCtx.resume();
      const now = audioCtx.currentTime;
      chimeGain.gain.cancelScheduledValues(now);
      chimeGain.gain.setValueAtTime(0, now);
      chimeGain.gain.linearRampToValueAtTime(0.2, now + 0.05);
      chimeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
    }

    function hiveCenter() {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      return { x: w * 0.28, y: h * 0.55 };
    }

    function createBees(count) {
      bees.length = 0;
      for (let i = 0; i < count; i++) {
        bees.push({
          x: 0,
          y: 0,
          angle: Math.random() * Math.PI * 2,
          progress: 0,
          target: null,
          delay: Math.random() * 1.2,
        });
      }
      resetBees();
      setupHoneyGrid(true);
    }

    function resetBees() {
      const { x, y } = hiveCenter();
      bees.forEach((b) => {
        b.x = x + (Math.random() - 0.5) * 12;
        b.y = y + (Math.random() - 0.5) * 12;
        b.progress = 0;
        b.target = null;
      });
    }

    function setupHoneyCells() {
      honeyCells.length = 0;
      const { x, y } = hiveCenter();
      const radius = (Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1)) * 0.04;
      for (let r = -1; r <= 1; r++) {
        for (let c = -1; c <= 1; c++) {
          if (Math.abs(r) + Math.abs(c) <= 1) {
            honeyCells.push({
              x: x + c * radius * 1.8,
              y: y + r * radius * 1.6,
              fill: 0.2,
            });
          }
        }
      }
    }

    function setupHoneyGrid(keepProgress = false) {
      const targetCells = Math.max(1, bees.length);
      const preserved = keepProgress ? Math.min(builtCells, targetCells) : 0;
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      const areaWidth = w * 0.5;
      const radius = Math.min(w, h) * 0.035;
      const horiz = radius * 1.8;
      const vert = radius * 1.55;
      const margin = radius * 1.2;

      honeyGrid.length = 0;
      let row = 0;
      for (let y = margin; y <= h - margin; y += vert) {
        const offset = row % 2 === 0 ? 0 : horiz * 0.5;
        for (let x = margin + offset; x <= areaWidth - margin; x += horiz) {
          honeyGrid.push({ x, y, fill: 0.15 + Math.random() * 0.05 });
        }
        row++;
      }

      const centerX = areaWidth * 0.5;
      const centerY = h * 0.5;
      honeyGrid.sort((a, b) => {
        const distA = Math.hypot(a.x - centerX, a.y - centerY);
        const distB = Math.hypot(b.x - centerX, b.y - centerY);
        return distA - distB;
      });

      const baseAmount = Math.min(targetCells, Math.max(2, Math.round(honeyGrid.length * 0.05)));
      builtCells = Math.min(honeyGrid.length, targetCells, Math.max(baseAmount, preserved));
      pendingBuilds = 0;
    }

    function createFlowers() {
      const positions = [];
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      lastSceneSize = { w, h };
      const baseX = w * 0.65;
      const spread = Math.min(w, h) * 0.18;
      for (let i = 0; i < 5; i++) {
        const offsetY = (i - 2) * (spread / 3);
        positions.push({
          x: baseX + (Math.random() - 0.3) * spread,
          y: h * 0.5 + offsetY + (Math.random() - 0.5) * 30,
          sway: Math.random() * Math.PI * 2,
        });
      }
      return positions;
    }

    function drawBackground(t) {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);

      const skyGrad = ctx.createLinearGradient(0, 0, 0, h);
      skyGrad.addColorStop(0, "#eaf6ff");
      skyGrad.addColorStop(1, "#f7fbff");
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, w, h);

      ctx.fillStyle = "#d6f0d4";
      ctx.beginPath();
      ctx.ellipse(w * 0.1, h * 0.2, 60, 18, -0.2, 0, Math.PI * 2);
      ctx.fill();

      const hillGrad = ctx.createLinearGradient(0, h * 0.6, 0, h);
      hillGrad.addColorStop(0, "#c9e9c4");
      hillGrad.addColorStop(1, "#a8d9a8");
      ctx.fillStyle = hillGrad;
      ctx.beginPath();
      ctx.moveTo(0, h * 0.55);
      ctx.quadraticCurveTo(w * 0.35, h * 0.45, w * 0.6, h * 0.6);
      ctx.quadraticCurveTo(w * 0.8, h * 0.7, w, h * 0.62);
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      const sunX = w * 0.15;
      const sunY = h * 0.18;
      const sunR = Math.min(w, h) * 0.08;
      const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
      sunGrad.addColorStop(0, "rgba(255,209,102,0.8)");
      sunGrad.addColorStop(1, "rgba(255,209,102,0)");
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (let i = 0; i < 6; i++) {
        const cx = w * 0.35 + i * 30;
        const cy = h * 0.15 + Math.sin(t * 0.0005 + i) * 6;
        ctx.beginPath();
        ctx.ellipse(cx, cy, 28, 16, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = "#84cc16";
      for (let i = 0; i < 10; i++) {
        const x = (w / 10) * i + (Math.sin(t * 0.001 + i) * 10);
        const y = h * 0.7 + (Math.sin(t * 0.0015 + i) * 6);
        ctx.beginPath();
        ctx.ellipse(x, y, 24, 8, 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawHoneyField(t) {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      const areaWidth = w * 0.5;

      const honeyGrad = ctx.createLinearGradient(0, 0, areaWidth, 0);
      honeyGrad.addColorStop(0, "rgba(119, 63, 0, 0.14)");
      honeyGrad.addColorStop(0.35, "rgba(149, 88, 10, 0.14)");
      honeyGrad.addColorStop(1, "rgba(196, 128, 24, 0.08)");
      ctx.fillStyle = honeyGrad;
      ctx.fillRect(0, 0, areaWidth, h);

      ctx.fillStyle = "rgba(255, 193, 7, 0.06)";
      ctx.fillRect(0, 0, areaWidth, h);

      const radius = Math.min(w, h) * 0.035;
      const wobble = Math.sin(t * 0.002) * 0.08;

      function drawHex(x, y, r) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const ang = Math.PI / 3 * i + Math.PI / 6 + wobble;
          const px = x + Math.cos(ang) * r;
          const py = y + Math.sin(ang) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
      }

      honeyGrid.forEach((cell, idx) => {
        const built = idx < builtCells;
        if (built) {
          cell.fill = Math.max(0.25, cell.fill * 0.985);
        }
        const alpha = built ? 0.18 + cell.fill * 0.55 : 0.06;
        ctx.fillStyle = `rgba(250, 204, 21, ${alpha})`;
        drawHex(cell.x, cell.y, radius);
        ctx.fill();

        if (built) {
          ctx.strokeStyle = "rgba(245, 158, 11, 0.5)";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });

      ctx.globalAlpha = 1;
    }

    function drawHive(t) {
      const { x, y } = hiveCenter();
      const baseR = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) * 0.08;

      const glow = ctx.createRadialGradient(x, y, baseR * 0.1, x, y, baseR * 1.4);
      glow.addColorStop(0, "rgba(250, 204, 21, 0.35)");
      glow.addColorStop(1, "rgba(250, 204, 21, 0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(x, y, baseR * 1.4, 0, Math.PI * 2);
      ctx.fill();

      for (let i = 0; i < 5; i++) {
        const r = baseR * (0.55 + i * 0.08);
        const wobble = Math.sin(t * 0.002 + i) * 1.5;
        ctx.fillStyle = `hsl(39, 85%, ${68 - i * 5}% )`;
        ctx.beginPath();
        ctx.ellipse(x, y + wobble, r * 0.85, r * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      honeyCells.forEach((cell, idx) => {
        const fill = cell.fill;
        const col = idx % 2 === 0 ? "#fef08a" : "#fde047";
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.ellipse(cell.x, cell.y, baseR * 0.26, baseR * 0.22, 0, 0, Math.PI * 2);
        ctx.globalAlpha = 0.3 + fill * 0.7;
        ctx.fill();
        ctx.globalAlpha = 1;
        cell.fill = Math.max(0.2, cell.fill * 0.97);
      });
    }

    function drawFlowers(t) {
      const petalColors = ["#f97316", "#ec4899", "#22c55e", "#06b6d4", "#eab308"];
      flowers.forEach((f, i) => {
        const sway = Math.sin(t * 0.002 + f.sway) * 6;
        const stemH = 110;
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate((sway * Math.PI) / 180);

        ctx.strokeStyle = "#15803d";
        ctx.lineWidth = 6;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(12, stemH * 0.4, 0, stemH);
        ctx.stroke();

        const petalCount = 8;
        const petalR = 28;
        for (let p = 0; p < petalCount; p++) {
          const a = (Math.PI * 2 * p) / petalCount;
          const px = Math.cos(a) * petalR;
          const py = Math.sin(a) * petalR;
          ctx.beginPath();
          ctx.fillStyle = petalColors[(i + p) % petalColors.length];
          ctx.ellipse(px, py, 18, 10, a, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      });
    }

    function drawBee(bee, t) {
      ctx.save();
      ctx.translate(bee.x, bee.y);
      ctx.rotate(bee.angle);
      const wobble = Math.sin(t * 0.005 + bee.x * 0.05) * 0.1;
      ctx.rotate(wobble);

      ctx.globalAlpha = 0.8;
      ctx.fillStyle = "rgba(255, 209, 102, 0.25)";
      ctx.beginPath();
      ctx.arc(-12, 0, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#facc15";
      ctx.beginPath();
      ctx.ellipse(0, 0, 22, 14, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#0f172a";
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      ctx.moveTo(-6, -14);
      ctx.lineTo(-6, 14);
      ctx.moveTo(8, -12);
      ctx.lineTo(8, 12);
      ctx.stroke();

      ctx.fillStyle = "#0f172a";
      ctx.beginPath();
      ctx.arc(16, 0, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(191, 219, 254, 0.9)";
      ctx.beginPath();
      ctx.ellipse(-6, -12, 12, 7, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-6, 12, 12, 7, 0.3, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawPollen(t) {
      for (let i = pollenBursts.length - 1; i >= 0; i--) {
        const p = pollenBursts[i];
        p.life -= 0.016;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        if (p.life <= 0) {
          pollenBursts.splice(i, 1);
          continue;
        }
        const alpha = Math.max(0, p.life / p.maxLife);
        ctx.fillStyle = `rgba(250, 204, 21, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2 + (1 - alpha) * 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function activateBees() {
      if (actionLocked) return;

      playChime();
      actionLocked = true;
      button.disabled = true;
      pendingBuilds = 0;
      const { x, y } = hiveCenter();
      bees.forEach((bee, i) => {
        const flower = flowers[i % flowers.length];
        const ctrl = { x: (x + flower.x) / 2, y: (y + flower.y) / 2 - 60 };
        const home = reserveHoneyCell();
        bee.target = { flower, ctrlOut: ctrl, home };
        bee.progress = 0;
        bee.delay = Math.random() * 0.75;
      });
      honeyCells.forEach((cell) => {
        cell.fill = 0.15;
      });
    }

    function reserveHoneyCell() {
      if (honeyGrid.length === 0) return { cell: hiveCenter(), index: null };
      const capacity = Math.min(honeyGrid.length, bees.length);
      const nextIndex = Math.min(capacity, builtCells + pendingBuilds);
      if (nextIndex < capacity) {
        pendingBuilds++;
        return { cell: honeyGrid[nextIndex], index: nextIndex };
      }
      const cell = honeyGrid[Math.floor(Math.random() * Math.max(1, builtCells))];
      return { cell, index: null };
    }

    function updateBees(dt) {
      bees.forEach((bee) => {
        if (!bee.target) return;
        if (bee.delay > 0) {
          bee.delay -= dt;
          return;
        }
        bee.progress = Math.min(1, bee.progress + dt * 0.133);
        const { x: hx, y: hy } = hiveCenter();
        const { flower, ctrlOut: ctrl } = bee.target;
        const t = bee.progress;
        const inv = 1 - t;
        bee.x = inv * inv * hx + 2 * inv * t * ctrl.x + t * t * flower.x;
        bee.y = inv * inv * hy + 2 * inv * t * ctrl.y + t * t * flower.y;
        const dx = flower.x - bee.x;
        const dy = flower.y - bee.y;
        bee.angle = Math.atan2(dy, dx);

        if (t >= 1) {
          const { home } = bee.target;
          const backCtrl = {
            x: (flower.x + home.cell.x) / 2,
            y: (flower.y + home.cell.y) / 2 - 60,
          };
          bee.target = { flower, ctrlOut: ctrl, returning: true, home, ctrlBack: backCtrl };
          bee.progress = 0;
          bee.delay = 0.1;
          spawnPollen(flower.x, flower.y, true);
        }
      });

      bees.forEach((bee) => {
        if (!bee.target || !bee.target.returning) return;
        if (bee.delay > 0) {
          bee.delay -= dt;
          return;
        }
        bee.progress = Math.min(1, bee.progress + dt * 0.15);
        const { home } = bee.target;
        const hx = home?.cell?.x ?? hiveCenter().x;
        const hy = home?.cell?.y ?? hiveCenter().y;
        const { flower, ctrlBack: ctrl } = bee.target;
        const t = bee.progress;
        const inv = 1 - t;
        bee.x = inv * inv * flower.x + 2 * inv * t * ctrl.x + t * t * hx;
        bee.y = inv * inv * flower.y + 2 * inv * t * ctrl.y + t * t * hy;
        const dx = hx - bee.x;
        const dy = hy - bee.y;
        bee.angle = Math.atan2(dy, dx);

        if (t >= 1) {
          bee.target = null;
          bee.progress = 0;
          bee.delay = Math.random() * 1.6;
          feedHive(home);
          spawnPollen(hx, hy, false);
        }
      });
    }

    function feedHive(homeTarget) {
      if (honeyGrid.length > 0) {
        const capacity = Math.min(honeyGrid.length, bees.length);
        if (homeTarget && homeTarget.index != null && homeTarget.index < capacity) {
          honeyGrid[homeTarget.index].fill = 1;
          builtCells = Math.min(capacity, Math.max(builtCells, homeTarget.index + 1));
          pendingBuilds = Math.max(0, pendingBuilds - 1);
        } else if (builtCells < capacity) {
          honeyGrid[builtCells].fill = 1;
          builtCells++;
          pendingBuilds = Math.max(0, pendingBuilds - 1);
        } else {
          const cell = honeyGrid[Math.floor(Math.random() * honeyGrid.length)];
          cell.fill = Math.min(1, cell.fill + 0.35);
        }
      }

      if (honeyCells.length > 0) {
        const hiveCell = honeyCells[Math.floor(Math.random() * honeyCells.length)];
        hiveCell.fill = Math.min(1, hiveCell.fill + 0.35);
      }
    }

    function checkIdle() {
      if (actionLocked && bees.every((b) => !b.target)) {
        actionLocked = false;
        button.disabled = false;
      }
    }

    function spawnPollen(x, y, bright) {
      for (let i = 0; i < 14; i++) {
        const ang = (Math.PI * 2 * i) / 14 + Math.random() * 0.3;
        const speed = bright ? 1.8 : 1.2;
        pollenBursts.push({
          x,
          y,
          vx: Math.cos(ang) * speed,
          vy: Math.sin(ang) * speed,
          life: 1,
          maxLife: 1,
        });
      }
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      drawBackground(now);
      drawHoneyField(now);
      updateBees(dt);
      checkIdle();
      drawHive(now);
      drawFlowers(now);
      bees.forEach((bee) => drawBee(bee, now));
      drawPollen(now);
      requestAnimationFrame(loop);
    }

    function handleAction() {
      activateBees();
    }

    button.addEventListener("click", handleAction);
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        handleAction();
      }
    });

    createBees(8);
    setupHoneyCells();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
