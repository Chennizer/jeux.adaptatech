<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title data-fr="Initiation à la programmation physique" data-en="English placeholder for Initiation to Physical Programming">Initiation à la programmation physique</title>

  <!-- CSS Files -->
  <link rel="stylesheet" href="../../css/menu.css" />
  <link rel="stylesheet" href="../../css/global.css" />
  <link rel="stylesheet" href="../../css/layout.css" />
  <link rel="stylesheet" href="../../css/components.css" />
  <link rel="stylesheet" href="../../css/instructions.css" />

  <!-- Custom Styles for the new layout structure -->
  <style>
    /* Clearfix for the main container */
    .instruction-container::after {
      content: "";
      display: table;
      clear: both;
    }
    /* Two-column flex layout for sections if needed */
    .two-col {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 20px;
      margin-bottom: 40px;
    }
    .two-col .text {
      flex: 1;
      min-width: 250px;
    }
    .two-col .image {
      flex: 0 0 30vw;
      max-width: 30vw;
    }
    .two-col .image img {
      width: 100%;
      height: auto;
      display: block;
    }
    @media (max-width: 800px) {
      .two-col {
        flex-direction: column;
      }
      .two-col .image {
        flex: none;
        width: 100%;
        max-width: 100%;
      }
    }
    /* Styling for inline floated images */
    .img-float-right {
      float: right;
      width: 30vw;
      max-width: 100%;
      margin-right: 50px;
      margin-bottom: 20px;
      padding-top: 20px;
      padding-left: 20px;
    }
    /* Styling for side-by-side images */
    .images-row {
      display: flex;
      margin-top: 10px;
      margin-bottom: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 5px;
    }
    .images-row img {
      width: 20vw;
      margin: 0;
    }
    pre code {
        display: block;
        background-color: #2d2d2d;  /* Dark background for contrast */
        color: #f8f8f2;             /* Light text color */
        padding: 1rem;              /* Space inside the code block */
        border-radius: 8px;         /* Rounded corners */
        font-family: 'Source Code Pro', monospace; /* Monospaced font */
        overflow-x: auto;           /* Horizontal scroll if content exceeds width */
        }

        pre {
        margin: 1rem 0;             /* Vertical spacing around code blocks */
        }

  </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B45TJG4GBJ');
</script>
<body class="menu">
  <!-- Top Navigation -->
  <nav class="top-menu">
    <div class="top-menu-title" data-fr="Portail de jeux adaptés" data-en="Adapted Games Portal">Portail de jeux adaptés</div>
    <ul>
      <li>
        <strong><a href="../index.html" data-fr="Accueil" data-en="Home">Accueil</a></strong>
      </li>
      <li>
        <strong><a href="#" id="language-toggle" onclick="toggleLanguage(); return false;" data-fr="" data-en=""></a></strong>
      </li>
    </ul>
  </nav>

  <!-- Hero Section -->
  <div class="hero-minimalist">
    <h1 data-fr="Initiation à la programmation physique" data-en="English placeholder for Initiation to Physical Programming">Initiation à la programmation physique</h1>
  </div>

  <!-- Main Content Container -->
  <main class="instruction-container">
  
    <!-- Section: Programmation physique -->
    <section>
      <h3 data-fr="Programmation physique" data-en="English placeholder for Physical Programming">Programmation physique</h3>
      <p data-fr="
La programmation physique consiste à développer le logiciel qui contrôle un microcontrôleur. Cet outil est essentiel pour concevoir du matériel adapté. 
Par exemple, il permet de créer des switchs numériques qui peuvent être pertinentes dans de nombreux contextes.
      
Grâce à cette approche, les possibilités créatives sont vastes. Les technologies adaptées deviennent accessibles à un public large, y compris aux personnes à force manuelle limitée. Par exemple, des capteurs de proximité (infrarouge, ultrasons) requièrent moins d'effort qu'un bouton classique, tandis que des switchs de type <em>Sip and Puff</em> (souffle et aspiration) – associées à un capteur barométrique – offrent une alternative pour ceux dont la mobilité est réduite.
      <br/>
De plus, la programmation physique permet de développer des projets technologiques au-delà des switchs adaptées. 
Il est possible d'exploiter ce dispositif pour concevoir des projets interactifs variés, qu'il s'agisse de piloter des moteurs, de moduler l'éclairage ou d'activer des haut-parleurs.¨En programmant comme entrée une switch adaptée, un appareil peut recevoir un signal qui, en retour, déclenche l'action d'un mécanisme – qu'il s'agisse d'un moteur, d'une pompe, de luminaires ou de tout autre petit équipement électronique – offrant ainsi des possibilités infinies et laissant libre cours à une créativité sans limite. 
      
Cet article présente une vue d'ensemble des principes de base de la programmation physique et son potentiel. L'objectif n'est pas d'offrir un tutoriel complet, mais de montrer comment démarrer. Des ressources supplémentaires (en anglais) seront indiquées en conclusion.
      " data-en="English placeholder for Physical Programming">
      </p>
    </section>

    <section>
      <h3 data-fr="Choix de langage de programmation" data-en="English placeholder for Programming Language Choice">Choix de langage de programmation</h3>
      <p data-fr="
      Pour construire un dispositif numérique efficace, il faut choisir des technologies de base : le capteur, le microcontrôleur et le langage de programmation. Le microcontrôleur, qui exécute le code et contrôle les composants électroniques, constitue le cœur de l'appareil. Dans ce projet, le Raspberry Pico est utilisé, apprécié pour sa polyvalence et son prix abordable (environ 6 à 7 dollars). Un capteur de proximité, tel que le KY-032, est également intégré pour sa fiabilité et sa simplicité, permettant de détecter la présence ou le mouvement et d'interagir avec le dispositif.      </p>
      <img src="CPU_programmation.webp"/>
      <p data-fr="
      Pour le langage de programmation, de nombreuses options sont disponibles selon l'expérience du développeur. Des langages comme le C/C++ ou l'Assembly assurent des performances élevées, mais leur apprentissage peut être plus difficile. Dans le domaine des switchs numériques et du matériel adapté, trois langages se distinguent particulièrement:
        <ul class=&quot;list-disc&quot;>
        <li><strong>Micropython :</strong> Une implémentation complète de Python 3 optimisée pour les microcontrôleurs, idéale pour ceux ayant déjà une expérience de Python ou d’autres langages orientés objet.</li>
        <li><strong>Arduino :</strong> Basé sur le C/C++, cette plateforme est largement utilisée pour ses performances, même si elle demande plus de temps d'apprentissage et offre moins d'outils de débogage.</li>
        <li><strong>Circuitpython :</strong> Une version de Micropython développée par Adafruit pour rendre la programmation plus accessible, notamment aux amateurs, avec plusieurs outils facilitant le processus de programmation</li>
        </ul>
      " data-en="English placeholder for Programming Language Options">
      </p>
    </section>
  
    <section>

      <h3 data-fr="Exemple : switch qui détecte le mouvement" data-en="English placeholder for Example: Motion-Detecting Switch">Exemple : switch qui détecte le mouvement</h3>
      <p data-fr="
Pour cet exemple, le code sera pour un détecteur de mouvement qui active un relai. Concrètement, cela permet de faire un appareil qui a le même prince qu'une switch détectrice de mouvement comme la HoneyBee. Avant de programmer, il faut choisir un éditeur de code. Bien qu'il soit possible d'écrire du code dans un éditeur de texte simple, des outils spécialisés facilitent grandement le processus. Pour Circuitpython, l'éditeur Mu est recommandé, car il permet de sauvegarder le code directement sur le microcontrôleur et de le tester facilement. Pour télécharger Mu, cliquez <strong><a href='https://codewith.mu/en/download' download>ici</a></strong>.
      " data-en="English placeholder for Code Editor Choice">
      </p>

    </section>
  
    <!-- Section: Bibliothèques -->
    <section>
      <h4 data-fr="Bibliothèques" data-en="English placeholder for Libraries">Bibliothèques</h4>
      <p data-fr="
      Une bibliothèque (ou module) est un ensemble de fonctions et de classes pré‑écrites qui facilite le développement en masquant les détails bas‑niveau. Sans elles, chaque fonctionnalité (temporisation, gestion des broches, communication I²C, etc.) devrait être codée manuellement, ce qui alourdit et complique le projet.

      CircuitPython propose un <em>Library Bundle</em> officiel : un ZIP contenant toutes les bibliothèques de base à télécharger, ce qui permet de sélectionner celles qui sont utiles au projet et de les copier sur le microcontrôleur. Parmi les plus courantes : <em>time</em>, <em>board</em> et <em>digitalio</em>.
      
      time pour gérer les délais,
    
        <em>board</em> pour accéder aux broches GPxx,
        <em>digitalio</em> pour configurer les entrées/sorties numériques.
        D’autres modules, comme <em>analogio</em> (capteurs analogiques), <em>busio</em> (I²C/SPI) ou <em>neopixel</em> (rubans LED), peuvent également être utiles.

      </p>
      <pre><code class="language-python">import board
import time
from digitalio import DigitalInOut, Direction, Pull
      </code></pre>
    </section>
  
    <!-- Section: Initialisation du matériel -->
    <section>
      <h4 data-fr="Initialisation du matériel" data-en="English placeholder for Hardware Initialization">Initialisation du matériel</h4>
      <img  src="../../images/hugo/circuit_digital.png" alt="Description" style="float: right; width:60vh; margin-right: 50px; padding-top: 20px; padding-left: 20px;"/>

      <p data-fr="
      Une broche (ou « pin ») est un point de connexion physique sur le microcontrôleur, identifié par GP suivi d’un numéro (GP0, GP1, GP2, etc.). C’est sur l’une de ces broches que l’on soude le fil reliant l’élément externe (capteur, relais, moteur, LED…) au microcontrôleur. Dans le code, chaque broche doit être définie comme :

      INPUT (entrée) : pour recevoir un signal (par exemple la détection d’un capteur, un état haut/bas).
      
      OUTPUT (sortie) : pour envoyer un signal (par exemple fermer un relais, piloter un moteur, allumer une LED).
      
      En configurant correctement chaque broche en mode INPUT ou OUTPUT, on prépare le système à dialoguer avec ses capteurs et actionneurs.      " data-en="English placeholder for Hardware Initialization">
      </p>
      
      <pre><code class="language-python">sensor = DigitalInOut(board.GP22)
sensor.direction = Direction.INPUT

relay = DigitalInOut(board.GP0)
relay.direction = Direction.OUTPUT
      </code></pre>
    </section>
  
    <!-- Section: Définir les fonctions et les variables -->
    <section>
      <h4 data-fr="Définir les fonctions et les variables" data-en="English placeholder for Defining Variables and Functions">Définir les fonctions et les variables</h4>
      <p data-fr="
      En programmation, une <em>variable</em> est un espace nommé en mémoire qui stocke une valeur et permet de la réutiliser et de la modifier facilement tout au long du code. Organiser son programme autour de variables et de fonctions renforce la lisibilité, facilite la maintenance et limite les répétitions.  
      Dans cet exemple, la variable <em>activation_time</em> définit clairement la durée pendant laquelle le relais reste actif, ce qui permet d’ajuster ce délai en un seul endroit sans toucher au reste du code. La fonction <em>relay_activation</em>, quant à elle, encapsule la logique de détection et d’action : elle lit l’état du capteur, active le relais pendant l’intervalle spécifié, puis le désactive. Ce découpage en blocs logiques favorise la compréhension et la réutilisation de chaque composant de code.      " data-en="English placeholder for Variables and Functions">
      </p>
      <pre><code class="language-python">activation_time = 5

def relay_activation():
    if sensor.value:
        relay.value = True
        time.sleep(activation_time)
        relay.value = False
      </code></pre>
    </section>
  
    <!-- Section: Boucle principale -->
    <section>
      <h4 data-fr="Boucle principale" data-en="English placeholder for Main Loop">Boucle principale</h4>
      <p data-fr="
      En programmation embarquée, la <em>boucle principale</em> est un cycle infini qui s’exécute tant que le microcontrôleur reste sous tension. Elle organise en continu les mêmes étapes :  
      lecture de l’état du capteur pour récupérer une valeur,  
      appel de la fonction de contrôle pour activer ou désactiver le relais  
      et retour automatique au début du cycle.  
      Grâce à ce mécanisme, le dispositif reste constamment à l’écoute et peut réagir immédiatement dès qu’un mouvement ou une présence est détecté. On peut également insérer une courte pause entre chaque itération pour limiter la fréquence de vérification et économiser de l’énergie.
      </p>      " data-en="English placeholder for Main Loop">
      </p>
      <pre><code class="language-python">while True:
    relay_activation()
    time.sleep(0.01)
      </code></pre>
    </section>
  
    <!-- Section: Code final -->
    <section>
      <h4 data-fr="Code final" data-en="English placeholder for Final Code">Code final</h4>
      <p data-fr="
Voici le code complet qui réunit toutes les étapes présentées ci-dessus :
      " data-en="English placeholder for Final Code">
      </p>
      <pre><code class="language-python">import board
from digitalio import DigitalInOut, Direction, Pull
import time

sensor = DigitalInOut(board.GP22)
sensor.direction = Direction.INPUT

relay = DigitalInOut(board.GP0)
relay.direction = Direction.OUTPUT

activation_time = 5

def relay_activation():
    if sensor.value:
        relay.value = True
        time.sleep(activation_time)
        relay.value = False

while True:
    relay_activation()
    time.sleep(0.01)
      </code></pre>
      <p data-fr="
      En à peine vingt lignes, ce programme met en place une switch numérique fonctionnelle et démontre à quel point la programmation physique peut être accessible. Il constitue une base modulable : on peut ajuster la durée d’activation, ajouter des retours visuels ou sonores, intégrer d’autres capteurs ou piloter de nouveaux actionneurs. À partir de cet exemple, il est possible d'explorer des projets plus élaborés, de l’automatisation d’objets du quotidien à la création d’installations interactives sur mesure. Il suffit de garder à l'esprit qu'on programme une entrée (normalement un senseur ou une switch adaptée) qui va activer une sortie (l'effet que l'on désire sur l'environnement).
      " data-en="English placeholder for Final Code Summary">
      </p>
    </section>
  
    <!-- Section: Ressources -->
    <section>
      <h3 data-fr="Ressources" data-en="English placeholder for Resources">Ressources</h3>
      <p data-fr="
John Gallagher, enseignant au Boston College, propose plusieurs tutoriels sur sa <strong><a href='https://www.youtube.com/watch?v=eU1e6xPvZEU&amp;list=PL9VJ9OpT-IPSsQUWqQcNrVJqy4LhBjPX2&amp;ab_channel=JohnGallaugher' download>chaîne YouTube</a></strong> destinée aux débutants.
      " data-en="English placeholder for Resources">
      </p>
      <p data-fr="
Adafruit offre <strong><a href='https://learn.adafruit.com/welcome-to-circuitpython/what-is-circuitpython' download>des instructions détaillées</a></strong> pour utiliser CircuitPython, accompagnées d'une documentation complète pour les bibliothèques.
      " data-en="English placeholder for Resources">
      </p>
      <p data-fr="
Pour aller plus loin, consultez <strong><a href='https://github.com/adafruit/circuitpython' download>la page GitHub</a></strong> de CircuitPython, qui recense une multitude de ressources d'apprentissage.
      " data-en="English placeholder for Resources">
      </p>
    </section>
  
  </main>
  
  <!-- Footer inclusion (if available) -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      fetch('../../footer.html')
        .then(response => response.text())
        .then(data => {
          document.body.insertAdjacentHTML('beforeend', data);
        });
    });
  </script>
  <script src="../../js/translationmain.js"></script>
</body>
</html>
