<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title class="translate" data-fr="Flappy-ish" data-en="Flappy-ish">Flappy-ish</title>

  <!-- Shared styles (optional in your setup) -->
  <link rel="stylesheet" href="../../css/games.css">
  <link rel="stylesheet" href="../../css/choiceeyegaze.css">

  <style>
    :root { --fg:#e0fbfc; --ui-font: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    *{ box-sizing:border-box; }
    html,body { margin:0; height:100%; background:#0b1522; color:var(--fg); font-family:var(--ui-font); }

    #wrap { position:fixed; inset:0; }
    canvas#game { width:100vw; height:100vh; display:block; background:#87ceeb; }

    .hud {
      position:absolute; inset:0; pointer-events:none;
      display:flex; align-items:flex-start; justify-content:space-between; padding:12px 14px;
      font-weight:700; text-shadow:0 2px 0 rgba(0,0,0,.25);
    }
    .badge{
      pointer-events:none;
      background:rgba(0,0,0,.35);
      padding:.35rem .6rem; border-radius:999px; font-size:14px;
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(2px);
    }

    .footer { position:absolute; bottom:8px; left:0; right:0; display:flex; gap:8px; justify-content:center; pointer-events:none; }
    .kbd{ pointer-events:none; font-size:12px; padding:.2rem .45rem; border:1px solid rgba(255,255,255,.18); border-bottom-width:2px; background:rgba(255,255,255,.06); border-radius:6px; }

    .small-note{ font-family:var(--ui-font); font-weight:700; letter-spacing:.25px; line-height:1.25; }

    .bird-scroll { display:flex; gap:10px; overflow-x:auto; padding:4px 2px; scroll-snap-type:x mandatory; }
    .bird-chip {
      flex:0 0 auto; scroll-snap-align:start; display:inline-flex; align-items:center; gap:8px;
      padding:.45rem .8rem; border-radius:999px; border:2px solid rgba(0,0,0,0.15);
      background:#fff; color:#000; cursor:pointer; user-select:none; font-weight:800;
      box-shadow:0 2px 10px rgba(0,0,0,0.06);
      transition: transform .08s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .bird-chip[data-active="true"]{ border-color:#009688; box-shadow:0 4px 16px rgba(0,150,136,0.18); }
    .bird-emoji{ font-size:1.25rem; line-height:1; }
    .dark .bird-chip{ background:#111; color:#fff; border-color:rgba(255,255,255,.18); }
    .dark .bird-chip[data-active="true"]{ border-color:#14b8a6; box-shadow:0 4px 16px rgba(20,184,166,0.18); }
  </style>
</head>
<body>

<button id="langToggle" title="Basculer la langue / Toggle language">FR / EN</button>

<!-- Options modal -->
<div id="game-options" class="modal">
  <div id="options-title-bar">
    <h2 id="options-main-title" class="translate" data-fr="Flappy-ish" data-en="Flappy-ish">Flappy-ish</h2>
  </div>

  <div id="control-panel-options">
    <div id="mode-divider"></div>

    <div id="options-inline-container">
      <!-- Column 1: Audio -->
      <div class="options-column">
        <div class="option-item">
          <label class="teal-label">
            <input type="checkbox" id="muteSFX">
            <span class="translate" data-fr="D√©sactiver les sons" data-en="Disable sounds">D√©sactiver les sons</span>
          </label>
        </div>
        <div class="option-item">
          <label for="sfxVol" class="teal-label">
            <span class="translate" data-fr="Volume des sons:" data-en="Sound volume:">Volume des sons:</span>
            <span id="sfxVolVal">50</span>
          </label>
          <input type="range" id="sfxVol" class="styled-slider" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Column 2: Difficulty -->
      <div class="options-column">
        <div class="option-item">
          <label for="difficultySelect" class="teal-label label-block translate" data-fr="Difficult√©" data-en="Difficulty">Difficult√©</label>
          <select id="difficultySelect" class="styled-select">
            <option value="easy" selected class="translate" data-fr="Facile" data-en="Easy">Facile</option>
            <option value="normal" class="translate" data-fr="Normal" data-en="Normal">Normal</option>
            <option value="hard" class="translate" data-fr="Difficile" data-en="Hard">Difficile</option>
          </select>
        </div>
      </div>

      <!-- Column 3: Bird selector -->
      <div class="options-column">
        <div class="option-item">
          <div class="teal-label translate" data-fr="Oiseau / Th√®me" data-en="Bird / Theme">Oiseau / Th√®me</div>
          <div id="birdScroll" class="bird-scroll" role="listbox" aria-label="Bird">
            <div class="bird-chip" role="option" aria-selected="true" data-bird="classic" data-active="true">
              <span class="bird-emoji">üê¶</span>
              <span class="translate" data-fr="Classique (Jour + tuyaux)" data-en="Classic (Day + pipes)">Classique (Jour + tuyaux)</span>
            </div>
            <div class="bird-chip" role="option" aria-selected="false" data-bird="owl">
              <span class="bird-emoji">ü¶â</span>
              <span class="translate" data-fr="Chouette (Nuit + sapins)" data-en="Owl (Night + firs)">Chouette (Nuit + sapins)</span>
            </div>
            <div class="bird-chip" role="option" aria-selected="false" data-bird="parrot">
              <span class="bird-emoji">ü¶ú</span>
              <span class="translate" data-fr="Perroquet (Soleil + Fleurs)" data-en="Parrot (Sunny + Flowers)">Perroquet (Soleil + Fleurs)</span>
            </div>
          </div>
        </div>

        <div class="option-item">
          <div class="teal-label translate" data-fr="Contr√¥les" data-en="Controls">Contr√¥les</div>
          <div class="small-note">
            <span class="translate" data-fr="Souris/Doigt pour monter/descendre" data-en="Mouse/Finger to steer up/down">Souris/Doigt pour monter/descendre</span><br>
            <span class="translate" data-fr="Pause: P ‚Äî Red√©marrer: R" data-en="Pause: P ‚Äî Restart: R">Pause: P ‚Äî Red√©marrer: R</span><br>
            <span class="translate" data-fr="D√©marrer: Espace ou Entr√©e" data-en="Start: Space or Enter">D√©marrer: Espace ou Entr√©e</span>
          </div>
        </div>
      </div>
    </div>

    <div id="mode-divider"></div>
    <button id="startButton" class="button translate" data-fr="Commencer" data-en="Start">Commencer</button>
  </div>
</div>

<!-- Game area -->
<div id="wrap" aria-label="Flappy style game">
  <canvas id="game"></canvas>

  <div class="hud" aria-live="polite">
    <div class="badge translate" data-fr="Pointage" data-en="Score">Pointage</div>
    <div class="badge"> <span class="translate" data-fr="Score:" data-en="Score:">Score:</span> <span id="score">0</span></div>
    <div class="badge"> <span class="translate" data-fr="Meilleur:" data-en="Best:">Meilleur:</span> <span id="best">0</span></div>
  </div>

  <div class="footer">
    <div class="kbd">Sprites: bird up/mid/down ‚Ä¢ owl 1‚Äì3 ‚Ä¢ parrot 1‚Äì3</div>
  </div>
</div>

<!-- Shared scripts (optional in your setup) -->
<script src="../../js/eyegaze-menu.js"></script>
<script src="../../js/translationonly.js"></script>

<script>
(() => {
  /* =========================
     Language
     ========================= */
  const LS_LANG_KEY = 'siteLanguage';
  const langToggle  = document.getElementById('langToggle');

  function getLang(){
    try {
      const saved = localStorage.getItem(LS_LANG_KEY);
      if (saved === 'en' || saved === 'fr') return saved;
    } catch(e){}
    return (document.documentElement.lang === 'en') ? 'en' : 'fr';
  }
  function setLang(lang){
    const safe = (lang === 'en') ? 'en' : 'fr';
    document.documentElement.lang = safe;
    try { localStorage.setItem(LS_LANG_KEY, safe); } catch(e){}
    document.querySelectorAll('.translate').forEach(el=>{
      const fr = el.getAttribute('data-fr');
      const en = el.getAttribute('data-en');
      if (safe === 'fr' && fr != null) el.textContent = fr;
      if (safe === 'en' && en != null) el.textContent = en;
    });
  }
  (function normalizeLangOnLoad(){
    let initial = 'fr';
    try {
      const saved = localStorage.getItem(LS_LANG_KEY);
      if (saved === 'en' || saved === 'fr') {
        initial = saved;
      } else {
        initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
        localStorage.setItem(LS_LANG_KEY, initial);
      }
    } catch(e){
      initial = (document.documentElement.lang === 'en') ? 'en' : 'fr';
    }
    setLang(initial);
  })();
  langToggle.addEventListener('click', ()=> setLang(getLang()==='fr' ? 'en' : 'fr'));

  /* =========================
     Controls & UI
     ========================= */
  const muteSFX        = document.getElementById('muteSFX');
  const sfxVol         = document.getElementById('sfxVol');
  const sfxVolVal      = document.getElementById('sfxVolVal');
  const startButton    = document.getElementById('startButton');
  const difficultySel  = document.getElementById('difficultySelect');

  // Bird selector (scroll chips)
  const birdScroll = document.getElementById('birdScroll');
  const birdChips  = Array.from(birdScroll.querySelectorAll('.bird-chip'));
  let birdSet = 'classic';

  birdChips.forEach(ch => {
    ch.addEventListener('click', () => {
      birdChips.forEach(c => { c.dataset.active = 'false'; c.setAttribute('aria-selected', 'false'); });
      ch.dataset.active = 'true';
      ch.setAttribute('aria-selected', 'true');
      birdSet = ch.dataset.bird || 'classic';
      loadSpriteSet(birdSet); // swap immediately in preview
    });
  });

  sfxVol.addEventListener('input', () => sfxVolVal.textContent = sfxVol.value);

  if (typeof initEyegazeMenu === 'function') initEyegazeMenu();

  /* =========================
     Canvas & Game
     ========================= */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let W = window.innerWidth;
  let H = window.innerHeight;
  let GH = Math.max(60, Math.round(H * 0.12)); // ground height
  let PIPE_W = Math.max(28, Math.round(W * 0.035)); // obstacle width basis
  let dpr = 1;

  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');

  let difficulty = 'easy';
  difficultySel.addEventListener('change', () => {
    difficulty = difficultySel.value;
    rescaleConfig();
  });

  // Audio
  let AC, masterGain;
  function ensureAudio() {
    if (!AC) {
      AC = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = AC.createGain();
      masterGain.gain.value = effectiveVolume();
      masterGain.connect(AC.destination);
    }
    if (AC.state === 'suspended') AC.resume();
    updateMasterGain();
  }
  function effectiveVolume(){
    const muted = !!muteSFX.checked;
    const volPercent = parseInt(sfxVol.value, 10);
    return muted ? 0 : Math.max(0, Math.min(1, (isNaN(volPercent)?50:volPercent) / 100));
  }
  function updateMasterGain(){
    if (masterGain) masterGain.gain.value = effectiveVolume();
  }
  muteSFX.addEventListener('change', updateMasterGain);
  sfxVol.addEventListener('input', updateMasterGain);

  function beep(freq=600, dur=0.08, type='sine', vol=0.6) {
    if (!AC) return;
    const t0 = AC.currentTime + 0.001;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(masterGain);
    o.start(t0); o.stop(t0 + dur + 0.02);
  }
  function scoreChime(){ ensureAudio(); beep(850, .07, 'square', .5); setTimeout(()=>beep(1100,.06,'square',.45), 30); }
  function hitSfx(){ ensureAudio(); beep(200, .18, 'sawtooth', .35); setTimeout(()=>beep(120,.22,'sawtooth',.3), 40); }

  const rand = (a,b)=>a + Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  const State = { READY:0, PLAYING:1, PAUSED:2, DEAD:3 };
  let state = State.READY;
  let score = 0, best = parseInt(localStorage.getItem('flappy-best')||'0',10);
  bestEl.textContent = best;

  // Difficulty presets
  const presetsBase = {
    easy:   { gap: 240, speed: 1.0 },
    normal: { gap: 170, speed: 2.4 },
    hard:   { gap: 140, speed: 3.6 }
  };
  const SPACING_FACTOR = { easy: 0.42, normal: 0.33, hard: 0.27 };

  // Flowers: larger than pipes but not huge
  const FLOWER_GAP_MULT = { easy: 1.30, normal: 1.38, hard: 1.50 };

  let cfg = { gap: 220, speed: 2.4, spawn: 1.5 };

  function rescaleConfig() {
    const base = presetsBase[difficulty];
    cfg.gap   = Math.round(base.gap * (H / 640));
    cfg.speed = base.speed;
    const spacingPx = Math.max(200, Math.round(W * SPACING_FACTOR[difficulty]));
    const vx = cfg.speed * 60; // px/s
    cfg.spawn = spacingPx / vx; // seconds
  }

  const bird = { x: Math.round(W*0.25), y: Math.round(H*0.45), r: 14, angle: 0, wingPhase: 0 };
  let targetY = bird.y;
  function setTargetY(y){ targetY = clamp(y, bird.r+5, H - GH - bird.r - 5); }

  /* =========================
     Sprite sets (classic vs owl vs parrot)
     ========================= */
  const SPRITE_EXTS = [".png", ".webp", ".jpg", ".jpeg"];

  const BIRD_SETS = {
    classic: {
      bases: [
        "../../images/flappybird/birdup",
        "../../images/flappybird/birdmid",
        "../../images/flappybird/birddown"
      ],
      cycle: [1, 0, 1, 2],
      scaleH: 6,
      theme: 'day-pipes'
    },
    owl: {
      bases: [
        "../../images/flappybird/owlsprite1",
        "../../images/flappybird/owlsprite2",
        "../../images/flappybird/owlsprite3"
      ],
      cycle: [0, 1, 2],
      scaleH: 6.5,
      theme: 'night-firs'
    },
    parrot: {
      bases: [
        "../../images/flappybird/parrot1",
        "../../images/flappybird/parrot2",
        "../../images/flappybird/parrot3"
      ],
      cycle: [0, 1, 2],
      scaleH: 6.2,
      theme: 'sunny-flowers'
    }
  };

  let spriteFrames = [];
  let spriteReady  = false;
  let currentSet   = 'classic';
  let currentCycle = BIRD_SETS.classic.cycle;
  let currentScaleH= BIRD_SETS.classic.scaleH;
  let currentTheme = BIRD_SETS.classic.theme;

  function loadWithFallback(base){
    return new Promise(resolve=>{
      let i = 0;
      function tryNext(){
        if (i >= SPRITE_EXTS.length){ resolve(null); return; }
        const src = base + SPRITE_EXTS[i++]; const img = new Image();
        img.onload = ()=>resolve(img); img.onerror = tryNext; img.src = src;
      }
      tryNext();
    });
  }

  async function loadSpriteSet(name){
    const def = BIRD_SETS[name] || BIRD_SETS.classic;
    const imgs = await Promise.all(def.bases.map(loadWithFallback));
    const ok = imgs.filter(Boolean);
    spriteReady = (ok.length === def.bases.length);
    if (spriteReady) {
      spriteFrames = ok;
      currentSet   = name;
      currentCycle = def.cycle;
      currentScaleH= def.scaleH;
      currentTheme = def.theme;
    } else {
      spriteFrames = [];
      currentTheme = def.theme;
    }
  }

  // Obstacles
  const pipes = [];       let pipeTimer   = 0;
  const flowerTunnels = []; let flowerTimer = 0;
  const firTunnels = [];    let firTimer    = 0;

  // Clouds & stars
  const clouds = [];
  function makeCloud() {
    const y = rand(20, H*0.55);
    const s = rand(0.6, 1.4);
    const w = rand(100, 200)*s;
    const h = rand(24, 42)*s;
    clouds.push({ x: W + w, y, w, h, speed: rand(12, 22)*s });
  }
  for(let i=0;i<8;i++) makeCloud();

  const stars = Array.from({length: 120}, () => ({
    x: Math.random(),
    y: Math.random()*0.7,
    r: Math.random()*1.2 + 0.3,
    tw: Math.random()*2*Math.PI
  }));

  let groundOffset = 0;

  function fit() {
    W = window.innerWidth; H = window.innerHeight;
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    GH = Math.max(60, Math.round(H * 0.12));
    PIPE_W = Math.max(28, Math.round(W * 0.035));
    rescaleConfig();
    bird.r = Math.max(10, Math.round(14 * (H / 640)));
    bird.x = Math.round(W * 0.25);
    setTargetY(targetY);
  }
  window.addEventListener('resize', fit, { passive:true });

  async function goFullscreen(){
    try{
      if (document.fullscreenElement) return;
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      setTimeout(()=>window.scrollTo(0,1), 50);
    }catch(e){}
  }

  function resetGameState(){
    rescaleConfig();
    score = 0; scoreEl.textContent = '0';
    pipes.length = 0; pipeTimer = 0;
    flowerTunnels.length = 0; flowerTimer = 0;
    firTunnels.length = 0; firTimer = 0;
    groundOffset = 0;
    bird.x = Math.round(W*0.25);
    bird.y = Math.round(H*0.45);
    targetY = bird.y;
    bird.angle = 0; bird.wingPhase = 0;
  }

  function restart(){ resetGameState(); state = State.READY; }

  async function startGame(){
    ensureAudio();
    await goFullscreen();
    try { document.getElementById('game-options').style.display = 'none'; } catch(e){}
    langToggle.style.display = 'none';
    await loadSpriteSet(birdSet);
    if (state === State.DEAD) resetGameState();
    state = State.PLAYING;
  }

  // Keyboard
  window.addEventListener('keydown', e=>{
    if (e.key === 'p' || e.key === 'P'){
      if (state === State.PLAYING){ state = State.PAUSED; }
      else if (state === State.PAUSED){ state = State.PLAYING; }
    } else if (e.key === 'r' || e.key === 'R'){
      restart();
    } else if (e.code === 'Space' || e.code === 'Enter'){
      if (state === State.READY || state === State.PAUSED || state === State.DEAD){
        e.preventDefault();
        startGame();
      }
    }
  });

  // Pointer
  window.addEventListener('mousedown', (e)=>{ if (state === State.PLAYING) setTargetY(e.clientY); });
  window.addEventListener('mousemove', (e)=>{ setTargetY(e.clientY); }, { passive:true });
  window.addEventListener('touchstart', (e)=>{ if (state === State.PLAYING && e.touches[0]) setTargetY(e.touches[0].clientY); }, { passive:true });
  window.addEventListener('touchmove', (e)=>{ if (e.touches[0]) setTargetY(e.touches[0].clientY); }, { passive:true });

  // Start button
  startButton.addEventListener('click', startGame);

  /* =========================
     Skies
     ========================= */
  function drawSkyDay() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#78c6ff');
    g.addColorStop(0.6, '#8ed0ff');
    g.addColorStop(1, '#b1e1ff');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
  function drawSun() {
    ctx.save();
    const cx = W*0.12, cy = H*0.16, r = Math.max(48, Math.min(W,H)*0.06);
    const glow = ctx.createRadialGradient(cx,cy,6, cx,cy,r*2.4);
    glow.addColorStop(0, 'rgba(255,230,170,.95)');
    glow.addColorStop(1, 'rgba(255,230,170,0)');
    ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(cx,cy,r*2.4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawSkyNight() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0b1020');
    g.addColorStop(1, '#081331');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // Twinkling stars
    ctx.save();
    for (const s of stars) {
      const tw = (Math.sin(performance.now()/600 + s.tw)+1)/2;
      ctx.globalAlpha = 0.4 + 0.6*tw;
      ctx.beginPath();
      ctx.arc(s.x*W, s.y*H, s.r, 0, Math.PI*2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
    }
    ctx.restore();

    // Full bright moon
    const mx = W*0.16, my = H*0.18;
    ctx.save();
    const mr = Math.max(28, Math.min(W,H)*0.05);
    const mglow = ctx.createRadialGradient(mx,my,4, mx,my,mr*2.2);
    mglow.addColorStop(0,'rgba(255,255,230,0.85)');
    mglow.addColorStop(1,'rgba(255,255,230,0)');
    ctx.fillStyle = mglow; ctx.beginPath(); ctx.arc(mx,my,mr*2.2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#f6f1d5'; ctx.beginPath(); ctx.arc(mx,my,mr,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawSkySunny() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#7fd3ff');
    g.addColorStop(0.6, '#9fe0ff');
    g.addColorStop(1, '#c7ecff');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    drawSun();
  }

  /* =========================
     Ground
     ========================= */
  function drawGround() {
    const y0 = H - GH;
    const g = ctx.createLinearGradient(0,y0,0,H);
    g.addColorStop(0,'#3b7f3b'); g.addColorStop(1,'#2c5f2c');
    ctx.fillStyle = g; ctx.fillRect(0,y0, W, GH);
    ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(0, y0, W, 2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0, y0+2, W, 2);

    const step = Math.max(60, Math.round(W * 0.06));
    const offset = groundOffset % step;
    function pebble(cx, cy, w, h, color){
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(cx, cy, w, h, 0, 0, Math.PI*2);
      ctx.fill();
    }
    for (let x = -offset; x < W + step; x += step) {
      pebble(x + 10, y0 + Math.round(GH*0.62), 14, 5, 'rgba(255,255,255,0.08)');
      pebble(x + 36, y0 + Math.round(GH*0.72), 10, 4, 'rgba(0,0,0,0.08)');
      pebble(x + 70, y0 + Math.round(GH*0.58), 8, 3,  'rgba(255,255,255,0.06)');
    }
  }

  /* =========================
     Pipes (day mode)
     ========================= */
  function drawPipe(x, topH, w=PIPE_W, gap=cfg.gap) {
    const bottomY = topH + gap;
    const capH = Math.max(10, Math.round(w * 0.36));
    const over = Math.max(6,  Math.round(w * 0.22));
    const bevelW = Math.max(3, Math.round(w * 0.10));

    const bodyGrad = ctx.createLinearGradient(x,0,x+w,0);
    bodyGrad.addColorStop(0.00, '#064f18');
    bodyGrad.addColorStop(0.16, '#0f8a2d');
    bodyGrad.addColorStop(0.50, '#39e15e');
    bodyGrad.addColorStop(0.84, '#0f8a2d');
    bodyGrad.addColorStop(1.00, '#064f18');

    ctx.fillStyle = bodyGrad;
    ctx.fillRect(x, 0, w, topH);
    ctx.fillRect(x, bottomY, w, H - bottomY);

    const stripeX1 = x + Math.round(w * 0.24);
    const stripeX2 = x + Math.round(w * 0.70);
    const stripeG1 = ctx.createLinearGradient(stripeX1-2,0,stripeX1+2,0);
    stripeG1.addColorStop(0,'rgba(255,255,255,0)');
    stripeG1.addColorStop(0.5,'rgba(255,255,255,0.22)');
    stripeG1.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = stripeG1;
    ctx.fillRect(stripeX1-2, 0, 4, topH);
    ctx.fillRect(stripeX1-2, bottomY, 4, H - bottomY);

    const stripeG2 = ctx.createLinearGradient(stripeX2-1,0,stripeX2+1,0);
    stripeG2.addColorStop(0,'rgba(255,255,255,0)');
    stripeG2.addColorStop(0.5,'rgba(255,255,255,0.12)');
    stripeG2.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = stripeG2;
    ctx.fillRect(stripeX2-1, 0, 2, topH);
    ctx.fillRect(stripeX2-1, bottomY, 2, H - bottomY);

    function roundRectPath(x, y, w, h, r){
      const rr = Math.min(r, h/2, w/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.lineTo(x+w-rr, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
      ctx.lineTo(x+w, y+h-rr);
      ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
      ctx.lineTo(x+rr, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
      ctx.lineTo(x, y+rr);
      ctx.quadraticCurveTo(x, y, x+rr, y);
      ctx.closePath();
    }

    function drawRim(cx, cy, cw, ch, facingDown){
      let base = ctx.createLinearGradient(cx, cy, cx, cy+ch);
      if (facingDown){
        base.addColorStop(0.00, '#6df279');
        base.addColorStop(0.45, '#2bd24f');
        base.addColorStop(1.00, '#18a83a');
      } else {
        base.addColorStop(0.00, '#18a83a');
        base.addColorStop(0.55, '#2bd24f');
        base.addColorStop(1.00, '#6df279');
      }
      ctx.fillStyle = base;
      roundRectPath(cx, cy, cw, ch, Math.round(ch*0.35));
      ctx.fill();

      function sideBevel(bx){
        const sg = ctx.createLinearGradient(bx, cy, bx+bevelW, cy);
        sg.addColorStop(0, 'rgba(0,0,0,0.45)');
        sg.addColorStop(0.6, 'rgba(0,0,0,0.0)');
        ctx.fillStyle = sg;
        roundRectPath(bx, cy+1, bevelW, ch-2, Math.round((ch-2)*0.33));
        ctx.fill();
      }
      sideBevel(cx);
      ctx.save(); ctx.translate(cx+cw,0); ctx.scale(-1,1); sideBevel(0); ctx.restore();

      const gloss = ctx.createLinearGradient(cx, cy, cx, cy+ch);
      gloss.addColorStop(0.15,'rgba(255,255,255,0.30)');
      gloss.addColorStop(0.35,'rgba(255,255,255,0.10)');
      gloss.addColorStop(0.65,'rgba(255,255,255,0.05)');
      gloss.addColorStop(1.00,'rgba(255,255,255,0.00)');
      ctx.fillStyle = gloss;
      roundRectPath(cx+2, cy+1, cw-4, Math.max(2, ch-2), Math.max(1, Math.round((ch-2)*0.28)));
      ctx.fill();

      ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(cx, cy, cw, 1);
      ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(cx+3, cy+Math.round(ch*0.28), cw-6, 1);

      const inner = facingDown
        ? ctx.createLinearGradient(cx, cy+ch-4, cx, cy+ch+6)
        : ctx.createLinearGradient(cx, cy-6, cx, cy+4);
      inner.addColorStop(0, 'rgba(0,0,0,0.35)');
      inner.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = inner;
      ctx.fillRect(cx, facingDown ? (cy+ch-4) : (cy-6), cw, 10);
    }

    drawRim(x - over, topH - capH, w + over*2, capH, true);
    drawRim(x - over, bottomY,      w + over*2, capH, false);
  }

  /* =========================
     Flowers (sunny theme)
     ========================= */
  function makeFlowerStyle(){
    const petals = ['#ff5e7e','#ff9f1c','#ffd166','#06d6a0','#7b5cff','#ff66c4','#ff7f50'];
    const centers= ['#fff176','#ffe066','#faf3dd','#ffd6a5','#ffd97d'];
    return {
      petal: petals[Math.floor(Math.random()*petals.length)],
      center: centers[Math.floor(Math.random()*centers.length)],
      leaf: '#2f8f2f'
    };
  }

  function drawLeafShape(w, h) {
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.quadraticCurveTo(w*0.55, -h*0.25, 0, -h);
    ctx.quadraticCurveTo(-w*0.55, -h*0.25, 0, 0);
    ctx.closePath();
    ctx.fill();
  }

  function drawFlowerHead(size, style){
    const petals = 8;
    const petalR = size * 0.58;
    const petalSize = size * 0.95;
    ctx.fillStyle = style.petal;
    for (let i=0;i<petals;i++){
      const a = (i / petals) * Math.PI*2;
      const px = Math.cos(a) * petalR;
      const py = Math.sin(a) * petalR;
      ctx.beginPath();
      ctx.ellipse(px, py, petalSize*0.46, petalSize*0.36, a, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.fillStyle = style.center;
    ctx.beginPath();
    ctx.arc(0,0, size*0.42, 0, Math.PI*2);
    ctx.fill();
  }

  function drawStemAndLeaves(x, yBase, height, style, top=false){
    const stemW = Math.max(12, Math.round(PIPE_W * 0.55));
    const grad = ctx.createLinearGradient(x, top ? yBase-height : yBase, x, top ? yBase : yBase+height);
    grad.addColorStop(0, '#2e7d32');
    grad.addColorStop(1, '#1b5e20');
    ctx.fillStyle = grad;
    ctx.fillRect(x - stemW/2, top ? yBase - height : yBase, stemW, height);

    ctx.fillStyle = style.leaf;
    const leafW = stemW * 1.8;
    const leafH = stemW * 2.2;
    const baseY = top ? (yBase - height + leafH * 1.2) : (yBase + height - leafH * 1.2);

    ctx.save();
    ctx.translate(x - stemW*0.9, baseY);
    ctx.rotate(top ? Math.PI*0.9 : -Math.PI*0.1);
    drawLeafShape(leafW, leafH);
    ctx.restore();

    ctx.save();
    ctx.translate(x + stemW*0.9, baseY);
    ctx.rotate(top ? Math.PI*0.1 : -Math.PI*0.9);
    drawLeafShape(leafW, leafH);
    ctx.restore();

    return stemW;
  }

  function drawFlowerTunnel(t){
    const {x, topH, gap, style} = t;
    const bottomY = topH + gap;

    const topStemHeight    = topH;
    const bottomStemHeight = H - GH - bottomY;

    const cx = x + Math.floor(t.w/2);

    const stemWTop = drawStemAndLeaves(cx, topStemHeight, topStemHeight, style, true);
    const stemWBot = drawStemAndLeaves(cx, bottomY, bottomStemHeight, style, false);

    const headSize = Math.max(28, PIPE_W * 1.2);

    ctx.save(); ctx.translate(cx, topStemHeight); ctx.scale(1, -1); drawFlowerHead(headSize, style); ctx.restore();
    ctx.save(); ctx.translate(cx, bottomY); drawFlowerHead(headSize, style); ctx.restore();

    t._hit = {
      stemTop:    {x: cx - stemWTop/2, y: 0, w: stemWTop, h: topStemHeight},
      stemBottom: {x: cx - stemWBot/2, y: bottomY, w: stemWBot, h: H - GH - bottomY},
      headTop:    {cx, cy: topStemHeight, r: headSize*0.46},
      headBottom: {cx, cy: bottomY,      r: headSize*0.46}
    };
  }

  /* =========================
     NIGHT FIR TREES (owl theme)
     ========================= */
  /* =========================
   CHRISTMAS-TREE LOOK
   ========================= */
function makeFirStyle(){
  // deeper greens + warmer bark = ‚ÄúChristmas tree‚Äù vibe
  return {
    trunk1: '#5a3a2a',
    trunk2: '#3e281f',
    foliage: '#256d2a',
    foliageShade: '#1e5723',
    highlight: 'rgba(255,255,255,0.06)'
  };
}
// 1) Tronc plus mince (garde les rainures)
function drawTrunkRect(r, style){
  const grad = ctx.createLinearGradient(r.x, 0, r.x + r.w, 0);
  grad.addColorStop(0, style.trunk2);
  grad.addColorStop(0.5, style.trunk1);
  grad.addColorStop(1, style.trunk2);
  ctx.fillStyle = grad;
  ctx.fillRect(r.x, r.y, r.w, r.h);

  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  const grooves = 2;
  for (let i = 1; i <= grooves; i++){
    const gx = r.x + Math.round((i/(grooves+1)) * r.w);
    ctx.fillRect(gx, r.y, 1, r.h);
  }
}

// 2) Tiers g√©ants couvrant toute la longueur, AVEC chevauchement
function buildFirHitboxes(t){
  const xCenter = t.x + t.w/2;
  const bottomY = t.topH + t.gap;
  const worldBottom = H - GH;

  const topStemH    = Math.max(0, t.topH);
  const bottomStemH = Math.max(0, worldBottom - bottomY);

  // >>> tronc aminci
  const trunkW = Math.max(8, Math.round(PIPE_W * 0.55));

  // c√¥ne: √©troit √† la pointe, large vers l‚Äôouverture
  const baseTierW = Math.max(trunkW*3.0, PIPE_W*3.2);
  const tipTierW  = Math.max(trunkW*1.05, PIPE_W*1.20);

  // 4 ou 5 gros triangles
  const TIERS = 5;                       // mets 4 si tu veux 4 √©tages
  const OVERHANG = Math.max(10, PIPE_W*0.45);   // la pointe d√©passe

  // chevauchement vertical entre √©tages (plus grand = plus ‚Äútouffu‚Äù)
  const OVERLAP = Math.max(8, Math.round(PIPE_W * 0.28)); 

  // utilitaire: calcule une hauteur de triangle telle que
  // N*h - (N-1)*overlap = longueur √† couvrir
  function tierHeightToCover(totalLen){
    return (totalLen + (TIERS-1)*OVERLAP) / TIERS;
  }

  const tiersTop = [];
  const tiersBot = [];

  function pushTier(list, apexY, tierH, w, inverted){
    list.push({
      x: Math.round(xCenter - w/2),
      y: Math.round(inverted ? (apexY - tierH) : apexY),
      w: Math.round(w),
      h: Math.round(tierH),
      apexY,
      inverted
    });
  }

  // ----- PARTIE HAUTE (invers√©e) : m√™me look mais pointe AU-DESSUS du tronc
  if (topStemH > 0){
    const total = topStemH + OVERHANG;           // tout couvrir + pointe
    const tierH = tierHeightToCover(total);      // tient compte du chevauchement
    const firstApex = t.topH - topStemH - OVERHANG; // point le plus haut
    for (let i=0;i<TIERS;i++){
      const tNorm = (i + 0.5) / TIERS;                       // 0..1
      const w = tipTierW + tNorm * (baseTierW - tipTierW);   // s‚Äô√©largit vers l‚Äôouverture
      const apexY = firstApex + i * (tierH - OVERLAP);       // chevauchement
      pushTier(tiersTop, apexY, tierH, w, /*inverted*/ true);
    }
  }

  // ----- PARTIE BASSE : m√™me recette, vers le bas
  if (bottomStemH > 0){
    const total = bottomStemH + OVERHANG;
    const tierH = tierHeightToCover(total);
    const firstApex = bottomY;                               // part du bord du tronc
    for (let i=0;i<TIERS;i++){
      const tNorm = (i + 0.5) / TIERS;
      const w = tipTierW + tNorm * (baseTierW - tipTierW);
      const apexY = firstApex + i * (tierH - OVERLAP);
      pushTier(tiersBot, apexY, tierH, w, /*inverted*/ false);
    }
  }

  // zones de collision (tronc + rectangles sous les triangles)
  t._hit = {
    topTrunk:    { x: Math.round(xCenter - trunkW/2), y: 0,       w: trunkW, h: topStemH },
    bottomTrunk: { x: Math.round(xCenter - trunkW/2), y: bottomY, w: trunkW, h: bottomStemH },
    tiersTop,
    tiersBot
  };
}

// slightly narrower trunk with subtle grooves/shading
function drawTrunkRect(r, style){
  const grad = ctx.createLinearGradient(r.x, 0, r.x + r.w, 0);
  grad.addColorStop(0, style.trunk2);
  grad.addColorStop(0.5, style.trunk1);
  grad.addColorStop(1, style.trunk2);
  ctx.fillStyle = grad;
  ctx.fillRect(r.x, r.y, r.w, r.h);

  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  const grooves = 3;
  for (let i = 1; i <= grooves; i++){
    const gx = r.x + Math.round((i/(grooves+1)) * r.w);
    ctx.fillRect(gx, r.y, 1, r.h);
  }
}

// fuller tier with small shadow + faint edge highlight
function drawTier(tier, style){
  const {x, w, h, apexY, inverted} = tier;
  const xCenter = x + w/2;

  ctx.save();
  ctx.translate(xCenter, apexY);
  if (inverted) ctx.scale(1, -1);

  // main triangle
  ctx.fillStyle = style.foliage;
  ctx.beginPath();
  ctx.moveTo(0, 0);          // apex
  ctx.lineTo(-w/2, h);
  ctx.lineTo( w/2, h);
  ctx.closePath();
  ctx.fill();

  // right-face shadow to give depth
  ctx.fillStyle = style.foliageShade;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(w/2, h);
  ctx.lineTo(0,   h);
  ctx.closePath();
  ctx.fill();

  // faint highlight near left edge
  ctx.fillStyle = style.highlight;
  ctx.beginPath();
  ctx.moveTo(-w*0.22, h*0.38);
  ctx.lineTo(-w*0.06, h*0.18);
  ctx.lineTo(-w*0.06, h*0.34);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}


  function drawFirTunnel(t){
    if (!t._hit) buildFirHitboxes(t);
    const style = t.style || makeFirStyle();
    drawTrunkRect(t._hit.topTrunk, style);
    drawTrunkRect(t._hit.bottomTrunk, style);
    for (const tier of t._hit.tiersTop) drawTier(tier, style);
    for (const tier of t._hit.tiersBot) drawTier(tier, style);
  }

  function collideFirTunnel(t, cx, cy, cr){
    if (!t._hit) buildFirHitboxes(t);
    const trunks = [t._hit.topTrunk, t._hit.bottomTrunk];
    for (const r of trunks){
      if (circleRectCollide(cx, cy, cr, r.x, r.y, r.w, r.h)) return true;
    }
    const tiers = t._hit.tiersTop.concat(t._hit.tiersBot);
    for (const r of tiers){
      if (circleRectCollide(cx, cy, cr, r.x, r.y, r.w, r.h)) return true;
    }
    return false;
  }

  /* =========================
     Bird drawing
     ========================= */
  function drawBirdSprite(b) {
    const idx = currentCycle[Math.floor((b.wingPhase * 1) % currentCycle.length)];
    const img = spriteFrames[idx] || spriteFrames[0];
    if (!img) { drawBirdVector(b); return; }

    const desiredH = b.r * currentScaleH;
    const scale = desiredH / img.naturalHeight;
    const dw = img.naturalWidth * scale;
    const dh = img.naturalHeight * scale;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);
    ctx.drawImage(img, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  }

  function drawBirdVector(b) {
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);

    const bodyR = b.r;
    const bodyGrad = ctx.createRadialGradient(0,0, bodyR*0.2, 0,0, bodyR*1.1);
    bodyGrad.addColorStop(0, '#ffd166'); bodyGrad.addColorStop(1, '#f4a261');
    ctx.fillStyle = bodyGrad; ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.beginPath(); ctx.ellipse(0, bodyR*0.2, bodyR*0.9, bodyR*0.7, 0, 0, Math.PI*2); ctx.fill();

    ctx.save();
    const wingA = Math.sin(b.wingPhase)*0.6 - 0.2;
    ctx.rotate(wingA); ctx.translate(-bodyR*0.1, 0);
    ctx.fillStyle = '#f77f00';
    ctx.beginPath(); ctx.ellipse(-bodyR*0.1, 0, bodyR*0.7, bodyR*0.45, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(bodyR*0.35, -bodyR*0.25, bodyR*0.28, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(bodyR*0.45, -bodyR*0.25, bodyR*0.12, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#ff7f00';
    ctx.beginPath(); ctx.moveTo(bodyR*0.9, 0);
    ctx.lineTo(bodyR*1.4, -bodyR*0.1);
    ctx.lineTo(bodyR*0.9, -bodyR*0.25);
    ctx.closePath(); ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.arc(0,0, bodyR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawBird(b) {
    if (spriteReady && spriteFrames.length) drawBirdSprite(b);
    else drawBirdVector(b);
  }

  /* =========================
     Collision helpers
     ========================= */
  function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  /* =========================
     Loop
     ========================= */
  let last = performance.now();
  fit();

  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt, now);
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function update(dt, now){
    rescaleConfig();

    const flapSpeed = (currentSet === 'owl') ? 10 : (currentSet === 'parrot' ? 9.5 : 8.5);
    bird.wingPhase += (state === State.PLAYING ? flapSpeed : 10)*dt;

    groundOffset += (cfg.speed * 60) * dt * 0.18;

    for (const c of clouds){ c.x -= c.speed*dt; }
    while (clouds.length && clouds[0].x + clouds[0].w < -10) clouds.shift();
    if (clouds.length < 8 && Math.random() < 0.02) makeCloud();

    if (state === State.PAUSED || state === State.READY || state === State.DEAD){
      if (state === State.READY){
        bird.y += Math.sin(now*0.004)*0.3;
        bird.angle = Math.sin(now*0.004)*0.05;
      }
      return;
    }

    const followSpeed = 8;
    const t = clamp(followSpeed * dt, 0, 1);
    const dy = targetY - bird.y;
    bird.y += dy * t;
    bird.angle = clamp(dy * 0.0025, -0.6, 0.6);

    bird.y = clamp(bird.y, bird.r+5, H - GH - bird.r - 5);

    if (currentTheme === 'sunny-flowers'){
      // FLOWER SPAWN
      flowerTimer -= dt;
      if (flowerTimer <= 0){
        const gap = Math.round(cfg.gap * (FLOWER_GAP_MULT[difficulty] || 1.35));
        const margin = 30;
        const minY = margin + 30, maxY = H - margin - 30 - GH;
        const center = rand(minY + gap/2, Math.max(minY + gap/2, maxY - gap/2));
        flowerTunnels.push({
          x: W + 8, topH: center - gap/2, w: PIPE_W, gap,
          scored: false, style: makeFlowerStyle(), _hit: null
        });
        if (flowerTunnels.length > 12) flowerTunnels.shift();
        flowerTimer = cfg.spawn;
      }
      for (const f of flowerTunnels){
        f.x -= (cfg.speed * 60) * dt;
        if (!f.scored && f.x + f.w < bird.x - bird.r){
          f.scored = true; score++; scoreEl.textContent = score; scoreChime();
        }
      }
      while (flowerTunnels.length && flowerTunnels[0].x + flowerTunnels[0].w < -10) flowerTunnels.shift();

    } else if (currentTheme === 'night-firs'){
      // FIR SPAWN
      firTimer -= dt;
      if (firTimer <= 0){
        const gap = cfg.gap;
        const margin = 30;
        const minY = margin + 30, maxY = H - margin - 30 - GH;
        const center = rand(minY + gap/2, Math.max(minY + gap/2, maxY - gap/2));
        firTunnels.push({ x: W + 8, topH: center - gap/2, w: PIPE_W, gap, scored:false, _hit:null, style: makeFirStyle() });
        if (firTunnels.length > 12) firTunnels.shift();
        firTimer = cfg.spawn;
      }
      for (const tN of firTunnels){
        tN.x -= (cfg.speed * 60) * dt;
        tN._hit = null; // geometry depends on x
        if (!tN.scored && tN.x + tN.w < bird.x - bird.r){
          tN.scored = true; score++; scoreEl.textContent = score; scoreChime();
        }
      }
      while (firTunnels.length && firTunnels[0].x + firTunnels[0].w < -10) firTunnels.shift();

    } else {
      // PIPES
      pipeTimer -= dt;
      if (pipeTimer <= 0){
        const gap = cfg.gap;
        const margin = 30;
        const minY = margin + 30, maxY = H - margin - 30 - GH;
        const center = rand(minY + gap/2, Math.max(minY + gap/2, maxY - gap/2));
        pipes.push({ x: W + 8, topH: center - gap/2, w: PIPE_W, gap, scored:false });
        if (pipes.length > 12) pipes.shift();
        pipeTimer = cfg.spawn;
      }
      for (const p of pipes){
        p.x -= (cfg.speed * 60) * dt;
        if (!p.scored && p.x + p.w < bird.x - bird.r){
          p.scored = true; score++; scoreEl.textContent = score; scoreChime();
        }
      }
      while (pipes.length && pipes[0].x + pipes[0].w < -10) pipes.shift();
    }

    // Collisions
    const hitTop = bird.y - bird.r < 0;
    const hitGround = bird.y + bird.r > H - GH;
    let hitObstacle = false;

    if (currentTheme === 'sunny-flowers'){
      for (const f of flowerTunnels){
        if (!f._hit){
          const headSize = Math.max(28, PIPE_W*1.2);
          const stemW = Math.max(12, Math.round(PIPE_W*0.55));
          const bottomY = f.topH + f.gap;
          const cx = f.x + f.w/2;
          f._hit = {
            stemTop:    {x: cx - stemW/2, y: 0, w: stemW, h: f.topH},
            stemBottom: {x: cx - stemW/2, y: bottomY, w: stemW, h: H - GH - bottomY},
            headTop:    {cx, cy: f.topH, r: headSize*0.46},
            headBottom: {cx, cy: bottomY, r: headSize*0.46}
          };
        }
        const h = f._hit;
        if ( circleRectCollide(bird.x, bird.y, bird.r, h.stemTop.x, h.stemTop.y, h.stemTop.w, h.stemTop.h) ||
             circleRectCollide(bird.x, bird.y, bird.r, h.stemBottom.x, h.stemBottom.y, h.stemBottom.w, h.stemBottom.h) ){
          hitObstacle = true; break;
        }
        const c1 = ( (bird.x - h.headTop.cx)**2 + (bird.y - h.headTop.cy)**2 <= (bird.r + h.headTop.r)**2 );
        const c2 = ( (bird.x - h.headBottom.cx)**2 + (bird.y - h.headBottom.cy)**2 <= (bird.r + h.headBottom.r)**2 );
        if (c1||c2){ hitObstacle = true; break; }
      }
    } else if (currentTheme === 'night-firs'){
      for (const tN of firTunnels){
        if (collideFirTunnel(tN, bird.x, bird.y, bird.r)){ hitObstacle = true; break; }
      }
    } else {
      for (const p of pipes){
        if (circleRectCollide(bird.x, bird.y, bird.r, p.x, 0, p.w, p.topH) ||
            circleRectCollide(bird.x, bird.y, bird.r, p.x, p.topH + p.gap, p.w, H - GH - (p.topH + p.gap)) ){
          hitObstacle = true; break;
        }
      }
    }

    if (hitTop || hitGround || hitObstacle){
      if (state !== State.DEAD){
        state = State.DEAD;
        hitSfx();
        if (score > best){ best = score; localStorage.setItem('flappy-best', String(best)); bestEl.textContent = best; }
        setTimeout(()=>{
          try { document.getElementById('game-options').style.display = 'flex'; } catch(e){}
          langToggle.style.display = '';
        }, 450);
      }
    }
  }

  function draw(){
    if (currentTheme === 'night-firs') drawSkyNight();
    else if (currentTheme === 'sunny-flowers') drawSkySunny();
    else { drawSkyDay(); drawSun(); }

    if (currentTheme !== 'night-firs') {
      ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.92)';
      for (const c of clouds) roundedCloud(c);
      ctx.restore();
    }

    if (currentTheme === 'sunny-flowers'){
      for (const f of flowerTunnels) drawFlowerTunnel(f);
    } else if (currentTheme === 'night-firs'){
      for (const tN of firTunnels) drawFirTunnel(tN);
    } else {
      for (const p of pipes) drawPipe(p.x, p.topH, p.w, p.gap);
    }

    drawBird(bird);
    drawGround();

    if (state === State.DEAD){
      const W2 = window.innerWidth, H2 = window.innerHeight;
      ctx.save();
      const g = ctx.createRadialGradient(W2/2,H2/2, 50, W2/2,H2/2, Math.max(W2,H2)*0.6);
      g.addColorStop(0, 'rgba(239,71,111,0)');
      g.addColorStop(1, 'rgba(239,71,111,0.25)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W2,H2);
      ctx.restore();
    }
  }

  function roundedCloud(c){
    const {x,y,w,h} = c;
    ctx.beginPath();
    const r = h/2;
    ctx.moveTo(x, y+h);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.quadraticCurveTo(x+w*0.35, y-h*.8, x+w*0.55, y);
    ctx.quadraticCurveTo(x+w-r, y, x+w, y+h);
    ctx.quadraticCurveTo(x+w, y+h*1.2, x+w-r, y+h*1.25);
    ctx.quadraticCurveTo(x+w*.55, y+h*1.6, x+w*.4, y+h*1.25);
    ctx.quadraticCurveTo(x+r, y+h*1.4, x, y+h);
    ctx.closePath(); ctx.fill();
  }

  // Init
  function initialLoad(){
    loadSpriteSet(birdSet);
    restart();
  }
  initialLoad();
})();
</script>
</body>
</html>
