<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <title
    class="translate"
    data-fr="Bulles géantes : jeu switch"
    data-en="Giant Bubbles: switch game"
    data-ja="巨大シャボン玉：スイッチゲーム">
    Bulles géantes : jeu switch
  </title>

  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>

  <!-- thème global -->
  <link rel="stylesheet" href="../../css/otherswitch.css">

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #020714;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    /* Icône réglages (40×40) */
    #settings-icon {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #000;
      color: #fff;
      font-size: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: hidden;
      cursor: pointer;
      z-index: 9999;
    }

    /* Bouton langue */
    #langToggle {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10000;
      padding: 8px 14px;
      border-radius: 12px;
      border: 2px solid #1ccad8;
      background: #0b0f12;
      color: #1ccad8;
      font-weight: 700;
      letter-spacing: .03em;
      cursor: pointer;
      user-select: none;
    }

    #menu {
      z-index: 10000;
    }
  </style>

  <!-- Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-B45TJG4GBJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-B45TJG4GBJ');
  </script>
</head>

<body>
<button id="langToggle" title="Changer la langue / Switch language">EN</button>

<!-- ────────── Landing ────────── -->
<div id="promptOverlay">
  <button id="infoButton"
          title="More info"
          class="translate"
          data-fr="ⓘ" data-en="ⓘ" data-ja="ⓘ">ⓘ</button>

  <p class="translate"
     data-fr="Barre d’espace : fait apparaître une bulle qui monte s’accumuler en haut. Entrée : fait éclater toutes les bulles."
     data-en="Space: creates a bubble that rises and gathers at the top. Enter: pops all bubbles."
     data-ja="スペース：上にたまるシャボン玉を出します。エンター：すべてのシャボン玉を割ります。">
    Barre d’espace : fait apparaître une bulle qui monte s’accumuler en haut. Entrée : fait éclater toutes les bulles.
  </p>

  <button id="startButton"
          class="translate"
          data-fr="Commencer"
          data-en="Start"
          data-ja="開始">
    Commencer
  </button>
</div>

<!-- ────────── Modal info ────────── -->
<div id="infoModal" style="display:none;">
  <p class="translate"
     data-fr="Compétence&nbsp;: appui simple, cause-à-effet<br>SENICT niveau&nbsp;1 · Roadmap 8-10<br>Espace = apparition/accumulation, Entrée = éclatement de toutes les bulles."
     data-en="Skill: single press, cause-and-effect<br>SENICT level 1 · Roadmap 8-10<br>Space = appear/accumulate, Enter = pop all bubbles."
     data-ja="スキル：単押し・原因と結果<br>SENICT レベル1・ロードマップ 8-10<br>スペース＝出現・蓄積、エンター＝全て割る。">
    Compétence : appui simple, cause-à-effet<br>SENICT niveau 1 · Roadmap 8-10<br>Espace = apparition/accumulation, Entrée = éclatement de toutes les bulles.
  </p>
  <button id="closeModal"
          class="translate"
          data-fr="Fermer"
          data-en="Close"
          data-ja="閉じる">
    Fermer
  </button>
</div>

<!-- Icône réglages -->
<div id="settings-icon"
     title="Settings"
     class="translate"
     data-fr="⚙️" data-en="⚙️" data-ja="⚙️">⚙️</div>

<!-- ────────── Menu options ────────── -->
<div id="menu">
  <h2 class="translate" data-fr="Options" data-en="Options" data-ja="オプション">Options</h2>

  <h3 class="translate" data-fr="Musique &amp; son" data-en="Music &amp; Sound" data-ja="音楽と効果音">
    Musique & son
  </h3>

  <label class="inline">
    <span class="translate"
          data-fr="Désactiver la musique"
          data-en="Disable music"
          data-ja="音楽をミュート">Désactiver la musique</span>
    <input type="checkbox" id="muteMusic">
  </label>

  <label>
    <span class="translate" data-fr="Volume musique" data-en="Music volume" data-ja="音楽の音量">
      Volume musique
    </span>
    <span id="musicVolVal">50</span>
    <input type="range" id="musicVol" min="0" max="100" value="50">
  </label>

  <label class="inline">
    <span class="translate"
          data-fr="Désactiver les effets"
          data-en="Disable SFX"
          data-ja="効果音をミュート">Désactiver les effets</span>
    <input type="checkbox" id="muteSFX">
  </label>

  <label>
    <span class="translate" data-fr="Volume effets" data-en="SFX volume" data-ja="効果音の音量">
      Volume effets
    </span>
    <span id="sfxVolVal">50</span>
    <input type="range" id="sfxVol" min="0" max="100" value="50">
  </label>

  <h3 class="translate" data-fr="Délai entre appuis" data-en="Press delay" data-ja="押下間隔">
    Délai entre appuis (ms)
  </h3>

  <label>
    <span class="translate" data-fr="Délai" data-en="Delay" data-ja="間隔">Délai</span>
    <span id="tapDelayVal">2000</span>
    <input type="range" id="tapDelaySlider" min="300" max="5000" value="2000">
  </label>
</div>

<!-- ────────── JS : logique du jeu ────────── -->
<script>
/* === AUDIO ================================================== */
const musicPath = '../../songs/space/spacebest1.mp3';   // à ajuster
const popPaths = [
  '../../sounds/woosh.mp3'
];

let popSounds = [];
let musicSound;

/* === VISUEL ================================================= */
let bgBubbles = [];     // petites bulles de fond (très subtiles)
let bigBubbles = [];    // bulles géantes déclenchées
let popBursts  = [];    // effets d’éclatement
const NUM_BG_BUBBLES = 60;

/* === ÉTAT =================================================== */
let tapDelay = 2000;
let lastTap  = -Infinity;

/* === VOLUMES =============================================== */
let isMusicMuted = false, isSFXMuted = false;
let volMusic = 0.5, volSFX = 0.5;

/* === p5 : PRELOAD ========================================== */
function preload() {
  popSounds  = popPaths.map(p => loadSound(p));
  musicSound = loadSound(musicPath);
}

/* === BULLES FOND (plus petites et plus pâles) ============== */
class BackgroundBubble {
  constructor() {
    this.reset(true);
  }

  reset(randomY = false) {
    this.x = random(width);
    this.y = randomY ? random(height) : height + random(20, 200);
    this.r = random(4, 14);                 // plus petites
    this.speed = random(0.2, 0.8);          // très lent
    this.alpha = random(15, 60);            // très pâle
  }

  update() {
    this.y -= this.speed;
    if (this.y + this.r < -20) {
      this.reset(false);
    }
  }

  draw() {
    noFill();
    stroke(180, 210, 255, this.alpha);
    strokeWeight(1);
    ellipse(this.x, this.y, this.r * 2);
  }
}

/* === BULLES GÉANTES AVEC "PHYSIQUE" ======================== */
class BigBubble {
  constructor(x, baseRadiusMult = 1) {
    this.x = x;
    this.y = height + 80;
    this.baseR = random(90, 180) * baseRadiusMult;
    this.r = this.baseR;
    this.vx = random(-0.3, 0.3);            // petite dérive horizontale
    this.vy = random(-1.2, -0.6);           // monte vers le haut
    this.wobblePhase = random(TWO_PI);
  }

  update(dt) {
    const k = dt / 16.67;

    // Légère dérive et amortissement
    this.vx *= 0.99;
    this.vy = lerp(this.vy, -1.2, 0.01);    // tend vers une vitesse de montée

    this.x += this.vx * k;
    this.y += this.vy * k;

    // "Plafond" : la bulle s'accumule près du haut
    const topMargin = 12;
    if (this.y - this.r < topMargin) {
      this.y = this.r + topMargin;
      this.vy = 0;
    }

    // Bords gauche/droite
    if (this.x - this.r < 0) {
      this.x = this.r;
      this.vx *= -0.5;
    }
    if (this.x + this.r > width) {
      this.x = width - this.r;
      this.vx *= -0.5;
    }

    // Légère "respiration" de la bulle
    this.wobblePhase += 0.005 * dt;
    const wobble = sin(this.wobblePhase) * 0.04;
    this.r = this.baseR * (1 + wobble);
  }

  draw() {
    const cx = this.x;
    const cy = this.y;
    const r  = this.r;

    // Halo flou
    push();
    drawingContext.save();
    drawingContext.shadowBlur  = 40;
    drawingContext.shadowColor = 'rgba(150,210,255,0.5)';

    noFill();
    stroke(200, 230, 255, 200);
    strokeWeight(6);
    ellipse(cx, cy, r * 2.1);

    drawingContext.restore();
    pop();

    // Contour principal
    noFill();
    stroke(230, 240, 255, 220);
    strokeWeight(4);
    ellipse(cx, cy, r * 2);

    // Reflets internes
    noStroke();
    fill(255, 255, 255, 170);
    ellipse(cx - r * 0.25, cy - r * 0.25, r * 0.6, r * 0.45);
    fill(200, 230, 255, 150);
    ellipse(cx + r * 0.15, cy + r * 0.2, r * 0.4, r * 0.35);
  }
}

/* === EFFET D’ÉCLATEMENT "POPPY" ============================ */
class PopBurst {
  constructor(x, y, baseR) {
    this.x = x;
    this.y = y;
    this.r0 = baseR * 0.5;
    this.r = this.r0;
    this.maxR = baseR * 1.6;
    this.life = 0;
    this.maxLife = 500;   // anneau principal
    this.flashLife = 220; // flash blanc

    this.particles = [];
    const count = 16;
    for (let i = 0; i < count; i++) {
      const ang = random(TWO_PI);
      const speed = random(2, 5);
      this.particles.push({
        x: x,
        y: y,
        vx: cos(ang) * speed,
        vy: sin(ang) * speed,
        r: random(baseR * 0.04, baseR * 0.08),
        life: 0,
        maxLife: random(350, 650),
        alpha: 220
      });
    }
  }

  update(dt) {
    this.life += dt;
    const t = constrain(this.life / this.maxLife, 0, 1);
    this.r = lerp(this.r0, this.maxR, t);
    this.alpha = map(1 - t, 0, 1, 0, 255);

    const k = dt / 16.67;

    for (let p of this.particles) {
      p.life += dt;
      const pt = constrain(p.life / p.maxLife, 0, 1);
      p.x += p.vx * k;
      p.y += p.vy * k;
      p.vy += 0.02 * k; // légère "gravité"
      p.alpha = map(1 - pt, 0, 1, 0, 220);
    }
  }

  isDead() {
    return this.life > this.maxLife &&
           this.particles.every(p => p.life >= p.maxLife);
  }

  draw() {
    // Flash blanc court
    const flashT = 1 - constrain(this.life / this.flashLife, 0, 1);
    if (flashT > 0) {
      noStroke();
      fill(255, 255, 255, 180 * flashT);
      ellipse(this.x, this.y, this.r * 1.4);
    }

    // Anneau principal
    noFill();
    stroke(230, 240, 255, this.alpha);
    strokeWeight(4);
    ellipse(this.x, this.y, this.r * 2);

    // Particules
    noStroke();
    for (let p of this.particles) {
      if (p.life < p.maxLife) {
        fill(230, 240, 255, p.alpha);
        ellipse(p.x, p.y, p.r * 2);
      }
    }
  }
}

/* === COLLISIONS ENTRE GROSSES BULLES ======================= */
function resolveBubbleCollisions() {
  const topMargin = 12;
  for (let i = 0; i < bigBubbles.length; i++) {
    for (let j = i + 1; j < bigBubbles.length; j++) {
      const a = bigBubbles[i];
      const b = bigBubbles[j];
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dist = Math.sqrt(dx * dx + dy * dy);

      const minDist = a.r + b.r;
      if (dist === 0) {
        dist = 0.0001;
        dx = 0.0001;
        dy = 0;
      }

      if (dist < minDist) {
        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        const shift = overlap / 2;

        a.x -= nx * shift;
        a.y -= ny * shift;
        b.x += nx * shift;
        b.y += ny * shift;

        if (a.y - a.r < topMargin) a.y = a.r + topMargin;
        if (b.y - b.r < topMargin) b.y = b.r + topMargin;
      }
    }
  }
}

/* === p5 : SETUP ============================================ */
function setup() {
  createCanvas(displayWidth, displayHeight);
  for (let i = 0; i < NUM_BG_BUBBLES; i++) {
    bgBubbles.push(new BackgroundBubble());
  }
}

/* === p5 : DRAW ============================================= */
function draw() {
  drawBackground();

  // Fond : petites bulles
  bgBubbles.forEach(b => {
    b.update();
    b.draw();
  });

  const dt = deltaTime;

  // Grosses bulles
  for (let i = 0; i < bigBubbles.length; i++) {
    bigBubbles[i].update(dt);
  }
  resolveBubbleCollisions();
  for (let i = 0; i < bigBubbles.length; i++) {
    bigBubbles[i].draw();
  }

  // Effets de pop
  for (let i = popBursts.length - 1; i >= 0; i--) {
    const pb = popBursts[i];
    pb.update(dt);
    pb.draw();
    if (pb.isDead()) {
      popBursts.splice(i, 1);
    }
  }
}

/* === FOND SANS LIGNES (juste une couleur lisse) ============ */
function drawBackground() {
  // couleur profonde bleu nuit
  background(5, 15, 40);
}

/* === ACTIONS SWITCHS ======================================= */

// Joueur 1 (espace) : bulle standard
function triggerPlayer1(mult = 1) {
  const cx = width * 0.5;
  bigBubbles.push(new BigBubble(cx, mult));
  playPop();
}

// Joueur 2 (Entrée) : éclatement de toutes les bulles
function triggerPlayer2() {
  if (bigBubbles.length === 0) return;

  bigBubbles.forEach(b => {
    popBursts.push(new PopBurst(b.x, b.y, b.r));
  });
  bigBubbles = [];

  playPop();
}

/* === AUDIO TRIGGER ======================================== */
function playPop() {
  if (!isSFXMuted && popSounds.length) {
    const s = random(popSounds);
    s.setVolume(volSFX);
    s.play();
  }
}

/* === CLAVIER : BARRE ESPACE + ENTRÉE ====================== */
function keyPressed() {
  const now = millis();

  if (key === ' ') {
    if (now - lastTap < tapDelay) return;
    lastTap = now;
    triggerPlayer1(1);     // mult fixe
  } else if (keyCode === ENTER) {
    if (now - lastTap < tapDelay) return;
    lastTap = now;
    triggerPlayer2();
  }
}

/* === UI : plein écran, sliders, menu, son ================= */
window.addEventListener('load', () => {
  const overlay    = document.getElementById('promptOverlay'),
        btn        = document.getElementById('startButton'),
        icon       = document.getElementById('settings-icon'),
        menu       = document.getElementById('menu'),
        muteMusic  = document.getElementById('muteMusic'),
        musicVol   = document.getElementById('musicVol'),
        musicVal   = document.getElementById('musicVolVal'),
        muteSFX    = document.getElementById('muteSFX'),
        sfxVol     = document.getElementById('sfxVol'),
        sfxVal     = document.getElementById('sfxVolVal'),
        tapSlider  = document.getElementById('tapDelaySlider'),
        tapVal     = document.getElementById('tapDelayVal'),
        infoBtn    = document.getElementById('infoButton'),
        infoModal  = document.getElementById('infoModal'),
        closeModal = document.getElementById('closeModal');

  // Sliders & mute
  tapSlider.oninput = e => {
    tapDelay = parseInt(e.target.value, 10);
    tapVal.textContent = e.target.value;
  };

  musicVol.oninput = e => {
    volMusic = e.target.value / 100;
    musicVal.textContent = e.target.value;
    if (!isMusicMuted && musicSound && musicSound.isLoaded()) {
      musicSound.setVolume(volMusic);
    }
  };

  sfxVol.oninput = e => {
    volSFX = e.target.value / 100;
    sfxVal.textContent = e.target.value;
    if (!isSFXMuted && popSounds.length) {
      popSounds.forEach(s => s.setVolume(volSFX));
    }
  };

  muteMusic.onchange = e => {
    isMusicMuted = e.target.checked;
    if (musicSound && musicSound.isLoaded()) {
      musicSound.setVolume(isMusicMuted ? 0 : volMusic);
    }
  };

  muteSFX.onchange = e => {
    isSFXMuted = e.target.checked;
    if (popSounds.length) {
      popSounds.forEach(s => s.setVolume(isSFXMuted ? 0 : volSFX));
    }
  };

  function startMusic() {
    if (musicSound && musicSound.isLoaded() && !isMusicMuted) {
      musicSound.setLoop(true);
      musicSound.setVolume(volMusic);
      musicSound.play();
    }
  }

  // Commencer
  btn.addEventListener('pointerup', () => {
    overlay.remove();

    const docEl = document.documentElement;
    if (docEl.requestFullscreen) docEl.requestFullscreen().catch(() => {});
    else if (docEl.webkitRequestFullscreen) docEl.webkitRequestFullscreen();

    const fitCanvas = () => resizeCanvas(displayWidth, displayHeight);
    fitCanvas();
    document.addEventListener('fullscreenchange', fitCanvas);
    window.addEventListener('resize', fitCanvas);

    icon.style.visibility = 'visible';

    startMusic();
  });

  // Menu toggle
  icon.onclick = () => menu.classList.toggle('show');
  document.onclick = e => {
    if (!menu.contains(e.target) && !icon.contains(e.target)) {
      menu.classList.remove('show');
    }
  };

  // Info modal
  infoBtn.onclick = () => { infoModal.style.display = 'block'; };
  closeModal.onclick = () => { infoModal.style.display = 'none'; };

  // Empêcher le scroll de la page avec espace/entrée
  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
    }
  }, { passive: false });
});
</script>

<script src="../../js/translationmain.js"></script>
<script>
  document.getElementById('langToggle')?.addEventListener('pointerup', toggleLanguage);
</script>
</body>
</html>
